<!DOCTYPE html>
<html lang="en">
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
		<meta charset="utf-8">
		<title>ASCIICKER - let's kick some ASCII</title>

		<link rel="apple-touch-icon" sizes="180x180" href="./apple-touch-icon.png">
		<link rel="icon" type="image/png" sizes="32x32" href="./favicon-32x32.png">
		<link rel="icon" type="image/png" sizes="16x16" href="./favicon-16x16.png">
		<link rel="manifest" href="./manifest.json">
		<link rel="mask-icon" href="./safari-pinned-tab.svg" color="#404040">
		<meta name="theme-color" content="#ffffff">

		<style>
			canvas {
				position: absolute;
			}

			html, body, canvas {
				width: 100%;
				height: 100%;
				border: 0;
				padding: 0;
				margin: 0;
				background-color: #000;
				overflow: hidden;
			}
		</style>

		<script id="vs" type="x-shader/x-vertex">
			//<![CDATA[
				attribute vec2 xy;
				uniform float width;
				uniform float height;
				uniform float cell_width;
				uniform float cell_height;
				uniform float view_width;
				uniform float view_height;
				uniform float scroll_x;
				uniform float scroll_y;

				varying vec4 tc;
				varying vec2 wrap_tc;

				void main()
				{
					float cx = 2.0*xy.x - 1.0;
					float cy = 2.0*xy.y - 1.0;
					float w = cell_width * width;
					float h = cell_height * height;
					gl_Position = vec4(cx * w/view_width, -cy * h/view_height,0.0,1.0);

					vec2 tex_size = vec2(960.0,540.0);//vec2(480.0,270.0);
					vec2 cc = vec2(xy.x * width + scroll_x, xy.y * height + scroll_y);
					tc = vec4( cc / tex_size,  cc );

					wrap_tc = vec2(width,height) / tex_size;
				}
			//]]>
		</script>

		<script id="fs" type="x-shader/x-fragment">
			//<![CDATA[
				precision highp float;

				uniform sampler2D fnt;
				uniform sampler2D tex;
				uniform sampler2D pal;

				varying vec4 tc;
				varying vec2 wrap_tc;

				void main()
				{
					vec4 cell = texture2D(tex, mod(tc.xy,wrap_tc));

					// split 1x8bit code to 2x4bit coords
					float gl = cell.x/16.0*255.01;// bb fix !
					cell.y = floor(gl);
					cell.x = (gl-cell.y)*16.0;

					vec2 glyph_tc = (cell.xy + fract( tc.zw )) / vec2(16.0,16.0);
					float mask = texture2D(fnt, glyph_tc).g;

					// pal_size is 32 (was 16)
					vec3 fg = texture2D(pal,vec2((cell.z*255.0+0.5)/32.0,0.5)).rgb;
					vec3 bg = texture2D(pal,vec2((cell.w*255.0+0.5)/32.0,0.5)).rgb;

					gl_FragColor = vec4(mix(bg,fg,mask),1.0);
				}
			//]]>
		</script>

		<script type="text/javascript">
			var PRNG = function (seed) {
				this._seed = seed % 2147483647;
				if (this._seed <= 0) {
					this._seed += 2147483646;
				}
			};

			PRNG.prototype.next = function (a, b) {
				this._seed = this._seed * 16807 % 2147483647;
				if (arguments.length === 0) {
					return this._seed / 2147483647;
				} else if (arguments.length === 1) {
					return (this._seed / 2147483647) * a;
				} else {
					return (this._seed / 2147483647) * (b - a) + a;
				}
			};

			var rng = new PRNG(2238473661);
		</script>

		<script type="text/javascript" src="ak_world.js"></script>
		<script type="text/javascript" src="min_ak_screen.js"></script>
		<script type="text/javascript" src="jszip.min.js"></script>
		<script type="text/javascript" src="ak_recorder.js"></script>

		<script type="text/javascript">
			//<![CDATA[

			var ak_lag = 0;
			var max_lag = 300;
			var ak_connection = null;

			var sim_lag_count = 0;
			var sim_lag_queue = [];

			var npc = null; // x,y,z,dir,frm home x,y and destination x,y
			var npcs = 0;

			function ak_Connect() {
				console.log('ws connecting...');

				var connection = null;
				connection = new WebSocket('ws://asciicker.com/ws/');

				connection.onopen = function () {
					// connection is opened and ready to use
					ak_connection = connection;
					console.log('ws ready!');

					// setInterval( function(){ ak_Send(world_center_x,world_center_y,world_center_z,player_dir,player_frm); }, 100 );
				};

				connection.onerror = function (error) {
					// an error occurred when sending/receiving data
					console.log('ws error', error);

					if (ak_connection) {
						ak_connection.close();
						ak_connection = null;
					}
					ak_lag = 0;
					sim_lag_queue.length = 0;

					setTimeout(ak_Connect, 3000);
				};

				connection.onmessage = function (message) {
					//console.log('ws received:',message.data);

					ak_lag--;

					//console.log(message.data);


					// split into npcs
					// find first ']'
					var num = 0;
					var pos = 0;
					var end = message.data.indexOf(']', pos);
					while (end > 0 && num < 300) {
						var xyzafl = JSON.parse(message.data.substr(pos, end - pos + 1));
						npc[9 * num] = xyzafl[0];
						npc[9 * num + 1] = xyzafl[1];
						npc[9 * num + 2] = xyzafl[2];
						npc[9 * num + 3] = xyzafl[3];
						npc[9 * num + 4] = xyzafl[4];
						npc[9 * num + 5] = xyzafl[5];

						num++;
						pos = end + 1;
						end = message.data.indexOf(']', pos);
					}

					npcs = num;
				};
			}

			function ak_Send(x, y, z, a, f) {
				ak_lag++;

				if (ak_lag > max_lag) {
					ak_connection.close();
					ak_connection = null;
					ak_lag = 0;
					sim_lag_queue.length = 0;

					setTimeout(ak_Connect, 3000);
					return;
				}

				if (sim_lag_count > 0) {
					sim_lag_queue.push(JSON.stringify([x, y, z, a, f, ak_lag]));
					if (sim_lag_queue.length === sim_lag_count)
						ak_connection.send(sim_lag_queue.shift());
				} else
					ak_connection.send(JSON.stringify([x, y, z, a, f, ak_lag]));
			}

			var ak_width = 0;  // in cells
			var ak_height = 0; // in cells
			var ak_canvas = null;
			var ak_ctx = null;
			var ak_tex = null; // 'HW' front buffer
			var ak_pal = null;
			var ak_buf = null;
			var ak_buf32 = null;
			var ak_prg = null;
			var ak_uni_width = null;
			var ak_uni_height = null;
			var ak_uni_cell_width = null;
			var ak_uni_cell_height = null;
			var ak_uni_view_width = null;
			var ak_uni_view_height = null;
			var ak_vtx = null;
			var ak_fonts = null; // array of textures
			var ak_font = 0;     // current font index
			var ak_max_width = 960; //480;
			var ak_max_height = 540; //270;
			var ak_min_width = 40;
			var ak_min_height = 20;
			var ak_ratio = 1; // device to css pixels

			var ak_lib = null;

			var ak_world = null;
			var ak_images = null;

			var ak_touch_move_dx = 0;
			var ak_touch_move_dy = 0;
			var ak_touch_jmp = -1;
			var ak_touch_left = -1;
			var ak_touch_right = -1;

			function setTouchHandlers() {
				var el = window;

				var start_handler = function (e) {
					if (pan && pan_tid >= 0 && e.changedTouches.length === 1 && ak_touch_jmp < 0) {
						var x = e.changedTouches[0].pageX / (ak_fonts[ak_font].width >> 4) * ak_ratio;
						if (x < 0.1 * ak_width)
							ak_touch_left = e.changedTouches[0].identifier;
						else if (x > 0.9 * ak_width)
							ak_touch_right = e.changedTouches[0].identifier;
						else
							ak_touch_jmp = e.changedTouches[0].identifier;
					} else {
						if (!pan && e.changedTouches.length === 1) {
							var x = e.changedTouches[0].pageX / (ak_fonts[ak_font].width >> 4) * ak_ratio;
							if (x < 0.1 * ak_width)
								ak_touch_left = e.changedTouches[0].identifier;
							else if (x > 0.9 * ak_width)
								ak_touch_right = e.changedTouches[0].identifier;
							else {
								pan = true;
								pan_tid = e.changedTouches[0].identifier;
								pan_x0 = e.changedTouches[0].pageX / (ak_fonts[ak_font].width >> 4);
								pan_y0 = e.changedTouches[0].pageY / (ak_fonts[ak_font].height >> 4);
							}
						}
					}
				};

				var move_handler = function (e) {
					if (pan && pan_tid >= 0) {
						for (var i = 0; i < e.changedTouches.length; i++) {
							if (e.changedTouches[i].identifier === pan_tid) {
								var x = e.changedTouches[i].pageX / (ak_fonts[ak_font].width >> 4);
								var y = e.changedTouches[i].pageY / (ak_fonts[ak_font].height >> 4);

								var dx = (x - pan_x0) * ak_ratio / ak_tile_to_char;
								var dy = (y - pan_y0) * 2 * ak_ratio / ak_tile_to_char;

								/*
									world_center_x -= Math.cos(-view_angle*Math.PI/180)*dx - Math.sin(-view_angle*Math.PI/180)*dy;
									world_center_y -= Math.sin(-view_angle*Math.PI/180)*dx + Math.cos(-view_angle*Math.PI/180)*dy;

									pan_x0 = x;
									pan_y0 = y;
									*/

								ak_touch_move_dx = dx;
								ak_touch_move_dy = dy;

								break;
							}
						}
						e.preventDefault();
					}
				};

				var end_handler = function (e) {
					for (var i = 0; i < e.changedTouches.length; i++) {
						if (e.changedTouches[i].identifier === ak_touch_jmp) {
							ak_touch_jmp = -1;
						}

						if (e.changedTouches[i].identifier === ak_touch_left) {
							ak_touch_left = -1;
						}

						if (e.changedTouches[i].identifier === ak_touch_right) {
							ak_touch_right = -1;
						}

						if (pan && pan_tid >= 0 && e.changedTouches[i].identifier === pan_tid) {
							pan = false;
							pan_tid = -1;

							ak_touch_move_dx = 0;
							ak_touch_move_dy = 0;

							break;
						}
					}
				};

				el.addEventListener('touchstart', start_handler);
				el.addEventListener('touchmove', move_handler);
				el.addEventListener('touchcancel', end_handler);
				el.addEventListener('touchend', end_handler);
			}

			var ak_screen = null;
			var frame = 0;

			var npc = null; // x,y,z,dir,frm home x,y and destination x,y
			var npcs = 0;

			// worldspace focus point
			// z values should be sampled from map @ x,y
			var world_center_x = 0.0;
			var world_center_y = 0.0;
			var world_center_z = 0.0;

			var tile_size = 0;

			// view dir in degrees
			var view_angle = 0.0;
			var dest_angle = 0;
			var player_dir = 0;
			var player_frm = 0;

			var velocity_x = 0.0;
			var velocity_y = 0.0;
			var velocity_z = 0.0;

			// world->view internal transform coeffs
			var view_xx, view_xy, view_yx, view_yy;
			var view_tx, view_ty;
			var prev_dx, prev_dy, prev_angle;

			var ak_hull = new Float32Array(4 * 4 + 4); // + water plane

			var ak_tile_to_char = 4;//1;// 32/Math.sqrt(2.0);

			// need to ba called on every resize or viewing angle & center changes
			function akPreTransform(hull, water) {
				var r = view_angle * Math.PI / 180.0;
				var R = 60 * Math.PI / 180.0;
				var s = Math.sin(r);
				var c = Math.cos(r);
				var S = Math.sin(R);
				var C = Math.cos(R);
				view_xx = c * ak_tile_to_char;
				view_xy = -s * ak_tile_to_char;   /*view_xz =  0;*/
				view_yx = s * C * ak_tile_to_char;
				view_yy = c * C * ak_tile_to_char; /*view_yz = -S;*/
				/*view_zx = s*S;*/             /*view_zy =  c*S;*/               /*view_zz =  C;*/

				var dx = view_xx * world_center_x + view_xy * world_center_y;
				var dy = view_yx * world_center_x + view_yy * world_center_y - world_center_z;
				//var dz = view_zx * world_center_x + view_zy * world_center_y + view_zz * world_center_z;

				// stability window
				if (prev_angle === view_angle) {
					if (Math.abs(prev_dx - dx) >= 1.0)
						prev_dx = dx;
					if (Math.abs(prev_dy - dy) >= 1.0)
						prev_dy = dy;
				} else {
					prev_dx = dx;
					prev_dy = dy;
				}

				view_tx = (ak_width >> 1) - Math.round(prev_dx) | 0;
				view_ty = (ak_height >> 1) - Math.round(prev_dy) | 0;
				//view_tz = 0-dx;

				// PREPARE HULL PLANES IN SCREEN SPACE
				// multiply plane by transposed world->screen
				/*
					[ view_xx view_yx  0 0 ] [ x ]
					[ view_xy view_yy  0 0 ] [ y ]
					[        0        -1 0 ] [ z ]
					[ view_tx view_ty  0 1 ] [ w ]
					*/

				// left {1,0,0,0}
				hull[0] = view_xx * tile_size;
				hull[1] = view_xy * tile_size;
				hull[2] = 0;/*view_xz*/
				hull[3] = view_tx;//-8;

				// right {-1,0,0,ak_width}
				hull[4] = -view_xx * tile_size;
				hull[5] = -view_xy * tile_size;
				hull[6] = 0;/*-view_xz*/
				hull[7] = -view_tx + ak_width;//-8;

				// top {0,1,0,0}
				hull[8] = view_yx * tile_size;
				hull[9] = view_yy * tile_size;
				hull[10] = -1;/*view_yz*/
				hull[11] = view_ty;//-8;

				// bottom {0,-1,0,ak_height}
				hull[12] = -view_yx * tile_size;
				hull[13] = -view_yy * tile_size;
				hull[14] = 1;/*-view_yz*/
				hull[15] = -view_ty + ak_height;//-8;

				// water plane
				hull[16] = 0;
				hull[17] = 0;
				hull[18] = 1;
				hull[19] = -water;
			}

			var tile_patch = null; // 2xtile_size^2 triangles, each 3 verts, each xyzuv

			function akTransformPatchRefl(x, y, quad, water) {
				var qx0 = x * tile_size;
				var qy0 = y * tile_size;
				var qx1 = qx0 + tile_size;
				var qy1 = qy0 + tile_size;

				var q = 0;

				for (y = qy0; y < qy1; y++) {
					for (x = qx0; x < qx1; x++) {
						// rounding moved to drawing funcs
						// (allowing enchanced resolution with dbl_y)

						var z00 = ak_world.GetMapHeight(x, y);
						var x00 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
						var y00 = (Math.round(view_yx * x + view_yy * y + z00) | 0) + view_ty - 2 * water;

						x++;
						var z01 = ak_world.GetMapHeight(x, y);
						var x01 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
						var y01 = (Math.round(view_yx * x + view_yy * y + z01) | 0) + view_ty - 2 * water;

						y++;
						var z11 = ak_world.GetMapHeight(x, y);
						var x11 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
						var y11 = (Math.round(view_yx * x + view_yy * y + z11) | 0) + view_ty - 2 * water;

						x--;
						var z10 = ak_world.GetMapHeight(x, y);
						var x10 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
						var y10 = (Math.round(view_yx * x + view_yy * y + z10) | 0) + view_ty - 2 * water;

						y--;

						// split by shorter diagonal
						if (Math.abs(z10 - z01) <= Math.abs(z00 - z11)) {
							quad[q] = x00;
							quad[q + 1] = y00;
							quad[q + 2] = z00;
							quad[q + 3] = x;
							quad[q + 4] = y;

							quad[q + 5] = x01;
							quad[q + 6] = y01;
							quad[q + 7] = z01;
							quad[q + 8] = x + 1;
							quad[q + 9] = y;

							quad[q + 10] = x10;
							quad[q + 11] = y10;
							quad[q + 12] = z10;
							quad[q + 13] = x;
							quad[q + 14] = y + 1;

							//

							quad[q + 15] = x10;
							quad[q + 16] = y10;
							quad[q + 17] = z10;
							quad[q + 18] = x;
							quad[q + 19] = y + 1;

							quad[q + 20] = x01;
							quad[q + 21] = y01;
							quad[q + 22] = z01;
							quad[q + 23] = x + 1;
							quad[q + 24] = y;

							quad[q + 25] = x11;
							quad[q + 26] = y11;
							quad[q + 27] = z11;
							quad[q + 28] = x + 1;
							quad[q + 29] = y + 1;

						} else {
							quad[q] = x00;
							quad[q + 1] = y00;
							quad[q + 2] = z00;
							quad[q + 3] = x;
							quad[q + 4] = y;

							quad[q + 5] = x01;
							quad[q + 6] = y01;
							quad[q + 7] = z01;
							quad[q + 8] = x + 1;
							quad[q + 9] = y;

							quad[q + 10] = x11;
							quad[q + 11] = y11;
							quad[q + 12] = z11;
							quad[q + 13] = x + 1;
							quad[q + 14] = y + 1;

							//

							quad[q + 15] = x11;
							quad[q + 16] = y11;
							quad[q + 17] = z11;
							quad[q + 18] = x + 1;
							quad[q + 19] = y + 1;

							quad[q + 20] = x10;
							quad[q + 21] = y10;
							quad[q + 22] = z10;
							quad[q + 23] = x;
							quad[q + 24] = y + 1;

							quad[q + 25] = x00;
							quad[q + 26] = y00;
							quad[q + 27] = z00;
							quad[q + 28] = x;
							quad[q + 29] = y;

						}

						q += 30;
					}
				}
			}

			function akTransformLeft(x, y, quad, water, refl) {
				var qx0 = x * tile_size;
				var qx1 = qx0 + tile_size;
				var qy0 = y * tile_size;
				var qy1 = qy0 + tile_size;
				var q = 0;

				var sgn = refl ? -1 : 1;
				var ofs = refl ? -2 * water : 0;

				x = qx0;
				for (y = qy0; y < qy1; y++) {

					var z00 = water;
					var x00 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y00 = (Math.round(view_yx * x + view_yy * y - sgn * z00) | 0) + view_ty + ofs;
					var u00 = 255;

					var z01 = ak_world.GetMapHeight(x, y);
					if (z01 < water) z01 = water;
					var x01 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y01 = (Math.round(view_yx * x + view_yy * y - sgn * z01) | 0) + view_ty + ofs;
					var u01 = 0;

					y++;
					var z11 = ak_world.GetMapHeight(x, y);
					if (z11 < water) z11 = water;
					var x11 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y11 = (Math.round(view_yx * x + view_yy * y - sgn * z11) | 0) + view_ty + ofs;
					var u11 = 0;

					var z10 = water;
					var x10 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y10 = (Math.round(view_yx * x + view_yy * y - sgn * z10) | 0) + view_ty + ofs;
					var u10 = 255;

					y--;

					quad[q] = x00;
					quad[q + 1] = y00;
					quad[q + 2] = z00;
					quad[q + 3] = u00;
					quad[q + 4] = 0;

					quad[q + 5] = x01;
					quad[q + 6] = y01;
					quad[q + 7] = z01;
					quad[q + 8] = u01;
					quad[q + 9] = 0;

					quad[q + 10] = x10;
					quad[q + 11] = y10;
					quad[q + 12] = z10;
					quad[q + 13] = u10;
					quad[q + 14] = 0;

					//

					quad[q + 15] = x10;
					quad[q + 16] = y10;
					quad[q + 17] = z10;
					quad[q + 18] = u10;
					quad[q + 19] = 0;

					quad[q + 20] = x01;
					quad[q + 21] = y01;
					quad[q + 22] = z01;
					quad[q + 23] = u01;
					quad[q + 24] = 0;

					quad[q + 25] = x11;
					quad[q + 26] = y11;
					quad[q + 27] = z11;
					quad[q + 28] = u11;
					quad[q + 29] = 0;

					q += 30;
				}
			}

			function akTransformRight(x, y, quad, water, refl) {
				var qx0 = x * tile_size;
				var qx1 = qx0 + tile_size;
				var qy0 = y * tile_size;
				var qy1 = qy0 + tile_size;
				var q = 0;

				var sgn = refl ? -1 : 1;
				var ofs = refl ? -2 * water : 0;

				x = qx1;
				for (y = qy0; y < qy1; y++) {
					y++;
					var z00 = water;
					var x00 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y00 = (Math.round(view_yx * x + view_yy * y - sgn * z00) | 0) + view_ty + ofs;
					var u00 = 255;

					var z01 = ak_world.GetMapHeight(x, y);
					if (z01 < water) z01 = water;
					var x01 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y01 = (Math.round(view_yx * x + view_yy * y - sgn * z01) | 0) + view_ty + ofs;
					var u01 = 0;

					y--;
					var z11 = ak_world.GetMapHeight(x, y);
					if (z11 < water) z11 = water;
					var x11 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y11 = (Math.round(view_yx * x + view_yy * y - sgn * z11) | 0) + view_ty + ofs;
					var u11 = 0;

					var z10 = water;
					var x10 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y10 = (Math.round(view_yx * x + view_yy * y - sgn * z10) | 0) + view_ty + ofs;
					var u10 = 255;

					quad[q] = x00;
					quad[q + 1] = y00;
					quad[q + 2] = z00;
					quad[q + 3] = u00;
					quad[q + 4] = 0;

					quad[q + 5] = x01;
					quad[q + 6] = y01;
					quad[q + 7] = z01;
					quad[q + 8] = u01;
					quad[q + 9] = 0;

					quad[q + 10] = x10;
					quad[q + 11] = y10;
					quad[q + 12] = z10;
					quad[q + 13] = u10;
					quad[q + 14] = 0;

					//

					quad[q + 15] = x10;
					quad[q + 16] = y10;
					quad[q + 17] = z10;
					quad[q + 18] = u10;
					quad[q + 19] = 0;

					quad[q + 20] = x01;
					quad[q + 21] = y01;
					quad[q + 22] = z01;
					quad[q + 23] = u01;
					quad[q + 24] = 0;

					quad[q + 25] = x11;
					quad[q + 26] = y11;
					quad[q + 27] = z11;
					quad[q + 28] = u11;
					quad[q + 29] = 0;

					q += 30;
				}
			}

			function akTransformTop(x, y, quad, water, refl) {
				var qx0 = x * tile_size;
				var qx1 = qx0 + tile_size;
				var qy0 = y * tile_size;
				var qy1 = qy0 + tile_size;
				var q = 0;

				var sgn = refl ? -1 : 1;
				var ofs = refl ? -2 * water : 0;

				y = qy0;
				for (x = qx0; x < qx1; x++) {
					var z00 = water;
					var x00 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y00 = (Math.round(view_yx * x + view_yy * y - sgn * z00) | 0) + view_ty + ofs;
					var u00 = 255;

					x++;

					var z01 = water;
					var x01 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y01 = (Math.round(view_yx * x + view_yy * y - sgn * z01) | 0) + view_ty + ofs;
					var u01 = 255;

					var z11 = ak_world.GetMapHeight(x, y);
					if (z11 < water) z11 = water;
					var x11 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y11 = (Math.round(view_yx * x + view_yy * y - sgn * z11) | 0) + view_ty + ofs;
					var u11 = 0;

					x--;

					var z10 = ak_world.GetMapHeight(x, y);
					if (z10 < water) z10 = water;
					var x10 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y10 = (Math.round(view_yx * x + view_yy * y - sgn * z10) | 0) + view_ty + ofs;
					var u10 = 0;

					quad[q] = x00;
					quad[q + 1] = y00;
					quad[q + 2] = z00;
					quad[q + 3] = u00;
					quad[q + 4] = 0;

					quad[q + 5] = x01;
					quad[q + 6] = y01;
					quad[q + 7] = z01;
					quad[q + 8] = u01;
					quad[q + 9] = 0;

					quad[q + 10] = x10;
					quad[q + 11] = y10;
					quad[q + 12] = z10;
					quad[q + 13] = u10;
					quad[q + 14] = 0;

					//

					quad[q + 15] = x10;
					quad[q + 16] = y10;
					quad[q + 17] = z10;
					quad[q + 18] = u10;
					quad[q + 19] = 0;

					quad[q + 20] = x01;
					quad[q + 21] = y01;
					quad[q + 22] = z01;
					quad[q + 23] = u01;
					quad[q + 24] = 0;

					quad[q + 25] = x11;
					quad[q + 26] = y11;
					quad[q + 27] = z11;
					quad[q + 28] = u11;
					quad[q + 29] = 0;

					q += 30;
				}
			}

			function akTransformBottom(x, y, quad, water, refl) {
				var qx0 = x * tile_size;
				var qx1 = qx0 + tile_size;
				var qy0 = y * tile_size;
				var qy1 = qy0 + tile_size;
				var q = 0;

				var sgn = refl ? -1 : 1;
				var ofs = refl ? -2 * water : 0;

				y = qy1;
				for (x = qx0; x < qx1; x++) {
					var z00 = water;
					var x00 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y00 = (Math.round(view_yx * x + view_yy * y - sgn * z00) | 0) + view_ty + ofs;
					var u00 = 255;

					var z01 = ak_world.GetMapHeight(x, y);
					if (z01 < water) z01 = water;
					var x01 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y01 = (Math.round(view_yx * x + view_yy * y - sgn * z01) | 0) + view_ty + ofs;
					var u01 = 0;

					x++;

					var z11 = ak_world.GetMapHeight(x, y);
					if (z11 < water) z11 = water;
					var x11 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y11 = (Math.round(view_yx * x + view_yy * y - sgn * z11) | 0) + view_ty + ofs;
					var u11 = 0;

					var z10 = water;
					var x10 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y10 = (Math.round(view_yx * x + view_yy * y - sgn * z10) | 0) + view_ty + ofs;
					var u10 = 255;

					x--;

					quad[q] = x00;
					quad[q + 1] = y00;
					quad[q + 2] = z00;
					quad[q + 3] = u00;
					quad[q + 4] = 0;

					quad[q + 5] = x01;
					quad[q + 6] = y01;
					quad[q + 7] = z01;
					quad[q + 8] = u01;
					quad[q + 9] = 0;

					quad[q + 10] = x10;
					quad[q + 11] = y10;
					quad[q + 12] = z10;
					quad[q + 13] = u10;
					quad[q + 14] = 0;

					//

					quad[q + 15] = x10;
					quad[q + 16] = y10;
					quad[q + 17] = z10;
					quad[q + 18] = u10;
					quad[q + 19] = 0;

					quad[q + 20] = x01;
					quad[q + 21] = y01;
					quad[q + 22] = z01;
					quad[q + 23] = u01;
					quad[q + 24] = 0;

					quad[q + 25] = x11;
					quad[q + 26] = y11;
					quad[q + 27] = z11;
					quad[q + 28] = u11;
					quad[q + 29] = 0;

					q += 30;
				}
			}

			function akTransformPatch(x, y, quad) {
				var qx0 = x * tile_size;
				var qy0 = y * tile_size;
				var qx1 = qx0 + tile_size;
				var qy1 = qy0 + tile_size;

				var q = 0;

				for (y = qy0; y < qy1; y++) {
					for (x = qx0; x < qx1; x++) {
						// rounding moved to drawing funcs
						// (allowing enchanced resolution with dbl_y)

						var z00 = ak_world.GetMapHeight(x, y);
						var x00 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
						var y00 = (Math.round(view_yx * x + view_yy * y - z00) | 0) + view_ty;

						x++;
						var z01 = ak_world.GetMapHeight(x, y);
						var x01 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
						var y01 = (Math.round(view_yx * x + view_yy * y - z01) | 0) + view_ty;

						y++;
						var z11 = ak_world.GetMapHeight(x, y);
						var x11 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
						var y11 = (Math.round(view_yx * x + view_yy * y - z11) | 0) + view_ty;

						x--;
						var z10 = ak_world.GetMapHeight(x, y);
						var x10 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
						var y10 = (Math.round(view_yx * x + view_yy * y - z10) | 0) + view_ty;

						y--;

						// split by shorter diagonal
						if (Math.abs(z10 - z01) <= Math.abs(z00 - z11)) {
							quad[q] = x00;
							quad[q + 1] = y00;
							quad[q + 2] = z00;
							quad[q + 3] = x;
							quad[q + 4] = y;

							quad[q + 5] = x01;
							quad[q + 6] = y01;
							quad[q + 7] = z01;
							quad[q + 8] = x + 1;
							quad[q + 9] = y;

							quad[q + 10] = x10;
							quad[q + 11] = y10;
							quad[q + 12] = z10;
							quad[q + 13] = x;
							quad[q + 14] = y + 1;

							//

							quad[q + 15] = x10;
							quad[q + 16] = y10;
							quad[q + 17] = z10;
							quad[q + 18] = x;
							quad[q + 19] = y + 1;

							quad[q + 20] = x01;
							quad[q + 21] = y01;
							quad[q + 22] = z01;
							quad[q + 23] = x + 1;
							quad[q + 24] = y;

							quad[q + 25] = x11;
							quad[q + 26] = y11;
							quad[q + 27] = z11;
							quad[q + 28] = x + 1;
							quad[q + 29] = y + 1;

						} else {
							quad[q] = x00;
							quad[q + 1] = y00;
							quad[q + 2] = z00;
							quad[q + 3] = x;
							quad[q + 4] = y;

							quad[q + 5] = x01;
							quad[q + 6] = y01;
							quad[q + 7] = z01;
							quad[q + 8] = x + 1;
							quad[q + 9] = y;

							quad[q + 10] = x11;
							quad[q + 11] = y11;
							quad[q + 12] = z11;
							quad[q + 13] = x + 1;
							quad[q + 14] = y + 1;

							//

							quad[q + 15] = x11;
							quad[q + 16] = y11;
							quad[q + 17] = z11;
							quad[q + 18] = x + 1;
							quad[q + 19] = y + 1;

							quad[q + 20] = x10;
							quad[q + 21] = y10;
							quad[q + 22] = z10;
							quad[q + 23] = x;
							quad[q + 24] = y + 1;

							quad[q + 25] = x00;
							quad[q + 26] = y00;
							quad[q + 27] = z00;
							quad[q + 28] = x;
							quad[q + 29] = y;

						}

						q += 30;
					}
				}
			}

			var line_step = 1; // tile_size / line_step MUST BE INTEGER

			function akTransformLine(x, y, quad) {
				var qx0 = x * tile_size;
				var qy0 = y * tile_size;
				var qx1 = qx0 + tile_size;
				var qy1 = qy0 + tile_size;

				var q = 0;


				for (x = qx1, y = qy0; x >= qx0; x -= line_step) {
					var z00 = ak_world.GetMapHeight(x, y);
					var x00 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y00 = (Math.round(2.0 * (view_yx * x + view_yy * y - z00)) | 0) + 2 * view_ty;

					quad[q] = x00;
					quad[q + 1] = y00;
					quad[q + 2] = z00;
					q += 3;
				}

				for (x = qx0, y = qy0 + line_step; y <= qy1; y += line_step) {
					var z00 = ak_world.GetMapHeight(x, y);
					var x00 = (Math.round(view_xx * x + view_xy * y) | 0) + view_tx;
					var y00 = (Math.round(2.0 * (view_yx * x + view_yy * y - z00)) | 0) + 2 * view_ty;

					quad[q] = x00;
					quad[q + 1] = y00;
					quad[q + 2] = z00;
					q += 3;
				}
			}

			var pan_tid = -1; // touch id
			var pan_x0 = 0;
			var pan_y0 = 0;
			var pan = false;

			var kbd_slow_inv = false;
			var kbd_slow = 0;
			var kbd_left = 0;
			var kbd_right = 0;
			var kbd_up = 0;
			var kbd_down = 0;
			var kbd_rot_left = 0;
			var kbd_rot_right = 0;
			var kbd_jmp = 0;

			function getKbdX() {
				if (kbd_left >= 1 && kbd_right <= 0)
					return -1;
				if (kbd_right >= 1 && kbd_left <= 0)
					return +1;
				return 0;
			}

			function getKbdY() {
				if (kbd_up >= 1 && kbd_down <= 0)
					return -1;
				if (kbd_down >= 1 && kbd_up <= 0)
					return +1;
				return 0;
			}

			function getKbdZ() {
				if (kbd_rot_right >= 1 && kbd_rot_left <= 0)
					return -1;
				if (kbd_rot_left >= 1 && kbd_rot_right <= 0)
					return +1;
				return 0;
			}

			function getKbdSlow() {
				if (kbd_slow_inv)
					return (kbd_slow <= 0);
				return (kbd_slow >= 1);
			}

			function getKbdJmp() {
				if (kbd_jmp >= 1) {
					kbd_jmp = 0;
					return true;
				}
				return false;
			}

			var kbd_state = new Int8Array(256);

			function setKeybHandlers() {
				function onKey(e, z) {
					// repeat detector
					if (kbd_state[e.which] === (z > 0 ? 1 : 0))
						return true;

					if (e.getModifierState !== undefined)
						kbd_slow_inv = e.getModifierState("CapsLock");

					if (e.ctrlKey === true && (e.which === 61 || e.which === 107 || e.which === 173 || e.which === 109 || e.which === 187 || e.which === 189)) {
						console.log("zoom");
						e.preventDefault();
					}

					switch (e.which) {
						case 0x20: // space
							kbd_jmp += z;
							break;

						case 114: // F3
							if (z > 0) {
								var rec = IsRecording();
								if (rec === 0)
									StartRecorder();
								else if (rec === 1)
									StopRecorder();
							}
							break;

						case 113: // F2
							if (z > 0) {
								var filename = prompt("Screen Shot", "shot.xp");
								if (filename !== null)
									xp_Export(ak_buf32, ak_width, ak_height, filename);
							}
							break;

						case 16: //shift
							kbd_slow += z;
							break;

						case 35: //end
						case 97: //num1
							kbd_left += z;
							kbd_down += z;
							break;

						case 40: //down
						case 98: //num2
						case 83: //keyS
							kbd_down += z;
							break;

						case 34: //pgdn
						case 99: //num3
							kbd_right += z;
							kbd_down += z;
							break;

						case 37: //left
						case 100: //num4
						case 65: //keyA
							kbd_left += z;
							break;

						case 39: //right
						case 102: //num6
						case 68: //keyD
							kbd_right += z;
							break;

						case 36: //home
						case 103: //num7
							kbd_left += z;
							kbd_up += z;
							break;

						case 38: //up
						case 104: //num8
						case 87: //keyW
							kbd_up += z;
							break;

						case 33: //pgup
						case 105: //num9
							kbd_right += z;
							kbd_up += z;
							break;

						case 81: //keyQ
							kbd_rot_left += z;
							//if (z>0)
							//	dest_angle += 90/3;
							break;

						case 69: //keyE
							kbd_rot_right += z;
							//if (z>0)
							//	dest_angle -= 90/3;
							break;

						default:
							return false;
					}

					kbd_state[e.which] = (z > 0 ? 1 : 0);

					kbd_slow = kbd_slow >= 0 ? kbd_slow : 0;
					kbd_jmp = kbd_jmp >= 0 ? kbd_jmp : 0;

					kbd_left = kbd_left >= 0 ? kbd_left : 0;
					kbd_right = kbd_right >= 0 ? kbd_right : 0;
					kbd_up = kbd_up >= 0 ? kbd_up : 0;
					kbd_down = kbd_down >= 0 ? kbd_down : 0;

					kbd_rot_left = kbd_rot_left >= 0 ? kbd_rot_left : 0;
					kbd_rot_right = kbd_rot_right >= 0 ? kbd_rot_right : 0;

					return true;
				}

				window.addEventListener("keydown", function (e) {
					if (onKey(e, +1)) e.preventDefault();
				});

				window.addEventListener("keyup", function (e) {
					if (onKey(e, -1)) e.preventDefault();
				});

				function onBlur(e) {
					for (var k = 0; k < 256; k++)
						kbd_state[k] = 0;
					kbd_left = kbd_right = kbd_up = kbd_down = 0;
					kbd_rot_left = kbd_rot_right = 0;
				}

				window.addEventListener("blur", onBlur);
				window.addEventListener("contextmenu", onBlur);
			}

			function setMouseHandlers() {
				function preventZoom(e) {
					console.log("zoom");
					e.preventDefault();
				}

				window.addEventListener("DOMMouseScroll", preventZoom);
				window.addEventListener("mousewheel", preventZoom);

				window.addEventListener("mousedown", function (e) {
					if (e.which === 1) {
						if (!pan) {
							pan = true;
							pan_x0 = e.pageX / (ak_fonts[ak_font].width >> 4);
							pan_y0 = e.pageY / (ak_fonts[ak_font].height >> 4);
						}
					}
				});

				window.addEventListener("mousemove", function (e) {
					if (pan && pan_tid < 0) {
						var x = e.pageX / (ak_fonts[ak_font].width >> 4);
						var y = e.pageY / (ak_fonts[ak_font].height >> 4);

						var dx = (x - pan_x0) * ak_ratio / ak_tile_to_char;
						var dy = (y - pan_y0) * 2 * ak_ratio / ak_tile_to_char;

						world_center_x -= Math.cos(-view_angle * Math.PI / 180) * dx - Math.sin(-view_angle * Math.PI / 180) * dy;
						world_center_y -= Math.sin(-view_angle * Math.PI / 180) * dx + Math.cos(-view_angle * Math.PI / 180) * dy;

						pan_x0 = x;
						pan_y0 = y;
					}
				});

				window.addEventListener("mouseup", function (e) {
					if (pan && e.which === 1 && pan_tid < 0) {
						pan = false;
					}
				});
			}

			var edge_shade = new Uint32Array([0x030200B0, 0x030800B0, 0x030800B1, 0x080300B0, 0x08030020, 0x080000B0, 0x080000B1, 0x000800B0]);

			var shade0 = new Uint32Array([0x02000060, 0x020000F9, 0x020000FA, 0x02080020, 0x020A00FA, 0x020A00F9, 0x020A0060]); // regular
			var shade1 = new Uint32Array([0x02030025, 0x02030025, 0x02030025, 0x02030025, 0x02030025, 0x02030025, 0x02030025]); // green squashed
			var shade2 = new Uint32Array([0x02010060, 0x020100F9, 0x020100FA, 0x02080020, 0x020B00FA, 0x020B00F9, 0x020B0060]); // tall green
			var shade3 = new Uint32Array([0x03020025, 0x03020025, 0x03020025, 0x03020025, 0x03020025, 0x03020025, 0x03020025]); // brown squashed
			var shade4 = new Uint32Array([0x03000060, 0x030000F9, 0x030000FA, 0x030B00F9, 0x030B00FA, 0x030B00F9, 0x030B0060]); // tall brown
			var shade5 = new Uint32Array([0x0807002E, 0x0807003A, 0x08070025, 0x07080023, 0x07080025, 0x0708003A, 0x0708002E]); // cliff

			var shade = [shade0, shade1, shade2, shade3, shade4, shade5];

			var prev_ts = null;

			function akPaint(ts) {
				var dt = 0;

				if (ts) {
					if (prev_ts) {
						dt = 60 / 1000 * (ts - prev_ts);
					}

					if (dt > 5) {
						console.log("paint lag", dt);
						dt = 5;
					}

					prev_ts = ts;
					frame++;
					requestAnimationFrame(akPaint);
				}

				/*
					var anim_water = Math.round(ak_lib.terrain.water + Math.sin(frame*0.1)*8);
					ak_screen.setWater(anim_water);
					ak_world.setWater(anim_water);
					*/


				if (ak_screen.getWidth() !== ak_width ||
					ak_screen.getHeight() !== ak_height) {
					ak_screen.Resize(ak_width, ak_height);
				} else {
					// if input is idle for more than 2secs
					// we can assume no state is changing
					// do power saving (just return)
				}


				// npcs

				for (var n = 0; n < npcs; n++) {
					var idx = n * 9;

					// check if reached dest
					var dx = npc[idx + 7] - npc[idx];
					var dy = npc[idx + 8] - npc[idx + 1];
					var dd = dx * dx + dy * dy;

					var dir = Math.atan2(dy, -dx) * 180 / Math.PI;
					if (dir < 0)
						dir += 360;
					npc[idx + 3] = dir; //dir

					if (dd < 10) {
						var jdx = ((Math.random() * npcs) | 0) * 9;
						npc[idx + 7] = npc[jdx + 5];
						npc[idx + 8] = npc[jdx + 6];
					} else {
						var vel = 4 * 4 / ak_tile_to_char;
						dd = vel / Math.sqrt(dd);
						dx *= dd;
						dy *= dd;

						npc[idx] += dx * 0.01 * 4 * dt;
						npc[idx + 1] += dy * 0.01 * 4 * dt;
						npc[idx + 2] = ak_world.SampleMapHeight(npc[idx], npc[idx + 1]);

						//frm
						var frm = npc[idx + 4] + vel * dt * 0.01 * 10; // 7 no slow
						frm -= (frm / 8) << 3;
						npc[idx + 4] = frm;

						ak_world.DecMapDecal(npc[idx], npc[idx + 1]);
					}
				}


				// SERIOUS STUFF:

				var kz = getKbdZ();
				if (kz === 0) {
					if (ak_touch_left >= 0)
						kz += 1;
					if (ak_touch_right >= 0)
						kz -= 1;
				}

				if (kz !== 0) {

					dest_angle = view_angle + 30 * kz;

					// snap to closest 45 + int * 30
					dest_angle -= 45;
					dest_angle /= 30;
					dest_angle = Math.round(dest_angle) | 0;
					dest_angle *= 30;
					dest_angle += 45;
				}

				var delta_angle = dest_angle - view_angle;
				var abs_delta_angle = Math.abs(delta_angle);
				if (abs_delta_angle > 20) // limit rotation speed!
					delta_angle *= 20 / abs_delta_angle;
				delta_angle *= dt;
				if (delta_angle < 0)
					delta_angle -= 3.0;
				if (delta_angle > 0)
					delta_angle += 3.0;
				view_angle += delta_angle * 0.05 * (3);
				if (Math.abs(dest_angle - view_angle) < 0.2 * (3))
					view_angle = dest_angle;

				var kbd_x = getKbdX();
				var kbd_y = getKbdY();

				if (kbd_x === 0 && kbd_y === 0) {
					kbd_x = 4 * ak_tile_to_char * ak_touch_move_dx / ak_width;
					kbd_y = 4 * ak_tile_to_char * ak_touch_move_dy / ak_height;
					var kbd_m = Math.sqrt(kbd_x * kbd_x + kbd_y * kbd_y);

					if (kbd_m > 1.0) {
						kbd_m = 1.0 / kbd_m;
						kbd_x *= kbd_m;
						kbd_y *= kbd_m;
					}
				} else if (kbd_x !== 0 || kbd_y !== 0) {
					var kbd_m = 1.0 / Math.sqrt(kbd_x * kbd_x + kbd_y * kbd_y);
					kbd_x *= kbd_m;
					kbd_y *= kbd_m;
				}

				if (kbd_x !== 0 || kbd_y !== 0)
					player_dir = 180 * Math.atan2(kbd_y, -kbd_x) / Math.PI + view_angle;

				var dx = dt * kbd_x * 4 / ak_tile_to_char;
				var dy = dt * kbd_y * 4 / ak_tile_to_char;

				velocity_x += Math.cos(-view_angle * Math.PI / 180) * dx - Math.sin(-view_angle * Math.PI / 180) * dy;
				velocity_y += Math.sin(-view_angle * Math.PI / 180) * dx + Math.cos(-view_angle * Math.PI / 180) * dy;

				velocity_m = Math.sqrt(velocity_x * velocity_x + velocity_y * velocity_y);

				var max_v = 100.0; // running limit by dump & acc

				var slow = getKbdSlow();
				if (slow)
					max_v = 3 * 4 / ak_tile_to_char;

				if (velocity_m > max_v) {
					var clamp = max_v / velocity_m;
					velocity_x *= clamp;
					velocity_y *= clamp;
					velocity_m = max_v;
				} else {
					if (velocity_m >= 0.1) {
						var damp = Math.pow(0.9, dt);
						velocity_x *= damp;
						velocity_y *= damp;
						velocity_m *= damp;
					} else {
						velocity_x = 0;
						velocity_y = 0;
						velocity_m = 0;
					}
				}

				player_frm = player_frm + velocity_m * dt * 0.01 * (slow ? 10 : 7);
				player_frm -= (player_frm / 8) << 3;
				if (velocity_m === 0)
					player_frm = -1;

				world_center_x += velocity_x * 0.01 * 4 * dt;
				world_center_y += velocity_y * 0.01 * 4 * dt;
				world_center_z += velocity_z * 0.01 * dt;

				var x_tiles = ((ak_world.getMapWidth() - 1) / tile_size) | 0;
				var y_tiles = ((ak_world.getMapHeight() - 1) / tile_size) | 0;

				if (world_center_x - 4 < 0)
					world_center_x = 4;
				if (world_center_y - 4 < 0)
					world_center_y = 4;

				if (world_center_x + 4 > x_tiles * tile_size)
					world_center_x = x_tiles * tile_size - 4;
				if (world_center_y + 4 > y_tiles * tile_size)
					world_center_y = y_tiles * tile_size - 4;

				var water = ak_world.getWater();

				var ground = ak_world.SampleMapHeight(world_center_x, world_center_y);
				if (world_center_z < ground) {
					var dz = (ground - world_center_z) / 0.01;
					if (velocity_z < dz)
						velocity_z = 0.9 * velocity_z + 0.1 * dz;
					if (velocity_z > 1)
						velocity_z = 1;
					world_center_z = ground;
				} else if (world_center_z > ground) {
					if (world_center_z + 3 >= water)
						velocity_z -= 4 * dt;
					else {
						velocity_z += (water - world_center_z - 3) * dt * 0.2;
						var damp = Math.pow(0.95, dt);
						velocity_z *= damp;
						velocity_x *= damp * damp * damp * damp * damp;
						velocity_y *= damp * damp * damp * damp * damp;
					}
				}

				if (Math.abs(world_center_z - ground) <= 1) {
					ak_world.DecMapDecal(world_center_x, world_center_y);
					if (getKbdJmp() || ak_touch_jmp >= 0) {
						ak_touch_jmp = -1;
						velocity_z = 100;
					}
				}

				var light_angle = frame;
				var light_z = 0.0;
				var light_x = Math.sin(light_angle / 180 * Math.PI);
				var light_y = Math.cos(light_angle / 180 * Math.PI);

				var x_tiles = ((ak_world.getMapWidth() - 1) / tile_size) | 0;
				var y_tiles = ((ak_world.getMapHeight() - 1) / tile_size) | 0;

				akPreTransform(ak_hull, water);
				//ak_world.SetLight(light_x,light_y,light_z,ak_hull);

				var cb1 = function (x, y, n) {
					var shade_smooth = ak_world.getMapSmooth();
					var shade_buffer = ak_world.getShadeBuf();
					var decal_buffer = ak_world.getDecalBuf();
					var shade_width = ak_world.getMapWidth();
					var depth_buffer = ak_screen.getDepthBuf();

					function sample(u, v, h, i) {
						var j = ((shade_smooth * u) | 0) + ((shade_smooth * v) | 0) * shade_width * shade_smooth;
						var dec = decal_buffer[j];

						/*
							if (dec <= 2)
								dec <<= 1;
							else
							if (dec & 1)
								dec = 1;
							else
								dec = 3;
							*/

						switch (dec) {
							case 1:
								dec = 5;
								break;
							case 3:
								dec = 4;
								break;
							default:
								if (dec >= 4) {
									if (dec & 1)
										dec = 3;
									else
										dec = 1;
								}
						}

						var shd = (shade_buffer[j] & 0xFF) >> 5;

						// shd= ((v+u)/shade_smooth)&0x7;
						// shd=0;

						shd = shd > 6 ? 6 : shd;

						// FUCK ME, let's move thick layers completely to post-fx pass !
						// and optimize by merging _Patch() with sample() into specialized _PatchXXX() w/o callback

						var d = i << 2;
						switch (dec) {
							case 2: {
								var d2 = d - 4 * ak_width;
								var i2 = i - ak_width;
								var h2 = h + 1;
								var h3 = h - 1;

								if (d2 >= 0 && depth_buffer[d2] <= h2) {
									ak_buf32[i2] = shade[dec][shd] | 0x100; // thick flag
									depth_buffer[d2] = h2;
									depth_buffer[d2 + 1] = h2;
									depth_buffer[d2 + 2] = h2;
									depth_buffer[d2 + 3] = h2;
								}
								if (depth_buffer[d] <= h3) {
									ak_buf32[i] = 0x02000025;//BA;
									depth_buffer[d] = h3;
									depth_buffer[d + 1] = h3;
									depth_buffer[d + 2] = h3;
									depth_buffer[d + 3] = h3;
								}
								break;
							}

							case 4: {
								var d2 = d - 4 * ak_width;
								var i2 = i - ak_width;
								var h2 = h + 1;
								var h3 = h - 1;

								if (d2 >= 0 && depth_buffer[d2] <= h2) {
									ak_buf32[i2] = shade[dec][shd] | 0x100; // thick flag
									depth_buffer[d2] = h2;
									depth_buffer[d2 + 1] = h2;
									depth_buffer[d2 + 2] = h2;
									depth_buffer[d2 + 3] = h2;
								}
								if (depth_buffer[d] <= h3) {
									ak_buf32[i] = 0x03000025;//BA;
									depth_buffer[d] = h3;
									depth_buffer[d + 1] = h3;
									depth_buffer[d + 2] = h3;
									depth_buffer[d + 3] = h3;
								}
								break;
							}

							default: {
								if (depth_buffer[d] <= h) {
									ak_buf32[i] = shade[dec][shd];
									depth_buffer[d] = h;
									depth_buffer[d + 1] = h;
									depth_buffer[d + 2] = h;
									depth_buffer[d + 3] = h;
								}
							}
						}

					}

					var count = 2 * tile_size * tile_size; // triangles
					var first = 0;
					var stride = 5; //x,y,z,u,v
					akTransformPatch(x, y, tile_patch);
					ak_screen._Patch(tile_patch, stride, first, count, sample, false);

					function edge_sample(u, v, h, i) {
						var d = i << 2;
						if (depth_buffer[d] <= h) {
							var shd = (0.03125 * u) | 0;
							if (shd < 0)
								shd = 0;
							if (shd > 7)
								shd = 7;
							ak_buf32[i] = edge_shade[shd];
							depth_buffer[d] = h;
							depth_buffer[d + 1] = h;
							depth_buffer[d + 2] = h;
							depth_buffer[d + 3] = h;
						}
					}

					// if this is boundary patch: paint world boundaries
					if (x === 0) {
						// paint left border
						akTransformLeft(x, y, tile_patch, water, false);
						ak_screen._Patch(tile_patch, stride, first, 2 * tile_size, edge_sample, false);
					}
					if (y === 0) {
						// paint top border
						akTransformTop(x, y, tile_patch, water, false);
						ak_screen._Patch(tile_patch, stride, first, 2 * tile_size, edge_sample, false);
					}
					if (x === x_tiles - 1) {
						akTransformRight(x, y, tile_patch, water, false);
						ak_screen._Patch(tile_patch, stride, first, 2 * tile_size, edge_sample, false);
						// paint right border
					}
					if (y === y_tiles - 1) {
						// paint bottom border
						akTransformBottom(x, y, tile_patch, water, false);
						ak_screen._Patch(tile_patch, stride, first, 2 * tile_size, edge_sample, false);
					}
				};

				var cb2 = function (x, y, n) {
					if (x === 0 && y === 0)
						return;

					akTransformLine(x, y, tile_patch);
					var lines = (tile_size / line_step) | 0;
					if (y > 0) {
						for (var l = 0; l < 3 * lines; l += 3) {
							ak_screen.Line(tile_patch[l], tile_patch[l + 1], tile_patch[l + 2], tile_patch[l + 3], tile_patch[l + 4], tile_patch[l + 5], 0xFFFF0000, true);
						}
					}
					if (x > 0) {
						for (var l = 3 * lines; l < 6 * lines; l += 3) {
							ak_screen.Line(tile_patch[l], tile_patch[l + 1], tile_patch[l + 2], tile_patch[l + 3], tile_patch[l + 4], tile_patch[l + 5], 0xFFFF0000, true);
						}
					}
				};

				ak_screen.Disable(ak_screen.SCISSOR_TEST);
				ak_screen.Disable(ak_screen.SCROLL_TEST);
				ak_screen.Enable(ak_screen.DEPTH_TEST);
				//ak_screen.Disable(ak_screen.DEPTH_TEST);
				ak_screen.Clear(12 + 16, 4 + 16, 32, 0);

				/*
					{
						// FAILED WITH STATIC IMAGE
						var sky_img = ak_lib.images[4].img;
						var sky_w = sky_img.getWidth();
						var sky_h = sky_img.getHeight();

						var sky_a = -view_angle;
						if (sky_a<0)
							sky_a += 360* ((1-sky_a/360)|0);

						sky_a = ( (sky_a|0)%360 ) / 360.0;

						var pan_x = (sky_w*sky_a)|0;
						var pan_y = (sky_h - ak_height)>>1;


						if (pan_x + ak_width > sky_w)
						{
							var dw = sky_w - pan_x;
							ak_screen.Blend(sky_img, pan_x,pan_y, 0,0, dw,ak_height, 0xF, water+1);
							ak_screen.Blend(sky_img, 0,pan_y, dw,0, ak_width - dw,ak_height, 0xF, water+1);
						}
						else
							ak_screen.Blend(sky_img, pan_x,pan_y, 0,0, ak_width,ak_height, 0xF, water+1);

					}
					*/

				// update slow-noise buffer
				/*
					var domain=ak_width*ak_height;
					var samples=domain*0.025*dt
					for (var i=0; i<samples; i++)
					{
						var sample = (Math.random()*domain)|0;
						ak_buf32[sample] ^= 0x100;
					}
					*/

				/*
					var domain=ak_height;
					var samples=domain*dt*0.1;
					for (var i=0; i<samples; i++)
					{
						var len = Math.random()*12+4;
						var sample = (Math.random()*(ak_width*ak_height-len))|0;

						var q=0;
						if (len&1)
							q=0x100;
						for (var j=0; j<len; j++)
						{
							ak_buf32[sample+j] = ak_buf32[sample+j] & 0xffff00ff;
							ak_buf32[sample+j] |= q;
						}
					}

					// paint waves
					for (var i=0; i<ak_width*ak_height-ak_height; i++)
					{
						var j=i+ak_width;

						if ((ak_buf32[i]& 0x100) && (ak_buf32[j]& 0x100)===0)
							ak_buf32[i] = (ak_buf32[i] & 0xffffff00) | 0x0000005F;
					}
					*/


				var count = ak_world.QueryHull(ak_hull, cb1);

				// GRID LINES (->option)
				ak_world.QueryHull(ak_hull, cb2);

				var depth_buffer = ak_screen.getDepthBuf();

				// POST-FX upper decal silhouettes
				for (var y = 0, i = 0; y < ak_height - 1; y++) {
					for (var x = 0; x < ak_width; x++, i++) {
						// if decal here is flat
						// and decal below is raised
						// (we store raised decals in buf32[] & 0x00000100)
						var here = ak_buf32[i];

						if ((here & 0x10100100) === 0x000) {
							var below = ak_buf32[i + ak_width];
							if ((below & 0x100) === 0x100) {
								// put here comma (original bk but fg is 8+ raised decal bk)
								if ((here & 0x0F000000) == 0x07000000)
								// if is above decal we have a rock, force its bkg to dk-grey
									ak_buf32[i] = 0x0808002C | ((below >> 8) & 0x00FF0000);
								else
									ak_buf32[i] = (here & 0xFF000000) | (0x0008002C | ((below >> 8) & 0x00FF0000));
							}
						}


						// silhouettes? fuck yeah
						var j = 4 * i;
						var ddif = depth_buffer[j + ak_width * 4] - depth_buffer[j];
						if (ddif >= 7 /* && (frame&0x1f)<0xf */) {
							var ul = ak_buf32[i - ak_width - 1] & 0xFF;
							var ur = ak_buf32[i - ak_width + 1] & 0xFF;
							var ab = ak_buf32[i - ak_width + 1] & 0xFF;

							if ((ul === 95 || ul === 92) && (ur === 95 || ur === 47)) {
								// if upper left & upper right are already marked, put -
								ak_buf32[i] = (ak_buf32[i] & 0xFF00FF00) | 45;
							} else if (ul === 95 || ul === 92) {
								// if upper left put \
								ak_buf32[i] = (ak_buf32[i] & 0xFF00FF00) | 92;
							} else if (ur === 95 || ur === 47) {
								// if upper right put /
								ak_buf32[i] = (ak_buf32[i] & 0xFF00FF00) | 47;
							} else {
								// otherwise just put _
								ak_buf32[i] = (ak_buf32[i] & 0xFF00FF00) | 95;//0x00000016;
							}
						}
					}
				}

				var scroll_x = ak_screen.getScrollX();
				var scroll_y = ak_screen.getScrollY();


				///////////////////////////////////////////////////////////
				// terrain reflection

				// mirror view transform & culling hull:

				akPreTransform(ak_hull, water); // once again so they are in expected order!

				// refl top
				ak_hull[11] = ak_hull[11] + 2 * ak_hull[10] * water;
				ak_hull[10] = -ak_hull[10];

				// refl bottom
				ak_hull[15] = ak_hull[15] + 2 * ak_hull[14] * water;
				ak_hull[14] = -ak_hull[14];

				var cb_refl1 = function (x, y, n) {

					var shade_smooth = ak_world.getMapSmooth();
					var shade_buffer = ak_world.getShadeBuf();
					var decal_buffer = ak_world.getDecalBuf();
					var shade_width = ak_world.getMapWidth();
					var depth_buffer = ak_screen.getDepthBuf();

					function sample(u, v, h, i) {
						var d = i << 2;
						if ((ak_buf32[i] & 0x10100000) !== 0 && depth_buffer[d] >= h || depth_buffer[d] === 0) {

							var j = ((shade_smooth * u) | 0) + ((shade_smooth * v) | 0) * shade_width * shade_smooth;
							var dec = decal_buffer[j];
							/*
								if (dec <= 2)
									dec <<= 1;
								else
								if (dec & 1)
									dec = 1;
								else
									dec = 3;
								*/
							switch (dec) {
								case 1:
									dec = 5;
									break;
								case 3:
									dec = 4;
									break;
								default:
									if (dec >= 4) {
										if (dec & 1)
											dec = 3;
										else
											dec = 1;
									}
							}

							var shd = (shade_buffer[j] & 0xFF) >> 5;
							shd = shd > 6 ? 6 : shd;

							switch (dec) {
								case 2: {

									ak_buf32[i] = shade[dec][shd] | 0x10100000;
									depth_buffer[d] = h;
									depth_buffer[d + 1] = h;
									depth_buffer[d + 2] = h;
									depth_buffer[d + 3] = h;
									break;
								}

								case 4: {
									ak_buf32[i] = shade[dec][shd] | 0x10100000;
									depth_buffer[d] = h;
									depth_buffer[d + 1] = h;
									depth_buffer[d + 2] = h;
									depth_buffer[d + 3] = h;
									break;
								}

								default: {
									ak_buf32[i] = shade[dec][shd] | 0x10100000;
									depth_buffer[d] = h;
									depth_buffer[d + 1] = h;
									depth_buffer[d + 2] = h;
									depth_buffer[d + 3] = h;
								}
							}
						}
					}

					var count = 2 * tile_size * tile_size; // triangles
					var first = 0;
					var stride = 5; //x,y,z,u,v
					akTransformPatchRefl(x, y, tile_patch, water);
					ak_screen._Patch(tile_patch, stride, first, count, sample, true);

					function edge_sample(u, v, h, i) {
						var d = i << 2;
						var shd = (0.03125 * u) | 0;
						if (shd < 0)
							shd = 0;
						if (shd > 7)
							shd = 7;
						ak_buf32[i] = edge_shade[shd] | 0x10100000;
						depth_buffer[d] = h;
						depth_buffer[d + 1] = h;
						depth_buffer[d + 2] = h;
						depth_buffer[d + 3] = h;
					}

					// if this is boundary patch: paint world boundaries
					if (x === 0) {
						// paint left border
						akTransformLeft(x, y, tile_patch, water, true);
						ak_screen._Patch(tile_patch, stride, first, 2 * tile_size, edge_sample, true);
					}
					if (y === 0) {
						// paint top border
						akTransformTop(x, y, tile_patch, water, true);
						ak_screen._Patch(tile_patch, stride, first, 2 * tile_size, edge_sample, true);
					}
					if (x === x_tiles - 1) {
						akTransformRight(x, y, tile_patch, water, true);
						ak_screen._Patch(tile_patch, stride, first, 2 * tile_size, edge_sample, true);
						// paint right border
					}
					if (y === y_tiles - 1) {
						// paint bottom border
						akTransformBottom(x, y, tile_patch, water, true);
						ak_screen._Patch(tile_patch, stride, first, 2 * tile_size, edge_sample, true);
					}
				};

				var refl_count = ak_world.QueryHull(ak_hull, cb_refl1);

				////////////////////////////////////////////////////////////////////////////////////
				// 2 sprite passes: over water, under water
				akPreTransform(ak_hull, water);
				for (var pass = 0; pass < 2; pass++) {
					var refl = pass !== 0;

					var sprites = 0;
					// paint sprites (houses/trees)
					var cb3 = function (id, x, y, z, state) {
						if (id === 0) {
							var hx = x * tile_size;
							var hy = y * tile_size;
							var cz = z;
							var cx = Math.round(view_xx * hx + view_xy * hy + view_tx) | 0;
							var cy = Math.floor(view_yx * hx + view_yy * hy - z + view_ty) | 0;

							if (refl)
								cy = (cy + 2 * (z - water)/*+0.5*/) | 0;

							ak_lib.sprites[id].paint(ak_lib, ak_screen, cx, cy, cz, light_angle, view_angle, refl, state);
						} else {
							var hx = x * tile_size;
							var hy = y * tile_size;
							var hz = z;

							ak_lib.sprites[id].paint3d(
								ak_lib, ak_screen,
								hx, hy, hz,
								view_xx, view_xy, view_tx,
								view_yx, view_yy, view_ty,
								light_angle, view_angle,
								refl, water, state);
						}

						sprites++;
					}

					count = ak_world.QueryHull(ak_hull, function (x, y, n) {
						ak_world.GetSprites(n, cb3);
					});

					// paint player with shadow
					{
						var cx = (view_xx * world_center_x + view_xy * world_center_y + view_tx + 0.5) | 0;
						var cy = (view_yx * world_center_x + view_yy * world_center_y - world_center_z + view_ty + 0.5) | 0;
						var cz = Math.round(world_center_z);

						if (refl) {
							cy = (cy + 2 * (world_center_z - water)/*+0.5*/) | 0;
						}

						// var frm = (frame>>1) & 7;
						var dx = 2.0 * Math.cos(-view_angle * Math.PI / 180) / ak_tile_to_char;
						var dy = 2.0 * Math.sin(-view_angle * Math.PI / 180) / ak_tile_to_char;

						var z1 = Math.round(ak_world.SampleMapHeight(world_center_x - dx, world_center_y - dy));
						var x1 = Math.round(view_xx * (world_center_x - dx) + view_xy * (world_center_y - dy) + view_tx) | 0;
						var y1 = Math.round(view_yx * (world_center_x - dx) + view_yy * (world_center_y - dy) - z1 + view_ty) | 0;
						var z2 = Math.round(ak_world.SampleMapHeight(world_center_x + dx, world_center_y + dy));
						var x2 = Math.round(view_xx * (world_center_x + dx) + view_xy * (world_center_y + dy) + view_tx) | 0;
						var y2 = Math.round(view_yx * (world_center_x + dx) + view_yy * (world_center_y + dy) - z2 + view_ty) | 0;

						// fix shadow asymmetry when y1==y2
						if (y1 !== y2)
							ak_screen.Line(x1, y1, z1, x2, y2, z2, 0, false);
						else {
							if (x1 < x2)
								ak_screen.Line(x1, y1, z1, x2 + 1, y2, z2, 0, false);
							else
								ak_screen.Line(x1 + 1, y1, z1, x2, y2, z2, 0, false);
						}

						ak_lib.sprites[1].paint(ak_lib, ak_screen, cx, cy, cz, light_angle, view_angle, refl, (player_dir << 16) | (player_frm & 0xFFFF));
					}

					// npcs
					for (var n = 0; n < npcs; n++) {
						var idx = n * 9;

						var cx = (view_xx * npc[idx] + view_xy * npc[idx + 1] + view_tx + 0.5) | 0;
						var cy = (view_yx * npc[idx] + view_yy * npc[idx + 1] - npc[idx + 2] + view_ty + 0.5) | 0;

						if (refl)
							cy = (cy + 2 * (npc[idx + 2] - water)/*+0.5*/) | 0;

						var cz = npc[idx + 2];

						// var frm = (frame>>1) & 7;
						var dx = 2.0 * Math.cos(-view_angle * Math.PI / 180) / ak_tile_to_char;
						var dy = 2.0 * Math.sin(-view_angle * Math.PI / 180) / ak_tile_to_char;

						var z1 = Math.round(ak_world.SampleMapHeight(npc[idx] - dx, npc[idx + 1] - dy));
						var x1 = Math.round(view_xx * (npc[idx] - dx) + view_xy * (npc[idx + 1] - dy) + view_tx) | 0;
						var y1 = Math.round(view_yx * (npc[idx] - dx) + view_yy * (npc[idx + 1] - dy) - z1 + view_ty) | 0;
						var z2 = Math.round(ak_world.SampleMapHeight(npc[idx] + dx, npc[idx + 1] + dy));
						var x2 = Math.round(view_xx * (npc[idx] + dx) + view_xy * (npc[idx + 1] + dy) + view_tx) | 0;
						var y2 = Math.round(view_yx * (npc[idx] + dx) + view_yy * (npc[idx + 1] + dy) - z2 + view_ty) | 0;

						// fix shadow asymmetry when y1==y2
						if (y1 !== y2)
							ak_screen.Line(x1, y1, z1, x2, y2, z2, 0, false);
						else {
							if (x1 < x2)
								ak_screen.Line(x1, y1, z1, x2 + 1, y2, z2, 0, false);
							else
								ak_screen.Line(x1 + 1, y1, z1, x2, y2, z2, 0, false);
						}

						ak_lib.sprites[1].paint(ak_lib, ak_screen, cx, cy, cz, light_angle, view_angle, refl, (npc[idx + 3] << 16) | (npc[idx + 4] & 0xFFFF));

						// can we paint animated waves if its z < water?
						// ...
					}


					if (!refl) {
						akPreTransform(ak_hull, water);
						// refl top
						ak_hull[11] = ak_hull[11] + 2 * ak_hull[10] * water;
						ak_hull[10] = -ak_hull[10];

						// refl bottom
						ak_hull[15] = ak_hull[15] + 2 * ak_hull[14] * water;
						ak_hull[14] = -ak_hull[14];
					}
				}

				// sprites end
				///////////////////////////////

				// last pass
				// - paint water quad over reflections only test if shading map is near wave animation phase -> unreflect palette
				{
					var wave_anim1 = 245 - (0.5 * frame) % 256;
					var wave_anim2 = 245 - (0.5 * frame + 64) % 256;
					var wave_anim3 = 245 - (0.5 * frame + 128) % 256;
					var wave_anim4 = 245 - (0.5 * frame + 192) % 256;

					// every 64 frames generate new noise params


					var wave_back = 10;

					var wave_pos1 = wave_anim1 * wave_anim1 / 256 - wave_back;
					var wave_pos2 = wave_anim2 * wave_anim2 / 256 - wave_back;
					var wave_pos3 = wave_anim3 * wave_anim3 / 256 - wave_back;
					var wave_pos4 = wave_anim4 * wave_anim4 / 256 - wave_back;

					var wave_siz1 = Math.min((200 - wave_anim1) / 10, 5);
					var wave_siz2 = Math.min((200 - wave_anim2) / 10, 5);
					var wave_siz3 = Math.min((200 - wave_anim3) / 10, 5);
					var wave_siz4 = Math.min((200 - wave_anim4) / 10, 5);

					if (wave_pos1 < 0) {
						wave_pos1 = -wave_pos1;
						wave_siz1 *= (wave_back - wave_pos1) / wave_back;
					}
					if (wave_pos2 < 0) {
						wave_pos2 = -wave_pos2;
						wave_siz2 *= (wave_back - wave_pos2) / wave_back
					}
					if (wave_pos3 < 0) {
						wave_pos3 = -wave_pos3;
						wave_siz3 *= (wave_back - wave_pos3) / wave_back;
					}
					if (wave_pos4 < 0) {
						wave_pos4 = -wave_pos4;
						wave_siz4 *= (wave_back - wave_pos4) / wave_back;
					}


					var shade_smooth = ak_world.getMapSmooth();
					var shade_buffer = ak_world.getShadeBuf();
					var shade_width = ak_world.getMapWidth() * shade_smooth;
					var shade_height = ak_world.getMapHeight() * shade_smooth;

					var den = shade_smooth / (view_xy * view_yx - view_xx * view_yy);

					var u0 = ((water - view_ty) * view_xy + view_tx * view_yy) * den;
					var v0 = ((water - view_ty) * view_xx + view_tx * view_yx) * -den;

					//	u -> ((water + y - view_ty) * view_xy + (view_tx - x) * view_yy) * den;
					//	v -> ((water + y - view_ty) * view_xx + (view_tx - x) * view_yx) * -den;

					var dux = -view_yy * den;
					var duy = view_xy * den;
					var dvx = view_yx * den;
					var dvy = -view_xx * den;

					for (var y = 0, i = 0; y < ak_height; y++) {
						var u = u0;
						var v = v0;
						for (var x = 0; x < ak_width; x++, i++) {
							if ((ak_buf32[i] & 0x10100000) /*=== 0x10100000*/) {
								if (u >= 0 && u < shade_width && v >= 0 && v < shade_height) {
									var j = ((u) | 0) + ((v) | 0) * shade_width;

									// we should use some pregenerated, general simplex noise for these:
									var ws1 = wave_siz1 * Math.abs(Math.cos(u * 0.1) * Math.sin(v * 0.1));
									var ws2 = wave_siz2 * Math.abs(Math.cos(u * 0.1 + 5) * Math.sin(v * 0.1 - 11));
									var ws3 = wave_siz3 * Math.abs(Math.cos(u * 0.1 + 10) * Math.sin(v * 0.1 - 22));
									var ws4 = wave_siz4 * Math.abs(Math.cos(u * 0.1 + 15) * Math.sin(v * 0.1 - 33));

									if (Math.abs(shade_buffer[j] - wave_pos1) < ws1 ||
										Math.abs(shade_buffer[j] - wave_pos2) < ws2 ||
										Math.abs(shade_buffer[j] - wave_pos3) < ws3 ||
										Math.abs(shade_buffer[j] - wave_pos4) < ws4) {
										// ak_buf32[i] &= 0xEFEFFFFF;
										if (i >= ak_width && (ak_buf32[i + ak_width] & 0x10100000) === 0x10100000 && (ak_buf32[i] & 0x10100000) === 0x10100000)
											ak_buf32[i] = ak_buf32[i + ak_width] & 0xEFEFFFFF;
										else
											ak_buf32[i] &= 0xEFEFFFFF;
									}
								}
							}

							u += dux;
							v += dvx;
						}

						u0 += duy;
						v0 += dvy;
					}

					/*
						function wave_sample(u,v,h,i)
						{
							if ((ak_buf32[i] & 0x10100000) === 0x10100000)
							{
								var j = ((u)|0) + ((v)|0)*shade_width*shade_smooth;

								if (Math.abs( shade_buffer[j] - wave_pos1 ) < wave_siz1 ||
									Math.abs( shade_buffer[j] - wave_pos2 ) < wave_siz2 ||
									Math.abs( shade_buffer[j] - wave_pos3 ) < wave_siz3 ||
									Math.abs( shade_buffer[j] - wave_pos4 ) < wave_siz4)
								{
									// ak_buf32[i] &= 0xEFEFFFFF;
									if (i>=ak_width && (ak_buf32[i-ak_width] & 0x10100000) === 0x10100000)
										ak_buf32[i-ak_width] = ak_buf32[i] & 0xEFEFFFFF;
								}
							}
						}

						//	u -> ((water + y - view_ty) * view_xy + (view_tx - x) * view_yy) * den;
						//	v -> ((water + y - view_ty) * view_xx + (view_tx - x) * view_yx) * -den;

						tile_patch[0]=0;
						tile_patch[1]=0;
						tile_patch[2]=water;
						tile_patch[3]=((water + 0 - view_ty) * view_xy + (view_tx - 0) * view_yy) * den;
						tile_patch[4]=((water + 0 - view_ty) * view_xx + (view_tx - 0) * view_yx) * -den;

						tile_patch[5]=0;
						tile_patch[6]=ak_height;
						tile_patch[7]=water;
						tile_patch[8]=((water + ak_height - view_ty) * view_xy + (view_tx - 0) * view_yy) * den;
						tile_patch[9]=((water + ak_height - view_ty) * view_xx + (view_tx - 0) * view_yx) * -den;

						tile_patch[10]=ak_width;
						tile_patch[11]=ak_height;
						tile_patch[12]=water;
						tile_patch[13]=((water + ak_height - view_ty) * view_xy + (view_tx - ak_width) * view_yy) * den;
						tile_patch[14]=((water + ak_height - view_ty) * view_xx + (view_tx - ak_width) * view_yx) * -den;

						tile_patch[15]=ak_width;
						tile_patch[16]=ak_height;
						tile_patch[17]=water;
						tile_patch[18]=((water + ak_height - view_ty) * view_xy + (view_tx - ak_width) * view_yy) * den;
						tile_patch[19]=((water + ak_height - view_ty) * view_xx + (view_tx - ak_width) * view_yx) * -den;

						tile_patch[20]=ak_width;
						tile_patch[21]=0;
						tile_patch[22]=water;
						tile_patch[23]=((water + 0 - view_ty) * view_xy + (view_tx - ak_width) * view_yy) * den;
						tile_patch[24]=((water + 0 - view_ty) * view_xx + (view_tx - ak_width) * view_yx) * -den;

						tile_patch[25]=0;
						tile_patch[26]=0;
						tile_patch[27]=water;
						tile_patch[28]=((water + 0 - view_ty) * view_xy + (view_tx - 0) * view_yy) * den;
						tile_patch[29]=((water + 0 - view_ty) * view_xx + (view_tx - 0) * view_yx) * -den;

						ak_screen._Patch(tile_patch,5,0,2,wave_sample,true);
						*/
				}


				if (ak_connection) {
					ak_Send(world_center_x, world_center_y, world_center_z, player_dir, player_frm);
				}

				var rec = IsRecording();
				if (rec === 1) {
					Record(ak_buf32, ak_width, ak_height, dt);
				}
				if (rec !== 0) {
					if ((frame & 0x3F) < 32) {
						ak_buf32[ak_width - 1] = rec === 1 ? 0x0B000052 : 0x0A000057;

						var rf = GetRecordedFrames();
						if (rf > 0) {
							var str = "" + rf;
							for (var x = str.length - 1; x >= 0; x--) {
								var gl = rf % 10 + 0x30;
								ak_buf32[ak_width - 3 - str.length + x] = 0x0B000000 | gl;
								rf = (rf / 10) | 0;
							}
						}
					}
				}

				// writing directly to memory
				var msg_w = "" + ak_width;
				var msg_h = "" + ak_height;
				var fnt = "" + ak_fonts[ak_font].size;
				while (fnt.length < 2) fnt = fnt + " ";

				while (msg_w.length < 3) msg_w = " " + msg_w;
				while (msg_h.length < 3) msg_h = msg_h + " ";

				var msgarr = ["+-------------------+",
					"| " + msg_w + " x " + msg_h + " font:" + fnt + " |",
					"+-------------------+"];

				for (var l = 0; l < msgarr.length; l++) {
					var msg = msgarr[l];
					var x = 1;
					var y = 1 + l;
					if (y >= 0 && y < ak_height)
						for (var m = 0; m < msg.length; m++, x++) {
							if (x >= 0 && x < ak_width) {
								var c = ((y + scroll_y) % ak_height * ak_width + (x + scroll_x) % ak_width) << 2;
								var gl = msg.charCodeAt(m);

								// ak_buf[c+0] = gl&0xF;
								// ak_buf[c+1] = gl>>4;
								ak_buf[c] = gl;

								ak_buf[c + 2] = 0xF;
								ak_buf[c + 3] = 0x7;
							}
						}
				}

				msgarr = ["+----------------------+",
					"| Mouse-drag to scroll |",
					"+----------------------+"];

				for (var l = 0; l < msgarr.length; l++) {
					var msg = msgarr[l];
					var x = 1;
					var y = 5 + l;
					if (y >= 0 && y < ak_height)
						for (var m = 0; m < msg.length; m++, x++) {
							if (x >= 0 && x < ak_width) {
								var c = ((y + scroll_y) % ak_height * ak_width + (x + scroll_x) % ak_width) << 2;
								var gl = msg.charCodeAt(m);

								//ak_buf[c+0] = gl&0xF;
								//ak_buf[c+1] = gl>>4;
								ak_buf[c] = gl;


								ak_buf[c + 2] = 0xF;
								ak_buf[c + 3] = 0x7;
							}
						}
				}


				msgarr = ["+--------------------------------+",
					"| Steering: Q W E  slower  jump: |",
					"|           A S D  +shift  space |",
					"+--------------------------------+"];

				for (var l = 0; l < msgarr.length; l++) {
					var msg = msgarr[l];
					var x = 1;
					var y = 9 + l;
					if (y >= 0 && y < ak_height)
						for (var m = 0; m < msg.length; m++, x++) {
							if (x >= 0 && x < ak_width) {
								var c = ((y + scroll_y) % ak_height * ak_width + (x + scroll_x) % ak_width) << 2;
								var gl = msg.charCodeAt(m);

								//ak_buf[c+0] = gl&0xF;
								//ak_buf[c+1] = gl>>4;
								ak_buf[c] = gl;


								ak_buf[c + 2] = 0xF;
								ak_buf[c + 3] = 0x7;
							}
						}
				}

				var lag = "" + ak_lag;

				var fps = "" + (dt >= 0.5 ? ((60 / dt + 0.5) | 0) : "lost");
				while (fps.length < 5) fps = fps + " ";
				while (lag.length < 5) lag = lag + " ";
				msgarr = ["+------------+",
					"| FPS: " + fps + " |",
					"| LAG: " + lag + " |"];

				/*
					for (var n=0; n<npcs; n++)
					{
						lag = "" + (npc[9*n+5] | 0);
						while (lag.length<5) lag = lag+" ";
						msgarr.push( "|      " + lag + " |" );
					}
					*/

				msgarr.push("+------------+");

				for (var l = 0; l < msgarr.length; l++) {
					var msg = msgarr[l];
					var x = 1;
					var y = 14 + l;
					if (y >= 0 && y < ak_height)
						for (var m = 0; m < msg.length; m++, x++) {
							if (x >= 0 && x < ak_width) {
								var c = ((y + scroll_y) % ak_height * ak_width + (x + scroll_x) % ak_width) << 2;
								var gl = msg.charCodeAt(m);

								//ak_buf[c+0] = gl&0xF;
								//ak_buf[c+1] = gl>>4;
								ak_buf[c] = gl;


								ak_buf[c + 2] = 0xF;
								ak_buf[c + 3] = 0x7;
							}
						}
				}

				// trunk proto
				if (false && !window.proto) {
					//window.proto = [];

					//var branch_at = 10; // 5,8,12,15
					var prev_x, prev_y, prev_z, prev_r;
					for (var th = 0; th <= 20; th += 1) {
						var spiral_phase = th * 0.2;
						var spiral_radius = (10 - Math.abs(th - 10)) * 0.05;
						var spiral_cx = spiral_radius * Math.cos(spiral_phase);
						var spiral_cy = spiral_radius * Math.sin(spiral_phase);
						var radius = ((20 - th) + 5) * 0.03;

						x = world_center_x;
						y = world_center_y;
						z = world_center_z;

						x += spiral_cx;
						y += spiral_cy;
						z += th + 10;

						var cx = (view_xx * x + view_xy * y + view_tx);
						var cy = (view_yx * x + view_yy * y - z + view_ty);
						var cz = z;

						if (th === 5 || th === 8 || th === 12 || th === 15) {
							var branch_cx = spiral_radius * Math.cos(spiral_phase * 2.5);
							var branch_cy = spiral_radius * Math.sin(spiral_phase * 2.5);


							var bx = x + 3 * branch_cx;
							var by = y + 3 * branch_cy;
							var bz = z + 1;

							var ex = (view_xx * bx + view_xy * by + view_tx);
							var ey = (view_yx * bx + view_yy * by - bz + view_ty);
							var ez = bz;

							//ak_screen.Line(cx,cy*2,cz, ex,ey*2,ez, 0x02FF0000 ,2);
							//ak_screen.Line(ex,ey*2,ez, cx,cy*2,cz, 0x02FF0000 ,2);
						}

						/*
							proto[th*2+0] = ((x-world_center_x)*256)|0;
							proto[th*2+1] = ((y-world_center_y)*256)|0;
							*/


						if (th > 0) {
							/*
								ak_screen.Line(Math.round(prev_x-prev_r),
											   Math.round(prev_y),
											   Math.round(prev_z),
											   Math.round(cx-radius),
											   Math.round(cy),
											   Math.round(cz),
											   0, false);

								ak_screen.Line(Math.round(prev_x+prev_r),
											   Math.round(prev_y),
											   Math.round(prev_z),
											   Math.round(cx+radius),
											   Math.round(cy),
											   Math.round(cz),
											   0, false);
								*/
						}

						prev_x = cx;
						prev_y = cy;
						prev_z = cz;
						prev_r = radius;
					}

					//console.log(proto);
				}


				// do back to front blt
				ak_ctx.activeTexture(ak_ctx.TEXTURE0);
				ak_ctx.bindTexture(ak_ctx.TEXTURE_2D, ak_tex);


				ak_ctx.texSubImage2D(ak_ctx.TEXTURE_2D, 0, 0, 0, ak_width, ak_height, ak_ctx.RGBA, ak_ctx.UNSIGNED_BYTE, ak_buf);

				var render_w = ak_ctx.drawingBufferWidth & ~1;
				var render_h = ak_ctx.drawingBufferHeight & ~1;


				// scan vga to wires (render quad)
				ak_ctx.viewport(0, 0, render_w, render_h);
				ak_ctx.clearColor(0, 0, 0, 0);
				ak_ctx.clear(ak_ctx.COLOR_BUFFER_BIT);

				var fnt = ak_fonts[ak_font];
				ak_ctx.activeTexture(ak_ctx.TEXTURE1);
				ak_ctx.bindTexture(ak_ctx.TEXTURE_2D, fnt.tex);

				// pass front, back buffers & font info to uniforms

				ak_ctx.activeTexture(ak_ctx.TEXTURE2);
				ak_ctx.bindTexture(ak_ctx.TEXTURE_2D, ak_pal);

				// render quad
				ak_ctx.useProgram(ak_prg);
				ak_ctx.uniform1f(ak_uni_width, ak_width);
				ak_ctx.uniform1f(ak_uni_height, ak_height);
				ak_ctx.uniform1f(ak_uni_cell_width, fnt.width >> 4);
				ak_ctx.uniform1f(ak_uni_cell_height, fnt.height >> 4);
				ak_ctx.uniform1f(ak_uni_view_width, render_w);
				ak_ctx.uniform1f(ak_uni_view_height, render_h);

				ak_ctx.uniform1f(ak_uni_scroll_x, scroll_x);
				ak_ctx.uniform1f(ak_uni_scroll_y, scroll_y);

				ak_ctx.bindBuffer(ak_ctx.ARRAY_BUFFER, ak_vtx);

				ak_ctx.drawArrays(ak_ctx.TRIANGLE_FAN, 0, 4);
			}

			function akResize(e) {
				ak_ratio = 1;
				// To account for zoom, change to use deviceXDPI instead of systemXDPI

				if (window.screen.systemXDPI !== undefined &&
					window.screen.logicalXDPI !== undefined &&
					window.screen.systemXDPI > window.screen.logicalXDPI) {
					// Only allow for values > 1
					ak_ratio = window.screen.systemXDPI / window.screen.logicalXDPI;
				} else if (window.devicePixelRatio !== undefined) {
					ak_ratio = window.devicePixelRatio;
				}


				/*
					if (window.screen.deviceXDPI !== undefined &&
						window.screen.logicalXDPI !== undefined &&
						window.screen.deviceXDPI > window.screen.logicalXDPI)
					{
						// Only allow for values > 1
						ak_ratio = window.screen.deviceXDPI / window.screen.logicalXDPI;
					}
					else
					if (window.devicePixelRatio !== undefined)
					{
						ak_ratio = window.devicePixelRatio;
					}
					*/

				var w = window.innerWidth;
				var h = window.innerHeight;

				ak_ctx.canvas.width = Math.floor(w * ak_ratio);
				ak_ctx.canvas.height = Math.floor(h * ak_ratio);

				var render_w = ak_ctx.drawingBufferWidth & ~1;
				var render_h = ak_ctx.drawingBufferHeight & ~1;

				var rw = render_w * 0.001;
				var rh = render_h * 0.001;
				var rs = 5.0 * Math.sqrt(rw * rw + rh * rh) * ak_ratio;
				for (var i = 0; i < ak_fonts.length; i++) {
					if (Math.abs(ak_fonts[ak_font].size - rs) >
						Math.abs(ak_fonts[i].size - rs)) {
						ak_font = i;
					}
				}

				//ak_font = 0;

				ak_width = Math.floor(render_w / (ak_fonts[ak_font].width >> 4));
				ak_height = Math.floor(render_h / (ak_fonts[ak_font].height >> 4));

				if (ak_width > ak_max_width)
					ak_width = ak_max_width;
				if (ak_width < ak_min_width)
					ak_width = ak_min_width;

				if (ak_height > ak_max_height)
					ak_height = ak_max_height;
				if (ak_height < ak_min_height)
					ak_height = ak_min_height;

				//640x400
				//ak_width = 80;
				//ak_height = 50;

				//720x400
				//ak_width = 90;
				//ak_height = 50;

				// 800x600
				//ak_width = 100;
				//ak_height = 75;

				// 1024x768
				//ak_width = 128;
				//ak_height = 96;

				// 1280x768
				//ak_width = 160;
				//ak_height = 96;

				akPaint(null);
			}

			function akBoot(fonts, library) {
				ak_canvas = document.getElementById('ascii');

				setTouchHandlers();
				setMouseHandlers();
				setKeybHandlers();

				var webgl_opts = {alpha: false, depth: false, stencil: false, antialias: false};

				try {
					ak_ctx =
						ak_canvas.getContext("webgl", webgl_opts) ||
						ak_canvas.getContext("experimental-webgl", webgl_opts);
				} catch (e) {
					ak_ctx = null;
				}

				if (!ak_ctx)
					return;

				ak_ctx.imageSmoothingEnabled = false;


				ak_vtx = ak_ctx.createBuffer();
				ak_ctx.bindBuffer(ak_ctx.ARRAY_BUFFER, ak_vtx);
				ak_ctx.bufferData(ak_ctx.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), ak_ctx.STATIC_DRAW);

				var vs = ak_ctx.createShader(ak_ctx.VERTEX_SHADER);
				ak_ctx.shaderSource(vs, document.getElementById('vs').innerHTML);
				ak_ctx.compileShader(vs);
				if (!ak_ctx.getShaderParameter(vs, ak_ctx.COMPILE_STATUS))
					console.log(ak_ctx.getShaderInfoLog(vs));

				var fs = ak_ctx.createShader(ak_ctx.FRAGMENT_SHADER);
				ak_ctx.shaderSource(fs, document.getElementById('fs').innerHTML);
				ak_ctx.compileShader(fs);
				if (!ak_ctx.getShaderParameter(fs, ak_ctx.COMPILE_STATUS))
					console.log(ak_ctx.getShaderInfoLog(fs));

				ak_prg = ak_ctx.createProgram();
				ak_ctx.attachShader(ak_prg, vs);
				ak_ctx.attachShader(ak_prg, fs);
				ak_ctx.linkProgram(ak_prg);

				ak_ctx.deleteShader(vs);
				ak_ctx.deleteShader(fs);

				ak_ctx.useProgram(ak_prg);

				// attribs
				var xy = ak_ctx.getAttribLocation(ak_prg, "xy");
				ak_ctx.vertexAttribPointer(xy, 2, ak_ctx.FLOAT, false, 0, 0);
				ak_ctx.enableVertexAttribArray(xy);

				// uniforms
				ak_ctx.uniform1i(ak_ctx.getUniformLocation(ak_prg, "tex"), 0);
				ak_ctx.uniform1i(ak_ctx.getUniformLocation(ak_prg, "fnt"), 1);
				ak_ctx.uniform1i(ak_ctx.getUniformLocation(ak_prg, "pal"), 2);

				ak_uni_width = ak_ctx.getUniformLocation(ak_prg, "width");
				ak_uni_height = ak_ctx.getUniformLocation(ak_prg, "height");
				ak_uni_cell_width = ak_ctx.getUniformLocation(ak_prg, "cell_width");
				ak_uni_cell_height = ak_ctx.getUniformLocation(ak_prg, "cell_height");
				ak_uni_view_width = ak_ctx.getUniformLocation(ak_prg, "view_width");
				ak_uni_view_height = ak_ctx.getUniformLocation(ak_prg, "view_height");
				ak_uni_scroll_x = ak_ctx.getUniformLocation(ak_prg, "scroll_x");
				ak_uni_scroll_y = ak_ctx.getUniformLocation(ak_prg, "scroll_y");

				ak_buf = new Uint8Array(ak_max_width * ak_max_height * 4);
				ak_buf32 = new Uint32Array(ak_buf.buffer); // just view


				// setup world (it is window['ak_World'])
				ak_world = /*new*/ ak_World(library, rng, 4); // smooth
				var water = ak_world.getWater();

				ak_screen = /*new*/ ak_Screen(ak_buf.buffer, water);

				ak_ctx.activeTexture(ak_ctx.TEXTURE0);

				ak_fonts = [];

				var def_font = fonts[0];
				fonts.sort(function (a, b) {
					return a.naturalHeight - b.naturalHeight;
				});

				for (var f = 0; f < fonts.length; f++) {
					var fnt =
						{
							tex: ak_ctx.createTexture(),
							size: fonts[f].naturalHeight >> 4,
							width: fonts[f].naturalWidth,
							height: fonts[f].naturalHeight
						};

					ak_fonts.push(fnt);

					ak_ctx.bindTexture(ak_ctx.TEXTURE_2D, fnt.tex);
					ak_ctx.texParameteri(ak_ctx.TEXTURE_2D, ak_ctx.TEXTURE_WRAP_S, ak_ctx.CLAMP_TO_EDGE);
					ak_ctx.texParameteri(ak_ctx.TEXTURE_2D, ak_ctx.TEXTURE_WRAP_T, ak_ctx.CLAMP_TO_EDGE);
					ak_ctx.texParameteri(ak_ctx.TEXTURE_2D, ak_ctx.TEXTURE_MIN_FILTER, ak_ctx.NEAREST);
					ak_ctx.texParameteri(ak_ctx.TEXTURE_2D, ak_ctx.TEXTURE_MAG_FILTER, ak_ctx.NEAREST);
					ak_ctx.texImage2D(ak_ctx.TEXTURE_2D, 0, ak_ctx.RGBA, ak_ctx.RGBA, ak_ctx.UNSIGNED_BYTE, fonts[f]);

					if (fonts[f] === def_font)
						ak_font = f;
				}

				ak_tex = ak_ctx.createTexture();
				ak_ctx.bindTexture(ak_ctx.TEXTURE_2D, ak_tex);
				ak_ctx.texParameteri(ak_ctx.TEXTURE_2D, ak_ctx.TEXTURE_WRAP_S, ak_ctx.CLAMP_TO_EDGE);
				ak_ctx.texParameteri(ak_ctx.TEXTURE_2D, ak_ctx.TEXTURE_WRAP_T, ak_ctx.CLAMP_TO_EDGE);
				ak_ctx.texParameteri(ak_ctx.TEXTURE_2D, ak_ctx.TEXTURE_MIN_FILTER, ak_ctx.NEAREST);
				ak_ctx.texParameteri(ak_ctx.TEXTURE_2D, ak_ctx.TEXTURE_MAG_FILTER, ak_ctx.NEAREST);
				ak_ctx.texImage2D(ak_ctx.TEXTURE_2D, 0, ak_ctx.RGBA, ak_max_width, ak_max_height, 0, ak_ctx.RGBA, ak_ctx.UNSIGNED_BYTE, ak_buf);

				var pal = new Uint8Array(
					[
						0, 0, 0, 255,
						170, 0, 0, 255,
						0, 170, 0, 255,
						170, 85, 0, 255,
						0, 0, 170, 255,
						170, 0, 170, 255,
						0, 170, 170, 255,
						170, 170, 170, 255,
						85, 85, 85, 255,
						255, 85, 85, 255,
						85, 255, 85, 255,
						255, 255, 85, 255,
						85, 85, 255, 255,
						255, 85, 255, 255,
						85, 255, 255, 255,
						255, 255, 255, 255,

						// reflection: lower contrast + some blue
						32, 32 + 16, 32 + 32, 255,
						128, 32 + 16, 32 + 32, 255,
						32, 128 + 16, 32 + 32, 255,
						128, 64 + 16, 32 + 32, 255,
						32, 32 + 16, 128 + 32, 255,
						128, 32 + 16, 128 + 32, 255,
						32, 128 + 16, 128 + 32, 255,
						128, 128 + 16, 128 + 32, 255,
						64, 64 + 16, 64 + 32, 255,
						192, 64 + 16, 64 + 32, 255,
						64, 192 + 16, 64 + 32, 255,
						192, 192 + 16, 64 + 32, 255,
						64, 64 + 16, 192 + 32, 255,
						192, 64 + 16, 192 + 32, 255,
						64, 192 + 16, 192 + 32, 255,
						192, 192 + 16, 192 + 32, 255
					]);

				// anything > 0xF should take color from backdrop background

				ak_pal = ak_ctx.createTexture();
				ak_ctx.bindTexture(ak_ctx.TEXTURE_2D, ak_pal);
				ak_ctx.texParameteri(ak_ctx.TEXTURE_2D, ak_ctx.TEXTURE_WRAP_S, ak_ctx.CLAMP_TO_EDGE);
				ak_ctx.texParameteri(ak_ctx.TEXTURE_2D, ak_ctx.TEXTURE_WRAP_T, ak_ctx.CLAMP_TO_EDGE);
				ak_ctx.texParameteri(ak_ctx.TEXTURE_2D, ak_ctx.TEXTURE_MIN_FILTER, ak_ctx.NEAREST);
				ak_ctx.texParameteri(ak_ctx.TEXTURE_2D, ak_ctx.TEXTURE_MAG_FILTER, ak_ctx.NEAREST);
				ak_ctx.texImage2D(ak_ctx.TEXTURE_2D, 0, ak_ctx.RGBA, pal.length >> 2, 1, 0, ak_ctx.RGBA, ak_ctx.UNSIGNED_BYTE, pal);

				// convert image objects to internal buffers
				for (var i = 0; i < library.images.length; i++) {
					if (library.images[i].fmt === 1)
						library.images[i].img = ak_Image(library.images[i].img);
				}

				tile_size = ak_world.getTileSize();
				var quads = tile_size * tile_size;
				// tile_patch = new Int32Array(2*quads*3*4);
				tile_patch = new Int32Array(2 * quads * 3 * 5);

				npc = new Float32Array(300 * 9);
				npcs = 0;


				for (var h = 0; h < 2000; h++) {
					// map coords

					var x = rng.next/*Math.random*/() * ak_world.getMapWidth();
					var y = rng.next/*Math.random*/() * ak_world.getMapHeight();

					// avoid houses & trees on farm fields
					if (ak_world.GetMapDecal(x | 0, y | 0) ===/*2*/3)
						continue;

					var z = ak_world.SampleMapHeight(x, y);


					var r = ((rng.next/*Math.random*/() * 12) * 30) | 0;
					var state = (r << 16) | 0;

					var id = (h < 300) ? 0 : 2;
					if (id !== 0) {
						var dz = (rng.next/*Math.random*/() * 65536) | 0;
						//dz=0;
						state |= dz;
						//z-=dz;
					}

					if (z > water + 2) {
						// it would be nice to check if there is some other sprite nearby
						// RayQuery with big XY eps should work


						var n = ak_world.InsertSprite(id, x / tile_size, y / tile_size, z, state);

						if (n !== -1) {
							// put decal zero
							var smooth = ak_world.getMapSmooth();
							if (id === 0) {
								ak_world.DecalCircle(x * smooth, y * smooth, 3 * smooth,/*3*/4);
								//ak_world.DecalRect(x*smooth,y*smooth,3*smooth,3*smooth,-r,0);

								//else
								//	ak_world.DecalCircle(x*smooth,y*smooth,1.5*smooth,1);

								var idx = npcs * 9;
								npc[idx] = x;
								npc[idx + 1] = y;
								npc[idx + 2] = z;
								npc[idx + 3] = Math.random() * 360;
								npc[idx + 4] = 0;

								npc[idx + 5] = x;
								npc[idx + 6] = y;

								npcs++;
							}

						}
					}
				}

				// generate paths, let's use npc array
				// lookup closest house
				// put squashed decal=3 rect in the middle rotatated by atan2(dy,dx) rx = distance/2, ry = path width
				for (var n = 0; n < npcs; n++) {
					var i = n * 9;

					var best = -1;
					var dist = 0;

					for (var m = 0; m < npcs; m++) {
						if (m === n)
							continue;
						var j = m * 9;

						var dx = npc[i] - npc[j];
						var dy = npc[i + 1] - npc[j + 1];
						var d = dx * dx + dy * dy;
						if (dist === 0 || d < dist) {
							dist = d;
							best = j;
						}
					}

					if (best <= n)
						continue;

					// make path wavy
					var dx = npc[best] - npc[i];
					var dy = npc[best + 1] - npc[i + 1];
					var d = Math.sqrt(dx * dx + dy * dy);

					var segs = 1 + (d) | 0;

					var prev_x = npc[i];
					var prev_y = npc[i + 1];
					for (var s = 1; s <= segs; s++) {
						var perturb = Math.sin(s * 0.3) * Math.min(1.75 / segs, segs * 0.5 - Math.abs(s - segs * 0.5));
						var next_x = npc[i] + dx * s / segs - dy * perturb;
						var next_y = npc[i + 1] + dy * s / segs + dx * perturb;

						cx = (prev_x + next_x) * 0.5;
						cy = (prev_y + next_y) * 0.5;
						var sx = next_x - prev_x;
						var sy = next_y - prev_y;
						var ds = Math.sqrt(sx * sx + sy * sy) + 1.0; // +1 ensures connectivity at high angle knees

						var a = Math.atan2(sy, sx) * 180 / Math.PI;

						ak_world.DecalRect(cx * smooth, cy * smooth, smooth * ds * 0.5, smooth * 0.5, -a,/*3*/4, 0);

						prev_x = next_x;
						prev_y = next_y;
					}

				}


				for (var n = 0; n < npcs; n++) {
					var idx = n * 9;
					var jdx = idx + 9;
					if (n === npcs)
						jdx = 0;

					npc[idx + 7] = npc[jdx + 5];
					npc[idx + 8] = npc[jdx + 6];
				}

				world_center_x = (1483 + Math.random() * 100 - 50) / ak_tile_to_char;//ak_world.getMapWidth() * 0.5;
				world_center_y = (1076 + Math.random() * 100 - 50) / ak_tile_to_char;//ak_world.getMapHeight() * 0.5;

				world_center_x = 371.0842116168597;
				world_center_y = 477.0845264970988;
				player_dir = 105;
				view_angle = 15;
				dest_angle = 15;


				world_center_z = ak_world.SampleMapHeight(world_center_x, world_center_y) | 0;

				ak_lib = library;

				// view dir in degrees

				console.log("ak_world.depth   = " + ak_world.getDepth());
				console.log("ak_world.count   = " + ak_world.getCount());
				console.log("ak_world.leafs   = " + ak_world.getLeafs());
				console.log("ak_world.sprites = " + ak_world.getSprites());

				window.onresize = akResize;
				akResize(null);

				// ak_Connect();

				requestAnimationFrame(akPaint);
			}

			function akLoad(library) {
				var loaded = 0;
				var failed = 0;

				// start with default size
				var fonts = [/*4,*/6, 8, 10, 12, 16, 14, 18, 20];

				var required = fonts.length + library.images.length;

				var failCheck = function () {
					if (loaded + failed === required)
						console.log("Can't boot");
				};

				for (var f = 0; f < fonts.length; f++) {
					var size = fonts[f];
					var fnt = new Image();
					fonts[f] = fnt;

					fnt.onerror = function (id) {
						return function () {
							failed++;
							console.log('Failed to load font: ' + id);
							failCheck();
						};
					}(size);

					fnt.onload = function () {
						loaded++;
						if (loaded === required)
							akBoot(fonts, library);
						else
							failCheck();
					};
					fnt.src = 'fonts/cp437_' + size + 'x' + size + '.png';
				}

				for (var i = 0; i < library.images.length; i++) {
					var name = library.images[i].src;
					var spr = new Image();
					library.images[i].img = spr;

					spr.onerror = function (id) {
						return function () {
							failed++;
							console.log('Failed to load image: ' + id);
							failCheck();
						};
					}(i);

					spr.onload = function () {
						loaded++;
						if (loaded === required)
							akBoot(fonts, library);
						else
							failCheck();
					};
					spr.src = 'images/' + name;
				}
			}

			//]]>
		</script>
	</head>
	<body>
		<canvas id="ascii"></canvas>
		<div style="text-align:center; position:absolute; bottom:4px; width:100%;">
			<!--button style="font-size:32px" onclick="akRotCCW();"></button-->
			<!--button onclick="ak_font=0; akResize(null);">08x08</button>
					<button onclick="ak_font=1; akResize(null);">10x10</button>
					<button onclick="ak_font=2; akResize(null);">12x12</button>
					<button onclick="ak_font=3; akResize(null);">14x14</button>
					<button onclick="ak_font=4; akResize(null);">16x16</button>
					<button onclick="ak_font=5; akResize(null);">18x18</button>
					<button onclick="ak_font=6; akResize(null);">20x20</button-->
			<!--button style="font-size:32px" onclick="akRotCW();"></button-->
		</div>
		<script type="text/javascript">
			var lib = {
				images: [{
					src: "house.png",
					img: null,
					fmt: 1
				} , {
					src: "map2.png",
					img: null
				} , {
					src: "player.png",
					img: null,
					fmt: 1
				} , {
					src: "tree.png",
					img: null,
					fmt: 1
				}/*, {
					src: "sky.png",
					img: null,
					fmt: 1
				}*/],
			terrain: {
				img: 1,
				tile: 6,
				water: 20
			},
			sprites: [{
				name: "house",
				img: 0,
				hMin: 0,
				hMax: 16,
				cx: 12,
				cy: 17,

				_slice_map: [0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 0,
					3, 3, 0, 0, 0, 1, 1, 1, 2, 2, 2, 3,
					3, 3, 0, 0, 0, 1, 1, 1, 2, 2, 2, 3,
					2, 2, 0, 0, 0, 1, 1, 1, 1, 1, 1, 2,
					2, 2, 3, 3, 3, 0, 0, 0, 1, 1, 1, 2,
					2, 2, 3, 3, 3, 0, 0, 0, 1, 1, 1, 2,
					1, 1, 2, 2, 2, 0, 0, 0, 1, 1, 1, 1,
					1, 1, 2, 2, 2, 3, 3, 3, 0, 0, 0, 1,
					1, 1, 2, 2, 2, 3, 3, 3, 0, 0, 0, 1,
					1, 1, 1, 1, 1, 2, 2, 2, 0, 0, 0, 1,
					0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 0,
					0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 0],

				paint: function (lib, screen, cx, cy, cz, lit_ang, ang, refl, state/*rot,frm*/) {
					var frm = state & 0xFFFF;
					var rot = (state >> 16) & 0xFFFF;

					var obj = this;
					var obj_img = lib.images[obj.img].img;
					var obj_w = obj_img.getWidth() / 12;
					var obj_h = obj_img.getHeight() / 8;
					var obj_r = (12 * (rot / 360)) | 0;

					var obj_a = 45 - ang;
					if (obj_a < 0)
						obj_a += 360 * ((1 + ang / 360) | 0);

					var obj_x = (Math.round(12 * obj_a / 360) + obj_r) % 12;

					var obj_y = this._slice_map[obj_r * 12 + obj_x];

					if (refl)
						obj_y = 7 - obj_y;

					obj_x *= obj_w;
					obj_y *= obj_h;

					if (refl)
						screen.Blend(obj_img, obj_x, obj_y, cx - obj.cx, cy - 9, obj_w, obj_h, 7, cz + 2);
					else
						screen.Blend(obj_img, obj_x, obj_y, cx - obj.cx, cy - obj.cy, obj_w, obj_h, 5, cz + 1);
				},

				getBox: function (state/*rot,frm*/, box) {
					var frm = state & 0xFFFF;
					var rot = (state >> 16) & 0xFFFF;

					box[0] = -9 * 256 / 24;
					box[1] = +9 * 256 / 24;

					box[2] = -9 * 256 / 24;
					box[3] = +9 * 256 / 24;

					box[4] = -6;
					box[5] = 12;
				}
			} , {
				name: "player",
				img: 2,
				hMin: 0,
				hMax: 16,
				cx: 2,
				cy: 8,
				paint: function (lib, screen, cx, cy, cz, lit_ang, ang, refl, state/*rot,frm*/) {
					var frm = state & 0xFFFF;
					var rot = (state >> 16) & 0xFFFF;

					// was negative before shifting in?
					if (frm & 0x8000)
						frm = -1;

					var obj = this;
					var obj_img = lib.images[obj.img].img;
					var obj_w = (obj_img.getWidth() / 18) | 0;
					var obj_h = (obj_img.getHeight() / 8) | 0;

					var obj_a = rot - ang - 90;
					if (obj_a < 0)
						obj_a += 360 * ((1 - obj_a / 360) | 0);

					var obj_x = 1 + frm;
					var obj_y = (Math.round(8 * obj_a / 360) | 0) & 7;

					if (refl)
						obj_x += 9;

					obj_x *= obj_w;
					obj_y *= obj_h;

					if (refl)
						screen.Blend(obj_img, obj_x, obj_y, cx - obj.cx, cy/*-obj.cy*/ - 2, obj_w, obj_h, 7, cz - 1);
					else
						screen.Blend(obj_img, obj_x, obj_y, cx - obj.cx, cy - obj.cy + 1, obj_w, obj_h, 5, cz - 1);
				},

				getBox: function (state/*rot,frm*/, box) {
					var frm = state & 0xFFFF;
					var rot = (state >> 16) & 0xFFFF;

					box[0] = -2 * 256 / 24;
					box[1] = +2 * 256 / 24;

					box[2] = -2 * 256 / 24;
					box[3] = +2 * 256 / 24;

					box[4] = 0;
					box[5] = 8;
				}
			} , {
				name: "tree",
				img: 3,
				cx: 4,
				cy: 20,

				/*
					paint: function(lib,screen,cx,cy,cz,ang,refl,state)
					{
						var frm = state&0xFFFF;
						var rot = (state>>16)&0xFFFF;

						var obj = this;
						var obj_img = lib.images[obj.img].img;
						var obj_w = obj_img.getWidth() / 12;
						var obj_h1 = 22; //obj_img.getHeight();
						var obj_h2 = obj_img.getHeight() - obj_h1;
						var obj_r = (12*(rot/360))|0;

						var obj_a = 45-ang;
						if (obj_a<0)
							obj_a += 360* (1+(ang/360)|0);

						var obj_x = (Math.round(12 * obj_a / 360) +obj_r ) % 12;
						var obj_y1 = 0;
						var obj_y2 = obj_h1;

						obj_x*=obj_w;

						screen.Blend(obj_img,obj_x,obj_y1,cx-obj.cx,cy-obj.cy,obj_w,obj_h1,5,cz);
						screen.Blend(obj_img,0,obj_y2,cx-obj.cx,cy-3-20,obj_w,obj_h2,1,cz+20);
					},
					*/

				paint3d: function (lib, screen, x, y, z, xx, xy, tx, yx, yy, ty, lit_ang, ang, refl, water, state/*rot,frm*/) {
					var cz = z;
					var cx = Math.round(xx * x + xy * y + tx) | 0;
					var cy = Math.floor(yx * x + yy * y - z + ty) | 0;

					if (refl)
						cy = (cy + 2 * (z - water)/*+0.5*/) | 0;

					var frm = state & 0xFFFF;
					var rot = (state >> 16) & 0xFFFF;

					var obj = this;
					var obj_img = lib.images[obj.img].img;
					var obj_w = obj_img.getWidth() / 12;
					var obj_h1 = 22; //obj_img.getHeight();
					var obj_h2 = obj_img.getHeight() / 2 - obj_h1;
					var obj_r = (12 * (rot / 360)) | 0;

					var obj_a = 45 - ang;
					if (obj_a < 0)
						obj_a += 360 * (1 + (ang / 360) | 0);

					var obj_x = (Math.round(12 * obj_a / 360) + obj_r) % 12;
					var obj_y1 = 0;
					var obj_y2 = obj_h1;

					obj_x *= obj_w;

					if (refl) {
						obj_y1 = obj_img.getHeight() - 22;
						obj_y2 = obj_y1 - obj_h2;
						screen.Blend(obj_img, obj_x, obj_y1, cx - obj.cx, cy - 3, obj_w, obj_h1, 7, cz);
					} else
						screen.Blend(obj_img, obj_x, obj_y1, cx - obj.cx, cy - obj.cy, obj_w, obj_h1, 5, cz);

					//screen.Blend(obj_img,0,obj_y2,cx-obj.cx,cy-3-20,obj_w,obj_h2,1,cz+20);

					// frm=(frm<<16)|(frm^0xFFFF);

					var t = 0;
					var i = 0;
					for (var h = 4; h <= 20; h += 5) {
						var ih = Math.pow(20.0 - h, 0.4);
						if (t <= 1)
							ih *= 0.5;

						/*
							var dx = ih*( ((frm>>i)&0x3) -2)*7;
							var dy = ih*( ((frm>>(i+2))&0x3) -2)*7;
							*/


						var dx = ((((x * h * x * y) ^ frm) & 0xF) * 2 - 15) * ih;
						var dy = ((((y * h * y * x) ^ (frm >> 4)) & 0xF) * 2 - 15) * ih;


						var lx = x + dx * 0.02;
						var ly = y + dy * 0.02;
						cz = z + h;
						cx = Math.round(xx * lx + xy * ly + tx) | 0;
						cy = Math.floor(yx * lx + yy * ly - cz + ty) | 0;
						if (refl) {
							cy = (cy + 2 * (cz - water)/*+0.5*/) | 0;
							screen.Blend(obj_img, obj_w * t, obj_y2, cx - obj.cx, cy - 5, obj_w, obj_h2, 3, cz - 1);
						} else {
							screen.Blend(obj_img, obj_w * t, obj_y2, cx - obj.cx, cy - 3, obj_w, obj_h2, 1, cz - 1);
						}

						t = (t + 1) & 0x3;
						i += 4;
					}
				},

				//Thank you, it was very motivating for me.
				getBox: function (state/*rot,frm*/, box) {
					var frm = state & 0xFFFF;
					var rot = (state >> 16) & 0xFFFF;

					box[0] = -4 * 256 / 24;
					box[1] = +4 * 256 / 24;

					box[2] = -4 * 256 / 24;
					box[3] = +4 * 256 / 24;

					box[4] = -0;
					box[5] = 20;
				}
			}]};

			akLoad(lib);
		</script>
	</body>
</html>