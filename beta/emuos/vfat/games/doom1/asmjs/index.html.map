{"version":3,"sources":["/mnt/c/Repositories/wasm-doom.git/src/doom/p_enemy.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_extnodes.c","/mnt/c/Repositories/wasm-doom.git/src/doom/m_menu.c","/mnt/c/Repositories/wasm-doom.git/src/doom/m_random.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_bexptr.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_blockmap.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_ceilng.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_doors.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_floor.c","/mnt/c/Repositories/wasm-doom.git/src/i_oplmusic.c","/mnt/c/Repositories/wasm-doom.git/src/i_sdlsound.c","/mnt/c/Repositories/wasm-doom.git/src/i_sound.c","/mnt/c/Repositories/wasm-doom.git/src/i_system.c","/mnt/c/Repositories/wasm-doom.git/src/i_txt.c","/mnt/c/Repositories/wasm-doom.git/src/i_video.c","/mnt/c/Repositories/wasm-doom.git/src/i_webmusic.c","/mnt/c/Repositories/wasm-doom.git/src/doom/r_things.c","/mnt/c/Repositories/wasm-doom.git/src/doom/s_sound.c","/mnt/c/Repositories/wasm-doom.git/src/doom/st_lib.c","/mnt/c/Repositories/wasm-doom.git/src/doom/st_stuff.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_saveg.c","/mnt/c/Repositories/wasm-doom.git/src/i_timer.c","/mnt/c/Repositories/wasm-doom.git/src/m_argv.c","/mnt/c/Repositories/wasm-doom.git/src/m_bbox.c","/mnt/c/Repositories/wasm-doom.git/src/m_cheat.c","/mnt/c/Repositories/wasm-doom.git/src/m_config.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_setup.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_map.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_maputl.c","/mnt/c/Repositories/wasm-doom.git/opl/opl3.c","/mnt/c/Repositories/wasm-doom.git/opl/opl_queue.c","/mnt/c/Repositories/wasm-doom.git/opl/opl_sdl.c","/mnt/c/Repositories/wasm-doom.git/sdl_mixer/effect_position.c","/mnt/c/Repositories/wasm-doom.git/src/doom/hu_stuff.c","/mnt/c/Repositories/wasm-doom.git/src/doom/wi_stuff.c","/mnt/c/Repositories/wasm-doom.git/src/i_endoom.c","/mnt/c/Repositories/wasm-doom.git/src/i_input.c","/mnt/c/Repositories/wasm-doom.git/src/doom/r_data.c","/mnt/c/Repositories/wasm-doom.git/src/doom/r_draw.c","/mnt/c/Repositories/wasm-doom.git/src/doom/r_main.c","/mnt/c/Repositories/wasm-doom.git/src/v_video.c","/mnt/c/Repositories/wasm-doom.git/src/w_file.c","/mnt/c/Repositories/wasm-doom.git/src/w_file_stdc.c","/mnt/c/Repositories/wasm-doom.git/src/w_main.c","/mnt/c/Repositories/wasm-doom.git/src/w_merge.c","/mnt/c/Repositories/wasm-doom.git/src/w_wad.c","/mnt/c/Repositories/wasm-doom.git/src/doom/r_segs.c","/mnt/c/Repositories/wasm-doom.git/src/sha1.c","/mnt/c/Repositories/wasm-doom.git/src/tables.c","/mnt/c/Repositories/wasm-doom.git/src/v_diskicon.c","/mnt/c/Repositories/wasm-doom.git/src/v_trans.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_mobj.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_inter.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_lights.c","/mnt/c/Repositories/wasm-doom.git/src/memio.c","/mnt/c/Repositories/wasm-doom.git/src/midifile.c","/mnt/c/Repositories/wasm-doom.git/src/mus2mid.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_plats.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_pspr.c","/mnt/c/Repositories/wasm-doom.git/src/z_native.c","/mnt/c/Repositories/wasm-doom.git/src/doom/g_game.c","/mnt/c/Repositories/wasm-doom.git/src/doom/deh_cheat.c","/mnt/c/Repositories/wasm-doom.git/src/doom/deh_frame.c","/mnt/c/Repositories/wasm-doom.git/src/doom/deh_misc.c","/mnt/c/Repositories/wasm-doom.git/src/doom/deh_ptr.c","/mnt/c/Repositories/wasm-doom.git/src/doom/deh_sound.c","/mnt/c/Repositories/wasm-doom.git/src/doom/deh_thing.c","/mnt/c/Repositories/wasm-doom.git/src/doom/deh_weapon.c","/mnt/c/Repositories/wasm-doom.git/src/doom/f_finale.c","/mnt/c/Repositories/wasm-doom.git/opl/opl.c","/mnt/c/Repositories/wasm-doom.git/src/deh_mapping.c","/mnt/c/Repositories/wasm-doom.git/src/deh_str.c","/mnt/c/Repositories/wasm-doom.git/src/deh_text.c","/mnt/c/Repositories/wasm-doom.git/src/doom/am_map.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_genlin.c","/mnt/c/Repositories/wasm-doom.git/src/doom/statdump.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_spec.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_switch.c","/mnt/c/Repositories/wasm-doom.git/src/i_joystick.c","/mnt/c/Repositories/wasm-doom.git/src/m_controls.c","/mnt/c/Repositories/wasm-doom.git/src/m_fixed.c","/mnt/c/Repositories/wasm-doom.git/src/m_misc.c","/mnt/c/Repositories/wasm-doom.git/src/doom/d_main.c","/mnt/c/Repositories/wasm-doom.git/sdl_mixer/mixer.c","/mnt/c/Repositories/wasm-doom.git/sdl_mixer/music.c","/mnt/c/Repositories/wasm-doom.git/src/d_event.c","/mnt/c/Repositories/wasm-doom.git/src/d_iwad.c","/mnt/c/Repositories/wasm-doom.git/src/d_loop.c","/mnt/c/Repositories/wasm-doom.git/src/d_mode.c","/mnt/c/Repositories/wasm-doom.git/src/deh_io.c","/mnt/c/Repositories/wasm-doom.git/src/deh_main.c","/home/zadarkside/.emscripten_cache/asmjs/ports-builds/sdl2/include/SDL_endian.h","/mnt/c/Repositories/wasm-doom.git/src/doom/p_sight.c","/mnt/c/Repositories/wasm-doom.git/src/doom/r_bmaps.c","/mnt/c/Repositories/wasm-doom.git/src/doom/r_bsp.c","/mnt/c/Repositories/wasm-doom.git/src/doom/r_plane.c","/mnt/c/Repositories/wasm-doom.git/src/doom/f_wipe.c","/mnt/c/Repositories/wasm-doom.git/src/doom/hu_lib.c","/mnt/c/Repositories/wasm-doom.git/src/doom/deh_bexptr.c","/mnt/c/Repositories/wasm-doom.git/src/doom/deh_bexstr.c","/mnt/c/Repositories/wasm-doom.git/src/i_main.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_telept.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_tick.c","/mnt/c/Repositories/wasm-doom.git/src/doom/p_user.c","/mnt/c/Repositories/wasm-doom.git/sdl_mixer/effects_internal.c","/mnt/c/Repositories/wasm-doom.git/src/doom/deh_bexincl.c","/mnt/c/Repositories/wasm-doom.git/src/doom/deh_bexpars.c","/mnt/c/Repositories/wasm-doom.git/src/doom/deh_ammo.c","/mnt/c/Repositories/wasm-doom.git/src/doom/r_sky.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;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AAA;AAAA;AAAA;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;;;;;;;;;;;;;;;;;;;AC6lDA;;;;;;;;;;;;;;;;;;;;;;AA6DA;AAAA;AAAA;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvjDA;;;AAYA;AAaA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;;;;;;;AAkBA;;AACA;AAAA;;;;;;;;;;;;;AAQA;AAAA;AAA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MA;;AAGA;AAGA;;;AAQA;AAGA;;;AA4CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjE5lBA;;AAGA;;;;;;AAzCA;AAAA;AAAA;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AAKA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;AACA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;;;;;;AAKA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;AACA;;;;;;AAKA;;;;;;;;;AAOA;AACA;;;;;;AAMA;AACA;;;;;;AAKA;AACA;;;;;;AAMA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAMA;;;;;;AAMA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;AAKA;;;;;;;;;AAMA;;;;;;AAKA;;;;;;AAKA;;;;;;;;;AAoBA;;;;;;;;;AAOA;;;;;;;;;AAOA;;;;;;;;;AAOA;;;;;;;;;AAOA;;;;;;;;;AAOA;;;;;;;;;AAOA;;;;;;;;;AAMA;;;;;;;;;AAQA;;;;;;;;;AAOA;;;;;;;;;AAOA;;;;;;;;;AAOA;;;;;;;;;AAOA;;;;;;;;;AAOA;;;;;;;;;AAMA;;;;;;;;;AAKA;;;;;;;;;;;;AAMA;;;;;;;;;;;;AAMA;;;;;;;;;;;;AAKA;;;;;;AAaA;;;;;;AAMA;;;;;;AAMA;;;;;;AAMA;;;;;;AAOA;AACA;;;;;;AAMA;;;;;;AAOA;;;;;;AAOA;;;;;;AAMA;;;;;;AAMA;;;;;;AAMA;;;;;;AAMA;;;;;;AAMA;;;;;;AAKA;;;;;;AAMA;;;;;;AAOA;;;;;;AAMA;;;;;;AAMA;;;;;;AAMA;;;;;;AAMA;;;;;;AAMA;;;;;;AAKA;;;;;;AAIA;;;;;;;;;AAKA;;;;;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;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A6D6IA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2CA;;;;;;;AAIA;;;;;;;;;;;AAIA;;;;;;;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CA;;;;;;;;;;;AAYA;;;;;;;;;;;AAMA;;;;;;;AAKA;AACA;;;;;;;;;;;AAMA;;;;;;;;;;;AAMA;;;;;;;;;;;AAMA;;;;;;;;;;;AAMA;;;;;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;;;;;Ab3eA;;;;;;;;;;;;;AKmMA;AAAA;;;;;A1EqvBA;AACA;;;;;;;;;;;;;;;AqE59BA;;;;;;;;;;;;;;;;;;;;;;;AI6tCA;;;;;;;AvEqHA;;;;;;;;;;;;;;;;;;Aap+BA;;;;;;AoEu/BA;AAhBA;;;;;;;;;;;;;;;ApCpxCA;AAAA;;;;;;;;;;;;;;A/C6TA;;;;;;;;;;;;;AsC+EA;;;;A2DjgBA;AACA;AACA;;;;;AxB8yBA;;;;;;;;AJroBA;;;;AX4CA;;;;;AgClKA;;AAIA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A1D2SA;AAAA;AAAA;;;;;;;;;;;;;;AHurBA;;;;;A3B46BA;AACA;;;;;;AFrcA;AAAA;;;;;;;;;;;;;;;;;;;AkBx5CA;;;;;;Acq0BA;;AACA;;;;;;;AAjtBA;;;;;;;;;;;;;;;Af+cA;;;;;;;;;;AYiUA;;;;;;;;;;;;;;;;;;;;AoEj+BA;AACA;;;;AvEqzCA;AACA;AACA;AACA;;;;;;;A+CjTA;;;;;;;;;;;;;;AJl9BA;;;;;;;;;;;;;;;;;;;;;AIibA;AACA;AACA;AACA;;;;;;;;;;;;AUrHA;;;;AjF2XA;AAEA;;;;;AkB7rBA;AAGA;;;;AD8yCA;AAEA;;;;;;;AWjvCA;;;;;;;;;;;;;Ab4YA;AACA;;;;;;AoDjMA;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ApDuMA;AACA;;;;;;;;;;;;;;;;AD7KA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AInSA;AACA;;;;;;;;;;;;;AiDCA;;;;AjE/EA;;;;;;;;;;;;;;AqGTA;;;;AtFs4CA;AACA;AAAA;;;;;;;;;;;;;;;AF7iCA;;;;;;;;;;;;;;AGrIA;AAAA;;;;;;;;AwB8DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AZ2XA;;AACA;;;;;;;;;;;;;;;;;;;;;AqC9kBA;;;;;;;;;;AnD7CA;AAAA;;;;;AYXA;AACA;AAEA;;;A5BmvBA;AAKA;;;;AAjBA;AAEA;;;;;;;;;;;;;;;;;;AmEzYA;;AAEA;;;;;ApCgQA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;AoC5QA;;AAEA;;;;;;;;;;;;;;;;;;;;AAlUA;;;;;;AAFA;;;;;;AALA;;;;;;;;;;;;AAhBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAKA;;;;;;AAgEA;;;AnEq/BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AgFp7BA;;;;;;;;;;;;ANomEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AqBz8DA;;;;;;A3D3HA;;;;;;;;;;;;;ATkrBA;;;;;A2E11BA;AAAA;;;;;;AxGssDA;;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A4E4fA;;;;;A3D7zDA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A+EhUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AdyxBA;AAAA;;;;;;A5DztBA;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;AsC86CA;AACA;;;;;A2Bp2CA;AAAA;;;;;;;;;;;A7BsjBA;;;;;;;;;;;;;;;;;;AvCmPA;AAGA;AAGA;;;;;;;;;;;;;;;;;;;;;AsD4PA;;;;AS7bA;;;;;;;;;;;;;;;;;AejlBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjGshCA;AACA;;;;;AA8PA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A6BvtCA;;;;;;;;A+BswDA;AACA;;;;AsBz4CA;AACA;AACA;;;;;;;;;;;;;;;;;AbzRA;;;;;;;;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;AxCgnBA;;;;;;;;;;;;;A7B4JA;AACA;;;;;;;;;;;;;;;AanjCA;;;A4D2zBA;;;;;;;;;;;;;;;;;;;;;;;;;AhE2jBA;AAAA;;;;;AT1UA;AACA;;;;;;;;;AuC59BA;;;;AiCnMA;;;;ArE4BA;AACA;;;;;;;;;;;;;;;AiEiXA;;;;Acw8BA;;;;;;AxB1nBA;;;;;;AALA;;;;;;AALA;;;;;;AA3ZA;;;;;;;;;;;AX3MA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A3C5HA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A8Eg2CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ATzcA;;;;AzC/vBA;;;;A9BqrBA;;;;AAwCA;;;;;;;;;;;;;;;;;;;;;;;;AiF5dA;;;;;;;;;;;;;;;;;;;;AnF+8CA;AACA;;;;;;;;;;;;;;;;;;;;A8Bl1DA;;;;;;;;;;;;;;;;;AduUA;;;;;AuBIA;;;;AvCu2CA;AACA;;;;;;;;;;;;;;;AqE31CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AARA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AARA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AApBA;;;;;;;;;;;;;;AATA;;;;;;;;;;;;;;;;;;;;;AATA;;;;;;;;;;;;;;AAAA;;;;;;;;;;;;;;AARA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AARA;;;;;;;AANA;;;;;;;;;;;;;;;;;;;;;ArDudA;;;;;;;AqD/dA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAPA;;;;;;;;;;;;;;AARA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA5JA;;;;;;;AAFA;;;;;;;;;;;;;;AAoBA;;;;;;;AAFA;;;;;;;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;;;;;;;;;;;;;;AAHA;;;;;;;;;;;;;;AAuFA;;;;;;;AAHA;;;;;;;AAFA;;;;;;;AARA;;;;;;;;;;;;;;;;AI8jCA;;;;;;;;;;;;;;;;ArDljCA;;;;;;;;;;;;AXwjBA;;;;;;A6F1uBA;;;;AA5BA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AvEmOA;;;;A/Bk9CA;AACA;;;;;A2E9lDA;;;;;A3EulDA;AACA;;;;;;;;;;;;;;;;;AkFtkCA;;;;;;;AAnCA;;;;;AHxQA;;;;;AAQA;;;;;AAvBA;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;AK0jBA;;AAeA;;;;;;;AfhpBA;;;;;;;;;;;;;;;;;;;;;;;AoB8CA;;;;;A5BxQA;;;;;;;;;;;;;;;;;;;;;;;;AEsFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjC/FA;;;;;AE8sDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A0EjuDA;;;;A3E+ZA;;;;;A7B4lBA;;;;;A8BuuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAvdA;;;;;;;;;;;;;;AAlWA;;;;;;;;;;;;AHxbA;;;;;;;;;;;;;;;;;AIoPA;AACA;;;;;A/B+QA;;;;ACx9BA;AAAA;;;;;ADk9BA;;;;;;;;;;;AyFt3BA;;;;;;;;;;;;;;;;;AlFm6BA;;;;AP5GA;;;;;;;;A0DmUA;AACA;;;;;A5D3FA;;;;;;;;;;;;;AEtZA;;;;;A4BnpBA;;;;;;;;;;A5BuqBA;;;;;AFguBA;;;;;;;AqE3wCA;;;;;;AALA;;;;;;AANA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ArCisBA;;;;;AHjaA;;;;;;;;;;;;AZmIA;;;;;;;;;AoDphBA;;;;;AcwWA;;;;;;;;;;;;;;;ADvCA;;;;;;;;;;;;;;AYwJA;;;;A9Do2BA;;;;;AuD3gCA;;;;;;;;;;;;;;;;;;;;;;;AnEi8BA;;;AWj9BA;;;;;ADzYA;;;;;;;;;AbsaA;;;;A4EwJA;;;;AALA;;;;AALA;;;AVo9BA;;;;;;;;;;;;AjDrqCA;;;;;;;;;;;;;A2DuLA;;;;AAVA;;;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;;;;AALA;;;;AALA;;;AVg+BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AjE9+CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AlB0uDA;;;;;;;;;AkFnyCA;;;;;;;;AAg4BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A9DntCA;;;;A8D0JA;;;;;;;;;;;;AYxRA;;;;AZudA;;;;;;;;;;;;;;;;;;AlE3LA;;;;;;;;;;;;;;;AuB4lBA;;;;AvCi7BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AmBprBA;;;;;;;;;;;;;;;;;;;;AV6oBA;;;;;;;;;;;;;;;;A+F9wDA;;;;A5C8TA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;A5BkeA;;;;;;;;;;;;AK7jBA;;;AuEpOA;;;;A1B0eA;;;A9D23BA;;;;;AU32CA;;;;;;;;AyDibA;;;;;;AjD9LA;;;;A4CuRA;;;;;;;;;;;;;;;;;AEjRA;;;;;;;;;;Af5DA;;;;ATmrDA;;;;;;;;;;;;;;;;;;;A5BvgCA;;;;;;;AcvpBA;;;;;;;;;;;;ArCy1BA;;;;;;;;;;;;AyEtdA;;;;AbtcA;;;AnE8yDA;;;;A0DtvBA;;;;;;;;AzCpLA;;;;ACv4BA;;;AHdA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AgBgTA;;;;AsDxJA;;;;;;;;;;;;;;;;;;;;;;;;;;;ArD0zBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AY1xBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AsC9EA","file":"index.html","sourcesContent":["//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tEnemy thinking, AI.\n//\tAction Pointer Functions\n//\tthat are associated with states/frames. \n//\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"m_random.h\"\n#include \"i_system.h\"\n\n#include \"doomdef.h\"\n#include \"p_local.h\"\n\n#include \"s_sound.h\"\n\n#include \"g_game.h\"\n\n// State.\n#include \"doomstat.h\"\n#include \"r_state.h\"\n\n// Data.\n#include \"sounds.h\"\n\n\n\n\ntypedef enum\n{\n    DI_EAST,\n    DI_NORTHEAST,\n    DI_NORTH,\n    DI_NORTHWEST,\n    DI_WEST,\n    DI_SOUTHWEST,\n    DI_SOUTH,\n    DI_SOUTHEAST,\n    DI_NODIR,\n    NUMDIRS\n    \n} dirtype_t;\n\n\n//\n// P_NewChaseDir related LUT.\n//\ndirtype_t opposite[] =\n{\n  DI_WEST, DI_SOUTHWEST, DI_SOUTH, DI_SOUTHEAST,\n  DI_EAST, DI_NORTHEAST, DI_NORTH, DI_NORTHWEST, DI_NODIR\n};\n\ndirtype_t diags[] =\n{\n    DI_NORTHWEST, DI_NORTHEAST, DI_SOUTHWEST, DI_SOUTHEAST\n};\n\n\n\n\n\nvoid A_Fall (mobj_t *actor);\n\n\n//\n// ENEMY THINKING\n// Enemies are allways spawned\n// with targetplayer = -1, threshold = 0\n// Most monsters are spawned unaware of all players,\n// but some can be made preaware\n//\n\n\n//\n// Called by P_NoiseAlert.\n// Recursively traverse adjacent sectors,\n// sound blocking lines cut off traversal.\n//\n\nmobj_t*\t\tsoundtarget;\n\nvoid\nP_RecursiveSound\n( sector_t*\tsec,\n  int\t\tsoundblocks )\n{\n    int\t\ti;\n    line_t*\tcheck;\n    sector_t*\tother;\n\t\n    // wake up all monsters in this sector\n    if (sec->validcount == validcount\n\t&& sec->soundtraversed <= soundblocks+1)\n    {\n\treturn;\t\t// already flooded\n    }\n    \n    sec->validcount = validcount;\n    sec->soundtraversed = soundblocks+1;\n    sec->soundtarget = soundtarget;\n\t\n    for (i=0 ;i<sec->linecount ; i++)\n    {\n\tcheck = sec->lines[i];\n\tif (! (check->flags & ML_TWOSIDED) )\n\t    continue;\n\t\n\tP_LineOpening (check);\n\n\tif (openrange <= 0)\n\t    continue;\t// closed door\n\t\n\tif ( sides[ check->sidenum[0] ].sector == sec)\n\t    other = sides[ check->sidenum[1] ] .sector;\n\telse\n\t    other = sides[ check->sidenum[0] ].sector;\n\t\n\tif (check->flags & ML_SOUNDBLOCK)\n\t{\n\t    if (!soundblocks)\n\t\tP_RecursiveSound (other, 1);\n\t}\n\telse\n\t    P_RecursiveSound (other, soundblocks);\n    }\n}\n\n\n\n//\n// P_NoiseAlert\n// If a monster yells at a player,\n// it will alert other monsters to the player.\n//\nvoid\nP_NoiseAlert\n( mobj_t*\ttarget,\n  mobj_t*\temmiter )\n{\n    soundtarget = target;\n    validcount++;\n    P_RecursiveSound (emmiter->subsector->sector, 0);\n}\n\n\n\n\n//\n// P_CheckMeleeRange\n//\nboolean P_CheckMeleeRange (mobj_t*\tactor)\n{\n    mobj_t*\tpl;\n    fixed_t\tdist;\n\t\n    if (!actor->target)\n\treturn false;\n\t\t\n    pl = actor->target;\n    dist = P_AproxDistance (pl->x-actor->x, pl->y-actor->y);\n\n    if (dist >= MELEERANGE-20*FRACUNIT+pl->info->radius)\n\treturn false;\n\t\n    if (! P_CheckSight (actor, actor->target) )\n\treturn false;\n\t\t\t\t\t\t\t\n    return true;\t\t\n}\n\n//\n// P_CheckMissileRange\n//\nboolean P_CheckMissileRange (mobj_t* actor)\n{\n    fixed_t\tdist;\n\t\n    if (! P_CheckSight (actor, actor->target) )\n\treturn false;\n\t\n    if ( actor->flags & MF_JUSTHIT )\n    {\n\t// the target just hit the enemy,\n\t// so fight back!\n\tactor->flags &= ~MF_JUSTHIT;\n\treturn true;\n    }\n\t\n    if (actor->reactiontime)\n\treturn false;\t// do not attack yet\n\t\t\n    // OPTIMIZE: get this from a global checksight\n    dist = P_AproxDistance ( actor->x-actor->target->x,\n\t\t\t     actor->y-actor->target->y) - 64*FRACUNIT;\n    \n    if (!actor->info->meleestate)\n\tdist -= 128*FRACUNIT;\t// no melee attack, so fire more\n\n    dist >>= FRACBITS;\n\n    if (actor->type == MT_VILE)\n    {\n\tif (dist > 14*64)\t\n\t    return false;\t// too far away\n    }\n\t\n\n    if (actor->type == MT_UNDEAD)\n    {\n\tif (dist < 196)\t\n\t    return false;\t// close for fist attack\n\tdist >>= 1;\n    }\n\t\n\n    if (actor->type == MT_CYBORG\n\t|| actor->type == MT_SPIDER\n\t|| actor->type == MT_SKULL)\n    {\n\tdist >>= 1;\n    }\n    \n    if (dist > 200)\n\tdist = 200;\n\t\t\n    if (actor->type == MT_CYBORG && dist > 160)\n\tdist = 160;\n\t\t\n    if (P_Random () < dist)\n\treturn false;\n\t\t\n    return true;\n}\n\n\n//\n// P_Move\n// Move in the current direction,\n// returns false if the move is blocked.\n//\nfixed_t\txspeed[8] = {FRACUNIT,47000,0,-47000,-FRACUNIT,-47000,0,47000};\nfixed_t yspeed[8] = {0,47000,FRACUNIT,47000,0,-47000,-FRACUNIT,-47000};\n\nboolean P_Move (mobj_t*\tactor)\n{\n    fixed_t\ttryx;\n    fixed_t\ttryy;\n    \n    line_t*\tld;\n    \n    // warning: 'catch', 'throw', and 'try'\n    // are all C++ reserved words\n    boolean\ttry_ok;\n    boolean\tgood;\n\t\t\n    if (actor->movedir == DI_NODIR)\n\treturn false;\n\t\t\n    if ((unsigned)actor->movedir >= 8)\n\tI_Error (\"Weird actor->movedir!\");\n\t\t\n    tryx = actor->x + actor->info->speed*xspeed[actor->movedir];\n    tryy = actor->y + actor->info->speed*yspeed[actor->movedir];\n\n    try_ok = P_TryMove (actor, tryx, tryy);\n\n    if (!try_ok)\n    {\n\t// open any specials\n\tif (actor->flags & MF_FLOAT && floatok)\n\t{\n\t    // must adjust height\n\t    if (actor->z < tmfloorz)\n\t\tactor->z += FLOATSPEED;\n\t    else\n\t\tactor->z -= FLOATSPEED;\n\n\t    actor->flags |= MF_INFLOAT;\n\t    return true;\n\t}\n\t\t\n\tif (!numspechit)\n\t    return false;\n\t\t\t\n\tactor->movedir = DI_NODIR;\n\tgood = false;\n\twhile (numspechit--)\n\t{\n\t    ld = spechit[numspechit];\n\t    // if the special is not a door\n\t    // that can be opened,\n\t    // return false\n\t    if (P_UseSpecialLine (actor, ld,0))\n\t\tgood = true;\n\t}\n\treturn good;\n    }\n    else\n    {\n\tactor->flags &= ~MF_INFLOAT;\n    }\n\t\n\t\n    if (! (actor->flags & MF_FLOAT) )\t\n\tactor->z = actor->floorz;\n    return true; \n}\n\n\n//\n// TryWalk\n// Attempts to move actor on\n// in its current (ob->moveangle) direction.\n// If blocked by either a wall or an actor\n// returns FALSE\n// If move is either clear or blocked only by a door,\n// returns TRUE and sets...\n// If a door is in the way,\n// an OpenDoor call is made to start it opening.\n//\nboolean P_TryWalk (mobj_t* actor)\n{\t\n    if (!P_Move (actor))\n    {\n\treturn false;\n    }\n\n    actor->movecount = P_Random()&15;\n    return true;\n}\n\n\n\n\nvoid P_NewChaseDir (mobj_t*\tactor)\n{\n    fixed_t\tdeltax;\n    fixed_t\tdeltay;\n    \n    dirtype_t\td[3];\n    \n    int\t\ttdir;\n    dirtype_t\tolddir;\n    \n    dirtype_t\tturnaround;\n\n    if (!actor->target)\n\tI_Error (\"P_NewChaseDir: called with no target\");\n\t\t\n    olddir = actor->movedir;\n    turnaround=opposite[olddir];\n\n    deltax = actor->target->x - actor->x;\n    deltay = actor->target->y - actor->y;\n\n    if (deltax>10*FRACUNIT)\n\td[1]= DI_EAST;\n    else if (deltax<-10*FRACUNIT)\n\td[1]= DI_WEST;\n    else\n\td[1]=DI_NODIR;\n\n    if (deltay<-10*FRACUNIT)\n\td[2]= DI_SOUTH;\n    else if (deltay>10*FRACUNIT)\n\td[2]= DI_NORTH;\n    else\n\td[2]=DI_NODIR;\n\n    // try direct route\n    if (d[1] != DI_NODIR\n\t&& d[2] != DI_NODIR)\n    {\n\tactor->movedir = diags[((deltay<0)<<1)+(deltax>0)];\n\tif (actor->movedir != (int) turnaround && P_TryWalk(actor))\n\t    return;\n    }\n\n    // try other directions\n    if (P_Random() > 200\n\t||  abs(deltay)>abs(deltax))\n    {\n\ttdir=d[1];\n\td[1]=d[2];\n\td[2]=tdir;\n    }\n\n    if (d[1]==turnaround)\n\td[1]=DI_NODIR;\n    if (d[2]==turnaround)\n\td[2]=DI_NODIR;\n\t\n    if (d[1]!=DI_NODIR)\n    {\n\tactor->movedir = d[1];\n\tif (P_TryWalk(actor))\n\t{\n\t    // either moved forward or attacked\n\t    return;\n\t}\n    }\n\n    if (d[2]!=DI_NODIR)\n    {\n\tactor->movedir =d[2];\n\n\tif (P_TryWalk(actor))\n\t    return;\n    }\n\n    // there is no direct path to the player,\n    // so pick another direction.\n    if (olddir!=DI_NODIR)\n    {\n\tactor->movedir =olddir;\n\n\tif (P_TryWalk(actor))\n\t    return;\n    }\n\n    // randomly determine direction of search\n    if (P_Random()&1) \t\n    {\n\tfor ( tdir=DI_EAST;\n\t      tdir<=DI_SOUTHEAST;\n\t      tdir++ )\n\t{\n\t    if (tdir != (int) turnaround)\n\t    {\n\t\tactor->movedir =tdir;\n\t\t\n\t\tif ( P_TryWalk(actor) )\n\t\t    return;\n\t    }\n\t}\n    }\n    else\n    {\n\tfor ( tdir=DI_SOUTHEAST;\n\t      tdir != (DI_EAST-1);\n\t      tdir-- )\n\t{\n\t    if (tdir != (int) turnaround)\n\t    {\n\t\tactor->movedir = tdir;\n\t\t\n\t\tif ( P_TryWalk(actor) )\n\t\t    return;\n\t    }\n\t}\n    }\n\n    if (turnaround !=  DI_NODIR)\n    {\n\tactor->movedir =turnaround;\n\tif ( P_TryWalk(actor) )\n\t    return;\n    }\n\n    actor->movedir = DI_NODIR;\t// can not move\n}\n\n\n\n//\n// P_LookForPlayers\n// If allaround is false, only look 180 degrees in front.\n// Returns true if a player is targeted.\n//\nboolean\nP_LookForPlayers\n( mobj_t*\tactor,\n  boolean\tallaround )\n{\n    int\t\tc;\n    int\t\tstop;\n    player_t*\tplayer;\n    angle_t\tan;\n    fixed_t\tdist;\n\n    c = 0;\n    stop = (actor->lastlook-1)&3;\n\t\n    for ( ; ; actor->lastlook = (actor->lastlook+1)&3 )\n    {\n\tif (!playeringame[actor->lastlook])\n\t    continue;\n\t\t\t\n\tif (c++ == 2\n\t    || actor->lastlook == stop)\n\t{\n\t    // done looking\n\t    return false;\t\n\t}\n\t\n\tplayer = &players[actor->lastlook];\n\n\tif (player->health <= 0)\n\t    continue;\t\t// dead\n\n\tif (!P_CheckSight (actor, player->mo))\n\t    continue;\t\t// out of sight\n\t\t\t\n\tif (!allaround)\n\t{\n\t    an = R_PointToAngle2 (actor->x,\n\t\t\t\t  actor->y, \n\t\t\t\t  player->mo->x,\n\t\t\t\t  player->mo->y)\n\t\t- actor->angle;\n\t    \n\t    if (an > ANG90 && an < ANG270)\n\t    {\n\t\tdist = P_AproxDistance (player->mo->x - actor->x,\n\t\t\t\t\tplayer->mo->y - actor->y);\n\t\t// if real close, react anyway\n\t\tif (dist > MELEERANGE)\n\t\t    continue;\t// behind back\n\t    }\n\t}\n\t\t\n\tactor->target = player->mo;\n\treturn true;\n    }\n\n    return false;\n}\n\n\n//\n// A_KeenDie\n// DOOM II special, map 32.\n// Uses special tag 666.\n//\nvoid A_KeenDie (mobj_t* mo)\n{\n    thinker_t*\tth;\n    mobj_t*\tmo2;\n    line_t\tjunk;\n\n    A_Fall (mo);\n    \n    // scan the remaining thinkers\n    // to see if all Keens are dead\n    for (th = thinkercap.next ; th != &thinkercap ; th=th->next)\n    {\n\tif (th->function.acp1 != (actionf_p1)P_MobjThinker)\n\t    continue;\n\n\tmo2 = (mobj_t *)th;\n\tif (mo2 != mo\n\t    && mo2->type == mo->type\n\t    && mo2->health > 0)\n\t{\n\t    // other Keen not dead\n\t    return;\t\t\n\t}\n    }\n\n    junk.tag = 666;\n    EV_DoDoor(&junk, openDoor);\n}\n\n\n//\n// ACTION ROUTINES\n//\n\n//\n// A_Look\n// Stay in state until a player is sighted.\n//\nvoid A_Look (mobj_t* actor)\n{\n    mobj_t*\ttarg;\n\t\n    actor->threshold = 0;\t// any shot will wake up\n    targ = actor->subsector->sector->soundtarget;\n\n    if (targ\n\t&& (targ->flags & MF_SHOOTABLE) )\n    {\n\tactor->target = targ;\n\n\tif ( actor->flags & MF_AMBUSH )\n\t{\n\t    if (P_CheckSight (actor, actor->target))\n\t\tgoto seeyou;\n\t}\n\telse\n\t    goto seeyou;\n    }\n\t\n\t\n    if (!P_LookForPlayers (actor, false) )\n\treturn;\n\t\t\n    // go into chase state\n  seeyou:\n    if (actor->info->seesound)\n    {\n\tint\t\tsound;\n\t\t\n\tswitch (actor->info->seesound)\n\t{\n\t  case sfx_posit1:\n\t  case sfx_posit2:\n\t  case sfx_posit3:\n\t    sound = sfx_posit1+P_Random()%3;\n\t    break;\n\n\t  case sfx_bgsit1:\n\t  case sfx_bgsit2:\n\t    sound = sfx_bgsit1+P_Random()%2;\n\t    break;\n\n\t  default:\n\t    sound = actor->info->seesound;\n\t    break;\n\t}\n\n\tif (actor->type==MT_SPIDER\n\t    || actor->type == MT_CYBORG)\n\t{\n\t    // full volume\n\t    S_StartSound (NULL, sound);\n\t}\n\telse\n\t    S_StartSound (actor, sound);\n    }\n\n    P_SetMobjState (actor, actor->info->seestate);\n}\n\n\n//\n// A_Chase\n// Actor has a melee attack,\n// so it tries to close as fast as possible\n//\nvoid A_Chase (mobj_t*\tactor)\n{\n    int\t\tdelta;\n\n    if (actor->reactiontime)\n\tactor->reactiontime--;\n\t\t\t\t\n\n    // modify target threshold\n    if  (actor->threshold)\n    {\n\tif (!actor->target\n\t    || actor->target->health <= 0)\n\t{\n\t    actor->threshold = 0;\n\t}\n\telse\n\t    actor->threshold--;\n    }\n    \n    // turn towards movement direction if not there yet\n    if (actor->movedir < 8)\n    {\n\tactor->angle &= (7<<29);\n\tdelta = actor->angle - (actor->movedir << 29);\n\t\n\tif (delta > 0)\n\t    actor->angle -= ANG90/2;\n\telse if (delta < 0)\n\t    actor->angle += ANG90/2;\n    }\n\n    if (!actor->target\n\t|| !(actor->target->flags&MF_SHOOTABLE))\n    {\n\t// look for a new target\n\tif (P_LookForPlayers(actor,true))\n\t    return; \t// got a new target\n\t\n\tP_SetMobjState (actor, actor->info->spawnstate);\n\treturn;\n    }\n    \n    // do not attack twice in a row\n    if (actor->flags & MF_JUSTATTACKED)\n    {\n\tactor->flags &= ~MF_JUSTATTACKED;\n\tif (gameskill != sk_nightmare && !fastparm)\n\t    P_NewChaseDir (actor);\n\treturn;\n    }\n    \n    // check for melee attack\n    if (actor->info->meleestate\n\t&& P_CheckMeleeRange (actor))\n    {\n\tif (actor->info->attacksound)\n\t    S_StartSound (actor, actor->info->attacksound);\n\n\tP_SetMobjState (actor, actor->info->meleestate);\n\treturn;\n    }\n    \n    // check for missile attack\n    if (actor->info->missilestate)\n    {\n\tif (gameskill < sk_nightmare\n\t    && !fastparm && actor->movecount)\n\t{\n\t    goto nomissile;\n\t}\n\t\n\tif (!P_CheckMissileRange (actor))\n\t    goto nomissile;\n\t\n\tP_SetMobjState (actor, actor->info->missilestate);\n\tactor->flags |= MF_JUSTATTACKED;\n\treturn;\n    }\n\n    // ?\n  nomissile:\n    // possibly choose another target\n    if (netgame\n\t&& !actor->threshold\n\t&& !P_CheckSight (actor, actor->target) )\n    {\n\tif (P_LookForPlayers(actor,true))\n\t    return;\t// got a new target\n    }\n    \n    // chase towards player\n    if (--actor->movecount<0\n\t|| !P_Move (actor))\n    {\n\tP_NewChaseDir (actor);\n    }\n    \n    // make active sound\n    if (actor->info->activesound\n\t&& P_Random () < 3)\n    {\n\tS_StartSound (actor, actor->info->activesound);\n    }\n}\n\n\n//\n// A_FaceTarget\n//\nvoid A_FaceTarget (mobj_t* actor)\n{\t\n    if (!actor->target)\n\treturn;\n    \n    actor->flags &= ~MF_AMBUSH;\n\t\n    actor->angle = R_PointToAngle2 (actor->x,\n\t\t\t\t    actor->y,\n\t\t\t\t    actor->target->x,\n\t\t\t\t    actor->target->y);\n    \n    if (actor->target->flags & MF_SHADOW)\n\tactor->angle += P_SubRandom() << 21;\n}\n\n\n//\n// A_PosAttack\n//\nvoid A_PosAttack (mobj_t* actor)\n{\n    int\t\tangle;\n    int\t\tdamage;\n    int\t\tslope;\n\t\n    if (!actor->target)\n\treturn;\n\t\t\n    A_FaceTarget (actor);\n    angle = actor->angle;\n    slope = P_AimLineAttack (actor, angle, MISSILERANGE);\n\n    S_StartSound (actor, sfx_pistol);\n    angle += P_SubRandom() << 20;\n    damage = ((P_Random()%5)+1)*3;\n    P_LineAttack (actor, angle, MISSILERANGE, slope, damage);\n}\n\nvoid A_SPosAttack (mobj_t* actor)\n{\n    int\t\ti;\n    int\t\tangle;\n    int\t\tbangle;\n    int\t\tdamage;\n    int\t\tslope;\n\t\n    if (!actor->target)\n\treturn;\n\n    S_StartSound (actor, sfx_shotgn);\n    A_FaceTarget (actor);\n    bangle = actor->angle;\n    slope = P_AimLineAttack (actor, bangle, MISSILERANGE);\n\n    for (i=0 ; i<3 ; i++)\n    {\n\tangle = bangle + (P_SubRandom() << 20);\n\tdamage = ((P_Random()%5)+1)*3;\n\tP_LineAttack (actor, angle, MISSILERANGE, slope, damage);\n    }\n}\n\nvoid A_CPosAttack (mobj_t* actor)\n{\n    int\t\tangle;\n    int\t\tbangle;\n    int\t\tdamage;\n    int\t\tslope;\n\t\n    if (!actor->target)\n\treturn;\n\n    S_StartSound (actor, sfx_shotgn);\n    A_FaceTarget (actor);\n    bangle = actor->angle;\n    slope = P_AimLineAttack (actor, bangle, MISSILERANGE);\n\n    angle = bangle + (P_SubRandom() << 20);\n    damage = ((P_Random()%5)+1)*3;\n    P_LineAttack (actor, angle, MISSILERANGE, slope, damage);\n}\n\nvoid A_CPosRefire (mobj_t* actor)\n{\t\n    // keep firing unless target got out of sight\n    A_FaceTarget (actor);\n\n    if (P_Random () < 40)\n\treturn;\n\n    if (!actor->target\n\t|| actor->target->health <= 0\n\t|| !P_CheckSight (actor, actor->target) )\n    {\n\tP_SetMobjState (actor, actor->info->seestate);\n    }\n}\n\n\nvoid A_SpidRefire (mobj_t* actor)\n{\t\n    // keep firing unless target got out of sight\n    A_FaceTarget (actor);\n\n    if (P_Random () < 10)\n\treturn;\n\n    if (!actor->target\n\t|| actor->target->health <= 0\n\t|| !P_CheckSight (actor, actor->target) )\n    {\n\tP_SetMobjState (actor, actor->info->seestate);\n    }\n}\n\nvoid A_BspiAttack (mobj_t *actor)\n{\t\n    if (!actor->target)\n\treturn;\n\t\t\n    A_FaceTarget (actor);\n\n    // launch a missile\n    P_SpawnMissile (actor, actor->target, MT_ARACHPLAZ);\n}\n\n\n//\n// A_TroopAttack\n//\nvoid A_TroopAttack (mobj_t* actor)\n{\n    int\t\tdamage;\n\t\n    if (!actor->target)\n\treturn;\n\t\t\n    A_FaceTarget (actor);\n    if (P_CheckMeleeRange (actor))\n    {\n\tS_StartSound (actor, sfx_claw);\n\tdamage = (P_Random()%8+1)*3;\n\tP_DamageMobj (actor->target, actor, actor, damage);\n\treturn;\n    }\n\n    \n    // launch a missile\n    P_SpawnMissile (actor, actor->target, MT_TROOPSHOT);\n}\n\n\nvoid A_SargAttack (mobj_t* actor)\n{\n    int\t\tdamage;\n\n    if (!actor->target)\n\treturn;\n\t\t\n    A_FaceTarget (actor);\n    if (P_CheckMeleeRange (actor))\n    {\n\tdamage = ((P_Random()%10)+1)*4;\n\tP_DamageMobj (actor->target, actor, actor, damage);\n    }\n}\n\nvoid A_HeadAttack (mobj_t* actor)\n{\n    int\t\tdamage;\n\t\n    if (!actor->target)\n\treturn;\n\t\t\n    A_FaceTarget (actor);\n    if (P_CheckMeleeRange (actor))\n    {\n\tdamage = (P_Random()%6+1)*10;\n\tP_DamageMobj (actor->target, actor, actor, damage);\n\treturn;\n    }\n    \n    // launch a missile\n    P_SpawnMissile (actor, actor->target, MT_HEADSHOT);\n}\n\nvoid A_CyberAttack (mobj_t* actor)\n{\t\n    if (!actor->target)\n\treturn;\n\t\t\n    A_FaceTarget (actor);\n    P_SpawnMissile (actor, actor->target, MT_ROCKET);\n}\n\n\nvoid A_BruisAttack (mobj_t* actor)\n{\n    int\t\tdamage;\n\t\n    if (!actor->target)\n\treturn;\n\t\t\n    if (P_CheckMeleeRange (actor))\n    {\n\tS_StartSound (actor, sfx_claw);\n\tdamage = (P_Random()%8+1)*10;\n\tP_DamageMobj (actor->target, actor, actor, damage);\n\treturn;\n    }\n    \n    // launch a missile\n    P_SpawnMissile (actor, actor->target, MT_BRUISERSHOT);\n}\n\n\n//\n// A_SkelMissile\n//\nvoid A_SkelMissile (mobj_t* actor)\n{\t\n    mobj_t*\tmo;\n\t\n    if (!actor->target)\n\treturn;\n\t\t\n    A_FaceTarget (actor);\n    actor->z += 16*FRACUNIT;\t// so missile spawns higher\n    mo = P_SpawnMissile (actor, actor->target, MT_TRACER);\n    actor->z -= 16*FRACUNIT;\t// back to normal\n\n    mo->x += mo->momx;\n    mo->y += mo->momy;\n    mo->tracer = actor->target;\n}\n\nint\tTRACEANGLE = 0xc000000;\n\nvoid A_Tracer (mobj_t* actor)\n{\n    angle_t\texact;\n    fixed_t\tdist;\n    fixed_t\tslope;\n    mobj_t*\tdest;\n    mobj_t*\tth;\n\t\t\n    if (gametic & 3)\n\treturn;\n    \n    // spawn a puff of smoke behind the rocket\t\t\n    P_SpawnPuff (actor->x, actor->y, actor->z);\n\t\n    th = P_SpawnMobj (actor->x-actor->momx,\n\t\t      actor->y-actor->momy,\n\t\t      actor->z, MT_SMOKE);\n    \n    th->momz = FRACUNIT;\n    th->tics -= P_Random()&3;\n    if (th->tics < 1)\n\tth->tics = 1;\n    \n    // adjust direction\n    dest = actor->tracer;\n\t\n    if (!dest || dest->health <= 0)\n\treturn;\n    \n    // change angle\t\n    exact = R_PointToAngle2 (actor->x,\n\t\t\t     actor->y,\n\t\t\t     dest->x,\n\t\t\t     dest->y);\n\n    if (exact != actor->angle)\n    {\n\tif (exact - actor->angle > 0x80000000)\n\t{\n\t    actor->angle -= TRACEANGLE;\n\t    if (exact - actor->angle < 0x80000000)\n\t\tactor->angle = exact;\n\t}\n\telse\n\t{\n\t    actor->angle += TRACEANGLE;\n\t    if (exact - actor->angle > 0x80000000)\n\t\tactor->angle = exact;\n\t}\n    }\n\t\n    exact = actor->angle>>ANGLETOFINESHIFT;\n    actor->momx = FixedMul (actor->info->speed, finecosine[exact]);\n    actor->momy = FixedMul (actor->info->speed, finesine[exact]);\n    \n    // change slope\n    dist = P_AproxDistance (dest->x - actor->x,\n\t\t\t    dest->y - actor->y);\n    \n    dist = dist / actor->info->speed;\n\n    if (dist < 1)\n\tdist = 1;\n    slope = (dest->z+40*FRACUNIT - actor->z) / dist;\n\n    if (slope < actor->momz)\n\tactor->momz -= FRACUNIT/8;\n    else\n\tactor->momz += FRACUNIT/8;\n}\n\n\nvoid A_SkelWhoosh (mobj_t*\tactor)\n{\n    if (!actor->target)\n\treturn;\n    A_FaceTarget (actor);\n    S_StartSound (actor,sfx_skeswg);\n}\n\nvoid A_SkelFist (mobj_t*\tactor)\n{\n    int\t\tdamage;\n\n    if (!actor->target)\n\treturn;\n\t\t\n    A_FaceTarget (actor);\n\t\n    if (P_CheckMeleeRange (actor))\n    {\n\tdamage = ((P_Random()%10)+1)*6;\n\tS_StartSound (actor, sfx_skepch);\n\tP_DamageMobj (actor->target, actor, actor, damage);\n    }\n}\n\n\n\n//\n// PIT_VileCheck\n// Detect a corpse that could be raised.\n//\nmobj_t*\t\tcorpsehit;\nmobj_t*\t\tvileobj;\nfixed_t\t\tviletryx;\nfixed_t\t\tviletryy;\n\nboolean PIT_VileCheck (mobj_t*\tthing)\n{\n    int\t\tmaxdist;\n    boolean\tcheck;\n\t\n    if (!(thing->flags & MF_CORPSE) )\n\treturn true;\t// not a monster\n    \n    if (thing->tics != -1)\n\treturn true;\t// not lying still yet\n    \n    if (thing->info->raisestate == S_NULL)\n\treturn true;\t// monster doesn't have a raise state\n    \n    maxdist = thing->info->radius + mobjinfo[MT_VILE].radius;\n\t\n    if ( abs(thing->x - viletryx) > maxdist\n\t || abs(thing->y - viletryy) > maxdist )\n\treturn true;\t\t// not actually touching\n\t\t\n    corpsehit = thing;\n    corpsehit->momx = corpsehit->momy = 0;\n    corpsehit->height <<= 2;\n    check = P_CheckPosition (corpsehit, corpsehit->x, corpsehit->y);\n    corpsehit->height >>= 2;\n\n    if (!check)\n\treturn true;\t\t// doesn't fit here\n\t\t\n    return false;\t\t// got one, so stop checking\n}\n\n\n\n//\n// A_VileChase\n// Check for ressurecting a body\n//\nvoid A_VileChase (mobj_t* actor)\n{\n    int\t\t\txl;\n    int\t\t\txh;\n    int\t\t\tyl;\n    int\t\t\tyh;\n    \n    int\t\t\tbx;\n    int\t\t\tby;\n\n    mobjinfo_t*\t\tinfo;\n    mobj_t*\t\ttemp;\n\t\n    if (actor->movedir != DI_NODIR)\n    {\n\t// check for corpses to raise\n\tviletryx =\n\t    actor->x + actor->info->speed*xspeed[actor->movedir];\n\tviletryy =\n\t    actor->y + actor->info->speed*yspeed[actor->movedir];\n\n\txl = (viletryx - bmaporgx - MAXRADIUS*2)>>MAPBLOCKSHIFT;\n\txh = (viletryx - bmaporgx + MAXRADIUS*2)>>MAPBLOCKSHIFT;\n\tyl = (viletryy - bmaporgy - MAXRADIUS*2)>>MAPBLOCKSHIFT;\n\tyh = (viletryy - bmaporgy + MAXRADIUS*2)>>MAPBLOCKSHIFT;\n\t\n\tvileobj = actor;\n\tfor (bx=xl ; bx<=xh ; bx++)\n\t{\n\t    for (by=yl ; by<=yh ; by++)\n\t    {\n\t\t// Call PIT_VileCheck to check\n\t\t// whether object is a corpse\n\t\t// that canbe raised.\n\t\tif (!P_BlockThingsIterator(bx,by,PIT_VileCheck))\n\t\t{\n\t\t    // got one!\n\t\t    temp = actor->target;\n\t\t    actor->target = corpsehit;\n\t\t    A_FaceTarget (actor);\n\t\t    actor->target = temp;\n\t\t\t\t\t\n\t\t    P_SetMobjState (actor, S_VILE_HEAL1);\n\t\t    S_StartSound (corpsehit, sfx_slop);\n\t\t    info = corpsehit->info;\n\t\t    \n\t\t    P_SetMobjState (corpsehit,info->raisestate);\n\t\t    corpsehit->height <<= 2;\n\t\t    corpsehit->flags = info->flags;\n\t\t    corpsehit->health = info->spawnhealth;\n\t\t    corpsehit->target = NULL;\n\n\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n\n    // Return to normal attack.\n    A_Chase (actor);\n}\n\n\n//\n// A_VileStart\n//\nvoid A_VileStart (mobj_t* actor)\n{\n    S_StartSound (actor, sfx_vilatk);\n}\n\n\n//\n// A_Fire\n// Keep fire in front of player unless out of sight\n//\nvoid A_Fire (mobj_t* actor);\n\nvoid A_StartFire (mobj_t* actor)\n{\n    S_StartSound(actor,sfx_flamst);\n    A_Fire(actor);\n}\n\nvoid A_FireCrackle (mobj_t* actor)\n{\n    S_StartSound(actor,sfx_flame);\n    A_Fire(actor);\n}\n\nvoid A_Fire (mobj_t* actor)\n{\n    mobj_t*\tdest;\n    mobj_t*     target;\n    unsigned\tan;\n\t\t\n    dest = actor->tracer;\n    if (!dest)\n\treturn;\n\n    target = P_SubstNullMobj(actor->target);\n\t\t\n    // don't move it if the vile lost sight\n    if (!P_CheckSight (target, dest) )\n\treturn;\n\n    an = dest->angle >> ANGLETOFINESHIFT;\n\n    P_UnsetThingPosition (actor);\n    actor->x = dest->x + FixedMul (24*FRACUNIT, finecosine[an]);\n    actor->y = dest->y + FixedMul (24*FRACUNIT, finesine[an]);\n    actor->z = dest->z;\n    P_SetThingPosition (actor);\n}\n\n\n\n//\n// A_VileTarget\n// Spawn the hellfire\n//\nvoid A_VileTarget (mobj_t*\tactor)\n{\n    mobj_t*\tfog;\n\t\n    if (!actor->target)\n\treturn;\n\n    A_FaceTarget (actor);\n\n    fog = P_SpawnMobj (actor->target->x,\n\t\t       actor->target->x,\n\t\t       actor->target->z, MT_FIRE);\n    \n    actor->tracer = fog;\n    fog->target = actor;\n    fog->tracer = actor->target;\n    A_Fire (fog);\n}\n\n\n\n\n//\n// A_VileAttack\n//\nvoid A_VileAttack (mobj_t* actor)\n{\t\n    mobj_t*\tfire;\n    int\t\tan;\n\t\n    if (!actor->target)\n\treturn;\n    \n    A_FaceTarget (actor);\n\n    if (!P_CheckSight (actor, actor->target) )\n\treturn;\n\n    S_StartSound (actor, sfx_barexp);\n    P_DamageMobj (actor->target, actor, actor, 20);\n    actor->target->momz = 1000*FRACUNIT/actor->target->info->mass;\n\t\n    an = actor->angle >> ANGLETOFINESHIFT;\n\n    fire = actor->tracer;\n\n    if (!fire)\n\treturn;\n\t\t\n    // move the fire between the vile and the player\n    fire->x = actor->target->x - FixedMul (24*FRACUNIT, finecosine[an]);\n    fire->y = actor->target->y - FixedMul (24*FRACUNIT, finesine[an]);\t\n    P_RadiusAttack (fire, actor, 70 );\n}\n\n\n\n\n//\n// Mancubus attack,\n// firing three missiles (bruisers)\n// in three different directions?\n// Doesn't look like it. \n//\n#define\tFATSPREAD\t(ANG90/8)\n\nvoid A_FatRaise (mobj_t *actor)\n{\n    A_FaceTarget (actor);\n    S_StartSound (actor, sfx_manatk);\n}\n\n\nvoid A_FatAttack1 (mobj_t* actor)\n{\n    mobj_t*\tmo;\n    mobj_t*     target;\n    int\t\tan;\n\n    A_FaceTarget (actor);\n\n    // Change direction  to ...\n    actor->angle += FATSPREAD;\n    target = P_SubstNullMobj(actor->target);\n    P_SpawnMissile (actor, target, MT_FATSHOT);\n\n    mo = P_SpawnMissile (actor, target, MT_FATSHOT);\n    mo->angle += FATSPREAD;\n    an = mo->angle >> ANGLETOFINESHIFT;\n    mo->momx = FixedMul (mo->info->speed, finecosine[an]);\n    mo->momy = FixedMul (mo->info->speed, finesine[an]);\n}\n\nvoid A_FatAttack2 (mobj_t* actor)\n{\n    mobj_t*\tmo;\n    mobj_t*     target;\n    int\t\tan;\n\n    A_FaceTarget (actor);\n    // Now here choose opposite deviation.\n    actor->angle -= FATSPREAD;\n    target = P_SubstNullMobj(actor->target);\n    P_SpawnMissile (actor, target, MT_FATSHOT);\n\n    mo = P_SpawnMissile (actor, target, MT_FATSHOT);\n    mo->angle -= FATSPREAD*2;\n    an = mo->angle >> ANGLETOFINESHIFT;\n    mo->momx = FixedMul (mo->info->speed, finecosine[an]);\n    mo->momy = FixedMul (mo->info->speed, finesine[an]);\n}\n\nvoid A_FatAttack3 (mobj_t*\tactor)\n{\n    mobj_t*\tmo;\n    mobj_t*     target;\n    int\t\tan;\n\n    A_FaceTarget (actor);\n\n    target = P_SubstNullMobj(actor->target);\n    \n    mo = P_SpawnMissile (actor, target, MT_FATSHOT);\n    mo->angle -= FATSPREAD/2;\n    an = mo->angle >> ANGLETOFINESHIFT;\n    mo->momx = FixedMul (mo->info->speed, finecosine[an]);\n    mo->momy = FixedMul (mo->info->speed, finesine[an]);\n\n    mo = P_SpawnMissile (actor, target, MT_FATSHOT);\n    mo->angle += FATSPREAD/2;\n    an = mo->angle >> ANGLETOFINESHIFT;\n    mo->momx = FixedMul (mo->info->speed, finecosine[an]);\n    mo->momy = FixedMul (mo->info->speed, finesine[an]);\n}\n\n\n//\n// SkullAttack\n// Fly at the player like a missile.\n//\n#define\tSKULLSPEED\t\t(20*FRACUNIT)\n\nvoid A_SkullAttack (mobj_t* actor)\n{\n    mobj_t*\t\tdest;\n    angle_t\t\tan;\n    int\t\t\tdist;\n\n    if (!actor->target)\n\treturn;\n\t\t\n    dest = actor->target;\t\n    actor->flags |= MF_SKULLFLY;\n\n    S_StartSound (actor, actor->info->attacksound);\n    A_FaceTarget (actor);\n    an = actor->angle >> ANGLETOFINESHIFT;\n    actor->momx = FixedMul (SKULLSPEED, finecosine[an]);\n    actor->momy = FixedMul (SKULLSPEED, finesine[an]);\n    dist = P_AproxDistance (dest->x - actor->x, dest->y - actor->y);\n    dist = dist / SKULLSPEED;\n    \n    if (dist < 1)\n\tdist = 1;\n    actor->momz = (dest->z+(dest->height>>1) - actor->z) / dist;\n}\n\n\n//\n// A_PainShootSkull\n// Spawn a lost soul and launch it at the target\n//\nvoid\nA_PainShootSkull\n( mobj_t*\tactor,\n  angle_t\tangle )\n{\n    fixed_t\tx;\n    fixed_t\ty;\n    fixed_t\tz;\n    \n    mobj_t*\tnewmobj;\n    angle_t\tan;\n    int\t\tprestep;\n    int\t\tcount;\n    thinker_t*\tcurrentthinker;\n\n    // count total number of skull currently on the level\n    count = 0;\n\n    currentthinker = thinkercap.next;\n    while (currentthinker != &thinkercap)\n    {\n\tif (   (currentthinker->function.acp1 == (actionf_p1)P_MobjThinker)\n\t    && ((mobj_t *)currentthinker)->type == MT_SKULL)\n\t    count++;\n\tcurrentthinker = currentthinker->next;\n    }\n\n    // if there are allready 20 skulls on the level,\n    // don't spit another one\n    if (count > 20)\n\treturn;\n\n\n    // okay, there's playe for another one\n    an = angle >> ANGLETOFINESHIFT;\n    \n    prestep =\n\t4*FRACUNIT\n\t+ 3*(actor->info->radius + mobjinfo[MT_SKULL].radius)/2;\n    \n    x = actor->x + FixedMul (prestep, finecosine[an]);\n    y = actor->y + FixedMul (prestep, finesine[an]);\n    z = actor->z + 8*FRACUNIT;\n\t\t\n    newmobj = P_SpawnMobj (x , y, z, MT_SKULL);\n\n    // Check for movements.\n    if (!P_TryMove (newmobj, newmobj->x, newmobj->y))\n    {\n\t// kill it immediately\n\tP_DamageMobj (newmobj,actor,actor,10000);\t\n\treturn;\n    }\n\t\t\n    newmobj->target = actor->target;\n    A_SkullAttack (newmobj);\n}\n\n\n//\n// A_PainAttack\n// Spawn a lost soul and launch it at the target\n// \nvoid A_PainAttack (mobj_t* actor)\n{\n    if (!actor->target)\n\treturn;\n\n    A_FaceTarget (actor);\n    A_PainShootSkull (actor, actor->angle);\n}\n\n\nvoid A_PainDie (mobj_t* actor)\n{\n    A_Fall (actor);\n    A_PainShootSkull (actor, actor->angle+ANG90);\n    A_PainShootSkull (actor, actor->angle+ANG180);\n    A_PainShootSkull (actor, actor->angle+ANG270);\n}\n\n\n\n\n\n\nvoid A_Scream (mobj_t* actor)\n{\n    int\t\tsound;\n\t\n    switch (actor->info->deathsound)\n    {\n      case 0:\n\treturn;\n\t\t\n      case sfx_podth1:\n      case sfx_podth2:\n      case sfx_podth3:\n\tsound = sfx_podth1 + P_Random ()%3;\n\tbreak;\n\t\t\n      case sfx_bgdth1:\n      case sfx_bgdth2:\n\tsound = sfx_bgdth1 + P_Random ()%2;\n\tbreak;\n\t\n      default:\n\tsound = actor->info->deathsound;\n\tbreak;\n    }\n\n    // Check for bosses.\n    if (actor->type==MT_SPIDER\n\t|| actor->type == MT_CYBORG)\n    {\n\t// full volume\n\tS_StartSound (NULL, sound);\n    }\n    else\n\tS_StartSound (actor, sound);\n}\n\n\nvoid A_XScream (mobj_t* actor)\n{\n    S_StartSound (actor, sfx_slop);\t\n}\n\nvoid A_Pain (mobj_t* actor)\n{\n    if (actor->info->painsound)\n\tS_StartSound (actor, actor->info->painsound);\t\n}\n\n\n\nvoid A_Fall (mobj_t *actor)\n{\n    // actor is on ground, it can be walked over\n    actor->flags &= ~MF_SOLID;\n\n    // So change this if corpse objects\n    // are meant to be obstacles.\n}\n\n\n//\n// A_Explode\n//\nvoid A_Explode (mobj_t* thingy)\n{\n    P_RadiusAttack(thingy, thingy->target, 128);\n}\n\n// Check whether the death of the specified monster type is allowed\n// to trigger the end of episode special action.\n//\n// This behavior changed in v1.9, the most notable effect of which\n// was to break uac_dead.wad\n\nstatic boolean CheckBossEnd(mobjtype_t motype)\n{\n    if (gameversion < exe_ultimate)\n    {\n        if (gamemap != 8)\n        {\n            return false;\n        }\n\n        // Baron death on later episodes is nothing special.\n\n        if (motype == MT_BRUISER && gameepisode != 1)\n        {\n            return false;\n        }\n\n        return true;\n    }\n    else\n    {\n        // New logic that appeared in Ultimate Doom.\n        // Looks like the logic was overhauled while adding in the\n        // episode 4 support.  Now bosses only trigger on their\n        // specific episode.\n\n\tswitch(gameepisode)\n\t{\n            case 1:\n                return gamemap == 8 && motype == MT_BRUISER;\n\n            case 2:\n                return gamemap == 8 && motype == MT_CYBORG;\n\n            case 3:\n                return gamemap == 8 && motype == MT_SPIDER;\n\n\t    case 4:\n                return (gamemap == 6 && motype == MT_CYBORG)\n                    || (gamemap == 8 && motype == MT_SPIDER);\n\n            default:\n                return gamemap == 8;\n\t}\n    }\n}\n\n//\n// A_BossDeath\n// Possibly trigger special effects\n// if on first boss level\n//\nvoid A_BossDeath (mobj_t* mo)\n{\n    thinker_t*\tth;\n    mobj_t*\tmo2;\n    line_t\tjunk;\n    int\t\ti;\n\t\t\n    if ( gamemode == commercial)\n    {\n\tif (gamemap != 7)\n\t    return;\n\t\t\n\tif ((mo->type != MT_FATSO)\n\t    && (mo->type != MT_BABY))\n\t    return;\n    }\n    else\n    {\n        if (!CheckBossEnd(mo->type))\n        {\n            return;\n        }\n    }\n\n    // make sure there is a player alive for victory\n    for (i=0 ; i<MAXPLAYERS ; i++)\n\tif (playeringame[i] && players[i].health > 0)\n\t    break;\n    \n    if (i==MAXPLAYERS)\n\treturn;\t// no one left alive, so do not end game\n    \n    // scan the remaining thinkers to see\n    // if all bosses are dead\n    for (th = thinkercap.next ; th != &thinkercap ; th=th->next)\n    {\n\tif (th->function.acp1 != (actionf_p1)P_MobjThinker)\n\t    continue;\n\t\n\tmo2 = (mobj_t *)th;\n\tif (mo2 != mo\n\t    && mo2->type == mo->type\n\t    && mo2->health > 0)\n\t{\n\t    // other boss not dead\n\t    return;\n\t}\n    }\n\t\n    // victory!\n    if ( gamemode == commercial)\n    {\n\tif (gamemap == 7)\n\t{\n\t    if (mo->type == MT_FATSO)\n\t    {\n\t\tjunk.tag = 666;\n\t\tEV_DoFloor(&junk,lowerFloorToLowest);\n\t\treturn;\n\t    }\n\t    \n\t    if (mo->type == MT_BABY)\n\t    {\n\t\tjunk.tag = 667;\n\t\tEV_DoFloor(&junk,raiseToTexture);\n\t\treturn;\n\t    }\n\t}\n    }\n    else\n    {\n\tswitch(gameepisode)\n\t{\n\t  case 1:\n\t    junk.tag = 666;\n\t    EV_DoFloor (&junk, lowerFloorToLowest);\n\t    return;\n\t    break;\n\t    \n\t  case 4:\n\t    switch(gamemap)\n\t    {\n\t      case 6:\n\t\tjunk.tag = 666;\n\t\tEV_DoDoor (&junk, blazeOpen);\n\t\treturn;\n\t\tbreak;\n\t\t\n\t      case 8:\n\t\tjunk.tag = 666;\n\t\tEV_DoFloor (&junk, lowerFloorToLowest);\n\t\treturn;\n\t\tbreak;\n\t    }\n\t}\n    }\n\t\n    G_ExitLevel ();\n}\n\n\nvoid A_Hoof (mobj_t* mo)\n{\n    S_StartSound (mo, sfx_hoof);\n    A_Chase (mo);\n}\n\nvoid A_Metal (mobj_t* mo)\n{\n    S_StartSound (mo, sfx_metal);\n    A_Chase (mo);\n}\n\nvoid A_BabyMetal (mobj_t* mo)\n{\n    S_StartSound (mo, sfx_bspwlk);\n    A_Chase (mo);\n}\n\nvoid\nA_OpenShotgun2\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\n    S_StartSound (player->mo, sfx_dbopn);\n}\n\nvoid\nA_LoadShotgun2\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\n    S_StartSound (player->mo, sfx_dbload);\n}\n\nvoid\nA_ReFire\n( player_t*\tplayer,\n  pspdef_t*\tpsp );\n\nvoid\nA_CloseShotgun2\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\n    S_StartSound (player->mo, sfx_dbcls);\n    A_ReFire(player,psp);\n}\n\n\n\nmobj_t*\t\tbraintargets[32];\nint\t\tnumbraintargets;\nint\t\tbraintargeton = 0;\n\nvoid A_BrainAwake (mobj_t* mo)\n{\n    thinker_t*\tthinker;\n    mobj_t*\tm;\n\t\n    // find all the target spots\n    numbraintargets = 0;\n    braintargeton = 0;\n\t\n    thinker = thinkercap.next;\n    for (thinker = thinkercap.next ;\n\t thinker != &thinkercap ;\n\t thinker = thinker->next)\n    {\n\tif (thinker->function.acp1 != (actionf_p1)P_MobjThinker)\n\t    continue;\t// not a mobj\n\n\tm = (mobj_t *)thinker;\n\n\tif (m->type == MT_BOSSTARGET )\n\t{\n\t    braintargets[numbraintargets] = m;\n\t    numbraintargets++;\n\t}\n    }\n\t\n    S_StartSound (NULL,sfx_bossit);\n}\n\n\nvoid A_BrainPain (mobj_t*\tmo)\n{\n    S_StartSound (NULL,sfx_bospn);\n}\n\n\nvoid A_BrainScream (mobj_t*\tmo)\n{\n    int\t\tx;\n    int\t\ty;\n    int\t\tz;\n    mobj_t*\tth;\n\t\n    for (x=mo->x - 196*FRACUNIT ; x< mo->x + 320*FRACUNIT ; x+= FRACUNIT*8)\n    {\n\ty = mo->y - 320*FRACUNIT;\n\tz = 128 + P_Random()*2*FRACUNIT;\n\tth = P_SpawnMobj (x,y,z, MT_ROCKET);\n\tth->momz = P_Random()*512;\n\n\tP_SetMobjState (th, S_BRAINEXPLODE1);\n\n\tth->tics -= P_Random()&7;\n\tif (th->tics < 1)\n\t    th->tics = 1;\n    }\n\t\n    S_StartSound (NULL,sfx_bosdth);\n}\n\n\n\nvoid A_BrainExplode (mobj_t* mo)\n{\n    int\t\tx;\n    int\t\ty;\n    int\t\tz;\n    mobj_t*\tth;\n\t\n    x = mo->x +  P_SubRandom() * 2048;\n    y = mo->y;\n    z = 128 + P_Random()*2*FRACUNIT;\n    th = P_SpawnMobj (x,y,z, MT_ROCKET);\n    th->momz = P_Random()*512;\n\n    P_SetMobjState (th, S_BRAINEXPLODE1);\n\n    th->tics -= P_Random()&7;\n    if (th->tics < 1)\n\tth->tics = 1;\n}\n\n\nvoid A_BrainDie (mobj_t*\tmo)\n{\n    G_ExitLevel ();\n}\n\nvoid A_BrainSpit (mobj_t*\tmo)\n{\n    mobj_t*\ttarg;\n    mobj_t*\tnewmobj;\n    \n    static int\teasy = 0;\n\t\n    easy ^= 1;\n    if (gameskill <= sk_easy && (!easy))\n\treturn;\n\t\t\n    // shoot a cube at current target\n    targ = braintargets[braintargeton];\n    braintargeton = (braintargeton+1)%numbraintargets;\n\n    // spawn brain missile\n    newmobj = P_SpawnMissile (mo, targ, MT_SPAWNSHOT);\n    newmobj->target = targ;\n    newmobj->reactiontime =\n\t((targ->y - mo->y)/newmobj->momy) / newmobj->state->tics;\n\n    S_StartSound(NULL, sfx_bospit);\n}\n\n\n\nvoid A_SpawnFly (mobj_t* mo);\n\n// travelling cube sound\nvoid A_SpawnSound (mobj_t* mo)\t\n{\n    S_StartSound (mo,sfx_boscub);\n    A_SpawnFly(mo);\n}\n\nvoid A_SpawnFly (mobj_t* mo)\n{\n    mobj_t*\tnewmobj;\n    mobj_t*\tfog;\n    mobj_t*\ttarg;\n    int\t\tr;\n    mobjtype_t\ttype;\n\t\n    if (--mo->reactiontime)\n\treturn;\t// still flying\n\t\n    targ = P_SubstNullMobj(mo->target);\n\n    // First spawn teleport fog.\n    fog = P_SpawnMobj (targ->x, targ->y, targ->z, MT_SPAWNFIRE);\n    S_StartSound (fog, sfx_telept);\n\n    // Randomly select monster to spawn.\n    r = P_Random ();\n\n    // Probability distribution (kind of :),\n    // decreasing likelihood.\n    if ( r<50 )\n\ttype = MT_TROOP;\n    else if (r<90)\n\ttype = MT_SERGEANT;\n    else if (r<120)\n\ttype = MT_SHADOWS;\n    else if (r<130)\n\ttype = MT_PAIN;\n    else if (r<160)\n\ttype = MT_HEAD;\n    else if (r<162)\n\ttype = MT_VILE;\n    else if (r<172)\n\ttype = MT_UNDEAD;\n    else if (r<192)\n\ttype = MT_BABY;\n    else if (r<222)\n\ttype = MT_FATSO;\n    else if (r<246)\n\ttype = MT_KNIGHT;\n    else\n\ttype = MT_BRUISER;\t\t\n\n    newmobj\t= P_SpawnMobj (targ->x, targ->y, targ->z, type);\n    if (P_LookForPlayers (newmobj, true) )\n\tP_SetMobjState (newmobj, newmobj->info->seestate);\n\t\n    // telefrag anything in this spot\n    P_TeleportMove (newmobj, newmobj->x, newmobj->y);\n\n    // remove self (i.e., cube).\n    P_RemoveMobj (mo);\n}\n\n\n\nvoid A_PlayerScream (mobj_t* mo)\n{\n    // Default death sound.\n    int\t\tsound = sfx_pldeth;\n\t\n    if ( (gamemode == commercial)\n\t&& \t(mo->health < -50))\n    {\n\t// IF THE PLAYER DIES\n\t// LESS THAN -50% WITHOUT GIBBING\n\tsound = sfx_pdiehi;\n    }\n    \n    S_StartSound (mo, sound);\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n// Copyright(C) 2015-2018 Fabian Greffrath\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\t[crispy] support maps with NODES in compressed or uncompressed ZDBSP\n// \tformat or DeePBSP format and/or LINEDEFS and THINGS lumps in Hexen format\n//\n\n#include \"m_bbox.h\"\n#include \"p_local.h\"\n#include \"i_swap.h\"\n#include \"i_system.h\"\n#include \"w_wad.h\"\n#include \"z_zone.h\"\n\n// [crispy] support maps with compressed ZDBSP nodes\n#include \"config.h\"\n#ifdef HAVE_LIBZ\n#include <zlib.h>\n#endif\n\n#include \"p_extnodes.h\"\n\nvoid P_SpawnMapThing (mapthing_t*    mthing);\nfixed_t GetOffset(vertex_t *v1, vertex_t *v2);\nsector_t* GetSectorAtNullAddress(void);\n\n// [crispy] support maps with NODES in compressed or uncompressed ZDBSP\n// format or DeePBSP format and/or LINEDEFS and THINGS lumps in Hexen format\nmapformat_t P_CheckMapFormat (int lumpnum)\n{\n    mapformat_t format = 0;\n    byte *nodes = NULL;\n    int b;\n\n    if ((b = lumpnum+ML_BLOCKMAP+1) < numlumps &&\n        !strncasecmp(lumpinfo[b]->name, \"BEHAVIOR\", 8))\n    {\n\tformat |= MFMT_HEXEN;\n    }\n\n    if (!((b = lumpnum+ML_NODES) < numlumps &&\n        (nodes = W_CacheLumpNum(b, PU_CACHE)) &&\n        W_LumpLength(b) > 0));\n    else\n    if (!memcmp(nodes, \"xNd4\\0\\0\\0\\0\", 8))\n    {\n\tformat |= MFMT_DEEPBSP;\n    }\n    else\n    if (!memcmp(nodes, \"XNOD\", 4))\n    {\n\tformat |= MFMT_ZDBSPX;\n    }\n    else\n    if (!memcmp(nodes, \"ZNOD\", 4))\n    {\n\tformat |= MFMT_ZDBSPZ;\n    }\n\n    if (nodes)\n\tW_ReleaseLumpNum(b);\n\n    return format;\n}\n\n// [crispy] support maps with DeePBSP nodes\n// adapted from prboom-plus/src/p_setup.c:633-752\nvoid P_LoadSegs_DeePBSP (int lump)\n{\n    int i;\n    mapseg_deepbsp_t *data;\n\n    numsegs = W_LumpLength(lump) / sizeof(mapseg_deepbsp_t);\n    segs = Z_Malloc(numsegs * sizeof(seg_t), PU_LEVEL, 0);\n    data = (mapseg_deepbsp_t *)W_CacheLumpNum(lump, PU_STATIC);\n\n    for (i = 0; i < numsegs; i++)\n    {\n\tseg_t *li = segs + i;\n\tmapseg_deepbsp_t *ml = data + i;\n\tint side, linedef;\n\tline_t *ldef;\n\n\tli->v1 = &vertexes[ml->v1];\n\tli->v2 = &vertexes[ml->v2];\n\n\tli->angle = (SHORT(ml->angle))<<FRACBITS;\n\n\tlinedef = (unsigned short)SHORT(ml->linedef);\n\tldef = &lines[linedef];\n\tli->linedef = ldef;\n\tside = SHORT(ml->side);\n\n        // e6y: check for wrong indexes\n        if ((unsigned)ldef->sidenum[side] >= (unsigned)numsides)\n        {\n            I_Error(\"P_LoadSegs: linedef %d for seg %d references a non-existent sidedef %d\",\n                    linedef, i, (unsigned)ldef->sidenum[side]);\n        }\n\n\tli->sidedef = &sides[ldef->sidenum[side]];\n\tli->frontsector = sides[ldef->sidenum[side]].sector;\n\tli->offset = GetOffset(li->v1, ((ml->side ^ 0) ? ldef->v2 : ldef->v1));\n\n\tif (ldef->flags & ML_TWOSIDED)\n\t{\n\t    int sidenum = ldef->sidenum[side ^ 1];\n\n\t    if (sidenum < 0 || sidenum >= numsides)\n\t    {\n\t\tif (li->sidedef->midtexture)\n\t\t{\n\t\t    li->backsector = 0;\n\t\t    fprintf(stderr, \"P_LoadSegs: Linedef %d has two-sided flag set, but no second sidedef\\n\", i);\n\t\t}\n\t\telse\n\t\t    li->backsector = GetSectorAtNullAddress();\n\t    }\n\t    else\n\t\tli->backsector = sides[sidenum].sector;\n\t}\n\telse\n\t    li->backsector = 0;\n    }\n\n    W_ReleaseLumpNum(lump);\n}\n\n// [crispy] support maps with DeePBSP nodes\n// adapted from prboom-plus/src/p_setup.c:843-863\nvoid P_LoadSubsectors_DeePBSP (int lump)\n{\n    mapsubsector_deepbsp_t *data;\n    int i;\n\n    numsubsectors = W_LumpLength(lump) / sizeof(mapsubsector_deepbsp_t);\n    subsectors = Z_Malloc(numsubsectors * sizeof(subsector_t), PU_LEVEL, 0);\n    data = (mapsubsector_deepbsp_t *)W_CacheLumpNum(lump, PU_STATIC);\n\n    // [crispy] fail on missing subsectors\n    if (!data || !numsubsectors)\n\tI_Error(\"P_LoadSubsectors: No subsectors in map!\");\n\n    for (i = 0; i < numsubsectors; i++)\n    {\n\tsubsectors[i].numlines = (int)data[i].numsegs;\n\tsubsectors[i].firstline = (int)data[i].firstseg;\n    }\n\n    W_ReleaseLumpNum(lump);\n}\n// [crispy] support maps with DeePBSP nodes\n// adapted from prboom-plus/src/p_setup.c:995-1038\nvoid P_LoadNodes_DeePBSP (int lump)\n{\n    const byte *data;\n    int i;\n\n    numnodes = (W_LumpLength (lump) - 8) / sizeof(mapnode_deepbsp_t);\n    nodes = Z_Malloc(numnodes * sizeof(node_t), PU_LEVEL, 0);\n    data = W_CacheLumpNum (lump, PU_STATIC);\n\n    // [crispy] warn about missing nodes\n    if (!data || !numnodes)\n    {\n\tif (numsubsectors == 1)\n\t    fprintf(stderr, \"P_LoadNodes: No nodes in map, but only one subsector.\\n\");\n\telse\n\t    I_Error(\"P_LoadNodes: No nodes in map!\");\n    }\n\n    // skip header\n    data += 8;\n\n    for (i = 0; i < numnodes; i++)\n    {\n\tnode_t *no = nodes + i;\n\tconst mapnode_deepbsp_t *mn = (const mapnode_deepbsp_t *) data + i;\n\tint j;\n\n\tno->x = SHORT(mn->x)<<FRACBITS;\n\tno->y = SHORT(mn->y)<<FRACBITS;\n\tno->dx = SHORT(mn->dx)<<FRACBITS;\n\tno->dy = SHORT(mn->dy)<<FRACBITS;\n\n\tfor (j = 0; j < 2; j++)\n\t{\n\t    int k;\n\t    no->children[j] = (unsigned int)(mn->children[j]);\n\n\t    for (k = 0; k < 4; k++)\n\t\tno->bbox[j][k] = SHORT(mn->bbox[j][k])<<FRACBITS;\n\t}\n    }\n\n  W_ReleaseLumpNum(lump);\n}\n\n// [crispy] support maps with compressed or uncompressed ZDBSP nodes\n// adapted from prboom-plus/src/p_setup.c:1040-1331\n// heavily modified, condensed and simplyfied\n// - removed most paranoid checks, brought in line with Vanilla P_LoadNodes()\n// - removed const type punning pointers\n// - inlined P_LoadZSegs()\n// - added support for compressed ZDBSP nodes\n// - added support for flipped levels\nvoid P_LoadNodes_ZDBSP (int lump, boolean compressed)\n{\n    byte *data;\n    unsigned int i;\n#ifdef HAVE_LIBZ\n    byte *output;\n#endif\n\n    unsigned int orgVerts, newVerts;\n    unsigned int numSubs, currSeg;\n    unsigned int numSegs;\n    unsigned int numNodes;\n    vertex_t *newvertarray = NULL;\n\n    data = W_CacheLumpNum(lump, PU_LEVEL);\n\n    // 0. Uncompress nodes lump (or simply skip header)\n\n    if (compressed)\n    {\n#ifdef HAVE_LIBZ\n\tconst int len =  W_LumpLength(lump);\n\tint outlen, err;\n\tz_stream *zstream;\n\n\t// first estimate for compression rate:\n\t// output buffer size == 2.5 * input size\n\toutlen = 2.5 * len;\n\toutput = Z_Malloc(outlen, PU_STATIC, 0);\n\n\t// initialize stream state for decompression\n\tzstream = malloc(sizeof(*zstream));\n\tmemset(zstream, 0, sizeof(*zstream));\n\tzstream->next_in = data + 4;\n\tzstream->avail_in = len - 4;\n\tzstream->next_out = output;\n\tzstream->avail_out = outlen;\n\n\tif (inflateInit(zstream) != Z_OK)\n\t    I_Error(\"P_LoadNodes: Error during ZDBSP nodes decompression initialization!\");\n\n\t// resize if output buffer runs full\n\twhile ((err = inflate(zstream, Z_SYNC_FLUSH)) == Z_OK)\n\t{\n\t    int outlen_old = outlen;\n\t    outlen = 2 * outlen_old;\n\t    output = I_Realloc(output, outlen);\n\t    zstream->next_out = output + outlen_old;\n\t    zstream->avail_out = outlen - outlen_old;\n\t}\n\n\tif (err != Z_STREAM_END)\n\t    I_Error(\"P_LoadNodes: Error during ZDBSP nodes decompression!\");\n\n\tfprintf(stderr, \"P_LoadNodes: ZDBSP nodes compression ratio %.3f\\n\",\n\t        (float)zstream->total_out/zstream->total_in);\n\n\tdata = output;\n\n\tif (inflateEnd(zstream) != Z_OK)\n\t    I_Error(\"P_LoadNodes: Error during ZDBSP nodes decompression shut-down!\");\n\n\t// release the original data lump\n\tW_ReleaseLumpNum(lump);\n\tfree(zstream);\n#else\n\tI_Error(\"P_LoadNodes: Compressed ZDBSP nodes are not supported!\");\n#endif\n    }\n    else\n    {\n\t// skip header\n\tdata += 4;\n    }\n\n    // 1. Load new vertices added during node building\n\n    orgVerts = *((unsigned int*)data);\n    data += sizeof(orgVerts);\n\n    newVerts = *((unsigned int*)data);\n    data += sizeof(newVerts);\n\n    if (orgVerts + newVerts == (unsigned int)numvertexes)\n    {\n\tnewvertarray = vertexes;\n    }\n    else\n    {\n\tnewvertarray = Z_Malloc((orgVerts + newVerts) * sizeof(vertex_t), PU_LEVEL, 0);\n\tmemcpy(newvertarray, vertexes, orgVerts * sizeof(vertex_t));\n\tmemset(newvertarray + orgVerts, 0, newVerts * sizeof(vertex_t));\n    }\n\n    for (i = 0; i < newVerts; i++)\n    {\n\tnewvertarray[i + orgVerts].r_x =\n\tnewvertarray[i + orgVerts].x = *((unsigned int*)data);\n\tdata += sizeof(newvertarray[0].x);\n\n\t// if (crispy->fliplevels)\n\t// {\n\t//     newvertarray[i + orgVerts].r_x =\n\t//     newvertarray[i + orgVerts].x = -newvertarray[i + orgVerts].x;\n\t// }\n\n\tnewvertarray[i + orgVerts].r_y =\n\tnewvertarray[i + orgVerts].y = *((unsigned int*)data);\n\tdata += sizeof(newvertarray[0].y);\n    }\n\n    if (vertexes != newvertarray)\n    {\n\tfor (i = 0; i < (unsigned int)numlines; i++)\n\t{\n\t    lines[i].v1 = lines[i].v1 - vertexes + newvertarray;\n\t    lines[i].v2 = lines[i].v2 - vertexes + newvertarray;\n\t}\n\n\tZ_Free(vertexes);\n\tvertexes = newvertarray;\n\tnumvertexes = orgVerts + newVerts;\n    }\n\n    // 2. Load subsectors\n\n    numSubs = *((unsigned int*)data);\n    data += sizeof(numSubs);\n\n    if (numSubs < 1)\n\tI_Error(\"P_LoadNodes: No subsectors in map!\");\n\n    numsubsectors = numSubs;\n    subsectors = Z_Malloc(numsubsectors * sizeof(subsector_t), PU_LEVEL, 0);\n\n    for (i = currSeg = 0; i < numsubsectors; i++)\n    {\n\tmapsubsector_zdbsp_t *mseg = (mapsubsector_zdbsp_t*) data + i;\n\n\tsubsectors[i].firstline = currSeg;\n\tsubsectors[i].numlines = mseg->numsegs;\n\tcurrSeg += mseg->numsegs;\n    }\n\n    data += numsubsectors * sizeof(mapsubsector_zdbsp_t);\n\n    // 3. Load segs\n\n    numSegs = *((unsigned int*)data);\n    data += sizeof(numSegs);\n\n    // The number of stored segs should match the number of segs used by subsectors\n    if (numSegs != currSeg)\n    {\n\tI_Error(\"P_LoadNodes: Incorrect number of segs in ZDBSP nodes!\");\n    }\n\n    numsegs = numSegs;\n    segs = Z_Malloc(numsegs * sizeof(seg_t), PU_LEVEL, 0);\n\n    for (i = 0; i < numsegs; i++)\n    {\n\tline_t *ldef;\n\tunsigned int linedef;\n\tunsigned char side;\n\tseg_t *li = segs + i;\n\tmapseg_zdbsp_t *ml = (mapseg_zdbsp_t *) data + i;\n\n\tli->v1 = &vertexes[ml->v1];\n\tli->v2 = &vertexes[ml->v2];\n\n\tlinedef = (unsigned short)SHORT(ml->linedef);\n\tldef = &lines[linedef];\n\tli->linedef = ldef;\n\tside = ml->side;\n\n        // e6y: check for wrong indexes\n        if ((unsigned)ldef->sidenum[side] >= (unsigned)numsides)\n        {\n            I_Error(\"P_LoadSegs: linedef %d for seg %d references a non-existent sidedef %d\",\n                    linedef, i, (unsigned)ldef->sidenum[side]);\n        }\n\n\tli->sidedef = &sides[ldef->sidenum[side]];\n\tli->frontsector = sides[ldef->sidenum[side]].sector;\n\n\t// seg angle and offset are not included\n\tli->angle = R_PointToAngle2(segs[i].v1->x, segs[i].v1->y, segs[i].v2->x, segs[i].v2->y);\n\tli->offset = GetOffset(li->v1, (ml->side ? ldef->v2 : ldef->v1));\n\n\tif (ldef->flags & ML_TWOSIDED)\n\t{\n\t    int sidenum = ldef->sidenum[side ^ 1];\n\n\t    if (sidenum < 0 || sidenum >= numsides)\n\t    {\n\t\tif (li->sidedef->midtexture)\n\t\t{\n\t\t    li->backsector = 0;\n\t\t    fprintf(stderr, \"P_LoadSegs: Linedef %u has two-sided flag set, but no second sidedef\\n\", i);\n\t\t}\n\t\telse\n\t\t    li->backsector = GetSectorAtNullAddress();\n\t    }\n\t    else\n\t\tli->backsector = sides[sidenum].sector;\n\t}\n\telse\n\t    li->backsector = 0;\n    }\n\n    data += numsegs * sizeof(mapseg_zdbsp_t);\n\n    // 4. Load nodes\n\n    numNodes = *((unsigned int*)data);\n    data += sizeof(numNodes);\n\n    numnodes = numNodes;\n    nodes = Z_Malloc(numnodes * sizeof(node_t), PU_LEVEL, 0);\n\n    for (i = 0; i < numnodes; i++)\n    {\n\tint j, k;\n\tnode_t *no = nodes + i;\n\tmapnode_zdbsp_t *mn = (mapnode_zdbsp_t *) data + i;\n\n\tno->x = SHORT(mn->x)<<FRACBITS;\n\tno->y = SHORT(mn->y)<<FRACBITS;\n\tno->dx = SHORT(mn->dx)<<FRACBITS;\n\tno->dy = SHORT(mn->dy)<<FRACBITS;\n\n\tfor (j = 0; j < 2; j++)\n\t{\n\t    no->children[j] = (unsigned int)(mn->children[j]);\n\n\t    for (k = 0; k < 4; k++)\n\t\tno->bbox[j][k] = SHORT(mn->bbox[j][k])<<FRACBITS;\n\t}\n    }\n\n#ifdef HAVE_LIBZ\n    if (compressed)\n\tZ_Free(output);\n    else\n#endif\n    W_ReleaseLumpNum(lump);\n}\n\n// [crispy] allow loading of Hexen-format maps\n// adapted from chocolate-doom/src/hexen/p_setup.c:348-400\nvoid P_LoadThings_Hexen (int lump)\n{\n    byte *data;\n    int i;\n    mapthing_t spawnthing;\n    mapthing_hexen_t *mt;\n    int numthings;\n\n    data = W_CacheLumpNum(lump, PU_STATIC);\n    numthings = W_LumpLength(lump) / sizeof(mapthing_hexen_t);\n\n    mt = (mapthing_hexen_t *) data;\n    for (i = 0; i < numthings; i++, mt++)\n    {\n\tspawnthing.x = SHORT(mt->x);\n\tspawnthing.y = SHORT(mt->y);\n\tspawnthing.angle = SHORT(mt->angle);\n\tspawnthing.type = SHORT(mt->type);\n\tspawnthing.options = SHORT(mt->options);\n\n\tP_SpawnMapThing(&spawnthing);\n    }\n\n    W_ReleaseLumpNum(lump);\n}\n\n// [crispy] allow loading of Hexen-format maps\n// adapted from chocolate-doom/src/hexen/p_setup.c:410-490\nvoid P_LoadLineDefs_Hexen (int lump)\n{\n    byte *data;\n    int i;\n    maplinedef_hexen_t *mld;\n    line_t *ld;\n    vertex_t *v1, *v2;\n    int warn; // [crispy] warn about unknown linedef types\n\n    numlines = W_LumpLength(lump) / sizeof(maplinedef_hexen_t);\n    lines = Z_Malloc(numlines * sizeof(line_t), PU_LEVEL, 0);\n    memset(lines, 0, numlines * sizeof(line_t));\n    data = W_CacheLumpNum(lump, PU_STATIC);\n\n    mld = (maplinedef_hexen_t *) data;\n    ld = lines;\n    warn = 0; // [crispy] warn about unknown linedef types\n    for (i = 0; i < numlines; i++, mld++, ld++)\n    {\n\tld->flags = (unsigned short)SHORT(mld->flags);\n\n\tld->special = mld->special;\n\n\t// [crispy] warn about unknown linedef types\n\tif ((unsigned short) ld->special > 141)\n\t{\n\t    fprintf(stderr, \"P_LoadLineDefs: Unknown special %d at line %d\\n\", ld->special, i);\n\t    warn++;\n\t}\n\n\tv1 = ld->v1 = &vertexes[(unsigned short)SHORT(mld->v1)];\n\tv2 = ld->v2 = &vertexes[(unsigned short)SHORT(mld->v2)];\n\tld->dx = v2->x - v1->x;\n\tld->dy = v2->y - v1->y;\n\tif (!ld->dx)\n\t    ld->slopetype = ST_VERTICAL;\n\telse if (!ld->dy)\n\t    ld->slopetype = ST_HORIZONTAL;\n\telse\n\t{\n\t    if (FixedDiv(ld->dy, ld->dx) > 0)\n\t\tld->slopetype = ST_POSITIVE;\n\t    else\n\t\tld->slopetype = ST_NEGATIVE;\n\t}\n\n\tif (v1->x < v2->x)\n\t{\n\t    ld->bbox[BOXLEFT] = v1->x;\n\t    ld->bbox[BOXRIGHT] = v2->x;\n\t}\n\telse\n\t{\n\t    ld->bbox[BOXLEFT] = v2->x;\n\t    ld->bbox[BOXRIGHT] = v1->x;\n\t}\n\tif (v1->y < v2->y)\n\t{\n\t    ld->bbox[BOXBOTTOM] = v1->y;\n\t    ld->bbox[BOXTOP] = v2->y;\n\t}\n\telse\n\t{\n\t    ld->bbox[BOXBOTTOM] = v2->y;\n\t    ld->bbox[BOXTOP] = v1->y;\n\t}\n\n\t// [crispy] calculate sound origin of line to be its midpoint\n\tld->soundorg.x = ld->bbox[BOXLEFT] / 2 + ld->bbox[BOXRIGHT] / 2;\n\tld->soundorg.y = ld->bbox[BOXTOP] / 2 + ld->bbox[BOXBOTTOM] / 2;\n\n\tld->sidenum[0] = SHORT(mld->sidenum[0]);\n\tld->sidenum[1] = SHORT(mld->sidenum[1]);\n\n\t// [crispy] substitute dummy sidedef for missing right side\n\tif (ld->sidenum[0] == NO_INDEX)\n\t{\n\t    ld->sidenum[0] = 0;\n\t    fprintf(stderr, \"P_LoadLineDefs: linedef %d without first sidedef!\\n\", i);\n\t}\n\n\tif (ld->sidenum[0] != NO_INDEX)\n\t    ld->frontsector = sides[ld->sidenum[0]].sector;\n\telse\n\t    ld->frontsector = 0;\n\tif (ld->sidenum[1] != NO_INDEX)\n\t    ld->backsector = sides[ld->sidenum[1]].sector;\n\telse\n\t    ld->backsector = 0;\n    }\n\n    // [crispy] warn about unknown linedef types\n    if (warn)\n    {\n\tfprintf(stderr, \"P_LoadLineDefs: Found %d line%s with unknown linedef type.\\n\"\n\t                \"THIS MAP MAY NOT WORK AS EXPECTED!\\n\", warn, (warn > 1) ? \"s\" : \"\");\n    }\n\n    W_ReleaseLumpNum(lump);\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tDOOM selection menu, options, episode etc.\n//\tSliders and icons. Kinda widget stuff.\n//\n\n\n#include <stdlib.h>\n#include <ctype.h>\n\n\n#include \"doomdef.h\"\n#include \"doomkeys.h\"\n#include \"dstrings.h\"\n\n#include \"d_main.h\"\n#include \"deh_main.h\"\n\n#include \"i_input.h\"\n#include \"i_swap.h\"\n#include \"i_system.h\"\n#include \"i_timer.h\"\n#include \"i_video.h\"\n#include \"m_misc.h\"\n#include \"v_video.h\"\n#include \"w_wad.h\"\n#include \"z_zone.h\"\n\n#include \"r_local.h\"\n\n\n#include \"hu_stuff.h\"\n\n#include \"g_game.h\"\n\n#include \"m_argv.h\"\n#include \"m_controls.h\"\n#include \"p_saveg.h\"\n\n#include \"s_sound.h\"\n\n#include \"doomstat.h\"\n\n// Data.\n#include \"sounds.h\"\n\n#include \"m_menu.h\"\n\n#include <emscripten.h>\n#include <time.h>\n\nextern patch_t*\t\thu_font[HU_FONTSIZE];\nextern boolean\t\tmessage_dontfuckwithme;\n\nextern boolean\t\tchat_on;\t\t// in heads-up code\n\n//\n// defaulted values\n//\nint\t\t\tmouseSensitivity = 5;\n\n// Show messages has default, 0 = off, 1 = on\nint\t\t\tshowMessages = 1;\n\t\n\n// Blocky mode, has default, 0 = high, 1 = normal\nint\t\t\tdetailLevel = 0;\nint\t\t\tscreenblocks = 10;\n\n// temp for screenblocks (0-9)\nint\t\t\tscreenSize;\n\n// -1 = no quicksave slot picked!\nint\t\t\tquickSaveSlot;\n\n // 1 = message to be printed\nint\t\t\tmessageToPrint;\n// ...and here is the message string!\nconst char\t\t*messageString;\n\n// message x & y\nint\t\t\tmessx;\nint\t\t\tmessy;\nint\t\t\tmessageLastMenuActive;\n\n// timed message = no input from user\nboolean\t\t\tmessageNeedsInput;\n\nvoid    (*messageRoutine)(int response);\n\nchar gammamsg[5][26] =\n{\n    GAMMALVL0,\n    GAMMALVL1,\n    GAMMALVL2,\n    GAMMALVL3,\n    GAMMALVL4\n};\n\n// we are going to be entering a savegame string\nint\t\t\tsaveStringEnter;              \nint             \tsaveSlot;\t// which slot to save in\nint\t\t\tsaveCharIndex;\t// which char we're editing\nstatic boolean          joypadSave = false; // was the save action initiated by joypad?\n// old save description before edit\nchar\t\t\tsaveOldString[SAVESTRINGSIZE];  \n\nboolean\t\t\tinhelpscreens;\nboolean\t\t\tmenuactive;\n\n#define SKULLXOFF\t\t-32\n#define LINEHEIGHT\t\t16\n\nextern boolean\t\tsendpause;\nchar\t\t\tsavegamestrings[10][SAVESTRINGSIZE];\n\nchar\tendstring[160];\n\nstatic boolean opldev;\n\n//\n// MENU TYPEDEFS\n//\ntypedef struct\n{\n    // 0 = no cursor here, 1 = ok, 2 = arrows ok\n    short\tstatus;\n    \n    char\tname[10];\n    \n    // choice = menu item #.\n    // if status = 2,\n    //   choice=0:leftarrow,1:rightarrow\n    void\t(*routine)(int choice);\n    \n    // hotkey in menu\n    char\talphaKey;\t\t\t\n} menuitem_t;\n\n\n\ntypedef struct menu_s\n{\n    short\t\tnumitems;\t// # of menu items\n    struct menu_s*\tprevMenu;\t// previous menu\n    menuitem_t*\t\tmenuitems;\t// menu items\n    void\t\t(*routine)();\t// draw routine\n    short\t\tx;\n    short\t\ty;\t\t// x,y of menu\n    short\t\tlastOn;\t\t// last item user was on in menu\n} menu_t;\n\nshort\t\titemOn;\t\t\t// menu item skull is on\nshort\t\tskullAnimCounter;\t// skull animation counter\nshort\t\twhichSkull;\t\t// which skull to draw\n\n// graphic name of skulls\n// warning: initializer-string for array of chars is too long\nchar    *skullName[2] = {\"M_SKULL1\",\"M_SKULL2\"};\n\n// current menudef\nmenu_t*\tcurrentMenu;                          \n\n//\n// PROTOTYPES\n//\nstatic void M_NewGame(int choice);\nstatic void M_Episode(int choice);\nstatic void M_ChooseSkill(int choice);\nstatic void M_LoadGame(int choice);\nstatic void M_SaveGame(int choice);\nstatic void M_Options(int choice);\nstatic void M_EndGame(int choice);\nstatic void M_ReadThis(int choice);\nstatic void M_ReadThis2(int choice);\nstatic void M_QuitDOOM(int choice);\n\nstatic void M_ChangeMessages(int choice);\nstatic void M_ChangeSensitivity(int choice);\nstatic void M_SfxVol(int choice);\nstatic void M_MusicVol(int choice);\nstatic void M_ChangeDetail(int choice);\nstatic void M_SizeDisplay(int choice);\nstatic void M_Sound(int choice);\n\nstatic void M_FinishReadThis(int choice);\nstatic void M_LoadSelect(int choice);\nstatic void M_SaveSelect(int choice);\nstatic void M_ReadSaveStrings(void);\nstatic void M_QuickSave(void);\nstatic void M_QuickLoad(void);\n\nstatic void M_DrawMainMenu(void);\nstatic void M_DrawReadThis1(void);\nstatic void M_DrawReadThis2(void);\nstatic void M_DrawNewGame(void);\nstatic void M_DrawEpisode(void);\nstatic void M_DrawOptions(void);\nstatic void M_DrawSound(void);\nstatic void M_DrawLoad(void);\nstatic void M_DrawSave(void);\n\nstatic void M_DrawSaveLoadBorder(int x,int y);\nstatic void M_SetupNextMenu(menu_t *menudef);\nstatic void M_DrawThermo(int x,int y,int thermWidth,int thermDot);\nstatic void M_WriteText(int x, int y, char *string);\nstatic int  M_StringWidth(char *string);\nstatic int  M_StringHeight(const char *string);\nstatic void M_StartMessage(const char *string, void *routine, boolean input);\nstatic void M_ClearMenus (void);\n\n\n\n\n//\n// DOOM MENU\n//\nenum\n{\n    newgame = 0,\n    options,\n    loadgame,\n    savegame,\n    readthis,\n    quitdoom,\n    main_end\n} main_e;\n\nmenuitem_t MainMenu[]=\n{\n    {1,\"M_NGAME\",M_NewGame,'n'},\n    {1,\"M_OPTION\",M_Options,'o'},\n    {1,\"M_LOADG\",M_LoadGame,'l'},\n    {1,\"M_SAVEG\",M_SaveGame,'s'},\n    // Another hickup with Special edition.\n    {1,\"M_RDTHIS\",M_ReadThis,'r'},\n    {1,\"M_QUITG\",M_QuitDOOM,'q'}\n};\n\nmenu_t  MainDef =\n{\n    main_end,\n    NULL,\n    MainMenu,\n    M_DrawMainMenu,\n    97,64,\n    0\n};\n\n\n//\n// EPISODE SELECT\n//\nenum\n{\n    ep1,\n    ep2,\n    ep3,\n    ep4,\n    ep_end\n} episodes_e;\n\nmenuitem_t EpisodeMenu[]=\n{\n    {1,\"M_EPI1\", M_Episode,'k'},\n    {1,\"M_EPI2\", M_Episode,'t'},\n    {1,\"M_EPI3\", M_Episode,'i'},\n    {1,\"M_EPI4\", M_Episode,'t'}\n};\n\nmenu_t  EpiDef =\n{\n    ep_end,\t\t// # of menu items\n    &MainDef,\t\t// previous menu\n    EpisodeMenu,\t// menuitem_t ->\n    M_DrawEpisode,\t// drawing routine ->\n    48,63,              // x,y\n    ep1\t\t\t// lastOn\n};\n\n//\n// NEW GAME\n//\nenum\n{\n    killthings,\n    toorough,\n    hurtme,\n    violence,\n    nightmare,\n    newg_end\n} newgame_e;\n\nmenuitem_t NewGameMenu[]=\n{\n    {1,\"M_JKILL\",\tM_ChooseSkill, 'i'},\n    {1,\"M_ROUGH\",\tM_ChooseSkill, 'h'},\n    {1,\"M_HURT\",\tM_ChooseSkill, 'h'},\n    {1,\"M_ULTRA\",\tM_ChooseSkill, 'u'},\n    {1,\"M_NMARE\",\tM_ChooseSkill, 'n'}\n};\n\nmenu_t  NewDef =\n{\n    newg_end,\t\t// # of menu items\n    &EpiDef,\t\t// previous menu\n    NewGameMenu,\t// menuitem_t ->\n    M_DrawNewGame,\t// drawing routine ->\n    48,63,              // x,y\n    hurtme\t\t// lastOn\n};\n\n\n\n//\n// OPTIONS MENU\n//\nenum\n{\n    endgame,\n    messages,\n    detail,\n    scrnsize,\n    option_empty1,\n    mousesens,\n    option_empty2,\n    soundvol,\n    opt_end\n} options_e;\n\nmenuitem_t OptionsMenu[]=\n{\n    {1,\"M_ENDGAM\",\tM_EndGame,'e'},\n    {1,\"M_MESSG\",\tM_ChangeMessages,'m'},\n    {1,\"M_DETAIL\",\tM_ChangeDetail,'g'},\n    {2,\"M_SCRNSZ\",\tM_SizeDisplay,'s'},\n    {-1,\"\",0,'\\0'},\n    {2,\"M_MSENS\",\tM_ChangeSensitivity,'m'},\n    {-1,\"\",0,'\\0'},\n    {1,\"M_SVOL\",\tM_Sound,'s'}\n};\n\nmenu_t  OptionsDef =\n{\n    opt_end,\n    &MainDef,\n    OptionsMenu,\n    M_DrawOptions,\n    60,37,\n    0\n};\n\n//\n// Read This! MENU 1 & 2\n//\nenum\n{\n    rdthsempty1,\n    read1_end\n} read_e;\n\nmenuitem_t ReadMenu1[] =\n{\n    {1,\"\",M_ReadThis2,0}\n};\n\nmenu_t  ReadDef1 =\n{\n    read1_end,\n    &MainDef,\n    ReadMenu1,\n    M_DrawReadThis1,\n    280,185,\n    0\n};\n\nenum\n{\n    rdthsempty2,\n    read2_end\n} read_e2;\n\nmenuitem_t ReadMenu2[]=\n{\n    {1,\"\",M_FinishReadThis,0}\n};\n\nmenu_t  ReadDef2 =\n{\n    read2_end,\n    &ReadDef1,\n    ReadMenu2,\n    M_DrawReadThis2,\n    330,175,\n    0\n};\n\n//\n// SOUND VOLUME MENU\n//\nenum\n{\n    sfx_vol,\n    sfx_empty1,\n    music_vol,\n    sfx_empty2,\n    sound_end\n} sound_e;\n\nmenuitem_t SoundMenu[]=\n{\n    {2,\"M_SFXVOL\",M_SfxVol,'s'},\n    {-1,\"\",0,'\\0'},\n    {2,\"M_MUSVOL\",M_MusicVol,'m'},\n    {-1,\"\",0,'\\0'}\n};\n\nmenu_t  SoundDef =\n{\n    sound_end,\n    &OptionsDef,\n    SoundMenu,\n    M_DrawSound,\n    80,64,\n    0\n};\n\n//\n// LOAD GAME MENU\n//\nenum\n{\n    load1,\n    load2,\n    load3,\n    load4,\n    load5,\n    load6,\n    load_end\n} load_e;\n\nmenuitem_t LoadMenu[]=\n{\n    {1,\"\", M_LoadSelect,'1'},\n    {1,\"\", M_LoadSelect,'2'},\n    {1,\"\", M_LoadSelect,'3'},\n    {1,\"\", M_LoadSelect,'4'},\n    {1,\"\", M_LoadSelect,'5'},\n    {1,\"\", M_LoadSelect,'6'}\n};\n\nmenu_t  LoadDef =\n{\n    load_end,\n    &MainDef,\n    LoadMenu,\n    M_DrawLoad,\n    80,54,\n    0\n};\n\n//\n// SAVE GAME MENU\n//\nmenuitem_t SaveMenu[]=\n{\n    {1,\"\", M_SaveSelect,'1'},\n    {1,\"\", M_SaveSelect,'2'},\n    {1,\"\", M_SaveSelect,'3'},\n    {1,\"\", M_SaveSelect,'4'},\n    {1,\"\", M_SaveSelect,'5'},\n    {1,\"\", M_SaveSelect,'6'}\n};\n\nmenu_t  SaveDef =\n{\n    load_end,\n    &MainDef,\n    SaveMenu,\n    M_DrawSave,\n    80,54,\n    0\n};\n\n\n//\n// M_ReadSaveStrings\n//  read the strings from the savegame files\n//\nvoid M_ReadSaveStrings(void)\n{\n    FILE   *handle;\n    int     i;\n    char    name[256];\n\n    for (i = 0;i < load_end;i++)\n    {\n        int retval;\n        M_StringCopy(name, P_SaveGameFile(i), sizeof(name));\n\n\thandle = fopen(name, \"rb\");\n        if (handle == NULL)\n        {\n            M_StringCopy(savegamestrings[i], EMPTYSTRING, SAVESTRINGSIZE);\n            LoadMenu[i].status = 0;\n            continue;\n        }\n        retval = fread(&savegamestrings[i], 1, SAVESTRINGSIZE, handle);\n\tfclose(handle);\n        LoadMenu[i].status = retval == SAVESTRINGSIZE;\n    }\n}\n\n\n//\n// M_LoadGame & Cie.\n//\nvoid M_DrawLoad(void)\n{\n    int             i;\n\t\n    V_DrawPatchDirect(72, 28, \n                      W_CacheLumpName(DEH_String(\"M_LOADG\"), PU_CACHE));\n\n    for (i = 0;i < load_end; i++)\n    {\n\tM_DrawSaveLoadBorder(LoadDef.x,LoadDef.y+LINEHEIGHT*i);\n\tM_WriteText(LoadDef.x,LoadDef.y+LINEHEIGHT*i,savegamestrings[i]);\n    }\n}\n\n\n\n//\n// Draw border for the savegame description\n//\nvoid M_DrawSaveLoadBorder(int x,int y)\n{\n    int             i;\n\t\n    V_DrawPatchDirect(x - 8, y + 7,\n                      W_CacheLumpName(DEH_String(\"M_LSLEFT\"), PU_CACHE));\n\t\n    for (i = 0;i < 24;i++)\n    {\n\tV_DrawPatchDirect(x, y + 7,\n                          W_CacheLumpName(DEH_String(\"M_LSCNTR\"), PU_CACHE));\n\tx += 8;\n    }\n\n    V_DrawPatchDirect(x, y + 7, \n                      W_CacheLumpName(DEH_String(\"M_LSRGHT\"), PU_CACHE));\n}\n\n\n\n//\n// User wants to load this game\n//\nvoid M_LoadSelect(int choice)\n{\n    char    name[256];\n\t\n    M_StringCopy(name, P_SaveGameFile(choice), sizeof(name));\n\n    G_LoadGame (name);\n    M_ClearMenus ();\n}\n\n//\n// Selected from DOOM menu\n//\nvoid M_LoadGame (int choice)\n{\n    if (netgame)\n    {\n\tM_StartMessage(DEH_String(LOADNET),NULL,false);\n\treturn;\n    }\n\t\n    M_SetupNextMenu(&LoadDef);\n    M_ReadSaveStrings();\n}\n\n\n//\n//  M_SaveGame & Cie.\n//\nvoid M_DrawSave(void)\n{\n    int             i;\n\t\n    V_DrawPatchDirect(72, 28, W_CacheLumpName(DEH_String(\"M_SAVEG\"), PU_CACHE));\n    for (i = 0;i < load_end; i++)\n    {\n\tM_DrawSaveLoadBorder(LoadDef.x,LoadDef.y+LINEHEIGHT*i);\n\tM_WriteText(LoadDef.x,LoadDef.y+LINEHEIGHT*i,savegamestrings[i]);\n    }\n\t\n    if (saveStringEnter)\n    {\n\ti = M_StringWidth(savegamestrings[saveSlot]);\n\tM_WriteText(LoadDef.x + i,LoadDef.y+LINEHEIGHT*saveSlot,\"_\");\n    }\n}\n\n//\n// M_Responder calls this when user is finished\n//\nvoid M_DoSave(int slot)\n{\n    G_SaveGame (slot,savegamestrings[slot]);\n    M_ClearMenus ();\n\n    // PICK QUICKSAVE SLOT YET?\n    if (quickSaveSlot == -2)\n\tquickSaveSlot = slot;\n}\n\n//\n// Generate a default save slot name when the user saves to\n// an empty slot via the joypad.\n//\nstatic void SetDefaultSaveName(int slot)\n{\n    M_snprintf(savegamestrings[itemOn], SAVESTRINGSIZE - 1,\n               \"JOYSTICK SLOT %i\", itemOn + 1);\n    joypadSave = false;\n}\n\n//\n// User wants to save. Start string input for M_Responder\n//\nvoid M_SaveSelect(int choice)\n{\n    if (I_IsMobile()) {\n        time_t t = time(NULL);\n        struct tm tm = *localtime(&t);\n\n        gameinfo_t *state = malloc(sizeof(gameinfo_t));\n        G_GetGameInfo(state);\n\n        if (gamemode == commercial || gameversion == exe_chex){\n            M_snprintf(savegamestrings[choice], SAVESTRINGSIZE - 1, \"MAP%02d %04d-%02d-%02d %02d:%02d\", state->map, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min);\n        }else{\n            M_snprintf(savegamestrings[choice], SAVESTRINGSIZE - 1, \"E%dM%d %04d-%02d-%02d %02d:%02d\", state->episode, state->map, tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday, tm.tm_hour, tm.tm_min);\n        }\n\n        free(state);\n\n        saveCharIndex = strlen(savegamestrings[choice]);\n        M_DoSave(choice);\n    } else {\n        int x, y;\n\n        // we are going to be intercepting all chars\n        saveStringEnter = 1;\n\n        // We need to turn on text input:\n        x = LoadDef.x - 11;\n        y = LoadDef.y + choice * LINEHEIGHT - 4;\n        I_StartTextInput(x, y, x + 8 + 24 * 8 + 8, y + LINEHEIGHT - 2);\n\n        saveSlot = choice;\n        M_StringCopy(saveOldString,savegamestrings[choice], SAVESTRINGSIZE);\n        if (!strcmp(savegamestrings[choice], EMPTYSTRING))\n        {\n            savegamestrings[choice][0] = 0;\n\n            if (joypadSave)\n            {\n                SetDefaultSaveName(choice);\n            }\n        }\n    }\n    saveCharIndex = strlen(savegamestrings[choice]);\n}\n\n//\n// Selected from DOOM menu\n//\nvoid M_SaveGame (int choice)\n{\n    if (!usergame)\n    {\n\tM_StartMessage(DEH_String(SAVEDEAD),NULL,false);\n\treturn;\n    }\n\t\n    if (gamestate != GS_LEVEL)\n\treturn;\n\t\n    M_SetupNextMenu(&SaveDef);\n    M_ReadSaveStrings();\n}\n\n\n\n//\n//      M_QuickSave\n//\nchar    tempstring[80];\n\nvoid M_QuickSaveResponse(int key)\n{\n    if (key == key_menu_confirm || key == key_menu_forward)\n    {\n\tM_DoSave(quickSaveSlot);\n\tS_StartSound(NULL,sfx_swtchx);\n    }\n}\n\nvoid M_QuickSave(void)\n{\n    if (!usergame)\n    {\n\tS_StartSound(NULL,sfx_oof);\n\treturn;\n    }\n\n    if (gamestate != GS_LEVEL)\n\treturn;\n\t\n    if (quickSaveSlot < 0)\n    {\n\tM_StartControlPanel();\n\tM_ReadSaveStrings();\n\tM_SetupNextMenu(&SaveDef);\n\tquickSaveSlot = -2;\t// means to pick a slot now\n\treturn;\n    }\n    DEH_snprintf(tempstring, 80, QSPROMPT, savegamestrings[quickSaveSlot]);\n    M_StartMessage(tempstring,M_QuickSaveResponse,true);\n}\n\n\n\n//\n// M_QuickLoad\n//\nvoid M_QuickLoadResponse(int key)\n{\n    if (key == key_menu_confirm || key == key_menu_forward)\n    {\n\tM_LoadSelect(quickSaveSlot);\n\tS_StartSound(NULL,sfx_swtchx);\n    }\n}\n\n\nvoid M_QuickLoad(void)\n{\n    if (netgame)\n    {\n\tM_StartMessage(DEH_String(QLOADNET),NULL,false);\n\treturn;\n    }\n\t\n    if (quickSaveSlot < 0)\n    {\n\tM_StartMessage(DEH_String(QSAVESPOT),NULL,false);\n\treturn;\n    }\n    DEH_snprintf(tempstring, 80, QLPROMPT, savegamestrings[quickSaveSlot]);\n    M_StartMessage(tempstring,M_QuickLoadResponse,true);\n}\n\n\n\n\n//\n// Read This Menus\n// Had a \"quick hack to fix romero bug\"\n//\nvoid M_DrawReadThis1(void)\n{\n    inhelpscreens = true;\n\n    V_DrawPatchDirect(0, 0, W_CacheLumpName(DEH_String(\"HELP2\"), PU_CACHE));\n}\n\n\n\n//\n// Read This Menus - optional second page.\n//\nvoid M_DrawReadThis2(void)\n{\n    inhelpscreens = true;\n\n    // We only ever draw the second page if this is \n    // gameversion == exe_doom_1_9 and gamemode == registered\n\n    V_DrawPatchDirect(0, 0, W_CacheLumpName(DEH_String(\"HELP1\"), PU_CACHE));\n}\n\nvoid M_DrawReadThisCommercial(void)\n{\n    inhelpscreens = true;\n\n    V_DrawPatchDirect(0, 0, W_CacheLumpName(DEH_String(\"HELP\"), PU_CACHE));\n}\n\n\n//\n// Change Sfx & Music volumes\n//\nvoid M_DrawSound(void)\n{\n    V_DrawPatchDirect (60, 38, W_CacheLumpName(DEH_String(\"M_SVOL\"), PU_CACHE));\n\n    M_DrawThermo(SoundDef.x,SoundDef.y+LINEHEIGHT*(sfx_vol+1),\n\t\t 16,sfxVolume);\n\n    M_DrawThermo(SoundDef.x,SoundDef.y+LINEHEIGHT*(music_vol+1),\n\t\t 16,musicVolume);\n}\n\nvoid M_Sound(int choice)\n{\n    M_SetupNextMenu(&SoundDef);\n}\n\nvoid M_SfxVol(int choice)\n{\n    switch(choice)\n    {\n      case 0:\n\tif (sfxVolume)\n\t    sfxVolume--;\n\tbreak;\n      case 1:\n\tif (sfxVolume < 15)\n\t    sfxVolume++;\n\tbreak;\n    }\n\t\n    S_SetSfxVolume(sfxVolume * 8);\n}\n\nvoid M_MusicVol(int choice)\n{\n    switch(choice)\n    {\n      case 0:\n\tif (musicVolume)\n\t    musicVolume--;\n\tbreak;\n      case 1:\n\tif (musicVolume < 15)\n\t    musicVolume++;\n\tbreak;\n    }\n\t\n    S_SetMusicVolume(musicVolume * 8);\n}\n\n\n\n\n//\n// M_DrawMainMenu\n//\nvoid M_DrawMainMenu(void)\n{\n    V_DrawPatchDirect(94, 2,\n                      W_CacheLumpName(DEH_String(\"M_DOOM\"), PU_CACHE));\n}\n\n\n\n\n//\n// M_NewGame\n//\nvoid M_DrawNewGame(void)\n{\n    V_DrawPatchDirect(96, 14, W_CacheLumpName(DEH_String(\"M_NEWG\"), PU_CACHE));\n    V_DrawPatchDirect(54, 38, W_CacheLumpName(DEH_String(\"M_SKILL\"), PU_CACHE));\n}\n\nvoid M_NewGame(int choice)\n{\n    if (netgame && !demoplayback)\n    {\n\tM_StartMessage(DEH_String(NEWGAME),NULL,false);\n\treturn;\n    }\n\t\n    // Chex Quest disabled the episode select screen, as did Doom II.\n\n    if (gamemode == commercial || gameversion == exe_chex)\n\tM_SetupNextMenu(&NewDef);\n    else\n\tM_SetupNextMenu(&EpiDef);\n}\n\n\n//\n//      M_Episode\n//\nint     epi;\n\nvoid M_DrawEpisode(void)\n{\n    V_DrawPatchDirect(54, 38, W_CacheLumpName(DEH_String(\"M_EPISOD\"), PU_CACHE));\n}\n\nvoid M_VerifyNightmare(int key)\n{\n    if (key != key_menu_confirm && key != key_menu_forward)\n\treturn;\n\t\t\n    G_DeferedInitNew(nightmare,epi+1,1);\n    M_ClearMenus ();\n}\n\nvoid M_ChooseSkill(int choice)\n{\n    if (choice == nightmare)\n    {\n\tM_StartMessage(DEH_String(NIGHTMARE),M_VerifyNightmare,true);\n\treturn;\n    }\n\t\n    G_DeferedInitNew(choice,epi+1,1);\n    M_ClearMenus ();\n}\n\nvoid M_Episode(int choice)\n{\n    if ( (gamemode == shareware)\n\t && choice)\n    {\n\tM_StartMessage(DEH_String(SWSTRING),NULL,false);\n\tM_SetupNextMenu(&ReadDef1);\n\treturn;\n    }\n\n    epi = choice;\n    M_SetupNextMenu(&NewDef);\n}\n\n\n\n//\n// M_Options\n//\nstatic char *detailNames[2] = {\"M_GDHIGH\",\"M_GDLOW\"};\nstatic char *msgNames[2] = {\"M_MSGOFF\",\"M_MSGON\"};\n\nvoid M_DrawOptions(void)\n{\n    V_DrawPatchDirect(108, 15, W_CacheLumpName(DEH_String(\"M_OPTTTL\"),\n                                               PU_CACHE));\n\t\n    V_DrawPatchDirect(OptionsDef.x + 175, OptionsDef.y + LINEHEIGHT * detail,\n\t\t      W_CacheLumpName(DEH_String(detailNames[detailLevel]),\n\t\t\t              PU_CACHE));\n\n    V_DrawPatchDirect(OptionsDef.x + 120, OptionsDef.y + LINEHEIGHT * messages,\n                      W_CacheLumpName(DEH_String(msgNames[showMessages]),\n                                      PU_CACHE));\n\n    M_DrawThermo(OptionsDef.x, OptionsDef.y + LINEHEIGHT * (mousesens + 1),\n\t\t 10, mouseSensitivity);\n\n    M_DrawThermo(OptionsDef.x,OptionsDef.y+LINEHEIGHT*(scrnsize+1),\n\t\t 9,screenSize);\n}\n\nvoid M_Options(int choice)\n{\n    M_SetupNextMenu(&OptionsDef);\n}\n\n\n\n//\n//      Toggle messages on/off\n//\nvoid M_ChangeMessages(int choice)\n{\n    // warning: unused parameter `int choice'\n    choice = 0;\n    showMessages = 1 - showMessages;\n\t\n    if (!showMessages)\n\tplayers[consoleplayer].message = DEH_String(MSGOFF);\n    else\n\tplayers[consoleplayer].message = DEH_String(MSGON);\n\n    message_dontfuckwithme = true;\n}\n\n\n//\n// M_EndGame\n//\nvoid M_EndGameResponse(int key)\n{\n    if (key != key_menu_confirm && key != key_menu_forward)\n\treturn;\n\t\t\n    currentMenu->lastOn = itemOn;\n    M_ClearMenus ();\n    D_StartTitle ();\n}\n\nvoid M_EndGame(int choice)\n{\n    choice = 0;\n    if (!usergame)\n    {\n\tS_StartSound(NULL,sfx_oof);\n\treturn;\n    }\n\t\n    if (netgame)\n    {\n\tM_StartMessage(DEH_String(NETEND),NULL,false);\n\treturn;\n    }\n\t\n    M_StartMessage(DEH_String(ENDGAME),M_EndGameResponse,true);\n}\n\n\n\n\n//\n// M_ReadThis\n//\nvoid M_ReadThis(int choice)\n{\n    choice = 0;\n    M_SetupNextMenu(&ReadDef1);\n}\n\nvoid M_ReadThis2(int choice)\n{\n    choice = 0;\n    M_SetupNextMenu(&ReadDef2);\n}\n\nvoid M_FinishReadThis(int choice)\n{\n    choice = 0;\n    M_SetupNextMenu(&MainDef);\n}\n\n\n\n\n//\n// M_QuitDOOM\n//\nint     quitsounds[8] =\n{\n    sfx_pldeth,\n    sfx_dmpain,\n    sfx_popain,\n    sfx_slop,\n    sfx_telept,\n    sfx_posit1,\n    sfx_posit3,\n    sfx_sgtatk\n};\n\nint     quitsounds2[8] =\n{\n    sfx_vilact,\n    sfx_getpow,\n    sfx_boscub,\n    sfx_slop,\n    sfx_skeswg,\n    sfx_kntdth,\n    sfx_bspact,\n    sfx_sgtatk\n};\n\n\n\nvoid M_QuitResponse(int key)\n{\n    if (key != key_menu_confirm && key != key_menu_forward)\n\treturn;\n    if (!netgame)\n    {\n\tif (gamemode == commercial)\n\t    S_StartSound(NULL,quitsounds2[(gametic>>2)&7]);\n\telse\n\t    S_StartSound(NULL,quitsounds[(gametic>>2)&7]);\n\tI_WaitVBL(105);\n    }\n    I_Quit ();\n}\n\n\nstatic char *M_SelectEndMessage(void)\n{\n    char **endmsg;\n\n    if (logical_gamemission == doom)\n    {\n        // Doom 1\n\n        endmsg = doom1_endmsg;\n    }\n    else\n    {\n        // Doom 2\n        \n        endmsg = doom2_endmsg;\n    }\n\n    return endmsg[gametic % NUM_QUITMESSAGES];\n}\n\n\nvoid M_QuitDOOM(int choice)\n{\n    DEH_snprintf(endstring, sizeof(endstring), \"%s\\n\\n\" DOSY,\n                 DEH_String(M_SelectEndMessage()));\n\n    M_StartMessage(endstring,M_QuitResponse,true);\n}\n\n\n\n\nvoid M_ChangeSensitivity(int choice)\n{\n    switch(choice)\n    {\n      case 0:\n\tif (mouseSensitivity)\n\t    mouseSensitivity--;\n\tbreak;\n      case 1:\n\tif (mouseSensitivity < 9)\n\t    mouseSensitivity++;\n\tbreak;\n    }\n}\n\n\n\n\nvoid M_ChangeDetail(int choice)\n{\n    choice = 0;\n    detailLevel = 1 - detailLevel;\n\n    R_SetViewSize (screenblocks, detailLevel);\n\n    if (!detailLevel)\n\tplayers[consoleplayer].message = DEH_String(DETAILHI);\n    else\n\tplayers[consoleplayer].message = DEH_String(DETAILLO);\n}\n\n\n\n\nvoid M_SizeDisplay(int choice)\n{\n    switch(choice)\n    {\n      case 0:\n\tif (screenSize > 0)\n\t{\n\t    screenblocks--;\n\t    screenSize--;\n\t}\n\tbreak;\n      case 1:\n\tif (screenSize < 8)\n\t{\n\t    screenblocks++;\n\t    screenSize++;\n\t}\n\tbreak;\n    }\n\t\n\n    R_SetViewSize (screenblocks, detailLevel);\n}\n\n\n\n\n//\n//      Menu Functions\n//\nvoid\nM_DrawThermo\n( int\tx,\n  int\ty,\n  int\tthermWidth,\n  int\tthermDot )\n{\n    int\t\txx;\n    int\t\ti;\n\n    xx = x;\n    V_DrawPatchDirect(xx, y, W_CacheLumpName(DEH_String(\"M_THERML\"), PU_CACHE));\n    xx += 8;\n    for (i=0;i<thermWidth;i++)\n    {\n\tV_DrawPatchDirect(xx, y, W_CacheLumpName(DEH_String(\"M_THERMM\"), PU_CACHE));\n\txx += 8;\n    }\n    V_DrawPatchDirect(xx, y, W_CacheLumpName(DEH_String(\"M_THERMR\"), PU_CACHE));\n\n    V_DrawPatchDirect((x + 8) + thermDot * 8, y,\n\t\t      W_CacheLumpName(DEH_String(\"M_THERMO\"), PU_CACHE));\n}\n\n\nvoid\nM_StartMessage\n( const char\t*string,\n  void*\t\troutine,\n  boolean\tinput )\n{\n    messageLastMenuActive = menuactive;\n    messageToPrint = 1;\n    messageString = string;\n    messageRoutine = routine;\n    messageNeedsInput = input;\n    menuactive = true;\n    return;\n}\n\n\n//\n// Find string width from hu_font chars\n//\nint M_StringWidth(char* string)\n{\n    size_t             i;\n    int             w = 0;\n    int             c;\n\t\n    for (i = 0;i < strlen(string);i++)\n    {\n\tc = toupper(string[i]) - HU_FONTSTART;\n\tif (c < 0 || c >= HU_FONTSIZE)\n\t    w += 4;\n\telse\n\t    w += SHORT (hu_font[c]->width);\n    }\n\t\t\n    return w;\n}\n\n\n\n//\n//      Find string height from hu_font chars\n//\nint M_StringHeight(const char* string)\n{\n    size_t             i;\n    int             h;\n    int             height = SHORT(hu_font[0]->height);\n\t\n    h = height;\n    for (i = 0;i < strlen(string);i++)\n\tif (string[i] == '\\n')\n\t    h += height;\n\t\t\n    return h;\n}\n\n\n//\n//      Write a string using the hu_font\n//\nvoid\nM_WriteText\n( int\t\tx,\n  int\t\ty,\n  char*\t\tstring)\n{\n    int\t\tw;\n    char*\tch;\n    int\t\tc;\n    int\t\tcx;\n    int\t\tcy;\n\t\t\n\n    ch = string;\n    cx = x;\n    cy = y;\n\t\n    while(1)\n    {\n\tc = *ch++;\n\tif (!c)\n\t    break;\n\tif (c == '\\n')\n\t{\n\t    cx = x;\n\t    cy += 12;\n\t    continue;\n\t}\n\t\t\n\tc = toupper(c) - HU_FONTSTART;\n\tif (c < 0 || c>= HU_FONTSIZE)\n\t{\n\t    cx += 4;\n\t    continue;\n\t}\n\t\t\n\tw = SHORT (hu_font[c]->width);\n\tif (cx+w > SCREENWIDTH)\n\t    break;\n\tV_DrawPatchDirect(cx, cy, hu_font[c]);\n\tcx+=w;\n    }\n}\n\n// These keys evaluate to a \"null\" key in Vanilla Doom that allows weird\n// jumping in the menus. Preserve this behavior for accuracy.\n\nstatic boolean IsNullKey(int key)\n{\n    return key == KEY_PAUSE || key == KEY_CAPSLOCK\n        || key == KEY_SCRLCK || key == KEY_NUMLOCK;\n}\n\n//\n// CONTROL PANEL\n//\n\n//\n// M_Responder\n//\nboolean M_Responder (event_t* ev)\n{\n    int             ch;\n    int             key;\n    int             i;\n    static  int     mousewait = 0;\n    static  int     mousey = 0;\n    static  int     lasty = 0;\n    static  int     mousex = 0;\n    static  int     lastx = 0;\n\n    // In testcontrols mode, none of the function keys should do anything\n    // - the only key is escape to quit.\n\n    if (testcontrols)\n    {\n        if (ev->type == ev_quit\n         || (ev->type == ev_keydown\n          && (ev->data1 == key_menu_activate || ev->data1 == key_menu_quit)))\n        {\n            I_Quit();\n            return true;\n        }\n\n        return false;\n    }\n\n    // \"close\" button pressed on window?\n    if (ev->type == ev_quit)\n    {\n        // First click on close button = bring up quit confirm message.\n        // Second click on close button = confirm quit\n\n        if (menuactive && messageToPrint && messageRoutine == M_QuitResponse)\n        {\n            M_QuitResponse(key_menu_confirm);\n        }\n        else\n        {\n            S_StartSound(NULL,sfx_swtchn);\n            M_QuitDOOM(0);\n        }\n\n        return true;\n    }\n\n    // key is the key pressed, ch is the actual character typed\n  \n    ch = 0;\n    key = -1;\n\t\n    if (ev->type == ev_joystick)\n    {\n        // Simulate key presses from joystick events to interact with the menu.\n\n\tif (ev->data3 < 0)\n\t{\n\t    key = key_menu_up;\n\t    joywait = I_GetTime() + 5;\n\t}\n\telse if (ev->data3 > 0)\n\t{\n\t    key = key_menu_down;\n\t    joywait = I_GetTime() + 5;\n\t}\n\t\t\n\tif (ev->data2 < 0)\n\t{\n\t    key = key_menu_left;\n\t    joywait = I_GetTime() + 2;\n\t}\n\telse if (ev->data2 > 0)\n\t{\n\t    key = key_menu_right;\n\t    joywait = I_GetTime() + 2;\n\t}\n\n#define JOY_BUTTON_MAPPED(x) ((x) >= 0)\n#define JOY_BUTTON_PRESSED(x) (JOY_BUTTON_MAPPED(x) && (ev->data1 & (1 << (x))) != 0)\n\n        if (JOY_BUTTON_PRESSED(joybfire))\n        {\n            // Simulate a 'Y' keypress when Doom show a Y/N dialog with Fire button.\n            if (messageToPrint && messageNeedsInput)\n            {\n                key = key_menu_confirm;\n            }\n            // Simulate pressing \"Enter\" when we are supplying a save slot name\n            else if (saveStringEnter)\n            {\n                key = KEY_ENTER;\n            }\n            else\n            {\n                // if selecting a save slot via joypad, set a flag\n                if (currentMenu == &SaveDef)\n                {\n                    joypadSave = true;\n                }\n                key = key_menu_forward;\n            }\n            joywait = I_GetTime() + 5;\n        }\n        if (JOY_BUTTON_PRESSED(joybuse))\n        {\n            // Simulate a 'N' keypress when Doom show a Y/N dialog with Use button.\n            if (messageToPrint && messageNeedsInput)\n            {\n                key = key_menu_abort;\n            }\n            // If user was entering a save name, back out\n            else if (saveStringEnter)\n            {\n                key = KEY_ESCAPE;\n            }\n            else\n            {\n                key = key_menu_back;\n            }\n            joywait = I_GetTime() + 5;\n        }\n        if (JOY_BUTTON_PRESSED(joybmenu))\n        {\n            key = key_menu_activate;\n            joywait = I_GetTime() + 5;\n        }\n    }\n    else\n    {\n\tif (ev->type == ev_mouse && mousewait < I_GetTime())\n\t{\n\t    mousey += ev->data3;\n\t    if (mousey < lasty-30)\n\t    {\n\t\tkey = key_menu_down;\n\t\tmousewait = I_GetTime() + 5;\n\t\tmousey = lasty -= 30;\n\t    }\n\t    else if (mousey > lasty+30)\n\t    {\n\t\tkey = key_menu_up;\n\t\tmousewait = I_GetTime() + 5;\n\t\tmousey = lasty += 30;\n\t    }\n\t\t\n\t    mousex += ev->data2;\n\t    if (mousex < lastx-30)\n\t    {\n\t\tkey = key_menu_left;\n\t\tmousewait = I_GetTime() + 5;\n\t\tmousex = lastx -= 30;\n\t    }\n\t    else if (mousex > lastx+30)\n\t    {\n\t\tkey = key_menu_right;\n\t\tmousewait = I_GetTime() + 5;\n\t\tmousex = lastx += 30;\n\t    }\n\t\t\n\t    if (ev->data1&1)\n\t    {\n\t\tkey = key_menu_forward;\n\t\tmousewait = I_GetTime() + 15;\n\t    }\n\t\t\t\n\t    if (ev->data1&2)\n\t    {\n\t\tkey = key_menu_back;\n\t\tmousewait = I_GetTime() + 15;\n\t    }\n\t}\n\telse\n\t{\n\t    if (ev->type == ev_keydown)\n\t    {\n\t\tkey = ev->data1;\n\t\tch = ev->data2;\n\t    }\n\t}\n    }\n    \n    if (key == -1)\n\treturn false;\n\n    // Save Game string input\n    if (saveStringEnter)\n    {\n\tswitch(key)\n\t{\n\t  case KEY_BACKSPACE:\n\t    if (saveCharIndex > 0)\n\t    {\n\t\tsaveCharIndex--;\n\t\tsavegamestrings[saveSlot][saveCharIndex] = 0;\n\t    }\n\t    break;\n\n          case KEY_ESCAPE:\n            saveStringEnter = 0;\n            I_StopTextInput();\n            M_StringCopy(savegamestrings[saveSlot], saveOldString,\n                         SAVESTRINGSIZE);\n            break;\n\n\t  case KEY_ENTER:\n\t    saveStringEnter = 0;\n            I_StopTextInput();\n\t    if (savegamestrings[saveSlot][0])\n\t\tM_DoSave(saveSlot);\n\t    break;\n\n\t  default:\n            // Savegame name entry. This is complicated.\n            // Vanilla has a bug where the shift key is ignored when entering\n            // a savegame name. If vanilla_keyboard_mapping is on, we want\n            // to emulate this bug by using ev->data1. But if it's turned off,\n            // it implies the user doesn't care about Vanilla emulation:\n            // instead, use ev->data3 which gives the fully-translated and\n            // modified key input.\n\n            if (ev->type != ev_keydown)\n            {\n                break;\n            }\n            if (vanilla_keyboard_mapping)\n            {\n                ch = ev->data1;\n            }\n            else\n            {\n                ch = ev->data3;\n            }\n\n            ch = toupper(ch);\n\n            if (ch != ' '\n             && (ch - HU_FONTSTART < 0 || ch - HU_FONTSTART >= HU_FONTSIZE))\n            {\n                break;\n            }\n\n\t    if (ch >= 32 && ch <= 127 &&\n\t\tsaveCharIndex < SAVESTRINGSIZE-1 &&\n\t\tM_StringWidth(savegamestrings[saveSlot]) <\n\t\t(SAVESTRINGSIZE-2)*8)\n\t    {\n\t\tsavegamestrings[saveSlot][saveCharIndex++] = ch;\n\t\tsavegamestrings[saveSlot][saveCharIndex] = 0;\n\t    }\n\t    break;\n\t}\n\treturn true;\n    }\n\n    // Take care of any messages that need input\n    if (messageToPrint)\n    {\n\tif (messageNeedsInput)\n        {\n            if (key != ' ' && key != KEY_ESCAPE\n             && key != key_menu_confirm && key != key_menu_forward && key != key_menu_abort)\n            {\n                return false;\n            }\n\t}\n\n\tmenuactive = messageLastMenuActive;\n\tmessageToPrint = 0;\n\tif (messageRoutine)\n\t    messageRoutine(key);\n\n\tmenuactive = false;\n\tS_StartSound(NULL,sfx_swtchx);\n\treturn true;\n    }\n\n    if ((devparm && key == key_menu_help) ||\n        (key != 0 && key == key_menu_screenshot))\n    {\n\tG_ScreenShot ();\n\treturn true;\n    }\n\n    // F-Keys\n    if (!menuactive)\n    {\n\tif (key == key_menu_decscreen)      // Screen size down\n        {\n\t    if (automapactive || chat_on)\n\t\treturn false;\n\t    M_SizeDisplay(0);\n\t    S_StartSound(NULL,sfx_stnmov);\n\t    return true;\n\t}\n        else if (key == key_menu_incscreen) // Screen size up\n        {\n\t    if (automapactive || chat_on)\n\t\treturn false;\n\t    M_SizeDisplay(1);\n\t    S_StartSound(NULL,sfx_stnmov);\n\t    return true;\n\t}\n        else if (key == key_menu_help)     // Help key\n        {\n\t    M_StartControlPanel ();\n\n\t    if (gameversion >= exe_ultimate)\n\t      currentMenu = &ReadDef2;\n\t    else\n\t      currentMenu = &ReadDef1;\n\n\t    itemOn = 0;\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    return true;\n\t}\n        else if (key == key_menu_save)     // Save\n        {\n\t    M_StartControlPanel();\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    M_SaveGame(0);\n\t    return true;\n        }\n        else if (key == key_menu_load)     // Load\n        {\n\t    M_StartControlPanel();\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    M_LoadGame(0);\n\t    return true;\n        }\n        else if (key == key_menu_volume)   // Sound Volume\n        {\n\t    M_StartControlPanel ();\n\t    currentMenu = &SoundDef;\n\t    itemOn = sfx_vol;\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    return true;\n\t}\n        else if (key == key_menu_detail)   // Detail toggle\n        {\n\t    M_ChangeDetail(0);\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    return true;\n        }\n        else if (key == key_menu_qsave)    // Quicksave\n        {\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    M_QuickSave();\n\t    return true;\n        }\n        else if (key == key_menu_endgame)  // End game\n        {\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    M_EndGame(0);\n\t    return true;\n        }\n        else if (key == key_menu_messages) // Toggle messages\n        {\n\t    M_ChangeMessages(0);\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    return true;\n        }\n        else if (key == key_menu_qload)    // Quickload\n        {\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    M_QuickLoad();\n\t    return true;\n        }\n        else if (key == key_menu_quit)     // Quit DOOM\n        {\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    M_QuitDOOM(0);\n\t    return true;\n        }\n        else if (key == key_menu_gamma)    // gamma toggle\n        {\n\t    usegamma++;\n\t    if (usegamma > 4)\n\t\tusegamma = 0;\n\t    players[consoleplayer].message = DEH_String(gammamsg[usegamma]);\n            I_SetPalette (W_CacheLumpName (DEH_String(\"PLAYPAL\"),PU_CACHE));\n\t    return true;\n\t}\n    }\n\n    // Pop-up menu?\n    if (!menuactive)\n    {\n\tif (key == key_menu_activate)\n\t{\n\t    M_StartControlPanel ();\n\t    S_StartSound(NULL,sfx_swtchn);\n\t    return true;\n\t}\n\treturn false;\n    }\n\n    // Keys usable within menu\n\n    if (key == key_menu_down)\n    {\n        // Move down to next item\n\n        do\n\t{\n\t    if (itemOn+1 > currentMenu->numitems-1)\n\t\titemOn = 0;\n\t    else itemOn++;\n\t    S_StartSound(NULL,sfx_pstop);\n\t} while(currentMenu->menuitems[itemOn].status==-1);\n\n\treturn true;\n    }\n    else if (key == key_menu_up)\n    {\n        // Move back up to previous item\n\n\tdo\n\t{\n\t    if (!itemOn)\n\t\titemOn = currentMenu->numitems-1;\n\t    else itemOn--;\n\t    S_StartSound(NULL,sfx_pstop);\n\t} while(currentMenu->menuitems[itemOn].status==-1);\n\n\treturn true;\n    }\n    else if (key == key_menu_left)\n    {\n        // Slide slider left\n\n\tif (currentMenu->menuitems[itemOn].routine &&\n\t    currentMenu->menuitems[itemOn].status == 2)\n\t{\n\t    S_StartSound(NULL,sfx_stnmov);\n\t    currentMenu->menuitems[itemOn].routine(0);\n\t}\n\treturn true;\n    }\n    else if (key == key_menu_right)\n    {\n        // Slide slider right\n\n\tif (currentMenu->menuitems[itemOn].routine &&\n\t    currentMenu->menuitems[itemOn].status == 2)\n\t{\n\t    S_StartSound(NULL,sfx_stnmov);\n\t    currentMenu->menuitems[itemOn].routine(1);\n\t}\n\treturn true;\n    }\n    else if (key == key_menu_forward)\n    {\n        // Activate menu item\n\n\tif (currentMenu->menuitems[itemOn].routine &&\n\t    currentMenu->menuitems[itemOn].status)\n\t{\n\t    currentMenu->lastOn = itemOn;\n\t    if (currentMenu->menuitems[itemOn].status == 2)\n\t    {\n\t\tcurrentMenu->menuitems[itemOn].routine(1);      // right arrow\n\t\tS_StartSound(NULL,sfx_stnmov);\n\t    }\n\t    else\n\t    {\n\t\tcurrentMenu->menuitems[itemOn].routine(itemOn);\n\t\tS_StartSound(NULL,sfx_pistol);\n\t    }\n\t}\n\treturn true;\n    }\n    else if (key == key_menu_activate)\n    {\n        // Deactivate menu\n\n\tcurrentMenu->lastOn = itemOn;\n\tM_ClearMenus ();\n\tS_StartSound(NULL,sfx_swtchx);\n\treturn true;\n    }\n    else if (key == key_menu_back)\n    {\n        // Go back to previous menu\n\n\tcurrentMenu->lastOn = itemOn;\n\tif (currentMenu->prevMenu)\n\t{\n\t    currentMenu = currentMenu->prevMenu;\n\t    itemOn = currentMenu->lastOn;\n\t    S_StartSound(NULL,sfx_swtchn);\n\t}\n\treturn true;\n    }\n\n    // Keyboard shortcut?\n    // Vanilla Doom has a weird behavior where it jumps to the scroll bars\n    // when the certain keys are pressed, so emulate this.\n\n    else if (ch != 0 || IsNullKey(key))\n    {\n\tfor (i = itemOn+1;i < currentMenu->numitems;i++)\n        {\n\t    if (currentMenu->menuitems[i].alphaKey == ch)\n\t    {\n\t\titemOn = i;\n\t\tS_StartSound(NULL,sfx_pstop);\n\t\treturn true;\n\t    }\n        }\n\n\tfor (i = 0;i <= itemOn;i++)\n        {\n\t    if (currentMenu->menuitems[i].alphaKey == ch)\n\t    {\n\t\titemOn = i;\n\t\tS_StartSound(NULL,sfx_pstop);\n\t\treturn true;\n\t    }\n        }\n    }\n\n    return false;\n}\n\n\n\n//\n// M_StartControlPanel\n//\nvoid M_StartControlPanel (void)\n{\n    // intro might call this repeatedly\n    if (menuactive)\n\treturn;\n    \n    menuactive = 1;\n    currentMenu = &MainDef;         // JDC\n    itemOn = currentMenu->lastOn;   // JDC\n}\n\n// Display OPL debug messages - hack for GENMIDI development.\n\nstatic void M_DrawOPLDev(void)\n{\n    extern void I_OPL_DevMessages(char *, size_t);\n    char debug[1024];\n    char *curr, *p;\n    int line;\n\n    I_OPL_DevMessages(debug, sizeof(debug));\n    curr = debug;\n    line = 0;\n\n    for (;;)\n    {\n        p = strchr(curr, '\\n');\n\n        if (p != NULL)\n        {\n            *p = '\\0';\n        }\n\n        M_WriteText(0, line * 8, curr);\n        ++line;\n\n        if (p == NULL)\n        {\n            break;\n        }\n\n        curr = p + 1;\n    }\n}\n\n//\n// M_Drawer\n// Called after the view has been rendered,\n// but before it has been blitted.\n//\nvoid M_Drawer (void)\n{\n    static short\tx;\n    static short\ty;\n    unsigned int\ti;\n    unsigned int\tmax;\n    char\t\tstring[80];\n    const char          *name;\n    int\t\t\tstart;\n\n    inhelpscreens = false;\n    \n    // Horiz. & Vertically center string and print it.\n    if (messageToPrint)\n    {\n\tstart = 0;\n\ty = SCREENHEIGHT/2 - M_StringHeight(messageString) / 2;\n\twhile (messageString[start] != '\\0')\n\t{\n\t    int foundnewline = 0;\n\n            for (i = 0; i < strlen(messageString + start); i++)\n            {\n                if (messageString[start + i] == '\\n')\n                {\n                    M_StringCopy(string, messageString + start,\n                                 sizeof(string));\n                    if (i < sizeof(string))\n                    {\n                        string[i] = '\\0';\n                    }\n\n                    foundnewline = 1;\n                    start += i + 1;\n                    break;\n                }\n            }\n\n            if (!foundnewline)\n            {\n                M_StringCopy(string, messageString + start, sizeof(string));\n                start += strlen(string);\n            }\n\n\t    x = SCREENWIDTH/2 - M_StringWidth(string) / 2;\n\t    M_WriteText(x, y, string);\n\t    y += SHORT(hu_font[0]->height);\n\t}\n\n\treturn;\n    }\n\n    if (opldev)\n    {\n        M_DrawOPLDev();\n    }\n\n    if (!menuactive)\n\treturn;\n\n    if (currentMenu->routine)\n\tcurrentMenu->routine();         // call Draw routine\n    \n    // DRAW MENU\n    x = currentMenu->x;\n    y = currentMenu->y;\n    max = currentMenu->numitems;\n\n    for (i=0;i<max;i++)\n    {\n        name = DEH_String(currentMenu->menuitems[i].name);\n\n\tif (name[0])\n\t{\n\t    V_DrawPatchDirect (x, y, W_CacheLumpName(name, PU_CACHE));\n\t}\n\ty += LINEHEIGHT;\n    }\n\n    \n    // DRAW SKULL\n    V_DrawPatchDirect(x + SKULLXOFF, currentMenu->y - 5 + itemOn*LINEHEIGHT,\n\t\t      W_CacheLumpName(DEH_String(skullName[whichSkull]),\n\t\t\t\t      PU_CACHE));\n}\n\n\n//\n// M_ClearMenus\n//\nvoid M_ClearMenus (void)\n{\n    menuactive = 0;\n}\n\n\n\n\n//\n// M_SetupNextMenu\n//\nvoid M_SetupNextMenu(menu_t *menudef)\n{\n    currentMenu = menudef;\n    itemOn = currentMenu->lastOn;\n}\n\n\n//\n// M_Ticker\n//\nvoid M_Ticker (void)\n{\n    if (--skullAnimCounter <= 0)\n    {\n\twhichSkull ^= 1;\n\tskullAnimCounter = 8;\n    }\n}\n\n\n//\n// M_Init\n//\nvoid M_Init (void)\n{\n    currentMenu = &MainDef;\n    menuactive = 0;\n    itemOn = currentMenu->lastOn;\n    whichSkull = 0;\n    skullAnimCounter = 10;\n    screenSize = screenblocks - 3;\n    messageToPrint = 0;\n    messageString = NULL;\n    messageLastMenuActive = menuactive;\n    quickSaveSlot = -1;\n\n    // Here we could catch other version dependencies,\n    //  like HELP1/2, and four episodes.\n\n    // The same hacks were used in the original Doom EXEs.\n\n    if (gameversion >= exe_ultimate)\n    {\n        MainMenu[readthis].routine = M_ReadThis2;\n        ReadDef2.prevMenu = NULL;\n    }\n\n    if (gameversion >= exe_final && gameversion <= exe_final2)\n    {\n        ReadDef2.routine = M_DrawReadThisCommercial;\n    }\n\n    if (gamemode == commercial)\n    {\n        MainMenu[readthis] = MainMenu[quitdoom];\n        MainDef.numitems--;\n        MainDef.y += 8;\n        NewDef.prevMenu = &MainDef;\n        ReadDef1.routine = M_DrawReadThisCommercial;\n        ReadDef1.x = 330;\n        ReadDef1.y = 165;\n        ReadMenu1[rdthsempty1].routine = M_FinishReadThis;\n    }\n\n    // Versions of doom.exe before the Ultimate Doom release only had\n    // three episodes; if we're emulating one of those then don't try\n    // to show episode four. If we are, then do show episode four\n    // (should crash if missing).\n    if (gameversion < exe_ultimate)\n    {\n        EpiDef.numitems--;\n    }\n    // chex.exe shows only one episode.\n    else if (gameversion == exe_chex)\n    {\n        EpiDef.numitems = 1;\n    }\n\n    opldev = M_CheckParm(\"-opldev\") > 0;\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tRandom number LUT.\n//\n\n//\n// M_Random\n// Returns a 0-255 number\n//\n\nstatic const unsigned char rndtable[256] = {\n    0,   8, 109, 220, 222, 241, 149, 107,  75, 248, 254, 140,  16,  66 ,\n    74,  21, 211,  47,  80, 242, 154,  27, 205, 128, 161,  89,  77,  36 ,\n    95, 110,  85,  48, 212, 140, 211, 249,  22,  79, 200,  50,  28, 188 ,\n    52, 140, 202, 120,  68, 145,  62,  70, 184, 190,  91, 197, 152, 224 ,\n    149, 104,  25, 178, 252, 182, 202, 182, 141, 197,   4,  81, 181, 242 ,\n    145,  42,  39, 227, 156, 198, 225, 193, 219,  93, 122, 175, 249,   0 ,\n    175, 143,  70, 239,  46, 246, 163,  53, 163, 109, 168, 135,   2, 235 ,\n    25,  92,  20, 145, 138,  77,  69, 166,  78, 176, 173, 212, 166, 113 ,\n    94, 161,  41,  50, 239,  49, 111, 164,  70,  60,   2,  37, 171,  75 ,\n    136, 156,  11,  56,  42, 146, 138, 229,  73, 146,  77,  61,  98, 196 ,\n    135, 106,  63, 197, 195,  86,  96, 203, 113, 101, 170, 247, 181, 113 ,\n    80, 250, 108,   7, 255, 237, 129, 226,  79, 107, 112, 166, 103, 241 ,\n    24, 223, 239, 120, 198,  58,  60,  82, 128,   3, 184,  66, 143, 224 ,\n    145, 224,  81, 206, 163,  45,  63,  90, 168, 114,  59,  33, 159,  95 ,\n    28, 139, 123,  98, 125, 196,  15,  70, 194, 253,  54,  14, 109, 226 ,\n    71,  17, 161,  93, 186,  87, 244, 138,  20,  52, 123, 251,  26,  36 ,\n    17,  46,  52, 231, 232,  76,  31, 221,  84,  37, 216, 165, 212, 106 ,\n    197, 242,  98,  43,  39, 175, 254, 145, 190,  84, 118, 222, 187, 136 ,\n    120, 163, 236, 249\n};\n\nint\trndindex = 0;\nint\tprndindex = 0;\nint\tcrndindex = 0;\n\n// Which one is deterministic?\nint P_Random (void)\n{\n    prndindex = (prndindex+1)&0xff;\n    return rndtable[prndindex];\n}\n\nint M_Random (void)\n{\n    rndindex = (rndindex+1)&0xff;\n    return rndtable[rndindex];\n}\n\n// [crispy] our own private random function\nint Crispy_Random (void)\n{\n    crndindex = (crndindex+1)&0xff;\n    return rndtable[crndindex];\n}\n\nvoid M_ClearRandom (void)\n{\n    rndindex = prndindex = 0;\n}\n\n// inspired by the same routine in Eternity, thanks haleyjd\nint P_SubRandom (void)\n{\n    int r = P_Random();\n    return r - P_Random();\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 1999 id Software, Chi Hoang, Lee Killough, Jim Flynn, Rand Phares, Ty Halderman\n// Copyright(C) 2005-2014 Simon Howard\n// Copyright(C) 2017 Fabian Greffrath\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\t[crispy] additional BOOM and MBF code pointers\n//\n\n#include \"p_local.h\"\n#include \"m_random.h\"\n#include \"s_sound.h\"\n\nextern void A_Explode();\nextern void A_FaceTarget();\n\nextern boolean P_CheckMeleeRange (mobj_t *actor);\nextern void P_Thrust (player_t* player, angle_t angle, fixed_t move);\n\n// killough 11/98: kill an object\nvoid A_Die(mobj_t *actor)\n{\n  P_DamageMobj(actor, NULL, NULL, actor->health);\n}\n\n//\n// A_Detonate\n// killough 8/9/98: same as A_Explode, except that the damage is variable\n//\n\nvoid A_Detonate(mobj_t *mo)\n{\n  P_RadiusAttack(mo, mo->target, mo->info->damage);\n}\n\n//\n// killough 9/98: a mushroom explosion effect, sorta :)\n// Original idea: Linguica\n//\n\nvoid A_Mushroom(mobj_t *actor)\n{\n  int i, j, n = actor->info->damage;\n\n  // Mushroom parameters are part of code pointer's state\n  fixed_t misc1 = actor->state->misc1 ? actor->state->misc1 : FRACUNIT*4;\n  fixed_t misc2 = actor->state->misc2 ? actor->state->misc2 : FRACUNIT/2;\n\n  A_Explode(actor);               // make normal explosion\n\n  for (i = -n; i <= n; i += 8)    // launch mushroom cloud\n    for (j = -n; j <= n; j += 8)\n      {\n\tmobj_t target = *actor, *mo;\n\ttarget.x += i << FRACBITS;    // Aim in many directions from source\n\ttarget.y += j << FRACBITS;\n\ttarget.z += P_AproxDistance(i,j) * misc1;           // Aim fairly high\n\tmo = P_SpawnMissile(actor, &target, MT_FATSHOT);    // Launch fireball\n\tmo->momx = FixedMul(mo->momx, misc2);\n\tmo->momy = FixedMul(mo->momy, misc2);               // Slow down a bit\n\tmo->momz = FixedMul(mo->momz, misc2);\n\tmo->flags &= ~MF_NOGRAVITY;   // Make debris fall under gravity\n      }\n}\n\n//\n// A_BetaSkullAttack()\n// killough 10/98: this emulates the beta version's lost soul attacks\n//\n\nvoid A_BetaSkullAttack(mobj_t *actor)\n{\n  int damage;\n  if (!actor->target || actor->target->type == MT_SKULL)\n    return;\n  S_StartSound(actor, actor->info->attacksound);\n  A_FaceTarget(actor);\n  damage = (P_Random(/* pr_skullfly */)%8+1)*actor->info->damage;\n  P_DamageMobj(actor->target, actor, actor, damage);\n}\n\nvoid A_Stop(mobj_t *actor)\n{\n  actor->momx = actor->momy = actor->momz = 0;\n}\n\n//\n// killough 11/98\n//\n// The following were inspired by Len Pitre\n//\n// A small set of highly-sought-after code pointers\n//\n\nvoid A_Spawn(mobj_t *mo)\n{\n  if (mo->state->misc1)\n    {\n\t\t\t\tP_SpawnMobj(mo->x, mo->y,\n\t\t\t\t    (mo->state->misc2 << FRACBITS) + mo->z,\n\t\t\t\t    mo->state->misc1 - 1);\n    }\n}\n\nvoid A_Turn(mobj_t *mo)\n{\n  mo->angle += (angle_t)(((uint64_t) mo->state->misc1 << 32) / 360);\n}\n\nvoid A_Face(mobj_t *mo)\n{\n  mo->angle = (angle_t)(((uint64_t) mo->state->misc1 << 32) / 360);\n}\n\nvoid A_Scratch(mobj_t *mo)\n{\n  mo->target && (A_FaceTarget(mo), P_CheckMeleeRange(mo)) ?\n    mo->state->misc2 ? S_StartSound(mo, mo->state->misc2) : (void) 0,\n    P_DamageMobj(mo->target, mo, mo, mo->state->misc1) : (void) 0;\n}\n\nvoid A_PlaySound(mobj_t *mo)\n{\n  S_StartSound(mo->state->misc2 ? NULL : mo, mo->state->misc1);\n}\n\n// [crispy] this is pretty much the only action pointer that makes sense for both mobj and pspr states\nvoid A_RandomJump(mobj_t *mo, player_t *player, pspdef_t *psp)\n{\n\t// [crispy] first, try to apply to pspr states\n\tif (player && psp)\n\t{\n\t\tif (Crispy_Random() < psp->state->misc2)\n\t\t{\n\t\t\textern void P_SetPsprite (player_t *player, int position, statenum_t stnum);\n\n\t\t\tP_SetPsprite(player, psp - &player->psprites[0], psp->state->misc1);\n\t\t}\n\t}\n\telse\n\t// [crispy] second, apply to mobj states\n\tif (mo)\n\t{\n\t\tif (Crispy_Random() < mo->state->misc2)\n\t\t{\n\t\t\tP_SetMobjState(mo, mo->state->misc1);\n\t\t}\n\t}\n}\n\n//\n// This allows linedef effects to be activated inside deh frames.\n//\n\nvoid A_LineEffect(mobj_t *mo)\n{\n\tline_t junk = *lines;                          // Fake linedef set to 1st\n\tif ((junk.special = (short)mo->state->misc1))  // Linedef type\n\t{\n\t  player_t player, *oldplayer = mo->player;  // Remember player status\n\t  mo->player = &player;                      // Fake player\n\t  player.health = 100;                       // Alive player\n\t  junk.tag = (short)mo->state->misc2;        // Sector tag for linedef\n\t  if (!P_UseSpecialLine(mo, &junk, 0))       // Try using it\n\t    P_CrossSpecialLinePtr(&junk, 0, mo);     // Try crossing it\n\t  mo->player = oldplayer;                    // Restore player status\n\t}\n}\n\n//\n// A_FireOldBFG\n//\n// This function emulates Doom's Pre-Beta BFG\n// By Lee Killough 6/6/98, 7/11/98, 7/19/98, 8/20/98\n//\n// This code may not be used in other mods without appropriate credit given.\n// Code leeches will be telefragged.\n\nvoid A_FireOldBFG(mobj_t *mobj, player_t *player, pspdef_t *psp)\n{\n  int type = MT_PLASMA1;\n  extern void P_CheckMissileSpawn (mobj_t* th);\n\n  if (!player) return; // [crispy] let pspr action pointers get called from mobj states\n\n  player->ammo[weaponinfo[player->readyweapon].ammo]--;\n\n  player->extralight = 2;\n\n  do\n    {\n      mobj_t *th, *mo = player->mo;\n      angle_t an = mo->angle;\n      angle_t an1 = ((P_Random(/* pr_bfg */)&127) - 64) * (ANG90/768) + an;\n      angle_t an2 = ((P_Random(/* pr_bfg */)&127) - 64) * (ANG90/640) + ANG90;\n\n      th = P_SpawnMobj(mo->x, mo->y,\n\t\t       mo->z + 62*FRACUNIT - player->psprites[ps_weapon].sy,\n\t\t       type);\n      th->target = mo; // P_SetTarget(&th->target, mo);\n      th->angle = an1;\n      th->momx = finecosine[an1>>ANGLETOFINESHIFT] * 25;\n      th->momy = finesine[an1>>ANGLETOFINESHIFT] * 25;\n      th->momz = finetangent[an2>>ANGLETOFINESHIFT] * 25;\n      P_CheckMissileSpawn(th);\n    }\n  while ((type != MT_PLASMA2) && (type = MT_PLASMA2)); //killough: obfuscated!\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 1999 id Software, Chi Hoang, Lee Killough, Jim Flynn, Rand Phares, Ty Halderman\n// Copyright(C) 2005-2014 Simon Howard\n// Copyright(C) 2017 Fabian Greffrath\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\t[crispy] Create Blockmap\n//\n\n#include <stdlib.h>\n#include \"i_system.h\"\n#include \"p_local.h\"\n#include \"z_zone.h\"\n\n// [crispy] taken from mbfsrc/P_SETUP.C:547-707, slightly adapted\n\nvoid P_CreateBlockMap(void)\n{\n  register int i;\n  fixed_t minx = INT_MAX, miny = INT_MAX, maxx = INT_MIN, maxy = INT_MIN;\n\n  // First find limits of map\n\n  for (i=0; i<numvertexes; i++)\n    {\n      if (vertexes[i].x >> FRACBITS < minx)\n\tminx = vertexes[i].x >> FRACBITS;\n      else\n\tif (vertexes[i].x >> FRACBITS > maxx)\n\t  maxx = vertexes[i].x >> FRACBITS;\n      if (vertexes[i].y >> FRACBITS < miny)\n\tminy = vertexes[i].y >> FRACBITS;\n      else\n\tif (vertexes[i].y >> FRACBITS > maxy)\n\t  maxy = vertexes[i].y >> FRACBITS;\n    }\n\n  // [crispy] doombsp/DRAWING.M:175-178\n  minx -= 8; miny -= 8;\n  maxx += 8; maxy += 8;\n\n  // Save blockmap parameters\n\n  bmaporgx = minx << FRACBITS;\n  bmaporgy = miny << FRACBITS;\n  bmapwidth  = ((maxx-minx) >> MAPBTOFRAC) + 1;\n  bmapheight = ((maxy-miny) >> MAPBTOFRAC) + 1;\n\n  // Compute blockmap, which is stored as a 2d array of variable-sized lists.\n  //\n  // Pseudocode:\n  //\n  // For each linedef:\n  //\n  //   Map the starting and ending vertices to blocks.\n  //\n  //   Starting in the starting vertex's block, do:\n  //\n  //     Add linedef to current block's list, dynamically resizing it.\n  //\n  //     If current block is the same as the ending vertex's block, exit loop.\n  //\n  //     Move to an adjacent block by moving towards the ending block in\n  //     either the x or y direction, to the block which contains the linedef.\n\n  {\n    typedef struct { int n, nalloc, *list; } bmap_t;  // blocklist structure\n    unsigned tot = bmapwidth * bmapheight;            // size of blockmap\n    bmap_t *bmap = calloc(sizeof *bmap, tot);         // array of blocklists\n    int x, y, adx, ady, bend;\n\n    for (i=0; i < numlines; i++)\n      {\n\tint dx, dy, diff, b;\n\n\tx = (lines[i].v1->x >> FRACBITS) - minx;\n\ty = (lines[i].v1->y >> FRACBITS) - miny;\n\n\t// x-y deltas\n\tadx = lines[i].dx >> FRACBITS, dx = adx < 0 ? -1 : 1;\n\tady = lines[i].dy >> FRACBITS, dy = ady < 0 ? -1 : 1;\n\n\t// difference in preferring to move across y (>0) instead of x (<0)\n\tdiff = !adx ? 1 : !ady ? -1 :\n\t  (((x >> MAPBTOFRAC) << MAPBTOFRAC) +\n\t   (dx > 0 ? MAPBLOCKUNITS-1 : 0) - x) * (ady = abs(ady)) * dx -\n\t  (((y >> MAPBTOFRAC) << MAPBTOFRAC) +\n\t   (dy > 0 ? MAPBLOCKUNITS-1 : 0) - y) * (adx = abs(adx)) * dy;\n\n\t// starting block, and pointer to its blocklist structure\n\tb = (y >> MAPBTOFRAC)*bmapwidth + (x >> MAPBTOFRAC);\n\n\tbend = (((lines[i].v2->y >> FRACBITS) - miny) >> MAPBTOFRAC) *\n\t\t\tbmapwidth + (((lines[i].v2->x >> FRACBITS) - minx) >> MAPBTOFRAC);\n\n\t// delta for pointer when moving across y\n\tdy *= bmapwidth;\n\n\t// deltas for diff inside the loop\n\tadx <<= MAPBTOFRAC;\n\tady <<= MAPBTOFRAC;\n\n\t// Now we simply iterate block-by-block until we reach the end block.\n\twhile ((unsigned) b < tot)    // failsafe -- should ALWAYS be true\n\t  {\n\t    // Increase size of allocated list if necessary\n\t    if (bmap[b].n >= bmap[b].nalloc)\n\t      bmap[b].list = I_Realloc(bmap[b].list,\n\t\t\t\t     (bmap[b].nalloc = bmap[b].nalloc ?\n\t\t\t\t      bmap[b].nalloc*2 : 8)*sizeof*bmap->list);\n\n\t    // Add linedef to end of list\n\t    bmap[b].list[bmap[b].n++] = i;\n\n\t    // If we have reached the last block, exit\n\t    if (b == bend)\n\t      break;\n\n\t    // Move in either the x or y direction to the next block\n\t    if (diff < 0)\n\t      diff += ady, b += dx;\n\t    else\n\t      diff -= adx, b += dy;\n\t  }\n      }\n\n    // Compute the total size of the blockmap.\n    //\n    // Compression of empty blocks is performed by reserving two offset words\n    // at tot and tot+1.\n    //\n    // 4 words, unused if this routine is called, are reserved at the start.\n\n    {\n      int count = tot+6;  // we need at least 1 word per block, plus reserved's\n\n      for (i = 0; i < tot; i++)\n\tif (bmap[i].n)\n\t  count += bmap[i].n + 2; // 1 header word + 1 trailer word + blocklist\n\n      // Allocate blockmap lump with computed count\n      blockmaplump = Z_Malloc(sizeof(*blockmaplump) * count, PU_LEVEL, 0);\n    }\n\n    // Now compress the blockmap.\n    {\n      int ndx = tot += 4;         // Advance index to start of linedef lists\n      bmap_t *bp = bmap;          // Start of uncompressed blockmap\n\n      blockmaplump[ndx++] = 0;    // Store an empty blockmap list at start\n      blockmaplump[ndx++] = -1;   // (Used for compression)\n\n      for (i = 4; i < tot; i++, bp++)\n\tif (bp->n)                                      // Non-empty blocklist\n\t  {\n\t    blockmaplump[blockmaplump[i] = ndx++] = 0;  // Store index & header\n\t    do\n\t      blockmaplump[ndx++] = bp->list[--bp->n];  // Copy linedef list\n\t    while (bp->n);\n\t    blockmaplump[ndx++] = -1;                   // Store trailer\n\t    free(bp->list);                             // Free linedef list\n\t  }\n\telse            // Empty blocklist: point to reserved empty blocklist\n\t  blockmaplump[i] = tot;\n\n      free(bmap);    // Free uncompressed blockmap\n    }\n  }\n\n  // [crispy] copied over from P_LoadBlockMap()\n\tint count = sizeof(*blocklinks) * bmapwidth * bmapheight;\n\tblocklinks = Z_Malloc(count, PU_LEVEL, 0);\n\tmemset(blocklinks, 0, count);\n\tblockmap = blockmaplump+4;\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:  Ceiling aninmation (lowering, crushing, raising)\n//\n\n\n\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"p_local.h\"\n\n#include \"s_sound.h\"\n\n// State.\n#include \"doomstat.h\"\n#include \"r_state.h\"\n\n// Data.\n#include \"sounds.h\"\n\n//\n// CEILINGS\n//\n\n\nceiling_t*\tactiveceilings[MAXCEILINGS];\n\n\n//\n// T_MoveCeiling\n//\n\nvoid T_MoveCeiling (ceiling_t* ceiling)\n{\n    result_e\tres;\n\t\n    switch(ceiling->direction)\n    {\n      case 0:\n\t// IN STASIS\n\tbreak;\n      case 1:\n\t// UP\n\tres = T_MovePlane(ceiling->sector,\n\t\t\t  ceiling->speed,\n\t\t\t  ceiling->topheight,\n\t\t\t  false,1,ceiling->direction);\n\t\n\tif (!(leveltime&7))\n\t{\n\t    switch(ceiling->type)\n\t    {\n\t      case silentCrushAndRaise:\n\t\tbreak;\n\t      default:\n\t\tS_StartSound(&ceiling->sector->soundorg, sfx_stnmov);\n\t\t// ?\n\t\tbreak;\n\t    }\n\t}\n\t\n\tif (res == pastdest)\n\t{\n\t    switch(ceiling->type)\n\t    {\n\t      case raiseToHighest:\n\t\tP_RemoveActiveCeiling(ceiling);\n\t\tbreak;\n\t\t\n\t      case silentCrushAndRaise:\n\t\tS_StartSound(&ceiling->sector->soundorg, sfx_pstop);\n\t      case fastCrushAndRaise:\n\t      case crushAndRaise:\n\t\tceiling->direction = -1;\n\t\tbreak;\n\t\t\n\t      default:\n\t\tbreak;\n\t    }\n\t    \n\t}\n\tbreak;\n\t\n      case -1:\n\t// DOWN\n\tres = T_MovePlane(ceiling->sector,\n\t\t\t  ceiling->speed,\n\t\t\t  ceiling->bottomheight,\n\t\t\t  ceiling->crush,1,ceiling->direction);\n\t\n\tif (!(leveltime&7))\n\t{\n\t    switch(ceiling->type)\n\t    {\n\t      case silentCrushAndRaise: break;\n\t      default:\n\t\tS_StartSound(&ceiling->sector->soundorg, sfx_stnmov);\n\t    }\n\t}\n\t\n\tif (res == pastdest)\n\t{\n\t    switch(ceiling->type)\n\t    {\n\t      case silentCrushAndRaise:\n\t\tS_StartSound(&ceiling->sector->soundorg, sfx_pstop);\n\t      case crushAndRaise:\n\t\tceiling->speed = CEILSPEED;\n\t      case fastCrushAndRaise:\n\t\tceiling->direction = 1;\n\t\tbreak;\n\n\t      case lowerAndCrush:\n\t      case lowerToFloor:\n\t\tP_RemoveActiveCeiling(ceiling);\n\t\tbreak;\n\n\t      default:\n\t\tbreak;\n\t    }\n\t}\n\telse // ( res != pastdest )\n\t{\n\t    if (res == crushed)\n\t    {\n\t\tswitch(ceiling->type)\n\t\t{\n\t\t  case silentCrushAndRaise:\n\t\t  case crushAndRaise:\n\t\t  case lowerAndCrush:\n\t\t    ceiling->speed = CEILSPEED / 8;\n\t\t    break;\n\n\t\t  default:\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tbreak;\n    }\n}\n\n\n//\n// EV_DoCeiling\n// Move a ceiling up/down and all around!\n//\nint\nEV_DoCeiling\n( line_t*\tline,\n  ceiling_e\ttype )\n{\n    int\t\tsecnum;\n    int\t\trtn;\n    sector_t*\tsec;\n    ceiling_t*\tceiling;\n\t\n    secnum = -1;\n    rtn = 0;\n    \n    //\tReactivate in-stasis ceilings...for certain types.\n    switch(type)\n    {\n      case fastCrushAndRaise:\n      case silentCrushAndRaise:\n      case crushAndRaise:\n\tP_ActivateInStasisCeiling(line);\n      default:\n\tbreak;\n    }\n\t\n    while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n    {\n\tsec = &sectors[secnum];\n\tif (sec->ceilingdata)\n\t    continue;\n\t\n\t// new door thinker\n\trtn = 1;\n\tceiling = Z_Malloc (sizeof(*ceiling), PU_LEVSPEC, 0);\n\tP_AddThinker (&ceiling->thinker);\n\tsec->ceilingdata = ceiling;\n\tceiling->thinker.function.acp1 = (actionf_p1)T_MoveCeiling;\n\tceiling->sector = sec;\n\tceiling->crush = false;\n\t\n\tswitch(type)\n\t{\n\t  case fastCrushAndRaise:\n\t    ceiling->crush = true;\n\t    ceiling->topheight = sec->ceilingheight;\n\t    ceiling->bottomheight = sec->floorheight + (8*FRACUNIT);\n\t    ceiling->direction = -1;\n\t    ceiling->speed = CEILSPEED * 2;\n\t    break;\n\n\t  case silentCrushAndRaise:\n\t  case crushAndRaise:\n\t    ceiling->crush = true;\n\t    ceiling->topheight = sec->ceilingheight;\n\t  case lowerAndCrush:\n\t  case lowerToFloor:\n\t    ceiling->bottomheight = sec->floorheight;\n\t    if (type != lowerToFloor)\n\t\tceiling->bottomheight += 8*FRACUNIT;\n\t    ceiling->direction = -1;\n\t    ceiling->speed = CEILSPEED;\n\t    break;\n\n\t  case raiseToHighest:\n\t    ceiling->topheight = P_FindHighestCeilingSurrounding(sec);\n\t    ceiling->direction = 1;\n\t    ceiling->speed = CEILSPEED;\n\t    break;\n\t}\n\t\t\n\tceiling->tag = sec->tag;\n\tceiling->type = type;\n\tP_AddActiveCeiling(ceiling);\n    }\n    return rtn;\n}\n\n\n//\n// Add an active ceiling\n//\nvoid P_AddActiveCeiling(ceiling_t* c)\n{\n    int\t\ti;\n    \n    for (i = 0; i < MAXCEILINGS;i++)\n    {\n\tif (activeceilings[i] == NULL)\n\t{\n\t    activeceilings[i] = c;\n\t    return;\n\t}\n    }\n}\n\n\n\n//\n// Remove a ceiling's thinker\n//\nvoid P_RemoveActiveCeiling(ceiling_t* c)\n{\n    int\t\ti;\n\t\n    for (i = 0;i < MAXCEILINGS;i++)\n    {\n\tif (activeceilings[i] == c)\n\t{\n\t    activeceilings[i]->sector->ceilingdata = NULL;\n\t    P_RemoveThinker (&activeceilings[i]->thinker);\n\t    activeceilings[i] = NULL;\n\t    break;\n\t}\n    }\n}\n\n\n\n//\n// Restart a ceiling that's in-stasis\n//\nint P_ActivateInStasisCeiling(line_t* line)\n{\n    int\t\ti;\n\tint\t\trtn = 0;\n\t\n    for (i = 0;i < MAXCEILINGS;i++)\n    {\n\tif (activeceilings[i]\n\t    && (activeceilings[i]->tag == line->tag)\n\t    && (activeceilings[i]->direction == 0))\n\t{\n\t    activeceilings[i]->direction = activeceilings[i]->olddirection;\n\t    activeceilings[i]->thinker.function.acp1\n\t      = (actionf_p1)T_MoveCeiling;\n\t\trtn = 1;\n\t}\n    }\n\n\treturn rtn;\n}\n\n\n\n//\n// EV_CeilingCrushStop\n// Stop a ceiling from crushing!\n//\nint\tEV_CeilingCrushStop(line_t\t*line)\n{\n    int\t\ti;\n    int\t\trtn;\n\t\n    rtn = 0;\n    for (i = 0;i < MAXCEILINGS;i++)\n    {\n\tif (activeceilings[i]\n\t    && (activeceilings[i]->tag == line->tag)\n\t    && (activeceilings[i]->direction != 0))\n\t{\n\t    activeceilings[i]->olddirection = activeceilings[i]->direction;\n\t    activeceilings[i]->thinker.function.acv = (actionf_v)NULL;\n\t    activeceilings[i]->direction = 0;\t\t// in-stasis\n\t    rtn = 1;\n\t}\n    }\n    \n\n    return rtn;\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION: Door animation code (opening/closing)\n//\n\n\n\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"deh_main.h\"\n#include \"p_local.h\"\n#include \"i_system.h\"\n\n#include \"s_sound.h\"\n\n\n// State.\n#include \"doomstat.h\"\n#include \"r_state.h\"\n\n// Data.\n#include \"dstrings.h\"\n#include \"sounds.h\"\n\n#if 0\n//\n// Sliding door frame information\n//\nslidename_t\tslideFrameNames[MAXSLIDEDOORS] =\n{\n    {\"GDOORF1\",\"GDOORF2\",\"GDOORF3\",\"GDOORF4\",\t// front\n     \"GDOORB1\",\"GDOORB2\",\"GDOORB3\",\"GDOORB4\"},\t// back\n\t \n    {\"\\0\",\"\\0\",\"\\0\",\"\\0\"}\n};\n#endif\n\n\n//\n// VERTICAL DOORS\n//\n\n//\n// T_VerticalDoor\n//\nvoid T_VerticalDoor (vldoor_t* door)\n{\n    result_e\tres;\n\t\n    switch(door->direction)\n    {\n      case 0:\n\t// WAITING\n\tif (!--door->topcountdown)\n\t{\n\t    switch(door->type)\n\t    {\n\t      case blazeRaise:\n\t\tdoor->direction = -1; // time to go back down\n\t\tS_StartSound(&door->sector->soundorg, sfx_bdcls);\n\t\tbreak;\n\t\t\n\t      case normal:\n\t\tdoor->direction = -1; // time to go back down\n\t\tS_StartSound(&door->sector->soundorg, sfx_dorcls);\n\t\tbreak;\n\t\t\n\t      case close30ThenOpen:\n\t\tdoor->direction = 1;\n\t\tS_StartSound(&door->sector->soundorg, sfx_doropn);\n\t\tbreak;\n\t\t\n\t      default:\n\t\tbreak;\n\t    }\n\t}\n\tbreak;\n\t\n      case 2:\n\t//  INITIAL WAIT\n\tif (!--door->topcountdown)\n\t{\n\t    switch(door->type)\n\t    {\n\t      case raiseIn5Mins:\n\t\tdoor->direction = 1;\n\t\tdoor->type = normal;\n\t\tS_StartSound(&door->sector->soundorg, sfx_doropn);\n\t\tbreak;\n\t\t\n\t      default:\n\t\tbreak;\n\t    }\n\t}\n\tbreak;\n\t\n      case -1:\n\t// DOWN\n\tres = T_MovePlane(door->sector,\n\t\t\t  door->speed,\n\t\t\t  door->sector->floorheight,\n\t\t\t  false,1,door->direction);\n\tif (res == pastdest)\n\t{\n\t    switch(door->type)\n\t    {\n\t      case blazeRaise:\n\t      case blazeClose:\n\t\tdoor->sector->ceilingdata = NULL;\n\t\tP_RemoveThinker (&door->thinker);  // unlink and free\n\t\tS_StartSound(&door->sector->soundorg, sfx_bdcls);\n\t\tbreak;\n\t\t\n\t      case normal:\n\t      case closeDoor:\n\t\tdoor->sector->ceilingdata = NULL;\n\t\tP_RemoveThinker (&door->thinker);  // unlink and free\n\t\tbreak;\n\t\t\n\t      case close30ThenOpen:\n\t\tdoor->direction = 0;\n\t\tdoor->topcountdown = TICRATE*30;\n\t\tbreak;\n\t\t\n\t      default:\n\t\tbreak;\n\t    }\n\t}\n\telse if (res == crushed)\n\t{\n\t    switch(door->type)\n\t    {\n\t      case blazeClose:\n\t      case closeDoor:\t\t// DO NOT GO BACK UP!\n\t\tbreak;\n\t\t\n\t      default:\n\t\tdoor->direction = 1;\n\t\tS_StartSound(&door->sector->soundorg, sfx_doropn);\n\t\tbreak;\n\t    }\n\t}\n\tbreak;\n\t\n      case 1:\n\t// UP\n\tres = T_MovePlane(door->sector,\n\t\t\t  door->speed,\n\t\t\t  door->topheight,\n\t\t\t  false,1,door->direction);\n\t\n\tif (res == pastdest)\n\t{\n\t    switch(door->type)\n\t    {\n\t      case blazeRaise:\n\t      case normal:\n\t\tdoor->direction = 0; // wait at top\n\t\tdoor->topcountdown = door->topwait;\n\t\tbreak;\n\t\t\n\t      case close30ThenOpen:\n\t      case blazeOpen:\n\t      case openDoor:\n\t\tdoor->sector->ceilingdata = NULL;\n\t\tP_RemoveThinker (&door->thinker);  // unlink and free\n\t\tbreak;\n\t\t\n\t      default:\n\t\tbreak;\n\t    }\n\t}\n\tbreak;\n    }\n}\n\n\n//\n// EV_DoLockedDoor\n// Move a locked door up/down\n//\n\nint\nEV_DoLockedDoor\n( line_t*\tline,\n  vldoor_e\ttype,\n  mobj_t*\tthing )\n{\n    player_t*\tp;\n\t\n    p = thing->player;\n\t\n    if (!p)\n\treturn 0;\n\t\t\n    switch(line->special)\n    {\n      case 99:\t// Blue Lock\n      case 133:\n\tif ( !p )\n\t    return 0;\n\tif (!p->cards[it_bluecard] && !p->cards[it_blueskull])\n\t{\n\t    p->message = DEH_String(PD_BLUEO);\n\t    S_StartSound(NULL,sfx_oof);\n\t    return 0;\n\t}\n\tbreak;\n\t\n      case 134: // Red Lock\n      case 135:\n\tif ( !p )\n\t    return 0;\n\tif (!p->cards[it_redcard] && !p->cards[it_redskull])\n\t{\n\t    p->message = DEH_String(PD_REDO);\n\t    S_StartSound(NULL,sfx_oof);\n\t    return 0;\n\t}\n\tbreak;\n\t\n      case 136:\t// Yellow Lock\n      case 137:\n\tif ( !p )\n\t    return 0;\n\tif (!p->cards[it_yellowcard] &&\n\t    !p->cards[it_yellowskull])\n\t{\n\t    p->message = DEH_String(PD_YELLOWO);\n\t    S_StartSound(NULL,sfx_oof);\n\t    return 0;\n\t}\n\tbreak;\t\n    }\n\n    return EV_DoDoor(line,type);\n}\n\n\nint\nEV_DoDoor\n( line_t*\tline,\n  vldoor_e\ttype )\n{\n    int\t\tsecnum,rtn;\n    sector_t*\tsec;\n    vldoor_t*\tdoor;\n\t\n    secnum = -1;\n    rtn = 0;\n    \n    while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n    {\n\tsec = &sectors[secnum];\n\tif (sec->ceilingdata)\n\t    continue;\n\t\t\n\t\n\t// new door thinker\n\trtn = 1;\n\tdoor = Z_Malloc (sizeof(*door), PU_LEVSPEC, 0);\n\tP_AddThinker (&door->thinker);\n\tsec->ceilingdata = door;\n\n\tdoor->thinker.function.acp1 = (actionf_p1) T_VerticalDoor;\n\tdoor->sector = sec;\n\tdoor->type = type;\n\tdoor->topwait = VDOORWAIT;\n\tdoor->speed = VDOORSPEED;\n\t\t\n\tswitch(type)\n\t{\n\t  case blazeClose:\n\t    door->topheight = P_FindLowestCeilingSurrounding(sec);\n\t    door->topheight -= 4*FRACUNIT;\n\t    door->direction = -1;\n\t    door->speed = VDOORSPEED * 4;\n\t    S_StartSound(&door->sector->soundorg, sfx_bdcls);\n\t    break;\n\t    \n\t  case closeDoor:\n\t    door->topheight = P_FindLowestCeilingSurrounding(sec);\n\t    door->topheight -= 4*FRACUNIT;\n\t    door->direction = -1;\n\t    S_StartSound(&door->sector->soundorg, sfx_dorcls);\n\t    break;\n\t    \n\t  case close30ThenOpen:\n\t    door->topheight = sec->ceilingheight;\n\t    door->direction = -1;\n\t    S_StartSound(&door->sector->soundorg, sfx_dorcls);\n\t    break;\n\t    \n\t  case blazeRaise:\n\t  case blazeOpen:\n\t    door->direction = 1;\n\t    door->topheight = P_FindLowestCeilingSurrounding(sec);\n\t    door->topheight -= 4*FRACUNIT;\n\t    door->speed = VDOORSPEED * 4;\n\t    if (door->topheight != sec->ceilingheight)\n\t\tS_StartSound(&door->sector->soundorg, sfx_bdopn);\n\t    break;\n\t    \n\t  case normal:\n\t  case openDoor:\n\t    door->direction = 1;\n\t    door->topheight = P_FindLowestCeilingSurrounding(sec);\n\t    door->topheight -= 4*FRACUNIT;\n\t    if (door->topheight != sec->ceilingheight)\n\t\tS_StartSound(&door->sector->soundorg, sfx_doropn);\n\t    break;\n\t    \n\t  default:\n\t    break;\n\t}\n\t\t\n    }\n    return rtn;\n}\n\n\n//\n// EV_VerticalDoor : open a door manually, no tag value\n//\nvoid\nEV_VerticalDoor\n( line_t*\tline,\n  mobj_t*\tthing )\n{\n    player_t*\tplayer;\n    sector_t*\tsec;\n    vldoor_t*\tdoor;\n    int\t\tside;\n\t\n    side = 0;\t// only front sides can be used\n\n    //\tCheck for locks\n    player = thing->player;\n\t\t\n    switch(line->special)\n    {\n      case 26: // Blue Lock\n      case 32:\n\tif ( !player )\n\t    return;\n\t\n\tif (!player->cards[it_bluecard] && !player->cards[it_blueskull])\n\t{\n\t    player->message = DEH_String(PD_BLUEK);\n\t    S_StartSound(NULL,sfx_oof);\n\t    return;\n\t}\n\tbreak;\n\t\n      case 27: // Yellow Lock\n      case 34:\n\tif ( !player )\n\t    return;\n\t\n\tif (!player->cards[it_yellowcard] &&\n\t    !player->cards[it_yellowskull])\n\t{\n\t    player->message = DEH_String(PD_YELLOWK);\n\t    S_StartSound(NULL,sfx_oof);\n\t    return;\n\t}\n\tbreak;\n\t\n      case 28: // Red Lock\n      case 33:\n\tif ( !player )\n\t    return;\n\t\n\tif (!player->cards[it_redcard] && !player->cards[it_redskull])\n\t{\n\t    player->message = DEH_String(PD_REDK);\n\t    S_StartSound(NULL,sfx_oof);\n\t    return;\n\t}\n\tbreak;\n    }\n\t\n    // if the sector has an active thinker, use it\n\n    if ((short)line->sidenum[side^1] == -1)\n    {\n        I_Error(\"EV_VerticalDoor: DR special type on 1-sided linedef\");\n    }\n\n    sec = sides[ line->sidenum[side^1]] .sector;\n\n    if (sec->ceilingdata)\n    {\n\tdoor = sec->ceilingdata;\n\tswitch(line->special)\n\t{\n\t  case\t1: // ONLY FOR \"RAISE\" DOORS, NOT \"OPEN\"s\n\t  case\t26:\n\t  case\t27:\n\t  case\t28:\n\t  case\t117:\n\t    if (door->direction == -1)\n\t\tdoor->direction = 1;\t// go back up\n\t    else\n\t    {\n\t\tif (!thing->player)\n\t\t    return;\t\t// JDC: bad guys never close doors\n\n                // When is a door not a door?\n                // In Vanilla, door->direction is set, even though\n                // \"specialdata\" might not actually point at a door.\n\n                if (door->thinker.function.acp1 == (actionf_p1) T_VerticalDoor)\n                {\n                    door->direction = -1;\t// start going down immediately\n                }\n                else if (door->thinker.function.acp1 == (actionf_p1) T_PlatRaise)\n                {\n                    // Erm, this is a plat, not a door.\n                    // This notably causes a problem in ep1-0500.lmp where\n                    // a plat and a door are cross-referenced; the door\n                    // doesn't open on 64-bit.\n                    // The direction field in vldoor_t corresponds to the wait\n                    // field in plat_t.  Let's set that to -1 instead.\n\n                    plat_t *plat;\n\n                    plat = (plat_t *) door;\n                    plat->wait = -1;\n                }\n                else\n                {\n                    // This isn't a door OR a plat.  Now we're in trouble.\n\n                    fprintf(stderr, \"EV_VerticalDoor: Tried to close \"\n                                    \"something that wasn't a door.\\n\");\n\n                    // Try closing it anyway. At least it will work on 32-bit\n                    // machines.\n\n                    door->direction = -1;\n                }\n\t    }\n\t    return;\n\t}\n    }\n\t\n    // for proper sound\n    switch(line->special)\n    {\n      case 117:\t// BLAZING DOOR RAISE\n      case 118:\t// BLAZING DOOR OPEN\n\tS_StartSound(&sec->soundorg,sfx_bdopn);\n\tbreak;\n\t\n      case 1:\t// NORMAL DOOR SOUND\n      case 31:\n\tS_StartSound(&sec->soundorg,sfx_doropn);\n\tbreak;\n\t\n      default:\t// LOCKED DOOR SOUND\n\tS_StartSound(&sec->soundorg,sfx_doropn);\n\tbreak;\n    }\n\t\n    \n    // new door thinker\n    door = Z_Malloc (sizeof(*door), PU_LEVSPEC, 0);\n    P_AddThinker (&door->thinker);\n    sec->ceilingdata = door;\n    door->thinker.function.acp1 = (actionf_p1) T_VerticalDoor;\n    door->sector = sec;\n    door->direction = 1;\n    door->speed = VDOORSPEED;\n    door->topwait = VDOORWAIT;\n\n    switch(line->special)\n    {\n      case 1:\n      case 26:\n      case 27:\n      case 28:\n\tdoor->type = normal;\n\tbreak;\n\t\n      case 31:\n      case 32:\n      case 33:\n      case 34:\n\tdoor->type = openDoor;\n\tline->special = 0;\n\tbreak;\n\t\n      case 117:\t// blazing door raise\n\tdoor->type = blazeRaise;\n\tdoor->speed = VDOORSPEED*4;\n\tbreak;\n      case 118:\t// blazing door open\n\tdoor->type = blazeOpen;\n\tline->special = 0;\n\tdoor->speed = VDOORSPEED*4;\n\tbreak;\n    }\n    \n    // find the top and bottom of the movement range\n    door->topheight = P_FindLowestCeilingSurrounding(sec);\n    door->topheight -= 4*FRACUNIT;\n}\n\n\n//\n// Spawn a door that closes after 30 seconds\n//\nvoid P_SpawnDoorCloseIn30 (sector_t* sec)\n{\n    vldoor_t*\tdoor;\n\t\n    door = Z_Malloc ( sizeof(*door), PU_LEVSPEC, 0);\n\n    P_AddThinker (&door->thinker);\n\n    sec->ceilingdata = door;\n    sec->special = 0;\n\n    door->thinker.function.acp1 = (actionf_p1)T_VerticalDoor;\n    door->sector = sec;\n    door->direction = 0;\n    door->type = normal;\n    door->speed = VDOORSPEED;\n    door->topcountdown = 30 * TICRATE;\n}\n\n//\n// Spawn a door that opens after 5 minutes\n//\nvoid\nP_SpawnDoorRaiseIn5Mins\n( sector_t*\tsec,\n  int\t\tsecnum )\n{\n    vldoor_t*\tdoor;\n\t\n    door = Z_Malloc ( sizeof(*door), PU_LEVSPEC, 0);\n    \n    P_AddThinker (&door->thinker);\n\n    sec->ceilingdata = door;\n    sec->special = 0;\n\n    door->thinker.function.acp1 = (actionf_p1)T_VerticalDoor;\n    door->sector = sec;\n    door->direction = 2;\n    door->type = raiseIn5Mins;\n    door->speed = VDOORSPEED;\n    door->topheight = P_FindLowestCeilingSurrounding(sec);\n    door->topheight -= 4*FRACUNIT;\n    door->topwait = VDOORWAIT;\n    door->topcountdown = 5 * 60 * TICRATE;\n}\n\n\n\n// UNUSED\n// Separate into p_slidoor.c?\n\n#if 0\t\t// ABANDONED TO THE MISTS OF TIME!!!\n//\n// EV_SlidingDoor : slide a door horizontally\n// (animate midtexture, then set noblocking line)\n//\n\n\nslideframe_t slideFrames[MAXSLIDEDOORS];\n\nvoid P_InitSlidingDoorFrames(void)\n{\n    int\t\ti;\n    int\t\tf1;\n    int\t\tf2;\n    int\t\tf3;\n    int\t\tf4;\n\t\n    // DOOM II ONLY...\n    if ( gamemode != commercial)\n\treturn;\n\t\n    for (i = 0;i < MAXSLIDEDOORS; i++)\n    {\n\tif (!slideFrameNames[i].frontFrame1[0])\n\t    break;\n\t\t\t\n\tf1 = R_TextureNumForName(slideFrameNames[i].frontFrame1);\n\tf2 = R_TextureNumForName(slideFrameNames[i].frontFrame2);\n\tf3 = R_TextureNumForName(slideFrameNames[i].frontFrame3);\n\tf4 = R_TextureNumForName(slideFrameNames[i].frontFrame4);\n\n\tslideFrames[i].frontFrames[0] = f1;\n\tslideFrames[i].frontFrames[1] = f2;\n\tslideFrames[i].frontFrames[2] = f3;\n\tslideFrames[i].frontFrames[3] = f4;\n\t\t\n\tf1 = R_TextureNumForName(slideFrameNames[i].backFrame1);\n\tf2 = R_TextureNumForName(slideFrameNames[i].backFrame2);\n\tf3 = R_TextureNumForName(slideFrameNames[i].backFrame3);\n\tf4 = R_TextureNumForName(slideFrameNames[i].backFrame4);\n\n\tslideFrames[i].backFrames[0] = f1;\n\tslideFrames[i].backFrames[1] = f2;\n\tslideFrames[i].backFrames[2] = f3;\n\tslideFrames[i].backFrames[3] = f4;\n    }\n}\n\n\n//\n// Return index into \"slideFrames\" array\n// for which door type to use\n//\nint P_FindSlidingDoorType(line_t*\tline)\n{\n    int\t\ti;\n    int\t\tval;\n\t\n    for (i = 0;i < MAXSLIDEDOORS;i++)\n    {\n\tval = sides[line->sidenum[0]].midtexture;\n\tif (val == slideFrames[i].frontFrames[0])\n\t    return i;\n    }\n\t\n    return -1;\n}\n\nvoid T_SlidingDoor (slidedoor_t*\tdoor)\n{\n    switch(door->status)\n    {\n      case sd_opening:\n\tif (!door->timer--)\n\t{\n\t    if (++door->frame == SNUMFRAMES)\n\t    {\n\t\t// IF DOOR IS DONE OPENING...\n\t\tsides[door->line->sidenum[0]].midtexture = 0;\n\t\tsides[door->line->sidenum[1]].midtexture = 0;\n\t\tdoor->line->flags &= ML_BLOCKING^0xff;\n\t\t\t\t\t\n\t\tif (door->type == sdt_openOnly)\n\t\t{\n\t\t    door->frontsector->specialdata = NULL;\n\t\t    P_RemoveThinker (&door->thinker);\n\t\t    break;\n\t\t}\n\t\t\t\t\t\n\t\tdoor->timer = SDOORWAIT;\n\t\tdoor->status = sd_waiting;\n\t    }\n\t    else\n\t    {\n\t\t// IF DOOR NEEDS TO ANIMATE TO NEXT FRAME...\n\t\tdoor->timer = SWAITTICS;\n\t\t\t\t\t\n\t\tsides[door->line->sidenum[0]].midtexture =\n\t\t    slideFrames[door->whichDoorIndex].\n\t\t    frontFrames[door->frame];\n\t\tsides[door->line->sidenum[1]].midtexture =\n\t\t    slideFrames[door->whichDoorIndex].\n\t\t    backFrames[door->frame];\n\t    }\n\t}\n\tbreak;\n\t\t\t\n      case sd_waiting:\n\t// IF DOOR IS DONE WAITING...\n\tif (!door->timer--)\n\t{\n\t    // CAN DOOR CLOSE?\n\t    if (door->frontsector->thinglist != NULL ||\n\t\tdoor->backsector->thinglist != NULL)\n\t    {\n\t\tdoor->timer = SDOORWAIT;\n\t\tbreak;\n\t    }\n\n\t    //door->frame = SNUMFRAMES-1;\n\t    door->status = sd_closing;\n\t    door->timer = SWAITTICS;\n\t}\n\tbreak;\n\t\t\t\n      case sd_closing:\n\tif (!door->timer--)\n\t{\n\t    if (--door->frame < 0)\n\t    {\n\t\t// IF DOOR IS DONE CLOSING...\n\t\tdoor->line->flags |= ML_BLOCKING;\n\t\tdoor->frontsector->specialdata = NULL;\n\t\tP_RemoveThinker (&door->thinker);\n\t\tbreak;\n\t    }\n\t    else\n\t    {\n\t\t// IF DOOR NEEDS TO ANIMATE TO NEXT FRAME...\n\t\tdoor->timer = SWAITTICS;\n\t\t\t\t\t\n\t\tsides[door->line->sidenum[0]].midtexture =\n\t\t    slideFrames[door->whichDoorIndex].\n\t\t    frontFrames[door->frame];\n\t\tsides[door->line->sidenum[1]].midtexture =\n\t\t    slideFrames[door->whichDoorIndex].\n\t\t    backFrames[door->frame];\n\t    }\n\t}\n\tbreak;\n    }\n}\n\n\n\nvoid\nEV_SlidingDoor\n( line_t*\tline,\n  mobj_t*\tthing )\n{\n    sector_t*\t\tsec;\n    slidedoor_t*\tdoor;\n\t\n    // DOOM II ONLY...\n    if (gamemode != commercial)\n\treturn;\n    \n    // Make sure door isn't already being animated\n    sec = line->frontsector;\n    door = NULL;\n    if (sec->specialdata)\n    {\n\tif (!thing->player)\n\t    return;\n\t\t\t\n\tdoor = sec->specialdata;\n\tif (door->type == sdt_openAndClose)\n\t{\n\t    if (door->status == sd_waiting)\n\t\tdoor->status = sd_closing;\n\t}\n\telse\n\t    return;\n    }\n    \n    // Init sliding door vars\n    if (!door)\n    {\n\tdoor = Z_Malloc (sizeof(*door), PU_LEVSPEC, 0);\n\tP_AddThinker (&door->thinker);\n\tsec->specialdata = door;\n\t\t\n\tdoor->type = sdt_openAndClose;\n\tdoor->status = sd_opening;\n\tdoor->whichDoorIndex = P_FindSlidingDoorType(line);\n\n\tif (door->whichDoorIndex < 0)\n\t    I_Error(\"EV_SlidingDoor: Can't use texture for sliding door!\");\n\t\t\t\n\tdoor->frontsector = sec;\n\tdoor->backsector = line->backsector;\n\tdoor->thinker.function = T_SlidingDoor;\n\tdoor->timer = SWAITTICS;\n\tdoor->frame = 0;\n\tdoor->line = line;\n    }\n}\n#endif\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tFloor animation: raising stairs.\n//\n\n\n\n#include \"z_zone.h\"\n#include \"doomdef.h\"\n#include \"p_local.h\"\n\n#include \"s_sound.h\"\n\n// State.\n#include \"doomstat.h\"\n#include \"r_state.h\"\n// Data.\n#include \"sounds.h\"\n\n\n//\n// FLOORS\n//\n\n//\n// Move a plane (floor or ceiling) and check for crushing\n//\nresult_e\nT_MovePlane\n( sector_t*\tsector,\n  fixed_t\tspeed,\n  fixed_t\tdest,\n  boolean\tcrush,\n  int\t\tfloorOrCeiling,\n  int\t\tdirection )\n{\n    boolean\tflag;\n    fixed_t\tlastpos;\n\t\n    switch(floorOrCeiling)\n    {\n      case 0:\n\t// FLOOR\n\tswitch(direction)\n\t{\n\t  case -1:\n\t    // DOWN\n\t    if (sector->floorheight - speed < dest)\n\t    {\n\t\tlastpos = sector->floorheight;\n\t\tsector->floorheight = dest;\n\t\tflag = P_ChangeSector(sector,crush);\n\t\tif (flag == true)\n\t\t{\n\t\t    sector->floorheight =lastpos;\n\t\t    P_ChangeSector(sector,crush);\n\t\t    //return crushed;\n\t\t}\n\t\treturn pastdest;\n\t    }\n\t    else\n\t    {\n\t\tlastpos = sector->floorheight;\n\t\tsector->floorheight -= speed;\n\t\tflag = P_ChangeSector(sector,crush);\n\t\tif (flag == true)\n\t\t{\n\t\t    sector->floorheight = lastpos;\n\t\t    P_ChangeSector(sector,crush);\n\t\t    return crushed;\n\t\t}\n\t    }\n\t    break;\n\t\t\t\t\t\t\n\t  case 1:\n\t    // UP\n\t    if (sector->floorheight + speed > dest)\n\t    {\n\t\tlastpos = sector->floorheight;\n\t\tsector->floorheight = dest;\n\t\tflag = P_ChangeSector(sector,crush);\n\t\tif (flag == true)\n\t\t{\n\t\t    sector->floorheight = lastpos;\n\t\t    P_ChangeSector(sector,crush);\n\t\t    //return crushed;\n\t\t}\n\t\treturn pastdest;\n\t    }\n\t    else\n\t    {\n\t\t// COULD GET CRUSHED\n\t\tlastpos = sector->floorheight;\n\t\tsector->floorheight += speed;\n\t\tflag = P_ChangeSector(sector,crush);\n\t\tif (flag == true)\n\t\t{\n\t\t    if (crush == true)\n\t\t\treturn crushed;\n\t\t    sector->floorheight = lastpos;\n\t\t    P_ChangeSector(sector,crush);\n\t\t    return crushed;\n\t\t}\n\t    }\n\t    break;\n\t}\n\tbreak;\n\t\t\t\t\t\t\t\t\t\n      case 1:\n\t// CEILING\n\tswitch(direction)\n\t{\n\t  case -1:\n\t    // DOWN\n\t    if (sector->ceilingheight - speed < dest)\n\t    {\n\t\tlastpos = sector->ceilingheight;\n\t\tsector->ceilingheight = dest;\n\t\tflag = P_ChangeSector(sector,crush);\n\n\t\tif (flag == true)\n\t\t{\n\t\t    sector->ceilingheight = lastpos;\n\t\t    P_ChangeSector(sector,crush);\n\t\t    //return crushed;\n\t\t}\n\t\treturn pastdest;\n\t    }\n\t    else\n\t    {\n\t\t// COULD GET CRUSHED\n\t\tlastpos = sector->ceilingheight;\n\t\tsector->ceilingheight -= speed;\n\t\tflag = P_ChangeSector(sector,crush);\n\n\t\tif (flag == true)\n\t\t{\n\t\t    if (crush == true)\n\t\t\treturn crushed;\n\t\t    sector->ceilingheight = lastpos;\n\t\t    P_ChangeSector(sector,crush);\n\t\t    return crushed;\n\t\t}\n\t    }\n\t    break;\n\t\t\t\t\t\t\n\t  case 1:\n\t    // UP\n\t    if (sector->ceilingheight + speed > dest)\n\t    {\n\t\tlastpos = sector->ceilingheight;\n\t\tsector->ceilingheight = dest;\n\t\tflag = P_ChangeSector(sector,crush);\n\t\tif (flag == true)\n\t\t{\n\t\t    sector->ceilingheight = lastpos;\n\t\t    P_ChangeSector(sector,crush);\n\t\t    //return crushed;\n\t\t}\n\t\treturn pastdest;\n\t    }\n\t    else\n\t    {\n\t\tlastpos = sector->ceilingheight;\n\t\tsector->ceilingheight += speed;\n\t\tflag = P_ChangeSector(sector,crush);\n// UNUSED\n#if 0\n\t\tif (flag == true)\n\t\t{\n\t\t    sector->ceilingheight = lastpos;\n\t\t    P_ChangeSector(sector,crush);\n\t\t    return crushed;\n\t\t}\n#endif\n\t    }\n\t    break;\n\t}\n\tbreak;\n\t\t\n    }\n    return ok;\n}\n\n\n//\n// MOVE A FLOOR TO IT'S DESTINATION (UP OR DOWN)\n//\nvoid T_MoveFloor(floormove_t* floor)\n{\n    result_e\tres;\n\t\n    res = T_MovePlane(floor->sector,\n\t\t      floor->speed,\n\t\t      floor->floordestheight,\n\t\t      floor->crush,0,floor->direction);\n    \n    if (!(leveltime&7))\n\tS_StartSound(&floor->sector->soundorg, sfx_stnmov);\n    \n    if (res == pastdest)\n    {\n\tfloor->sector->floordata = NULL;\n\n\tif (floor->direction == 1)\n\t{\n\t    switch(floor->type)\n\t    {\n\t      case donutRaise:\n\t\tfloor->sector->special = floor->newspecial;\n\t\tfloor->sector->floorpic = floor->texture;\n\t      default:\n\t\tbreak;\n\t    }\n\t}\n\telse if (floor->direction == -1)\n\t{\n\t    switch(floor->type)\n\t    {\n\t      case lowerAndChange:\n\t\tfloor->sector->special = floor->newspecial;\n\t\tfloor->sector->floorpic = floor->texture;\n\t      default:\n\t\tbreak;\n\t    }\n\t}\n\tP_RemoveThinker(&floor->thinker);\n\n\tS_StartSound(&floor->sector->soundorg, sfx_pstop);\n    }\n\n}\n\n//\n// T_MoveElevator()\n//\n// Move an elevator to it's destination (up or down)\n// Called once per tick for each moving floor.\n//\n// Passed an elevator_t structure that contains all pertinent info about the\n// move. See P_SPEC.H for fields.\n// No return.\n//\n// jff 02/22/98 added to support parallel floor/ceiling motion\n//\nvoid T_MoveElevator(elevator_t* elevator)\n{\n  result_e      res;\n\n  if (elevator->direction<0)      // moving down\n  {\n    res = T_MovePlane             //jff 4/7/98 reverse order of ceiling/floor\n    (\n      elevator->sector,\n      elevator->speed,\n      elevator->ceilingdestheight,\n      0,\n      1,                          // move floor\n      elevator->direction\n    );\n    if (res==ok || res==pastdest) // jff 4/7/98 don't move ceil if blocked\n      T_MovePlane\n      (\n        elevator->sector,\n        elevator->speed,\n        elevator->floordestheight,\n        0,\n        0,                        // move ceiling\n        elevator->direction\n      );\n  }\n  else // up\n  {\n    res = T_MovePlane             //jff 4/7/98 reverse order of ceiling/floor\n    (\n      elevator->sector,\n      elevator->speed,\n      elevator->floordestheight,\n      0,\n      0,                          // move ceiling\n      elevator->direction\n    );\n    if (res==ok || res==pastdest) // jff 4/7/98 don't move floor if blocked\n      T_MovePlane\n      (\n        elevator->sector,\n        elevator->speed,\n        elevator->ceilingdestheight,\n        0,\n        1,                        // move floor\n        elevator->direction\n      );\n  }\n\n  // make floor move sound\n  if (!(leveltime&7))\n    S_StartSound((mobj_t *)&elevator->sector->soundorg, sfx_stnmov);\n\n  if (res == pastdest)            // if destination height acheived\n  {\n    elevator->sector->floordata = NULL;     //jff 2/22/98\n    elevator->sector->ceilingdata = NULL;   //jff 2/22/98\n    P_RemoveThinker(&elevator->thinker);    // remove elevator from actives\n\n    // make floor stop sound\n    S_StartSound((mobj_t *)&elevator->sector->soundorg, sfx_pstop);\n  }\n}\n\n//\n// HANDLE FLOOR TYPES\n//\nint\nEV_DoFloor\n( line_t*\tline,\n  floor_e\tfloortype )\n{\n    int\t\t\tsecnum;\n    int\t\t\trtn;\n    int\t\t\ti;\n    sector_t*\t\tsec;\n    floormove_t*\tfloor;\n\n    secnum = -1;\n    rtn = 0;\n    while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n    {\n\tsec = &sectors[secnum];\n\t\t\n\t// ALREADY MOVING?  IF SO, KEEP GOING...\n\tif (sec->floordata)\n\t    continue;\n\t\n\t// new floor thinker\n\trtn = 1;\n\tfloor = Z_Malloc (sizeof(*floor), PU_LEVSPEC, 0);\n\tP_AddThinker (&floor->thinker);\n\tsec->floordata = floor;\n\tfloor->thinker.function.acp1 = (actionf_p1) T_MoveFloor;\n\tfloor->type = floortype;\n\tfloor->crush = false;\n\n\tswitch(floortype)\n\t{\n\t  case lowerFloor:\n\t    floor->direction = -1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED;\n\t    floor->floordestheight = \n\t\tP_FindHighestFloorSurrounding(sec);\n\t    break;\n\n\t  case lowerFloorToLowest:\n\t    floor->direction = -1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED;\n\t    floor->floordestheight = \n\t\tP_FindLowestFloorSurrounding(sec);\n\t    break;\n\n\t  case turboLower:\n\t    floor->direction = -1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED * 4;\n\t    floor->floordestheight = \n\t\tP_FindHighestFloorSurrounding(sec);\n\t    if (floor->floordestheight != sec->floorheight)\n\t\tfloor->floordestheight += 8*FRACUNIT;\n\t    break;\n\n\t  case raiseFloorCrush:\n\t    floor->crush = true;\n\t  case raiseFloor:\n\t    floor->direction = 1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED;\n\t    floor->floordestheight = \n\t\tP_FindLowestCeilingSurrounding(sec);\n\t    if (floor->floordestheight > sec->ceilingheight)\n\t\tfloor->floordestheight = sec->ceilingheight;\n\t    floor->floordestheight -= (8*FRACUNIT)*\n\t\t(floortype == raiseFloorCrush);\n\t    break;\n\n\t  case raiseFloorTurbo:\n\t    floor->direction = 1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED*4;\n\t    floor->floordestheight = \n\t\tP_FindNextHighestFloor(sec,sec->floorheight);\n\t    break;\n\n\t  case raiseFloorToNearest:\n\t    floor->direction = 1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED;\n\t    floor->floordestheight = \n\t\tP_FindNextHighestFloor(sec,sec->floorheight);\n\t    break;\n\n\t  case raiseFloor24:\n\t    floor->direction = 1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED;\n\t    floor->floordestheight = floor->sector->floorheight +\n\t\t24 * FRACUNIT;\n\t    break;\n\t  case raiseFloor512:\n\t    floor->direction = 1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED;\n\t    floor->floordestheight = floor->sector->floorheight +\n\t\t512 * FRACUNIT;\n\t    break;\n\n\t  case raiseFloor24AndChange:\n\t    floor->direction = 1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED;\n\t    floor->floordestheight = floor->sector->floorheight +\n\t\t24 * FRACUNIT;\n\t    sec->floorpic = line->frontsector->floorpic;\n\t    sec->special = line->frontsector->special;\n\t    break;\n\n\t  case raiseToTexture:\n\t  {\n\t      int\tminsize = INT_MAX;\n\t      side_t*\tside;\n\t\t\t\t\n\t      floor->direction = 1;\n\t      floor->sector = sec;\n\t      floor->speed = FLOORSPEED;\n\t      for (i = 0; i < sec->linecount; i++)\n\t      {\n\t\t  if (twoSided (secnum, i) )\n\t\t  {\n\t\t      side = getSide(secnum,i,0);\n\t\t      if (side->bottomtexture >= 0)\n\t\t\t  if (textureheight[side->bottomtexture] < \n\t\t\t      minsize)\n\t\t\t      minsize = \n\t\t\t\t  textureheight[side->bottomtexture];\n\t\t      side = getSide(secnum,i,1);\n\t\t      if (side->bottomtexture >= 0)\n\t\t\t  if (textureheight[side->bottomtexture] < \n\t\t\t      minsize)\n\t\t\t      minsize = \n\t\t\t\t  textureheight[side->bottomtexture];\n\t\t  }\n\t      }\n\t      floor->floordestheight =\n\t\t  floor->sector->floorheight + minsize;\n\t  }\n\t  break;\n\t  \n\t  case lowerAndChange:\n\t    floor->direction = -1;\n\t    floor->sector = sec;\n\t    floor->speed = FLOORSPEED;\n\t    floor->floordestheight = \n\t\tP_FindLowestFloorSurrounding(sec);\n\t    floor->texture = sec->floorpic;\n\n\t    for (i = 0; i < sec->linecount; i++)\n\t    {\n\t\tif ( twoSided(secnum, i) )\n\t\t{\n\t\t    if (getSide(secnum,i,0)->sector-sectors == secnum)\n\t\t    {\n\t\t\tsec = getSector(secnum,i,1);\n\n\t\t\tif (sec->floorheight == floor->floordestheight)\n\t\t\t{\n\t\t\t    floor->texture = sec->floorpic;\n\t\t\t    floor->newspecial = sec->special;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\tsec = getSector(secnum,i,0);\n\n\t\t\tif (sec->floorheight == floor->floordestheight)\n\t\t\t{\n\t\t\t    floor->texture = sec->floorpic;\n\t\t\t    floor->newspecial = sec->special;\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    }\n\t  default:\n\t    break;\n\t}\n    }\n    return rtn;\n}\n\n\n\n\n//\n// BUILD A STAIRCASE!\n//\nint\nEV_BuildStairs\n( line_t*\tline,\n  stair_e\ttype )\n{\n    int\t\t\tsecnum;\n    int\t\t\theight;\n    int\t\t\ti;\n    int\t\t\tnewsecnum;\n    int\t\t\ttexture;\n    int\t\t\tok;\n    int\t\t\trtn;\n    \n    sector_t*\t\tsec;\n    sector_t*\t\ttsec;\n\n    floormove_t*\tfloor;\n    \n    fixed_t\t\tstairsize = 0;\n    fixed_t\t\tspeed = 0;\n\n    secnum = -1;\n    rtn = 0;\n    while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n    {\n\tsec = &sectors[secnum];\n\t\t\n\t// ALREADY MOVING?  IF SO, KEEP GOING...\n\tif (sec->floordata)\n\t    continue;\n\t\n\t// new floor thinker\n\trtn = 1;\n\tfloor = Z_Malloc (sizeof(*floor), PU_LEVSPEC, 0);\n\tP_AddThinker (&floor->thinker);\n\tsec->floordata = floor;\n\tfloor->thinker.function.acp1 = (actionf_p1) T_MoveFloor;\n\tfloor->direction = 1;\n\tfloor->sector = sec;\n\tswitch(type)\n\t{\n\t  case build8:\n\t    speed = FLOORSPEED/4;\n\t    stairsize = 8*FRACUNIT;\n\t    break;\n\t  case turbo16:\n\t    speed = FLOORSPEED*4;\n\t    stairsize = 16*FRACUNIT;\n\t    break;\n\t}\n\tfloor->speed = speed;\n\theight = sec->floorheight + stairsize;\n\tfloor->floordestheight = height;\n\t// Initialize\n\tfloor->type = lowerFloor;\n\tfloor->crush = true;\n\t\t\n\ttexture = sec->floorpic;\n\t\n\t// Find next sector to raise\n\t// 1.\tFind 2-sided line with same sector side[0]\n\t// 2.\tOther side is the next sector to raise\n\tdo\n\t{\n\t    ok = 0;\n\t    for (i = 0;i < sec->linecount;i++)\n\t    {\n\t\tif ( !((sec->lines[i])->flags & ML_TWOSIDED) )\n\t\t    continue;\n\t\t\t\t\t\n\t\ttsec = (sec->lines[i])->frontsector;\n\t\tnewsecnum = tsec-sectors;\n\t\t\n\t\tif (secnum != newsecnum)\n\t\t    continue;\n\n\t\ttsec = (sec->lines[i])->backsector;\n\t\tnewsecnum = tsec - sectors;\n\n\t\tif (tsec->floorpic != texture)\n\t\t    continue;\n\t\t\t\t\t\n\t\theight += stairsize;\n\n\t\tif (tsec->floordata)\n\t\t    continue;\n\t\t\t\t\t\n\t\tsec = tsec;\n\t\tsecnum = newsecnum;\n\t\tfloor = Z_Malloc (sizeof(*floor), PU_LEVSPEC, 0);\n\n\t\tP_AddThinker (&floor->thinker);\n\n\t\tsec->floordata = floor;\n\t\tfloor->thinker.function.acp1 = (actionf_p1) T_MoveFloor;\n\t\tfloor->direction = 1;\n\t\tfloor->sector = sec;\n\t\tfloor->speed = speed;\n\t\tfloor->floordestheight = height;\n\t\t// Initialize\n\t\tfloor->type = lowerFloor;\n\t\tfloor->crush = true;\n\t\tok = 1;\n\t\tbreak;\n\t    }\n\t} while(ok);\n    }\n    return rtn;\n}\n\n//\n// EV_DoChange()\n//\n// Handle pure change types. These change floor texture and sector type\n// by trigger or numeric model without moving the floor.\n//\n// The linedef causing the change and the type of change is passed\n// Returns true if any sector changes\n//\n// jff 3/15/98 added to better support generalized sector types\n//\nint EV_DoChange\n( line_t*       line,\n  change_e      changetype )\n{\n  int                   secnum;\n  int                   rtn;\n  sector_t*             sec;\n  sector_t*             secm;\n\n  secnum = -1;\n  rtn = 0;\n  // change all sectors with the same tag as the linedef\n  while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n  {\n    sec = &sectors[secnum];\n\n    rtn = 1;\n\n    // handle trigger or numeric change type\n    switch(changetype)\n    {\n      case trigChangeOnly:\n        sec->floorpic = line->frontsector->floorpic;\n        sec->special = line->frontsector->special;\n        sec->oldspecial = line->frontsector->oldspecial;\n        break;\n      case numChangeOnly:\n        secm = P_FindModelFloorSector(sec->floorheight,secnum);\n        if (secm) // if no model, no change\n        {\n          sec->floorpic = secm->floorpic;\n          sec->special = secm->special;\n          sec->oldspecial = secm->oldspecial;\n        }\n        break;\n      default:\n        break;\n    }\n  }\n  return rtn;\n}\n\n//\n// EV_DoElevator\n//\n// Handle elevator linedef types\n//\n// Passed the linedef that triggered the elevator and the elevator action\n//\n// jff 2/22/98 new type to move floor and ceiling in parallel\n//\nint EV_DoElevator\n( line_t*       line,\n  elevator_e    elevtype )\n{\n  int                   secnum;\n  int                   rtn;\n  sector_t*             sec;\n  elevator_t*           elevator;\n\n  secnum = -1;\n  rtn = 0;\n  // act on all sectors with the same tag as the triggering linedef\n  while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n  {\n    sec = &sectors[secnum];\n\n    // If either floor or ceiling is already activated, skip it\n    if (sec->floordata || sec->ceilingdata) //jff 2/22/98\n      continue;\n\n    // create and initialize new elevator thinker\n    rtn = 1;\n    elevator = Z_Malloc (sizeof(*elevator), PU_LEVSPEC, 0);\n    memset(elevator, 0, sizeof(*elevator));\n    P_AddThinker (&elevator->thinker);\n    sec->floordata = elevator; //jff 2/22/98\n    sec->ceilingdata = elevator; //jff 2/22/98\n    elevator->thinker.function.acp1 = (actionf_p1) T_MoveElevator;\n    elevator->type = elevtype;\n\n    // set up the fields according to the type of elevator action\n    switch(elevtype)\n    {\n        // elevator down to next floor\n      case elevateDown:\n        elevator->direction = -1;\n        elevator->sector = sec;\n        elevator->speed = ELEVATORSPEED;\n        elevator->floordestheight =\n          P_FindNextLowestFloor(sec,sec->floorheight);\n        elevator->ceilingdestheight =\n          elevator->floordestheight + sec->ceilingheight - sec->floorheight;\n        break;\n\n        // elevator up to next floor\n      case elevateUp:\n        elevator->direction = 1;\n        elevator->sector = sec;\n        elevator->speed = ELEVATORSPEED;\n        elevator->floordestheight =\n          P_FindNextHighestFloor(sec,sec->floorheight);\n        elevator->ceilingdestheight =\n          elevator->floordestheight + sec->ceilingheight - sec->floorheight;\n        break;\n\n        // elevator to floor height of activating switch's front sector\n      case elevateCurrent:\n        elevator->sector = sec;\n        elevator->speed = ELEVATORSPEED;\n        elevator->floordestheight = line->frontsector->floorheight;\n        elevator->ceilingdestheight =\n          elevator->floordestheight + sec->ceilingheight - sec->floorheight;\n        elevator->direction =\n          elevator->floordestheight>sec->floorheight?  1 : -1;\n        break;\n\n      default:\n        break;\n    }\n  }\n  return rtn;\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//   System interface for music.\n//\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"memio.h\"\n#include \"mus2mid.h\"\n\n#include \"deh_main.h\"\n#include \"i_sound.h\"\n#include \"i_swap.h\"\n#include \"m_misc.h\"\n#include \"w_wad.h\"\n#include \"z_zone.h\"\n\n#include \"opl.h\"\n#include \"midifile.h\"\n\n// #define OPL_MIDI_DEBUG\n\n#define MAXMIDLENGTH (96 * 1024)\n#define GENMIDI_NUM_INSTRS  128\n#define GENMIDI_NUM_PERCUSSION 47\n\n#define GENMIDI_HEADER          \"#OPL_II#\"\n#define GENMIDI_FLAG_FIXED      0x0001         /* fixed pitch */\n#define GENMIDI_FLAG_2VOICE     0x0004         /* double voice (OPL3) */\n\n#define PERCUSSION_LOG_LEN 16\n\ntypedef PACKED_STRUCT (\n{\n    byte tremolo;\n    byte attack;\n    byte sustain;\n    byte waveform;\n    byte scale;\n    byte level;\n}) genmidi_op_t;\n\ntypedef PACKED_STRUCT (\n{\n    genmidi_op_t modulator;\n    byte feedback;\n    genmidi_op_t carrier;\n    byte unused;\n    short base_note_offset;\n}) genmidi_voice_t;\n\ntypedef PACKED_STRUCT (\n{\n    unsigned short flags;\n    byte fine_tuning;\n    byte fixed_note;\n\n    genmidi_voice_t voices[2];\n}) genmidi_instr_t;\n\n// Data associated with a channel of a track that is currently playing.\n\ntypedef struct\n{\n    // The instrument currently used for this track.\n\n    genmidi_instr_t *instrument;\n\n    // Volume level\n\n    int volume;\n    int volume_base;\n\n    // Pan\n\n    int pan;\n\n    // Pitch bend value:\n\n    int bend;\n\n} opl_channel_data_t;\n\n// Data associated with a track that is currently playing.\n\ntypedef struct\n{\n    // Track iterator used to read new events.\n\n    midi_track_iter_t *iter;\n} opl_track_data_t;\n\ntypedef struct opl_voice_s opl_voice_t;\n\nstruct opl_voice_s\n{\n    // Index of this voice:\n    int index;\n\n    // The operators used by this voice:\n    int op1, op2;\n\n    // Array used by voice:\n    int array;\n\n    // Currently-loaded instrument data\n    genmidi_instr_t *current_instr;\n\n    // The voice number in the instrument to use.\n    // This is normally set to zero; if this is a double voice\n    // instrument, it may be one.\n    unsigned int current_instr_voice;\n\n    // The channel currently using this voice.\n    opl_channel_data_t *channel;\n\n    // The midi key that this voice is playing.\n    unsigned int key;\n\n    // The note being played.  This is normally the same as\n    // the key, but if the instrument is a fixed pitch\n    // instrument, it is different.\n    unsigned int note;\n\n    // The frequency value being used.\n    unsigned int freq;\n\n    // The volume of the note being played on this channel.\n    unsigned int note_volume;\n\n    // The current volume (register value) that has been set for this channel.\n    unsigned int car_volume;\n    unsigned int mod_volume;\n\n    // Pan.\n    unsigned int reg_pan;\n\n    // Priority.\n    unsigned int priority;\n};\n\n// Operators used by the different voices.\n\nstatic const int voice_operators[2][OPL_NUM_VOICES] = {\n    { 0x00, 0x01, 0x02, 0x08, 0x09, 0x0a, 0x10, 0x11, 0x12 },\n    { 0x03, 0x04, 0x05, 0x0b, 0x0c, 0x0d, 0x13, 0x14, 0x15 }\n};\n\n// Frequency values to use for each note.\n\nstatic const unsigned short frequency_curve[] = {\n\n    0x133, 0x133, 0x134, 0x134, 0x135, 0x136, 0x136, 0x137,   // -1\n    0x137, 0x138, 0x138, 0x139, 0x139, 0x13a, 0x13b, 0x13b,\n    0x13c, 0x13c, 0x13d, 0x13d, 0x13e, 0x13f, 0x13f, 0x140,\n    0x140, 0x141, 0x142, 0x142, 0x143, 0x143, 0x144, 0x144,\n\n    0x145, 0x146, 0x146, 0x147, 0x147, 0x148, 0x149, 0x149,   // -2\n    0x14a, 0x14a, 0x14b, 0x14c, 0x14c, 0x14d, 0x14d, 0x14e,\n    0x14f, 0x14f, 0x150, 0x150, 0x151, 0x152, 0x152, 0x153,\n    0x153, 0x154, 0x155, 0x155, 0x156, 0x157, 0x157, 0x158,\n\n    // These are used for the first seven MIDI note values:\n\n    0x158, 0x159, 0x15a, 0x15a, 0x15b, 0x15b, 0x15c, 0x15d,   // 0\n    0x15d, 0x15e, 0x15f, 0x15f, 0x160, 0x161, 0x161, 0x162,\n    0x162, 0x163, 0x164, 0x164, 0x165, 0x166, 0x166, 0x167,\n    0x168, 0x168, 0x169, 0x16a, 0x16a, 0x16b, 0x16c, 0x16c,\n\n    0x16d, 0x16e, 0x16e, 0x16f, 0x170, 0x170, 0x171, 0x172,   // 1\n    0x172, 0x173, 0x174, 0x174, 0x175, 0x176, 0x176, 0x177,\n    0x178, 0x178, 0x179, 0x17a, 0x17a, 0x17b, 0x17c, 0x17c,\n    0x17d, 0x17e, 0x17e, 0x17f, 0x180, 0x181, 0x181, 0x182,\n\n    0x183, 0x183, 0x184, 0x185, 0x185, 0x186, 0x187, 0x188,   // 2\n    0x188, 0x189, 0x18a, 0x18a, 0x18b, 0x18c, 0x18d, 0x18d,\n    0x18e, 0x18f, 0x18f, 0x190, 0x191, 0x192, 0x192, 0x193,\n    0x194, 0x194, 0x195, 0x196, 0x197, 0x197, 0x198, 0x199,\n\n    0x19a, 0x19a, 0x19b, 0x19c, 0x19d, 0x19d, 0x19e, 0x19f,   // 3\n    0x1a0, 0x1a0, 0x1a1, 0x1a2, 0x1a3, 0x1a3, 0x1a4, 0x1a5,\n    0x1a6, 0x1a6, 0x1a7, 0x1a8, 0x1a9, 0x1a9, 0x1aa, 0x1ab,\n    0x1ac, 0x1ad, 0x1ad, 0x1ae, 0x1af, 0x1b0, 0x1b0, 0x1b1,\n\n    0x1b2, 0x1b3, 0x1b4, 0x1b4, 0x1b5, 0x1b6, 0x1b7, 0x1b8,   // 4\n    0x1b8, 0x1b9, 0x1ba, 0x1bb, 0x1bc, 0x1bc, 0x1bd, 0x1be,\n    0x1bf, 0x1c0, 0x1c0, 0x1c1, 0x1c2, 0x1c3, 0x1c4, 0x1c4,\n    0x1c5, 0x1c6, 0x1c7, 0x1c8, 0x1c9, 0x1c9, 0x1ca, 0x1cb,\n\n    0x1cc, 0x1cd, 0x1ce, 0x1ce, 0x1cf, 0x1d0, 0x1d1, 0x1d2,   // 5\n    0x1d3, 0x1d3, 0x1d4, 0x1d5, 0x1d6, 0x1d7, 0x1d8, 0x1d8,\n    0x1d9, 0x1da, 0x1db, 0x1dc, 0x1dd, 0x1de, 0x1de, 0x1df,\n    0x1e0, 0x1e1, 0x1e2, 0x1e3, 0x1e4, 0x1e5, 0x1e5, 0x1e6,\n\n    0x1e7, 0x1e8, 0x1e9, 0x1ea, 0x1eb, 0x1ec, 0x1ed, 0x1ed,   // 6\n    0x1ee, 0x1ef, 0x1f0, 0x1f1, 0x1f2, 0x1f3, 0x1f4, 0x1f5,\n    0x1f6, 0x1f6, 0x1f7, 0x1f8, 0x1f9, 0x1fa, 0x1fb, 0x1fc,\n    0x1fd, 0x1fe, 0x1ff, 0x200, 0x201, 0x201, 0x202, 0x203,\n\n    // First note of looped range used for all octaves:\n\n    0x204, 0x205, 0x206, 0x207, 0x208, 0x209, 0x20a, 0x20b,   // 7\n    0x20c, 0x20d, 0x20e, 0x20f, 0x210, 0x210, 0x211, 0x212,\n    0x213, 0x214, 0x215, 0x216, 0x217, 0x218, 0x219, 0x21a,\n    0x21b, 0x21c, 0x21d, 0x21e, 0x21f, 0x220, 0x221, 0x222,\n\n    0x223, 0x224, 0x225, 0x226, 0x227, 0x228, 0x229, 0x22a,   // 8\n    0x22b, 0x22c, 0x22d, 0x22e, 0x22f, 0x230, 0x231, 0x232,\n    0x233, 0x234, 0x235, 0x236, 0x237, 0x238, 0x239, 0x23a,\n    0x23b, 0x23c, 0x23d, 0x23e, 0x23f, 0x240, 0x241, 0x242,\n\n    0x244, 0x245, 0x246, 0x247, 0x248, 0x249, 0x24a, 0x24b,   // 9\n    0x24c, 0x24d, 0x24e, 0x24f, 0x250, 0x251, 0x252, 0x253,\n    0x254, 0x256, 0x257, 0x258, 0x259, 0x25a, 0x25b, 0x25c,\n    0x25d, 0x25e, 0x25f, 0x260, 0x262, 0x263, 0x264, 0x265,\n\n    0x266, 0x267, 0x268, 0x269, 0x26a, 0x26c, 0x26d, 0x26e,   // 10\n    0x26f, 0x270, 0x271, 0x272, 0x273, 0x275, 0x276, 0x277,\n    0x278, 0x279, 0x27a, 0x27b, 0x27d, 0x27e, 0x27f, 0x280,\n    0x281, 0x282, 0x284, 0x285, 0x286, 0x287, 0x288, 0x289,\n\n    0x28b, 0x28c, 0x28d, 0x28e, 0x28f, 0x290, 0x292, 0x293,   // 11\n    0x294, 0x295, 0x296, 0x298, 0x299, 0x29a, 0x29b, 0x29c,\n    0x29e, 0x29f, 0x2a0, 0x2a1, 0x2a2, 0x2a4, 0x2a5, 0x2a6,\n    0x2a7, 0x2a9, 0x2aa, 0x2ab, 0x2ac, 0x2ae, 0x2af, 0x2b0,\n\n    0x2b1, 0x2b2, 0x2b4, 0x2b5, 0x2b6, 0x2b7, 0x2b9, 0x2ba,   // 12\n    0x2bb, 0x2bd, 0x2be, 0x2bf, 0x2c0, 0x2c2, 0x2c3, 0x2c4,\n    0x2c5, 0x2c7, 0x2c8, 0x2c9, 0x2cb, 0x2cc, 0x2cd, 0x2ce,\n    0x2d0, 0x2d1, 0x2d2, 0x2d4, 0x2d5, 0x2d6, 0x2d8, 0x2d9,\n\n    0x2da, 0x2dc, 0x2dd, 0x2de, 0x2e0, 0x2e1, 0x2e2, 0x2e4,   // 13\n    0x2e5, 0x2e6, 0x2e8, 0x2e9, 0x2ea, 0x2ec, 0x2ed, 0x2ee,\n    0x2f0, 0x2f1, 0x2f2, 0x2f4, 0x2f5, 0x2f6, 0x2f8, 0x2f9,\n    0x2fb, 0x2fc, 0x2fd, 0x2ff, 0x300, 0x302, 0x303, 0x304,\n\n    0x306, 0x307, 0x309, 0x30a, 0x30b, 0x30d, 0x30e, 0x310,   // 14\n    0x311, 0x312, 0x314, 0x315, 0x317, 0x318, 0x31a, 0x31b,\n    0x31c, 0x31e, 0x31f, 0x321, 0x322, 0x324, 0x325, 0x327,\n    0x328, 0x329, 0x32b, 0x32c, 0x32e, 0x32f, 0x331, 0x332,\n\n    0x334, 0x335, 0x337, 0x338, 0x33a, 0x33b, 0x33d, 0x33e,   // 15\n    0x340, 0x341, 0x343, 0x344, 0x346, 0x347, 0x349, 0x34a,\n    0x34c, 0x34d, 0x34f, 0x350, 0x352, 0x353, 0x355, 0x357,\n    0x358, 0x35a, 0x35b, 0x35d, 0x35e, 0x360, 0x361, 0x363,\n\n    0x365, 0x366, 0x368, 0x369, 0x36b, 0x36c, 0x36e, 0x370,   // 16\n    0x371, 0x373, 0x374, 0x376, 0x378, 0x379, 0x37b, 0x37c,\n    0x37e, 0x380, 0x381, 0x383, 0x384, 0x386, 0x388, 0x389,\n    0x38b, 0x38d, 0x38e, 0x390, 0x392, 0x393, 0x395, 0x397,\n\n    0x398, 0x39a, 0x39c, 0x39d, 0x39f, 0x3a1, 0x3a2, 0x3a4,   // 17\n    0x3a6, 0x3a7, 0x3a9, 0x3ab, 0x3ac, 0x3ae, 0x3b0, 0x3b1,\n    0x3b3, 0x3b5, 0x3b7, 0x3b8, 0x3ba, 0x3bc, 0x3bd, 0x3bf,\n    0x3c1, 0x3c3, 0x3c4, 0x3c6, 0x3c8, 0x3ca, 0x3cb, 0x3cd,\n\n    // The last note has an incomplete range, and loops round back to\n    // the start.  Note that the last value is actually a buffer overrun\n    // and does not fit with the other values.\n\n    0x3cf, 0x3d1, 0x3d2, 0x3d4, 0x3d6, 0x3d8, 0x3da, 0x3db,   // 18\n    0x3dd, 0x3df, 0x3e1, 0x3e3, 0x3e4, 0x3e6, 0x3e8, 0x3ea,\n    0x3ec, 0x3ed, 0x3ef, 0x3f1, 0x3f3, 0x3f5, 0x3f6, 0x3f8,\n    0x3fa, 0x3fc, 0x3fe, 0x36c,\n};\n\n// Mapping from MIDI volume level to OPL level value.\n\nstatic const unsigned int volume_mapping_table[] = {\n    0, 1, 3, 5, 6, 8, 10, 11,\n    13, 14, 16, 17, 19, 20, 22, 23,\n    25, 26, 27, 29, 30, 32, 33, 34,\n    36, 37, 39, 41, 43, 45, 47, 49,\n    50, 52, 54, 55, 57, 59, 60, 61,\n    63, 64, 66, 67, 68, 69, 71, 72,\n    73, 74, 75, 76, 77, 79, 80, 81,\n    82, 83, 84, 84, 85, 86, 87, 88,\n    89, 90, 91, 92, 92, 93, 94, 95,\n    96, 96, 97, 98, 99, 99, 100, 101,\n    101, 102, 103, 103, 104, 105, 105, 106,\n    107, 107, 108, 109, 109, 110, 110, 111,\n    112, 112, 113, 113, 114, 114, 115, 115,\n    116, 117, 117, 118, 118, 119, 119, 120,\n    120, 121, 121, 122, 122, 123, 123, 123,\n    124, 124, 125, 125, 126, 126, 127, 127\n};\n\nstatic opl_driver_ver_t opl_drv_ver = opl_doom_1_9;\nstatic boolean music_initialized = false;\n\n//static boolean musicpaused = false;\nstatic int start_music_volume;\nstatic int current_music_volume;\n\n// GENMIDI lump instrument data:\n\nstatic genmidi_instr_t *main_instrs;\nstatic genmidi_instr_t *percussion_instrs;\nstatic char (*main_instr_names)[32];\nstatic char (*percussion_names)[32];\n\n// Voices:\n\nstatic opl_voice_t voices[OPL_NUM_VOICES * 2];\nstatic opl_voice_t *voice_free_list[OPL_NUM_VOICES * 2];\nstatic opl_voice_t *voice_alloced_list[OPL_NUM_VOICES * 2];\nstatic int voice_free_num;\nstatic int voice_alloced_num;\nstatic int opl_opl3mode;\nstatic int num_opl_voices;\n\n// Data for each channel.\n\nstatic opl_channel_data_t channels[MIDI_CHANNELS_PER_TRACK];\n\n// Track data for playing tracks:\n\nstatic opl_track_data_t *tracks;\nstatic unsigned int num_tracks = 0;\nstatic unsigned int running_tracks = 0;\nstatic boolean song_looping;\n\n// Tempo control variables\n\nstatic unsigned int ticks_per_beat;\nstatic unsigned int us_per_beat;\n\n// Mini-log of recently played percussion instruments:\n\nstatic uint8_t last_perc[PERCUSSION_LOG_LEN];\nstatic unsigned int last_perc_count;\n\n// Configuration file variable, containing the port number for the\n// adlib chip.\n\nchar *snd_dmxoption = \"\";\nint opl_io_port = 0x388;\n\n// If true, OPL sound channels are reversed to their correct arrangement\n// (as intended by the MIDI standard) rather than the backwards one\n// used by DMX due to a bug.\n\nstatic boolean opl_stereo_correct = false;\n\n// Load instrument table from GENMIDI lump:\n\nstatic boolean LoadInstrumentTable(void)\n{\n    byte *lump;\n\n    lump = W_CacheLumpName(DEH_String(\"genmidi\"), PU_STATIC);\n\n    // DMX does not check header\n\n    main_instrs = (genmidi_instr_t *) (lump + strlen(GENMIDI_HEADER));\n    percussion_instrs = main_instrs + GENMIDI_NUM_INSTRS;\n    main_instr_names =\n        (char (*)[32]) (percussion_instrs + GENMIDI_NUM_PERCUSSION);\n    percussion_names = main_instr_names + GENMIDI_NUM_INSTRS;\n\n    return true;\n}\n\n// Get the next available voice from the freelist.\n\nstatic opl_voice_t *GetFreeVoice(void)\n{\n    opl_voice_t *result;\n    int i;\n\n    // None available?\n\n    if (voice_free_num == 0)\n    {\n        return NULL;\n    }\n\n    // Remove from free list\n\n    result = voice_free_list[0];\n\n    voice_free_num--;\n\n    for (i = 0; i < voice_free_num; i++)\n    {\n        voice_free_list[i] = voice_free_list[i + 1];\n    }\n\n    // Add to allocated list\n\n    voice_alloced_list[voice_alloced_num++] = result;\n\n    return result;\n}\n\n// Release a voice back to the freelist.\n\nstatic void VoiceKeyOff(opl_voice_t *voice);\n\nstatic void ReleaseVoice(int index)\n{\n    opl_voice_t *voice;\n    boolean double_voice;\n    int i;\n\n    // Doom 2 1.666 OPL crash emulation.\n    if (index >= voice_alloced_num)\n    {\n\n        voice_alloced_num = 0;\n        voice_free_num = 0;\n        return;\n    }\n\n    voice = voice_alloced_list[index];\n\n    VoiceKeyOff(voice);\n\n    voice->channel = NULL;\n    voice->note = 0;\n\n    double_voice = voice->current_instr_voice != 0;\n    \n    // Remove from alloced list.\n\n    voice_alloced_num--;\n\n    for (i = index; i < voice_alloced_num; i++)\n    {\n        voice_alloced_list[i] = voice_alloced_list[i + 1];\n    }\n\n    // Search to the end of the freelist (This is how Doom behaves!)\n\n    voice_free_list[voice_free_num++] = voice;\n\n    if (double_voice && opl_drv_ver < opl_doom_1_9)\n    {\n        ReleaseVoice(index);\n    }\n}\n\n// Load data to the specified operator\n\nstatic void LoadOperatorData(int operator, genmidi_op_t *data,\n                             boolean max_level, unsigned int *volume)\n{\n    int level;\n\n    // The scale and level fields must be combined for the level register.\n    // For the carrier wave we always set the maximum level.\n\n    level = data->scale;\n\n    if (max_level)\n    {\n        level |= 0x3f;\n    }\n    else\n    {\n        level |= data->level;\n    }\n\n    *volume = level;\n\n    OPL_WriteRegister(OPL_REGS_LEVEL + operator, level);\n    OPL_WriteRegister(OPL_REGS_TREMOLO + operator, data->tremolo);\n    OPL_WriteRegister(OPL_REGS_ATTACK + operator, data->attack);\n    OPL_WriteRegister(OPL_REGS_SUSTAIN + operator, data->sustain);\n    OPL_WriteRegister(OPL_REGS_WAVEFORM + operator, data->waveform);\n}\n\n// Set the instrument for a particular voice.\n\nstatic void SetVoiceInstrument(opl_voice_t *voice,\n                               genmidi_instr_t *instr,\n                               unsigned int instr_voice)\n{\n    genmidi_voice_t *data;\n    unsigned int modulating;\n\n    // Instrument already set for this channel?\n\n    if (voice->current_instr == instr\n     && voice->current_instr_voice == instr_voice)\n    {\n        return;\n    }\n\n    voice->current_instr = instr;\n    voice->current_instr_voice = instr_voice;\n\n    data = &instr->voices[instr_voice];\n\n    // Are we usind modulated feedback mode?\n\n    modulating = (data->feedback & 0x01) == 0;\n\n    // Doom loads the second operator first, then the first.\n    // The carrier is set to minimum volume until the voice volume\n    // is set in SetVoiceVolume (below).  If we are not using\n    // modulating mode, we must set both to minimum volume.\n\n    LoadOperatorData(voice->op2 | voice->array, &data->carrier, true,\n                     &voice->car_volume);\n    LoadOperatorData(voice->op1 | voice->array, &data->modulator, !modulating,\n                     &voice->mod_volume);\n\n    // Set feedback register that control the connection between the\n    // two operators.  Turn on bits in the upper nybble; I think this\n    // is for OPL3, where it turns on channel A/B.\n\n    OPL_WriteRegister((OPL_REGS_FEEDBACK + voice->index) | voice->array,\n                      data->feedback | voice->reg_pan);\n\n    // Calculate voice priority.\n\n    voice->priority = 0x0f - (data->carrier.attack >> 4)\n                    + 0x0f - (data->carrier.sustain & 0x0f);\n}\n\nstatic void SetVoiceVolume(opl_voice_t *voice, unsigned int volume)\n{\n    genmidi_voice_t *opl_voice;\n    unsigned int midi_volume;\n    unsigned int full_volume;\n    unsigned int car_volume;\n    unsigned int mod_volume;\n\n    voice->note_volume = volume;\n\n    opl_voice = &voice->current_instr->voices[voice->current_instr_voice];\n\n    // Multiply note volume and channel volume to get the actual volume.\n\n    midi_volume = 2 * (volume_mapping_table[voice->channel->volume] + 1);\n\n    full_volume = (volume_mapping_table[voice->note_volume] * midi_volume)\n                >> 9;\n\n    // The volume value to use in the register:\n    car_volume = 0x3f - full_volume;\n\n    // Update the volume register(s) if necessary.\n\n    if (car_volume != (voice->car_volume & 0x3f))\n    {\n        voice->car_volume = car_volume | (voice->car_volume & 0xc0);\n\n        OPL_WriteRegister((OPL_REGS_LEVEL + voice->op2) | voice->array,\n                          voice->car_volume);\n\n        // If we are using non-modulated feedback mode, we must set the\n        // volume for both voices.\n\n        if ((opl_voice->feedback & 0x01) != 0\n         && opl_voice->modulator.level != 0x3f)\n        {\n            mod_volume = opl_voice->modulator.level;\n            if (mod_volume < car_volume)\n            {\n                mod_volume = car_volume;\n            }\n\n            mod_volume |= voice->mod_volume & 0xc0;\n\n            if(mod_volume != voice->mod_volume)\n            {\n                voice->mod_volume = mod_volume;\n                OPL_WriteRegister((OPL_REGS_LEVEL + voice->op1) | voice->array,\n                                  mod_volume |\n                                  (opl_voice->modulator.scale & 0xc0));\n            }\n        }\n    }\n}\n\nstatic void SetVoicePan(opl_voice_t *voice, unsigned int pan)\n{\n    genmidi_voice_t *opl_voice;\n\n    voice->reg_pan = pan;\n    opl_voice = &voice->current_instr->voices[voice->current_instr_voice];;\n\n    OPL_WriteRegister((OPL_REGS_FEEDBACK + voice->index) | voice->array,\n                      opl_voice->feedback | pan);\n}\n\n// Initialize the voice table and freelist\n\nstatic void InitVoices(void)\n{\n    int i;\n\n    // Start with an empty free list.\n    \n    voice_free_num = num_opl_voices;\n    voice_alloced_num = 0;\n\n    // Initialize each voice.\n\n    for (i = 0; i < num_opl_voices; ++i)\n    {\n        voices[i].index = i % OPL_NUM_VOICES;\n        voices[i].op1 = voice_operators[0][i % OPL_NUM_VOICES];\n        voices[i].op2 = voice_operators[1][i % OPL_NUM_VOICES];\n        voices[i].array = (i / OPL_NUM_VOICES) << 8;\n        voices[i].current_instr = NULL;\n\n        // Add this voice to the freelist.\n\n        voice_free_list[i] = &voices[i];\n    }\n}\n\nstatic void SetChannelVolume(opl_channel_data_t *channel, unsigned int volume,\n                             boolean clip_start);\n\n// Set music volume (0 - 127)\n\nstatic void I_OPL_SetMusicVolume(int volume)\n{\n    unsigned int i;\n\n    if (current_music_volume == volume)\n    {\n        return;\n    }\n\n    // Internal state variable.\n\n    current_music_volume = volume;\n\n    // Update the volume of all voices.\n\n    for (i = 0; i < MIDI_CHANNELS_PER_TRACK; ++i)\n    {\n        if (i == 15)\n        {\n            SetChannelVolume(&channels[i], volume, false);\n        }\n        else\n        {\n            SetChannelVolume(&channels[i], channels[i].volume_base, false);\n        }\n    }\n}\n\nstatic void VoiceKeyOff(opl_voice_t *voice)\n{\n    OPL_WriteRegister((OPL_REGS_FREQ_2 + voice->index) | voice->array,\n                      voice->freq >> 8);\n}\n\nstatic opl_channel_data_t *TrackChannelForEvent(opl_track_data_t *track,\n                                                midi_event_t *event)\n{\n    unsigned int channel_num = event->data.channel.channel;\n\n    // MIDI uses track #9 for percussion, but for MUS it's track #15\n    // instead. Because DMX works on MUS data internally, we need to\n    // swap back to the MUS version of the channel number.\n    if (channel_num == 9)\n    {\n        channel_num = 15;\n    }\n    else if (channel_num == 15)\n    {\n        channel_num = 9;\n    }\n\n    return &channels[channel_num];\n}\n\n// Get the frequency that we should be using for a voice.\n\nstatic void KeyOffEvent(opl_track_data_t *track, midi_event_t *event)\n{\n    opl_channel_data_t *channel;\n    int i;\n    unsigned int key;\n\n/*\n    printf(\"note off: channel %i, %i, %i\\n\",\n           event->data.channel.channel,\n           event->data.channel.param1,\n           event->data.channel.param2);\n*/\n\n    channel = TrackChannelForEvent(track, event);\n    key = event->data.channel.param1;\n\n    // Turn off voices being used to play this key.\n    // If it is a double voice instrument there will be two.\n\n    for (i = 0; i < voice_alloced_num; i++)\n    {\n        if (voice_alloced_list[i]->channel == channel\n         && voice_alloced_list[i]->key == key)\n        {\n            // Finished with this voice now.\n\n            ReleaseVoice(i);\n\n            i--;\n        }\n    }\n}\n\n// When all voices are in use, we must discard an existing voice to\n// play a new note.  Find and free an existing voice.  The channel\n// passed to the function is the channel for the new note to be\n// played.\n\nstatic void ReplaceExistingVoice(void)\n{\n    int i;\n    int result;\n\n    // Check the allocated voices, if we find an instrument that is\n    // of a lower priority to the new instrument, discard it.\n    // If a voice is being used to play the second voice of an instrument,\n    // use that, as second voices are non-essential.\n    // Lower numbered MIDI channels implicitly have a higher priority\n    // than higher-numbered channels, eg. MIDI channel 1 is never\n    // discarded for MIDI channel 2.\n\n    result = 0;\n\n    for (i = 0; i < voice_alloced_num; i++)\n    {\n        if (voice_alloced_list[i]->current_instr_voice != 0\n         || voice_alloced_list[i]->channel\n         >= voice_alloced_list[result]->channel)\n        {\n            result = i;\n        }\n    }\n\n    ReleaseVoice(result);\n}\n\n// Alternate versions of ReplaceExistingVoice() used when emulating old\n// versions of the DMX library used in Doom 1.666, Heretic and Hexen.\n\nstatic void ReplaceExistingVoiceDoom1(void)\n{\n    int i;\n    int result;\n\n    result = 0;\n\n    for (i = 0; i < voice_alloced_num; i++)\n    {\n        if (voice_alloced_list[i]->channel\n          > voice_alloced_list[result]->channel)\n        {\n            result = i;\n        }\n    }\n\n    ReleaseVoice(result);\n}\n\nstatic void ReplaceExistingVoiceDoom2(opl_channel_data_t *channel)\n{\n    int i;\n    int result;\n    int priority;\n\n    result = 0;\n\n    priority = 0x8000;\n\n    for (i = 0; i < voice_alloced_num - 3; i++)\n    {\n        if (voice_alloced_list[i]->priority < priority\n         && voice_alloced_list[i]->channel >= channel)\n        {\n            priority = voice_alloced_list[i]->priority;\n            result = i;\n        }\n    }\n\n    ReleaseVoice(result);\n}\n\n\nstatic unsigned int FrequencyForVoice(opl_voice_t *voice)\n{\n    genmidi_voice_t *gm_voice;\n    signed int freq_index;\n    unsigned int octave;\n    unsigned int sub_index;\n    signed int note;\n\n    note = voice->note;\n\n    // Apply note offset.\n    // Don't apply offset if the instrument is a fixed note instrument.\n\n    gm_voice = &voice->current_instr->voices[voice->current_instr_voice];\n\n    if ((SHORT(voice->current_instr->flags) & GENMIDI_FLAG_FIXED) == 0)\n    {\n        note += (signed short) SHORT(gm_voice->base_note_offset);\n    }\n\n    // Avoid possible overflow due to base note offset:\n\n    while (note < 0)\n    {\n        note += 12;\n    }\n\n    while (note > 95)\n    {\n        note -= 12;\n    }\n\n    freq_index = 64 + 32 * note + voice->channel->bend;\n\n    // If this is the second voice of a double voice instrument, the\n    // frequency index can be adjusted by the fine tuning field.\n\n    if (voice->current_instr_voice != 0)\n    {\n        freq_index += (voice->current_instr->fine_tuning / 2) - 64;\n    }\n\n    if (freq_index < 0)\n    {\n        freq_index = 0;\n    }\n\n    // The first 7 notes use the start of the table, while\n    // consecutive notes loop around the latter part.\n\n    if (freq_index < 284)\n    {\n        return frequency_curve[freq_index];\n    }\n\n    sub_index = (freq_index - 284) % (12 * 32);\n    octave = (freq_index - 284) / (12 * 32);\n\n    // Once the seventh octave is reached, things break down.\n    // We can only go up to octave 7 as a maximum anyway (the OPL\n    // register only has three bits for octave number), but for the\n    // notes in octave 7, the first five bits have octave=7, the\n    // following notes have octave=6.  This 7/6 pattern repeats in\n    // following octaves (which are technically impossible to\n    // represent anyway).\n\n    if (octave >= 7)\n    {\n        octave = 7;\n    }\n\n    // Calculate the resulting register value to use for the frequency.\n\n    return frequency_curve[sub_index + 284] | (octave << 10);\n}\n\n// Update the frequency that a voice is programmed to use.\n\nstatic void UpdateVoiceFrequency(opl_voice_t *voice)\n{\n    unsigned int freq;\n\n    // Calculate the frequency to use for this voice and update it\n    // if neccessary.\n\n    freq = FrequencyForVoice(voice);\n\n    if (voice->freq != freq)\n    {\n        OPL_WriteRegister((OPL_REGS_FREQ_1 + voice->index) | voice->array,\n                          freq & 0xff);\n        OPL_WriteRegister((OPL_REGS_FREQ_2 + voice->index) | voice->array,\n                          (freq >> 8) | 0x20);\n\n        voice->freq = freq;\n    }\n}\n\n// Program a single voice for an instrument.  For a double voice\n// instrument (GENMIDI_FLAG_2VOICE), this is called twice for each\n// key on event.\n\nstatic void VoiceKeyOn(opl_channel_data_t *channel,\n                       genmidi_instr_t *instrument,\n                       unsigned int instrument_voice,\n                       unsigned int note,\n                       unsigned int key,\n                       unsigned int volume)\n{\n    opl_voice_t *voice;\n\n    if (!opl_opl3mode && opl_drv_ver == opl_doom1_1_666)\n    {\n        instrument_voice = 0;\n    }\n\n    // Find a voice to use for this new note.\n\n    voice = GetFreeVoice();\n\n    if (voice == NULL)\n    {\n        return;\n    }\n\n    voice->channel = channel;\n    voice->key = key;\n\n    // Work out the note to use.  This is normally the same as\n    // the key, unless it is a fixed pitch instrument.\n\n    if ((SHORT(instrument->flags) & GENMIDI_FLAG_FIXED) != 0)\n    {\n        voice->note = instrument->fixed_note;\n    }\n    else\n    {\n        voice->note = note;\n    }\n\n    voice->reg_pan = channel->pan;\n\n    // Program the voice with the instrument data:\n\n    SetVoiceInstrument(voice, instrument, instrument_voice);\n\n    // Set the volume level.\n\n    SetVoiceVolume(voice, volume);\n\n    // Write the frequency value to turn the note on.\n\n    voice->freq = 0;\n    UpdateVoiceFrequency(voice);\n}\n\nstatic void KeyOnEvent(opl_track_data_t *track, midi_event_t *event)\n{\n    genmidi_instr_t *instrument;\n    opl_channel_data_t *channel;\n    unsigned int note, key, volume, voicenum;\n    boolean double_voice;\n\n/*\n    printf(\"note on: channel %i, %i, %i\\n\",\n           event->data.channel.channel,\n           event->data.channel.param1,\n           event->data.channel.param2);\n*/\n\n    note = event->data.channel.param1;\n    key = event->data.channel.param1;\n    volume = event->data.channel.param2;\n\n    // A volume of zero means key off. Some MIDI tracks, eg. the ones\n    // in AV.wad, use a second key on with a volume of zero to mean\n    // key off.\n    if (volume <= 0)\n    {\n        KeyOffEvent(track, event);\n        return;\n    }\n\n    // The channel.\n    channel = TrackChannelForEvent(track, event);\n\n    // Percussion channel is treated differently.\n    if (event->data.channel.channel == 9)\n    {\n        if (key < 35 || key > 81)\n        {\n            return;\n        }\n\n        instrument = &percussion_instrs[key - 35];\n\n        last_perc[last_perc_count] = key;\n        last_perc_count = (last_perc_count + 1) % PERCUSSION_LOG_LEN;\n        note = 60;\n    }\n    else\n    {\n        instrument = channel->instrument;\n    }\n\n    double_voice = (SHORT(instrument->flags) & GENMIDI_FLAG_2VOICE) != 0;\n\n    switch (opl_drv_ver)\n    {\n        case opl_doom1_1_666:\n            voicenum = double_voice + 1;\n            if (!opl_opl3mode)\n            {\n                voicenum = 1;\n            }\n            while (voice_alloced_num > num_opl_voices - voicenum)\n            {\n                ReplaceExistingVoiceDoom1();\n            }\n\n            // Find and program a voice for this instrument.  If this\n            // is a double voice instrument, we must do this twice.\n\n            if (double_voice)\n            {\n                VoiceKeyOn(channel, instrument, 1, note, key, volume);\n            }\n\n            VoiceKeyOn(channel, instrument, 0, note, key, volume);\n            break;\n        case opl_doom2_1_666:\n            if (voice_alloced_num == num_opl_voices)\n            {\n                ReplaceExistingVoiceDoom2(channel);\n            }\n            if (voice_alloced_num == num_opl_voices - 1 && double_voice)\n            {\n                ReplaceExistingVoiceDoom2(channel);\n            }\n\n            // Find and program a voice for this instrument.  If this\n            // is a double voice instrument, we must do this twice.\n\n            if (double_voice)\n            {\n                VoiceKeyOn(channel, instrument, 1, note, key, volume);\n            }\n\n            VoiceKeyOn(channel, instrument, 0, note, key, volume);\n            break;\n        default:\n        case opl_doom_1_9:\n            if (voice_free_num == 0)\n            {\n                ReplaceExistingVoice();\n            }\n\n            // Find and program a voice for this instrument.  If this\n            // is a double voice instrument, we must do this twice.\n\n            VoiceKeyOn(channel, instrument, 0, note, key, volume);\n\n            if (double_voice)\n            {\n                VoiceKeyOn(channel, instrument, 1, note, key, volume);\n            }\n            break;\n    }\n}\n\nstatic void ProgramChangeEvent(opl_track_data_t *track, midi_event_t *event)\n{\n    opl_channel_data_t *channel;\n    int instrument;\n\n    // Set the instrument used on this channel.\n\n    channel = TrackChannelForEvent(track, event);\n    instrument = event->data.channel.param1;\n    channel->instrument = &main_instrs[instrument];\n\n    // TODO: Look through existing voices that are turned on on this\n    // channel, and change the instrument.\n}\n\nstatic void SetChannelVolume(opl_channel_data_t *channel, unsigned int volume,\n                             boolean clip_start)\n{\n    unsigned int i;\n\n    channel->volume_base = volume;\n\n    if (volume > current_music_volume)\n    {\n        volume = current_music_volume;\n    }\n\n    if (clip_start && volume > start_music_volume)\n    {\n        volume = start_music_volume;\n    }\n\n    channel->volume = volume;\n\n    // Update all voices that this channel is using.\n\n    for (i = 0; i < num_opl_voices; ++i)\n    {\n        if (voices[i].channel == channel)\n        {\n            SetVoiceVolume(&voices[i], voices[i].note_volume);\n        }\n    }\n}\n\nstatic void SetChannelPan(opl_channel_data_t *channel, unsigned int pan)\n{\n    unsigned int reg_pan;\n    unsigned int i;\n\n    // The DMX library has the stereo channels backwards, maybe because\n    // Paul Radek had a Soundblaster card with the channels reversed, or\n    // perhaps it was just a bug in the OPL3 support that was never\n    // finished. By default we preserve this bug, but we also provide a\n    // secret DMXOPTION to fix it.\n    if (opl_stereo_correct)\n    {\n        pan = 144 - pan;\n    }\n\n    if (opl_opl3mode)\n    {\n        if (pan >= 96)\n        {\n            reg_pan = 0x10;\n        }\n        else if (pan <= 48)\n        {\n            reg_pan = 0x20;\n        }\n        else\n        {\n            reg_pan = 0x30;\n        }\n        if (channel->pan != reg_pan)\n        {\n            channel->pan = reg_pan;\n            for (i = 0; i < num_opl_voices; i++)\n            {\n                if (voices[i].channel == channel)\n                {\n                    SetVoicePan(&voices[i], reg_pan);\n                }\n            }\n        }\n    }\n}\n\n// Handler for the MIDI_CONTROLLER_ALL_NOTES_OFF channel event.\nstatic void AllNotesOff(opl_channel_data_t *channel, unsigned int param)\n{\n    int i;\n\n    for (i = 0; i < voice_alloced_num; i++)\n    {\n        if (voice_alloced_list[i]->channel == channel)\n        {\n            // Finished with this voice now.\n\n            ReleaseVoice(i);\n            \n            i--;\n        }\n    }\n}\n\nstatic void ControllerEvent(opl_track_data_t *track, midi_event_t *event)\n{\n    opl_channel_data_t *channel;\n    unsigned int controller;\n    unsigned int param;\n\n/*\n    printf(\"change controller: channel %i, %i, %i\\n\",\n           event->data.channel.channel,\n           event->data.channel.param1,\n           event->data.channel.param2);\n*/\n\n    channel = TrackChannelForEvent(track, event);\n    controller = event->data.channel.param1;\n    param = event->data.channel.param2;\n\n    switch (controller)\n    {\n        case MIDI_CONTROLLER_MAIN_VOLUME:\n            SetChannelVolume(channel, param, true);\n            break;\n\n        case MIDI_CONTROLLER_PAN:\n            SetChannelPan(channel, param);\n            break;\n\n        case MIDI_CONTROLLER_ALL_NOTES_OFF:\n            AllNotesOff(channel, param);\n            break;\n\n        default:\n#ifdef OPL_MIDI_DEBUG\n            fprintf(stderr, \"Unknown MIDI controller type: %i\\n\", controller);\n#endif\n            break;\n    }\n}\n\n// Process a pitch bend event.\n\nstatic void PitchBendEvent(opl_track_data_t *track, midi_event_t *event)\n{\n    opl_channel_data_t *channel;\n    int i;\n    opl_voice_t *voice_updated_list[OPL_NUM_VOICES * 2];\n    unsigned int voice_updated_num = 0;\n    opl_voice_t *voice_not_updated_list[OPL_NUM_VOICES * 2];\n    unsigned int voice_not_updated_num = 0;\n\n    // Update the channel bend value.  Only the MSB of the pitch bend\n    // value is considered: this is what Doom does.\n\n    channel = TrackChannelForEvent(track, event);\n    channel->bend = event->data.channel.param2 - 64;\n\n    // Update all voices for this channel.\n\n\tfor (i = 0; i < voice_alloced_num; ++i)\n    {\n        if (voice_alloced_list[i]->channel == channel)\n        {\n            UpdateVoiceFrequency(voice_alloced_list[i]);\n            voice_updated_list[voice_updated_num++] = voice_alloced_list[i];\n        }\n        else\n        {\n            voice_not_updated_list[voice_not_updated_num++] =\n            voice_alloced_list[i];\n        }\n    }\n\n    for (i = 0; i < voice_not_updated_num; i++)\n    {\n        voice_alloced_list[i] = voice_not_updated_list[i];\n    }\n\n    for (i = 0; i < voice_updated_num; i++)\n    {\n        voice_alloced_list[i + voice_not_updated_num] = voice_updated_list[i];\n    }\n}\n\nstatic void MetaSetTempo(unsigned int tempo)\n{\n    OPL_AdjustCallbacks((float) us_per_beat / tempo);\n    us_per_beat = tempo;\n}\n\n// Process a meta event.\n\nstatic void MetaEvent(opl_track_data_t *track, midi_event_t *event)\n{\n    byte *data = event->data.meta.data;\n    unsigned int data_len = event->data.meta.length;\n\n    switch (event->data.meta.type)\n    {\n        // Things we can just ignore.\n\n        case MIDI_META_SEQUENCE_NUMBER:\n        case MIDI_META_TEXT:\n        case MIDI_META_COPYRIGHT:\n        case MIDI_META_TRACK_NAME:\n        case MIDI_META_INSTR_NAME:\n        case MIDI_META_LYRICS:\n        case MIDI_META_MARKER:\n        case MIDI_META_CUE_POINT:\n        case MIDI_META_SEQUENCER_SPECIFIC:\n            break;\n\n        case MIDI_META_SET_TEMPO:\n            if (data_len == 3)\n            {\n                MetaSetTempo((data[0] << 16) | (data[1] << 8) | data[2]);\n            }\n            break;\n\n        // End of track - actually handled when we run out of events\n        // in the track, see below.\n\n        case MIDI_META_END_OF_TRACK:\n            break;\n\n        default:\n#ifdef OPL_MIDI_DEBUG\n            fprintf(stderr, \"Unknown MIDI meta event type: %i\\n\",\n                            event->data.meta.type);\n#endif\n            break;\n    }\n}\n\n// Process a MIDI event from a track.\n\nstatic void ProcessEvent(opl_track_data_t *track, midi_event_t *event)\n{\n    switch (event->event_type)\n    {\n        case MIDI_EVENT_NOTE_OFF:\n            KeyOffEvent(track, event);\n            break;\n\n        case MIDI_EVENT_NOTE_ON:\n            KeyOnEvent(track, event);\n            break;\n\n        case MIDI_EVENT_CONTROLLER:\n            ControllerEvent(track, event);\n            break;\n\n        case MIDI_EVENT_PROGRAM_CHANGE:\n            ProgramChangeEvent(track, event);\n            break;\n\n        case MIDI_EVENT_PITCH_BEND:\n            PitchBendEvent(track, event);\n            break;\n\n        case MIDI_EVENT_META:\n            MetaEvent(track, event);\n            break;\n\n        // SysEx events can be ignored.\n\n        case MIDI_EVENT_SYSEX:\n        case MIDI_EVENT_SYSEX_SPLIT:\n            break;\n\n        default:\n#ifdef OPL_MIDI_DEBUG\n            fprintf(stderr, \"Unknown MIDI event type %i\\n\", event->event_type);\n#endif\n            break;\n    }\n}\n\nstatic void ScheduleTrack(opl_track_data_t *track);\nstatic void InitChannel(opl_channel_data_t *channel);\n\n// Restart a song from the beginning.\n\nstatic void RestartSong(void *unused)\n{\n    unsigned int i;\n\n    running_tracks = num_tracks;\n\n    start_music_volume = current_music_volume;\n\n    for (i = 0; i < num_tracks; ++i)\n    {\n        MIDI_RestartIterator(tracks[i].iter);\n        ScheduleTrack(&tracks[i]);\n    }\n\n    for (i = 0; i < MIDI_CHANNELS_PER_TRACK; ++i)\n    {\n        InitChannel(&channels[i]);\n    }\n}\n\n// Callback function invoked when another event needs to be read from\n// a track.\n\nstatic void TrackTimerCallback(void *arg)\n{\n    opl_track_data_t *track = arg;\n    midi_event_t *event;\n\n    // Get the next event and process it.\n\n    if (!MIDI_GetNextEvent(track->iter, &event))\n    {\n        return;\n    }\n\n    ProcessEvent(track, event);\n\n    // End of track?\n\n    if (event->event_type == MIDI_EVENT_META\n     && event->data.meta.type == MIDI_META_END_OF_TRACK)\n    {\n        --running_tracks;\n\n        // When all tracks have finished, restart the song.\n        // Don't restart the song immediately, but wait for 5ms\n        // before triggering a restart.  Otherwise it is possible\n        // to construct an empty MIDI file that causes the game\n        // to lock up in an infinite loop. (5ms should be short\n        // enough not to be noticeable by the listener).\n\n        if (running_tracks <= 0 && song_looping)\n        {\n            OPL_SetCallback(5000, RestartSong, NULL);\n        }\n\n        return;\n    }\n\n    // Reschedule the callback for the next event in the track.\n\n    ScheduleTrack(track);\n}\n\nstatic void ScheduleTrack(opl_track_data_t *track)\n{\n    unsigned int nticks;\n    uint64_t us;\n\n    // Get the number of microseconds until the next event.\n\n    nticks = MIDI_GetDeltaTime(track->iter);\n    us = ((uint64_t) nticks * us_per_beat) / ticks_per_beat;\n\n    // Set a timer to be invoked when the next event is\n    // ready to play.\n\n    OPL_SetCallback(us, TrackTimerCallback, track);\n}\n\n// Initialize a channel.\n\nstatic void InitChannel(opl_channel_data_t *channel)\n{\n    // TODO: Work out sensible defaults?\n\n    channel->instrument = &main_instrs[0];\n    channel->volume = current_music_volume;\n    channel->volume_base = 100;\n    if (channel->volume > channel->volume_base)\n    {\n        channel->volume = channel->volume_base;\n    }\n    channel->pan = 0x30;\n    channel->bend = 0;\n}\n\n// Start a MIDI track playing:\n\nstatic void StartTrack(midi_file_t *file, unsigned int track_num)\n{\n    opl_track_data_t *track;\n\n    track = &tracks[track_num];\n    track->iter = MIDI_IterateTrack(file, track_num);\n\n    // Schedule the first event.\n\n    ScheduleTrack(track);\n}\n\n// Start playing a mid\n\nstatic void I_OPL_PlaySong(void *handle, boolean looping)\n{\n    midi_file_t *file;\n    unsigned int i;\n\n    if (!music_initialized || handle == NULL)\n    {\n        return;\n    }\n\n    file = handle;\n\n    // Allocate track data.\n\n    tracks = malloc(MIDI_NumTracks(file) * sizeof(opl_track_data_t));\n\n    num_tracks = MIDI_NumTracks(file);\n    running_tracks = num_tracks;\n    song_looping = looping;\n\n    ticks_per_beat = MIDI_GetFileTimeDivision(file);\n\n    // Default is 120 bpm.\n    // TODO: this is wrong\n\n    us_per_beat = 500 * 1000;\n\n    start_music_volume = current_music_volume;\n\n    for (i = 0; i < num_tracks; ++i)\n    {\n        StartTrack(file, i);\n    }\n\n    for (i = 0; i < MIDI_CHANNELS_PER_TRACK; ++i)\n    {\n        InitChannel(&channels[i]);\n    }\n\n    // If the music was previously paused, it needs to be unpaused; playing\n    // a new song implies that we turn off pause. This matches vanilla\n    // behavior of the DMX library, and some of the higher-level code in\n    // s_sound.c relies on this.\n    OPL_SetPaused(0);\n}\n\nstatic void I_OPL_PauseSong(void)\n{\n    unsigned int i;\n\n    if (!music_initialized)\n    {\n        return;\n    }\n\n    // Pause OPL callbacks.\n\n    OPL_SetPaused(1);\n\n    // Turn off all main instrument voices (not percussion).\n    // This is what Vanilla does.\n\n    for (i = 0; i < num_opl_voices; ++i)\n    {\n        if (voices[i].channel != NULL\n         && voices[i].current_instr < percussion_instrs)\n        {\n            VoiceKeyOff(&voices[i]);\n        }\n    }\n}\n\nstatic void I_OPL_ResumeSong(void)\n{\n    if (!music_initialized)\n    {\n        return;\n    }\n\n    OPL_SetPaused(0);\n}\n\nstatic void I_OPL_StopSong(void)\n{\n    unsigned int i;\n\n    if (!music_initialized)\n    {\n        return;\n    }\n\n    OPL_Lock();\n\n    // Stop all playback.\n\n    OPL_ClearCallbacks();\n\n    // Free all voices.\n\n    for (i = 0; i < MIDI_CHANNELS_PER_TRACK; ++i)\n    {\n        AllNotesOff(&channels[i], 0);\n    }\n\n    // Free all track data.\n\n    for (i = 0; i < num_tracks; ++i)\n    {\n        MIDI_FreeIterator(tracks[i].iter);\n    }\n\n    free(tracks);\n\n    tracks = NULL;\n    num_tracks = 0;\n\n    OPL_Unlock();\n}\n\nstatic void I_OPL_UnRegisterSong(void *handle)\n{\n    if (!music_initialized)\n    {\n        return;\n    }\n\n    if (handle != NULL)\n    {\n        MIDI_FreeFile(handle);\n    }\n}\n\n// Determine whether memory block is a .mid file\n\nstatic boolean IsMid(byte *mem, int len)\n{\n    return len > 4 && !memcmp(mem, \"MThd\", 4);\n}\n\nstatic boolean ConvertMus(byte *musdata, int len, char *filename)\n{\n    MEMFILE *instream;\n    MEMFILE *outstream;\n    void *outbuf;\n    size_t outbuf_len;\n    int result;\n\n    instream = mem_fopen_read(musdata, len);\n    outstream = mem_fopen_write();\n\n    result = mus2mid(instream, outstream);\n\n    if (result == 0)\n    {\n        mem_get_buf(outstream, &outbuf, &outbuf_len);\n\n        M_WriteFile(filename, outbuf, outbuf_len);\n    }\n\n    mem_fclose(instream);\n    mem_fclose(outstream);\n\n    return result;\n}\n\nstatic void *I_OPL_RegisterSong(void *data, int len)\n{\n    midi_file_t *result;\n    char *filename;\n\n    if (!music_initialized)\n    {\n        return NULL;\n    }\n\n    // MUS files begin with \"MUS\"\n    // Reject anything which doesnt have this signature\n\n    filename = M_TempFile(\"doom.mid\");\n\n    if (IsMid(data, len) && len < MAXMIDLENGTH)\n    {\n        M_WriteFile(filename, data, len);\n    }\n    else\n    {\n        // Assume a MUS file and try to convert\n\n        ConvertMus(data, len, filename);\n    }\n\n    result = MIDI_LoadFile(filename);\n\n    if (result == NULL)\n    {\n        fprintf(stderr, \"I_OPL_RegisterSong: Failed to load MID.\\n\");\n    }\n\n    // remove file now\n\n    remove(filename);\n    free(filename);\n\n    return result;\n}\n\n// Is the song playing?\n\nstatic boolean I_OPL_MusicIsPlaying(void)\n{\n    if (!music_initialized)\n    {\n        return false;\n    }\n\n    return num_tracks > 0;\n}\n\n// Shutdown music\n\nstatic void I_OPL_ShutdownMusic(void)\n{\n    if (music_initialized)\n    {\n        // Stop currently-playing track, if there is one:\n\n        I_OPL_StopSong();\n\n        OPL_Shutdown();\n\n        // Release GENMIDI lump\n\n        W_ReleaseLumpName(DEH_String(\"genmidi\"));\n\n        music_initialized = false;\n    }\n}\n\n// Initialize music subsystem\n\nstatic boolean I_OPL_InitMusic(void)\n{\n    char *dmxoption;\n    opl_init_result_t chip_type;\n\n    OPL_SetSampleRate(snd_samplerate);\n\n    chip_type = OPL_Init(opl_io_port);\n    if (chip_type == OPL_INIT_NONE)\n    {\n        printf(\"Dude.  The Adlib isn't responding.\\n\");\n        return false;\n    }\n\n    // The DMXOPTION variable must be set to enable OPL3 support.\n    // As an extension, we also allow it to be set from the config file.\n    dmxoption = getenv(\"DMXOPTION\");\n    if (dmxoption == NULL)\n    {\n        dmxoption = snd_dmxoption != NULL ? snd_dmxoption : \"\";\n    }\n\n    if (chip_type == OPL_INIT_OPL3 && strstr(dmxoption, \"-opl3\") != NULL)\n    {\n        opl_opl3mode = 1;\n        num_opl_voices = OPL_NUM_VOICES * 2;\n    }\n    else\n    {\n        opl_opl3mode = 0;\n        num_opl_voices = OPL_NUM_VOICES;\n    }\n\n    // Secret, undocumented DMXOPTION that reverses the stereo channels\n    // into their correct orientation.\n    opl_stereo_correct = strstr(dmxoption, \"-reverse\") != NULL;\n\n    // Initialize all registers.\n\n    OPL_InitRegisters(opl_opl3mode);\n\n    // Load instruments from GENMIDI lump:\n\n    if (!LoadInstrumentTable())\n    {\n        OPL_Shutdown();\n        return false;\n    }\n\n    InitVoices();\n\n    tracks = NULL;\n    num_tracks = 0;\n    music_initialized = true;\n\n    return true;\n}\n\nstatic snddevice_t music_opl_devices[] =\n{\n    SNDDEVICE_ADLIB,\n    SNDDEVICE_SB,\n};\n\nmusic_module_t music_opl_module =\n{\n    music_opl_devices,\n    arrlen(music_opl_devices),\n    I_OPL_InitMusic,\n    I_OPL_ShutdownMusic,\n    I_OPL_SetMusicVolume,\n    I_OPL_PauseSong,\n    I_OPL_ResumeSong,\n    I_OPL_RegisterSong,\n    I_OPL_UnRegisterSong,\n    I_OPL_PlaySong,\n    I_OPL_StopSong,\n    I_OPL_MusicIsPlaying,\n    NULL,  // Poll\n};\n\nvoid I_SetOPLDriverVer(opl_driver_ver_t ver)\n{\n    opl_drv_ver = ver;\n}\n\n//----------------------------------------------------------------------\n//\n// Development / debug message generation, to help developing GENMIDI\n// lumps.\n//\n//----------------------------------------------------------------------\n\nstatic int NumActiveChannels(void)\n{\n    int i;\n\n    for (i = MIDI_CHANNELS_PER_TRACK - 1; i >= 0; --i)\n    {\n        if (channels[i].instrument != &main_instrs[0])\n        {\n            return i + 1;\n        }\n    }\n\n    return 0;\n}\n\nstatic int ChannelInUse(opl_channel_data_t *channel)\n{\n    int i;\n\n    for (i = 0; i < voice_alloced_num; i++)\n    {\n        if (voice_alloced_list[i]->channel == channel)\n        {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nvoid I_OPL_DevMessages(char *result, size_t result_len)\n{\n    char tmp[80];\n    int instr_num;\n    int lines;\n    int i;\n\n    if (num_tracks == 0)\n    {\n        M_snprintf(result, result_len, \"No OPL track!\");\n        return;\n    }\n\n    M_snprintf(result, result_len, \"Tracks:\\n\");\n    lines = 1;\n\n    for (i = 0; i < NumActiveChannels(); ++i)\n    {\n        if (channels[i].instrument == NULL)\n        {\n            continue;\n        }\n\n        instr_num = channels[i].instrument - main_instrs;\n\n        M_snprintf(tmp, sizeof(tmp),\n                   \"chan %i: %c i#%i (%s)\\n\",\n                   i,\n                   ChannelInUse(&channels[i]) ? '\\'' : ' ',\n                   instr_num + 1,\n                   main_instr_names[instr_num]);\n        M_StringConcat(result, tmp, result_len);\n\n        ++lines;\n    }\n\n    M_snprintf(tmp, sizeof(tmp), \"\\nLast percussion:\\n\");\n    M_StringConcat(result, tmp, result_len);\n    lines += 2;\n\n    i = (last_perc_count + PERCUSSION_LOG_LEN - 1) % PERCUSSION_LOG_LEN;\n\n    do {\n        if (last_perc[i] == 0)\n        {\n            break;\n        }\n\n        M_snprintf(tmp, sizeof(tmp),\n                   \"%cp#%i (%s)\\n\",\n                   i == 0 ? '\\'' : ' ',\n                   last_perc[i],\n                   percussion_names[last_perc[i] - 35]);\n        M_StringConcat(result, tmp, result_len);\n        ++lines;\n\n        i = (i + PERCUSSION_LOG_LEN - 1) % PERCUSSION_LOG_LEN;\n    } while (lines < 25 && i != last_perc_count);\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n// Copyright(C) 2008 David Flater\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tSystem interface for sound.\n//\n\n#include \"config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include \"SDL.h\"\n#include \"SDL_mixer.h\"\n\n#include \"deh_str.h\"\n#include \"i_sound.h\"\n#include \"i_system.h\"\n#include \"i_swap.h\"\n#include \"m_argv.h\"\n#include \"m_misc.h\"\n#include \"w_wad.h\"\n#include \"z_zone.h\"\n\n#include \"doomtype.h\"\n\n#define LOW_PASS_FILTER\n//#define DEBUG_DUMP_WAVS\n#define NUM_CHANNELS 16\n\ntypedef struct allocated_sound_s allocated_sound_t;\n\nstruct allocated_sound_s\n{\n    sfxinfo_t *sfxinfo;\n    Mix_Chunk chunk;\n    int use_count;\n    int pitch;\n    allocated_sound_t *prev, *next;\n};\n\nstatic boolean sound_initialized = false;\n\nstatic allocated_sound_t *channels_playing[NUM_CHANNELS];\n\nstatic int mixer_freq;\nstatic Uint16 mixer_format;\nstatic int mixer_channels;\nstatic boolean use_sfx_prefix;\nstatic boolean (*ExpandSoundData)(sfxinfo_t *sfxinfo,\n                                  byte *data,\n                                  int samplerate,\n                                  int length) = NULL;\n\n// Doubly-linked list of allocated sounds.\n// When a sound is played, it is moved to the head, so that the oldest\n// sounds not used recently are at the tail.\n\nstatic allocated_sound_t *allocated_sounds_head = NULL;\nstatic allocated_sound_t *allocated_sounds_tail = NULL;\nstatic int allocated_sounds_size = 0;\n\n// Hook a sound into the linked list at the head.\n\nstatic void AllocatedSoundLink(allocated_sound_t *snd)\n{\n    snd->prev = NULL;\n\n    snd->next = allocated_sounds_head;\n    allocated_sounds_head = snd;\n\n    if (allocated_sounds_tail == NULL)\n    {\n        allocated_sounds_tail = snd;\n    }\n    else\n    {\n        snd->next->prev = snd;\n    }\n}\n\n// Unlink a sound from the linked list.\n\nstatic void AllocatedSoundUnlink(allocated_sound_t *snd)\n{\n    if (snd->prev == NULL)\n    {\n        allocated_sounds_head = snd->next;\n    }\n    else\n    {\n        snd->prev->next = snd->next;\n    }\n\n    if (snd->next == NULL)\n    {\n        allocated_sounds_tail = snd->prev;\n    }\n    else\n    {\n        snd->next->prev = snd->prev;\n    }\n}\n\nstatic void FreeAllocatedSound(allocated_sound_t *snd)\n{\n    // Unlink from linked list.\n\n    AllocatedSoundUnlink(snd);\n\n    // Keep track of the amount of allocated sound data:\n\n    allocated_sounds_size -= snd->chunk.alen;\n\n    free(snd);\n}\n\n// Search from the tail backwards along the allocated sounds list, find\n// and free a sound that is not in use, to free up memory.  Return true\n// for success.\n\nstatic boolean FindAndFreeSound(void)\n{\n    allocated_sound_t *snd;\n\n    snd = allocated_sounds_tail;\n\n    while (snd != NULL)\n    {\n        if (snd->use_count == 0)\n        {\n            FreeAllocatedSound(snd);\n            return true;\n        }\n\n        snd = snd->prev;\n    }\n\n    // No available sounds to free...\n\n    return false;\n}\n\n// Enforce SFX cache size limit.  We are just about to allocate \"len\"\n// bytes on the heap for a new sound effect, so free up some space\n// so that we keep allocated_sounds_size < snd_cachesize\n\nstatic void ReserveCacheSpace(size_t len)\n{\n    if (snd_cachesize <= 0)\n    {\n        return;\n    }\n\n    // Keep freeing sound effects that aren't currently being played,\n    // until there is enough space for the new sound.\n\n    while (allocated_sounds_size + len > snd_cachesize)\n    {\n        // Free a sound.  If there is nothing more to free, stop.\n\n        if (!FindAndFreeSound())\n        {\n            break;\n        }\n    }\n}\n\n// Allocate a block for a new sound effect.\n\nstatic allocated_sound_t *AllocateSound(sfxinfo_t *sfxinfo, size_t len)\n{\n    allocated_sound_t *snd;\n\n    // Keep allocated sounds within the cache size.\n\n    ReserveCacheSpace(len);\n\n    // Allocate the sound structure and data.  The data will immediately\n    // follow the structure, which acts as a header.\n\n    do\n    {\n        snd = malloc(sizeof(allocated_sound_t) + len);\n\n        // Out of memory?  Try to free an old sound, then loop round\n        // and try again.\n\n        if (snd == NULL && !FindAndFreeSound())\n        {\n            return NULL;\n        }\n\n    } while (snd == NULL);\n\n    // Skip past the chunk structure for the audio buffer\n\n    snd->chunk.abuf = (byte *) (snd + 1);\n    snd->chunk.alen = len;\n    snd->chunk.allocated = 1;\n    snd->chunk.volume = MIX_MAX_VOLUME;\n    snd->pitch = NORM_PITCH;\n\n    snd->sfxinfo = sfxinfo;\n    snd->use_count = 0;\n\n    // Keep track of how much memory all these cached sounds are using...\n\n    allocated_sounds_size += len;\n\n    AllocatedSoundLink(snd);\n\n    return snd;\n}\n\n// Lock a sound, to indicate that it may not be freed.\n\nstatic void LockAllocatedSound(allocated_sound_t *snd)\n{\n    // Increase use count, to stop the sound being freed.\n\n    ++snd->use_count;\n\n    // When we use a sound, re-link it into the list at the head, so\n    // that the oldest sounds fall to the end of the list for freeing.\n\n    AllocatedSoundUnlink(snd);\n    AllocatedSoundLink(snd);\n}\n\n// Unlock a sound to indicate that it may now be freed.\n\nstatic void UnlockAllocatedSound(allocated_sound_t *snd)\n{\n    if (snd->use_count <= 0)\n    {\n        I_Error(\"Sound effect released more times than it was locked...\");\n    }\n\n    --snd->use_count;\n}\n\n// Search through the list of allocated sounds and return the one that matches\n// the supplied sfxinfo entry and pitch level.\n\nstatic allocated_sound_t * GetAllocatedSoundBySfxInfoAndPitch(sfxinfo_t *sfxinfo, int pitch)\n{\n    allocated_sound_t * p = allocated_sounds_head;\n\n    while (p != NULL)\n    {\n        if (p->sfxinfo == sfxinfo && p->pitch == pitch)\n        {\n            return p;\n        }\n        p = p->next;\n    }\n\n    return NULL;\n}\n\n// Allocate a new sound chunk and pitch-shift an existing sound up-or-down\n// into it.\n\nstatic allocated_sound_t * PitchShift(allocated_sound_t *insnd, int pitch)\n{\n    allocated_sound_t * outsnd;\n    Sint16 *inp, *outp;\n    Sint16 *srcbuf, *dstbuf;\n    Uint32 srclen, dstlen;\n\n    srcbuf = (Sint16 *)insnd->chunk.abuf;\n    srclen = insnd->chunk.alen;\n\n    // determine ratio pitch:NORM_PITCH and apply to srclen, then invert.\n    // This is an approximation of vanilla behaviour based on measurements\n    dstlen = (int)((1 + (1 - (float)pitch / NORM_PITCH)) * srclen);\n\n    // ensure that the new buffer is an even length\n    if ((dstlen % 2) == 0)\n    {\n        dstlen++;\n    }\n\n    outsnd = AllocateSound(insnd->sfxinfo, dstlen);\n\n    if (!outsnd)\n    {\n        return NULL;\n    }\n\n    outsnd->pitch = pitch;\n    dstbuf = (Sint16 *)outsnd->chunk.abuf;\n\n    // loop over output buffer. find corresponding input cell, copy over\n    for (outp = dstbuf; outp < dstbuf + dstlen/2; ++outp)\n    {\n        inp = srcbuf + (int)((float)(outp - dstbuf) / dstlen * srclen);\n        *outp = *inp;\n    }\n\n    return outsnd;\n}\n\n// When a sound stops, check if it is still playing.  If it is not,\n// we can mark the sound data as CACHE to be freed back for other\n// means.\n\nstatic void ReleaseSoundOnChannel(int channel)\n{\n    allocated_sound_t *snd = channels_playing[channel];\n\n    Mix_HaltChannel(channel);\n\n    if (snd == NULL)\n    {\n        return;\n    }\n\n    channels_playing[channel] = NULL;\n\n    UnlockAllocatedSound(snd);\n\n    // if the sound is a pitch-shift and it's not in use, immediately\n    // free it\n    if (snd->pitch != NORM_PITCH && snd->use_count <= 0)\n    {\n        FreeAllocatedSound(snd);\n    }\n}\n\nstatic boolean ConvertibleRatio(int freq1, int freq2)\n{\n    int ratio;\n\n    if (freq1 > freq2)\n    {\n        return ConvertibleRatio(freq2, freq1);\n    }\n    else if ((freq2 % freq1) != 0)\n    {\n        // Not in a direct ratio\n\n        return false;\n    }\n    else\n    {\n        // Check the ratio is a power of 2\n\n        ratio = freq2 / freq1;\n\n        while ((ratio & 1) == 0)\n        {\n            ratio = ratio >> 1;\n        }\n\n        return ratio == 1;\n    }\n}\n\n#ifdef DEBUG_DUMP_WAVS\n\n// Debug code to dump resampled sound effects to WAV files for analysis.\n\nstatic void WriteWAV(char *filename, byte *data,\n                     uint32_t length, int samplerate)\n{\n    FILE *wav;\n    unsigned int i;\n    unsigned short s;\n\n    wav = fopen(filename, \"wb\");\n\n    // Header\n\n    fwrite(\"RIFF\", 1, 4, wav);\n    i = LONG(36 + samplerate);\n    fwrite(&i, 4, 1, wav);\n    fwrite(\"WAVE\", 1, 4, wav);\n\n    // Subchunk 1\n\n    fwrite(\"fmt \", 1, 4, wav);\n    i = LONG(16);\n    fwrite(&i, 4, 1, wav);           // Length\n    s = SHORT(1);\n    fwrite(&s, 2, 1, wav);           // Format (PCM)\n    s = SHORT(2);\n    fwrite(&s, 2, 1, wav);           // Channels (2=stereo)\n    i = LONG(samplerate);\n    fwrite(&i, 4, 1, wav);           // Sample rate\n    i = LONG(samplerate * 2 * 2);\n    fwrite(&i, 4, 1, wav);           // Byte rate (samplerate * stereo * 16 bit)\n    s = SHORT(2 * 2);\n    fwrite(&s, 2, 1, wav);           // Block align (stereo * 16 bit)\n    s = SHORT(16);\n    fwrite(&s, 2, 1, wav);           // Bits per sample (16 bit)\n\n    // Data subchunk\n\n    fwrite(\"data\", 1, 4, wav);\n    i = LONG(length);\n    fwrite(&i, 4, 1, wav);           // Data length\n    fwrite(data, 1, length, wav);    // Data\n\n    fclose(wav);\n}\n\n#endif\n\n// Generic sound expansion function for any sample rate.\n// Returns number of clipped samples (always 0).\n\nstatic boolean ExpandSoundData_SDL(sfxinfo_t *sfxinfo,\n                                   byte *data,\n                                   int samplerate,\n                                   int length)\n{\n    SDL_AudioCVT convertor;\n    allocated_sound_t *snd;\n    Mix_Chunk *chunk;\n    uint32_t expanded_length;\n\n    // Calculate the length of the expanded version of the sample.\n\n    expanded_length = (uint32_t) ((((uint64_t) length) * mixer_freq) / samplerate);\n\n    // Double up twice: 8 -> 16 bit and mono -> stereo\n\n    expanded_length *= 4;\n\n    // Allocate a chunk in which to expand the sound\n\n    snd = AllocateSound(sfxinfo, expanded_length);\n\n    if (snd == NULL)\n    {\n        return false;\n    }\n\n    chunk = &snd->chunk;\n\n    // If we can, use the standard / optimized SDL conversion routines.\n\n    if (samplerate <= mixer_freq\n     && ConvertibleRatio(samplerate, mixer_freq)\n     && SDL_BuildAudioCVT(&convertor,\n                          AUDIO_U8, 1, samplerate,\n                          mixer_format, mixer_channels, mixer_freq))\n    {\n        convertor.len = length;\n        convertor.buf = malloc(convertor.len * convertor.len_mult);\n        assert(convertor.buf != NULL);\n        memcpy(convertor.buf, data, length);\n\n        SDL_ConvertAudio(&convertor);\n\n        memcpy(chunk->abuf, convertor.buf, chunk->alen);\n        free(convertor.buf);\n    }\n    else\n    {\n        Sint16 *expanded = (Sint16 *) chunk->abuf;\n        int expanded_length;\n        int expand_ratio;\n        int i;\n\n        // Generic expansion if conversion does not work:\n        //\n        // SDL's audio conversion only works for rate conversions that are\n        // powers of 2; if the two formats are not in a direct power of 2\n        // ratio, do this naive conversion instead.\n\n        // number of samples in the converted sound\n\n        expanded_length = ((uint64_t) length * mixer_freq) / samplerate;\n        expand_ratio = (length << 8) / expanded_length;\n\n        for (i=0; i<expanded_length; ++i)\n        {\n            Sint16 sample;\n            int src;\n\n            src = (i * expand_ratio) >> 8;\n\n            sample = data[src] | (data[src] << 8);\n            sample -= 32768;\n\n            // expand 8->16 bits, mono->stereo\n\n            expanded[i * 2] = expanded[i * 2 + 1] = sample;\n        }\n\n#ifdef LOW_PASS_FILTER\n        // Perform a low-pass filter on the upscaled sound to filter\n        // out high-frequency noise from the conversion process.\n\n        {\n            float rc, dt, alpha;\n\n            // Low-pass filter for cutoff frequency f:\n            //\n            // For sampling rate r, dt = 1 / r\n            // rc = 1 / 2*pi*f\n            // alpha = dt / (rc + dt)\n\n            // Filter to the half sample rate of the original sound effect\n            // (maximum frequency, by nyquist)\n\n            dt = 1.0f / mixer_freq;\n            rc = 1.0f / (3.14f * samplerate);\n            alpha = dt / (rc + dt);\n\n            // Both channels are processed in parallel, hence [i-2]:\n\n            for (i=2; i<expanded_length * 2; ++i)\n            {\n                expanded[i] = (Sint16) (alpha * expanded[i]\n                                      + (1 - alpha) * expanded[i-2]);\n            }\n        }\n#endif /* #ifdef LOW_PASS_FILTER */\n    }\n\n    return true;\n}\n\n// Load and convert a sound effect\n// Returns true if successful\n\nstatic boolean CacheSFX(sfxinfo_t *sfxinfo)\n{\n    int lumpnum;\n    unsigned int lumplen;\n    int samplerate;\n    unsigned int length;\n    byte *data;\n\n    // need to load the sound\n\n    lumpnum = sfxinfo->lumpnum;\n    data = W_CacheLumpNum(lumpnum, PU_STATIC);\n    lumplen = W_LumpLength(lumpnum);\n\n    // Check the header, and ensure this is a valid sound\n\n    if (lumplen < 8\n     || data[0] != 0x03 || data[1] != 0x00)\n    {\n        // Invalid sound\n\n        return false;\n    }\n\n    // 16 bit sample rate field, 32 bit length field\n\n    samplerate = (data[3] << 8) | data[2];\n    length = (data[7] << 24) | (data[6] << 16) | (data[5] << 8) | data[4];\n\n    // If the header specifies that the length of the sound is greater than\n    // the length of the lump itself, this is an invalid sound lump\n\n    // We also discard sound lumps that are less than 49 samples long,\n    // as this is how DMX behaves - although the actual cut-off length\n    // seems to vary slightly depending on the sample rate.  This needs\n    // further investigation to better understand the correct\n    // behavior.\n\n    if (length > lumplen - 8 || length <= 48)\n    {\n        return false;\n    }\n\n    // The DMX sound library seems to skip the first 16 and last 16\n    // bytes of the lump - reason unknown.\n\n    data += 16;\n    length -= 32;\n\n    // Sample rate conversion\n\n    if (!ExpandSoundData(sfxinfo, data + 8, samplerate, length))\n    {\n        return false;\n    }\n\n#ifdef DEBUG_DUMP_WAVS\n    {\n        char filename[16];\n        allocated_sound_t * snd;\n\n        M_snprintf(filename, sizeof(filename), \"%s.wav\",\n                   DEH_String(sfxinfo->name));\n        snd = GetAllocatedSoundBySfxInfoAndPitch(sfxinfo, NORM_PITCH);\n        WriteWAV(filename, snd->chunk.abuf, snd->chunk.alen,mixer_freq);\n    }\n#endif\n\n    // don't need the original lump any more\n  \n    W_ReleaseLumpNum(lumpnum);\n\n    return true;\n}\n\nstatic void GetSfxLumpName(sfxinfo_t *sfx, char *buf, size_t buf_len)\n{\n    // Linked sfx lumps? Get the lump number for the sound linked to.\n\n    if (sfx->link != NULL)\n    {\n        sfx = sfx->link;\n    }\n\n    // Doom adds a DS* prefix to sound lumps; Heretic and Hexen don't\n    // do this.\n\n    if (use_sfx_prefix)\n    {\n        M_snprintf(buf, buf_len, \"ds%s\", DEH_String(sfx->name));\n    }\n    else\n    {\n        M_StringCopy(buf, DEH_String(sfx->name), buf_len);\n    }\n}\n\nstatic void I_SDL_PrecacheSounds(sfxinfo_t *sounds, int num_sounds)\n{\n    // no-op\n}\n\n// Load a SFX chunk into memory and ensure that it is locked.\n\nstatic boolean LockSound(sfxinfo_t *sfxinfo)\n{\n    // If the sound isn't loaded, load it now\n    if (GetAllocatedSoundBySfxInfoAndPitch(sfxinfo, NORM_PITCH) == NULL)\n    {\n        if (!CacheSFX(sfxinfo))\n        {\n            return false;\n        }\n    }\n\n    LockAllocatedSound(GetAllocatedSoundBySfxInfoAndPitch(sfxinfo, NORM_PITCH));\n\n    return true;\n}\n\n//\n// Retrieve the raw data lump index\n//  for a given SFX name.\n//\n\nstatic int I_SDL_GetSfxLumpNum(sfxinfo_t *sfx)\n{\n    char namebuf[9];\n\n    GetSfxLumpName(sfx, namebuf, sizeof(namebuf));\n\n    return W_GetNumForName(namebuf);\n}\n\nstatic void I_SDL_UpdateSoundParams(int handle, int vol, int sep)\n{\n    int left, right;\n\n    if (!sound_initialized || handle < 0 || handle >= NUM_CHANNELS)\n    {\n        return;\n    }\n\n    left = ((254 - sep) * vol) / 127;\n    right = ((sep) * vol) / 127;\n\n    if (left < 0) left = 0;\n    else if ( left > 255) left = 255;\n    if (right < 0) right = 0;\n    else if (right > 255) right = 255;\n\n    Mix_SetPanning(handle, left, right);\n}\n\n//\n// Starting a sound means adding it\n//  to the current list of active sounds\n//  in the internal channels.\n// As the SFX info struct contains\n//  e.g. a pointer to the raw data,\n//  it is ignored.\n// As our sound handling does not handle\n//  priority, it is ignored.\n// Pitching (that is, increased speed of playback)\n//  is set, but currently not used by mixing.\n//\n\nstatic int I_SDL_StartSound(sfxinfo_t *sfxinfo, int channel, int vol, int sep, int pitch)\n{\n    allocated_sound_t *snd;\n\n    if (!sound_initialized || channel < 0 || channel >= NUM_CHANNELS)\n    {\n        return -1;\n    }\n\n    // Release a sound effect if there is already one playing\n    // on this channel\n\n    ReleaseSoundOnChannel(channel);\n\n    // Get the sound data\n\n    if (!LockSound(sfxinfo))\n    {\n        return -1;\n    }\n\n    snd = GetAllocatedSoundBySfxInfoAndPitch(sfxinfo, pitch);\n\n    if (snd == NULL)\n    {\n        allocated_sound_t *newsnd;\n        // fetch the base sound effect, un-pitch-shifted\n        snd = GetAllocatedSoundBySfxInfoAndPitch(sfxinfo, NORM_PITCH);\n\n        if (snd == NULL)\n        {\n            return -1;\n        }\n\n        if (snd_pitchshift)\n        {\n            newsnd = PitchShift(snd, pitch);\n\n            if (newsnd)\n            {\n                LockAllocatedSound(newsnd);\n                UnlockAllocatedSound(snd);\n                snd = newsnd;\n            }\n        }\n    }\n    else\n    {\n        LockAllocatedSound(snd);\n    }\n\n    // play sound\n\n    Mix_PlayChannel(channel, &snd->chunk, 0);\n\n    channels_playing[channel] = snd;\n\n    // set separation, etc.\n\n    I_SDL_UpdateSoundParams(channel, vol, sep);\n\n    return channel;\n}\n\nstatic void I_SDL_StopSound(int handle)\n{\n    if (!sound_initialized || handle < 0 || handle >= NUM_CHANNELS)\n    {\n        return;\n    }\n\n    // Sound data is no longer needed; release the\n    // sound data being used for this channel\n\n    ReleaseSoundOnChannel(handle);\n}\n\n\nstatic boolean I_SDL_SoundIsPlaying(int handle)\n{\n    if (!sound_initialized || handle < 0 || handle >= NUM_CHANNELS)\n    {\n        return false;\n    }\n\n    return Mix_Playing(handle);\n}\n\n//\n// Periodically called to update the sound system\n//\n\nstatic void I_SDL_UpdateSound(void)\n{\n    int i;\n\n    // Check all channels to see if a sound has finished\n\n    for (i=0; i<NUM_CHANNELS; ++i)\n    {\n        if (channels_playing[i] && !I_SDL_SoundIsPlaying(i))\n        {\n            // Sound has finished playing on this channel,\n            // but sound data has not been released to cache\n\n            ReleaseSoundOnChannel(i);\n        }\n    }\n}\n\nstatic void I_SDL_ShutdownSound(void)\n{\n    if (!sound_initialized)\n    {\n        return;\n    }\n\n    Mix_CloseAudio();\n    SDL_QuitSubSystem(SDL_INIT_AUDIO);\n\n    sound_initialized = false;\n}\n\n// Calculate slice size, based on snd_maxslicetime_ms.\n// The result must be a power of two.\n\nstatic int GetSliceSize(void)\n{\n    int limit;\n    int n;\n\n    limit = (snd_samplerate * snd_maxslicetime_ms) / 1000;\n\n    // Try all powers of two, not exceeding the limit.\n\n    for (n=0;; ++n)\n    {\n        // 2^n <= limit < 2^n+1 ?\n\n        if ((1 << (n + 1)) > limit)\n        {\n            return (1 << n);\n        }\n    }\n\n    // Should never happen?\n\n    return 1024;\n}\n\nstatic boolean I_SDL_InitSound(boolean _use_sfx_prefix)\n{\n    int i;\n\n    // SDL 2.0.6 has a bug that makes it unusable.\n    if (SDL_COMPILEDVERSION == SDL_VERSIONNUM(2, 0, 6))\n    {\n        I_Error(\n            \"I_SDL_InitSound: \"\n            \"You are trying to launch with SDL 2.0.6 which has a known bug \"\n            \"that makes the game crash. Please either downgrade to \"\n            \"SDL 2.0.5 or upgrade to 2.0.7. See the following bug for some \"\n            \"additional context:\\n\"\n            \"<https://github.com/chocolate-doom/chocolate-doom/issues/945>\");\n    }\n\n    use_sfx_prefix = _use_sfx_prefix;\n\n    // No sounds yet\n    for (i=0; i<NUM_CHANNELS; ++i)\n    {\n        channels_playing[i] = NULL;\n    }\n\n    if (SDL_Init(SDL_INIT_AUDIO) < 0)\n    {\n        fprintf(stderr, \"Unable to set up sound.\\n\");\n        return false;\n    }\n\n    if (Mix_OpenAudio(snd_samplerate, AUDIO_S16SYS, 2, GetSliceSize()) < 0)\n    {\n        fprintf(stderr, \"Error initialising SDL_mixer: %s\\n\", Mix_GetError());\n        return false;\n    }\n\n    ExpandSoundData = ExpandSoundData_SDL;\n\n    Mix_QuerySpec(&mixer_freq, &mixer_format, &mixer_channels);\n    Mix_AllocateChannels(NUM_CHANNELS);\n\n    SDL_PauseAudio(0);\n\n    sound_initialized = true;\n\n    return true;\n}\n\nstatic snddevice_t sound_sdl_devices[] = \n{\n    SNDDEVICE_SB,\n    SNDDEVICE_PAS,\n    SNDDEVICE_GUS,\n    SNDDEVICE_WAVEBLASTER,\n    SNDDEVICE_SOUNDCANVAS,\n    SNDDEVICE_AWE32,\n};\n\nsound_module_t sound_sdl_module = \n{\n    sound_sdl_devices,\n    arrlen(sound_sdl_devices),\n    I_SDL_InitSound,\n    I_SDL_ShutdownSound,\n    I_SDL_GetSfxLumpNum,\n    I_SDL_UpdateSound,\n    I_SDL_UpdateSoundParams,\n    I_SDL_StartSound,\n    I_SDL_StopSound,\n    I_SDL_SoundIsPlaying,\n    I_SDL_PrecacheSounds,\n};\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:  none\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"SDL_mixer.h\"\n\n#include \"config.h\"\n#include \"doomtype.h\"\n\n#include \"i_sound.h\"\n#include \"i_video.h\"\n#include \"m_argv.h\"\n#include \"m_config.h\"\n\n// Sound sample rate to use for digital output (Hz)\n\nint snd_samplerate = 48000;\n\n// Maximum number of bytes to dedicate to allocated sound effects.\n// (Default: 64MB)\n\nint snd_cachesize = 64 * 1024 * 1024;\n\n// Config variable that controls the sound buffer size.\n// We default to 28ms (1000 / 35fps = 1 buffer per tic).\n\nint snd_maxslicetime_ms = 28 * 4;\n\n// External command to invoke to play back music.\n\nchar *snd_musiccmd = \"\";\n\n// Whether to vary the pitch of sound effects\n// Each game will set the default differently\n\nint snd_pitchshift = -1;\n\n// Low-level sound and music modules we are using\n\nstatic sound_module_t *sound_module;\nstatic music_module_t *music_module;\n\nint snd_musicdevice = SNDDEVICE_SB;\nint snd_sfxdevice = SNDDEVICE_SB;\n\n// Sound modules\n\nextern sound_module_t sound_sdl_module;\nextern music_module_t music_opl_module;\nextern music_module_t music_web_module;\n\n// For OPL module:\n\nextern opl_driver_ver_t opl_drv_ver;\nextern int opl_io_port;\n\n// DOS-specific options: These are unused but should be maintained\n// so that the config file can be shared between chocolate\n// doom and doom.exe\n\nstatic int snd_sbport = 0;\nstatic int snd_sbirq = 0;\nstatic int snd_sbdma = 0;\nstatic int snd_mport = 0;\n\n// Compiled-in sound modules:\n\nstatic sound_module_t *sound_modules[] = \n{\n    &sound_sdl_module,\n    NULL,\n};\n\n// Compiled-in music modules:\n\nstatic music_module_t *music_modules[] =\n{\n    &music_web_module,\n    &music_opl_module,\n    NULL,\n};\n\n// Check if a sound device is in the given list of devices\n\nstatic boolean SndDeviceInList(snddevice_t device, snddevice_t *list,\n                               int len)\n{\n    int i;\n\n    for (i=0; i<len; ++i)\n    {\n        if (device == list[i])\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Find and initialize a sound_module_t appropriate for the setting\n// in snd_sfxdevice.\n\nstatic void InitSfxModule(boolean use_sfx_prefix)\n{\n    int i;\n\n    sound_module = NULL;\n\n    for (i=0; sound_modules[i] != NULL; ++i)\n    {\n        // Is the sfx device in the list of devices supported by\n        // this module?\n\n        if (SndDeviceInList(snd_sfxdevice, \n                            sound_modules[i]->sound_devices,\n                            sound_modules[i]->num_sound_devices))\n        {\n            // Initialize the module\n\n            if (sound_modules[i]->Init(use_sfx_prefix))\n            {\n                sound_module = sound_modules[i];\n                return;\n            }\n        }\n    }\n}\n\n// Initialize music according to snd_musicdevice.\n\nstatic void InitMusicModule(void)\n{\n    int i;\n\n    music_module = NULL;\n\n    for (i=0; music_modules[i] != NULL; ++i)\n    {\n        // Is the music device in the list of devices supported\n        // by this module?\n\n        if (SndDeviceInList(snd_musicdevice, \n                            music_modules[i]->sound_devices,\n                            music_modules[i]->num_sound_devices))\n        {\n            // Initialize the module\n\n            if (music_modules[i]->Init())\n            {\n                music_module = music_modules[i];\n                return;\n            }\n        }\n    }\n}\n\n//\n// Initializes sound stuff, including volume\n// Sets channels, SFX and music volume,\n//  allocates channel buffer, sets S_sfx lookup.\n//\n\nvoid I_InitSound(boolean use_sfx_prefix)\n{  \n    boolean nosound, nosfx, nomusic;\n\n    int p = M_CheckParmWithArgs(\"-sndbufferms\", 1);\n\n    if (p)\n    {\n\t    snd_maxslicetime_ms = atoi(myargv[p+1]);\n    }\n\n    //!\n    // @vanilla\n    //\n    // Disable all sound output.\n    //\n\n    nosound = M_CheckParm(\"-nosound\") > 0;\n\n    //!\n    // @vanilla\n    //\n    // Disable sound effects. \n    //\n\n    nosfx = M_CheckParm(\"-nosfx\") > 0;\n\n    //!\n    // @vanilla\n    //\n    // Disable music.\n    //\n\n    nomusic = M_CheckParm(\"-nomusic\") > 0;\n\n    // Initialize the sound and music subsystems.\n\n    if (!nosound && !screensaver_mode)\n    {\n        // This is kind of a hack. If native MIDI is enabled, set up\n        // the TIMIDITY_CFG environment variable here before SDL_mixer\n        // is opened.\n\n        if (!nomusic\n         && (snd_musicdevice == SNDDEVICE_GENMIDI\n          || snd_musicdevice == SNDDEVICE_GUS))\n        {\n            // I_InitTimidityConfig();\n        }\n\n        if (!nosfx)\n        {\n            InitSfxModule(use_sfx_prefix);\n        }\n\n        if (!nomusic)\n        {\n            InitMusicModule();\n        }\n    }\n}\n\nvoid I_ShutdownSound(void)\n{\n    if (sound_module != NULL)\n    {\n        sound_module->Shutdown();\n    }\n\n    if (music_module != NULL)\n    {\n        music_module->Shutdown();\n    }\n}\n\nint I_GetSfxLumpNum(sfxinfo_t *sfxinfo)\n{\n    if (sound_module != NULL) \n    {\n        return sound_module->GetSfxLumpNum(sfxinfo);\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nvoid I_UpdateSound(void)\n{\n    if (sound_module != NULL)\n    {\n        sound_module->Update();\n    }\n\n    if (music_module != NULL && music_module->Poll != NULL)\n    {\n        music_module->Poll();\n    }\n}\n\nstatic void CheckVolumeSeparation(int *vol, int *sep)\n{\n    if (*sep < 0)\n    {\n        *sep = 0;\n    }\n    else if (*sep > 254)\n    {\n        *sep = 254;\n    }\n\n    if (*vol < 0)\n    {\n        *vol = 0;\n    }\n    else if (*vol > 127)\n    {\n        *vol = 127;\n    }\n}\n\nvoid I_UpdateSoundParams(int channel, int vol, int sep)\n{\n    if (sound_module != NULL)\n    {\n        CheckVolumeSeparation(&vol, &sep);\n        sound_module->UpdateSoundParams(channel, vol, sep);\n    }\n}\n\nint I_StartSound(sfxinfo_t *sfxinfo, int channel, int vol, int sep, int pitch)\n{\n    if (sound_module != NULL)\n    {\n        CheckVolumeSeparation(&vol, &sep);\n        return sound_module->StartSound(sfxinfo, channel, vol, sep, pitch);\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nvoid I_StopSound(int channel)\n{\n    if (sound_module != NULL)\n    {\n        sound_module->StopSound(channel);\n    }\n}\n\nboolean I_SoundIsPlaying(int channel)\n{\n    if (sound_module != NULL)\n    {\n        return sound_module->SoundIsPlaying(channel);\n    }\n    else\n    {\n        return false;\n    }\n}\n\nvoid I_PrecacheSounds(sfxinfo_t *sounds, int num_sounds)\n{\n    if (sound_module != NULL && sound_module->CacheSounds != NULL)\n    {\n        sound_module->CacheSounds(sounds, num_sounds);\n    }\n}\n\nvoid I_InitMusic(void)\n{\n}\n\nvoid I_ShutdownMusic(void)\n{\n\n}\n\nvoid I_SetMusicVolume(int volume)\n{\n    if (music_module != NULL)\n    {\n        music_module->SetMusicVolume(volume);\n    }\n}\n\nvoid I_PauseSong(void)\n{\n    if (music_module != NULL)\n    {\n        music_module->PauseMusic();\n    }\n}\n\nvoid I_ResumeSong(void)\n{\n    if (music_module != NULL)\n    {\n        music_module->ResumeMusic();\n    }\n}\n\nvoid *I_RegisterSong(void *data, int len)\n{\n    if (music_module != NULL)\n    {\n        return music_module->RegisterSong(data, len);\n    }\n    else\n    {\n        return NULL;\n    }\n}\n\nvoid I_UnRegisterSong(void *handle)\n{\n    if (music_module != NULL)\n    {\n        music_module->UnRegisterSong(handle);\n    }\n}\n\nvoid I_PlaySong(void *handle, boolean looping)\n{\n    if (music_module != NULL)\n    {\n        music_module->PlaySong(handle, looping);\n    }\n}\n\nvoid I_StopSong(void)\n{\n    if (music_module != NULL)\n    {\n        music_module->StopSong();\n    }\n}\n\nboolean I_MusicIsPlaying(void)\n{\n    if (music_module != NULL)\n    {\n        return music_module->MusicIsPlaying();\n    }\n    else\n    {\n        return false;\n    }\n}\n\nvoid I_BindSoundVariables(void)\n{\n    extern char *snd_dmxoption;\n\n    M_BindIntVariable(\"snd_musicdevice\",         &snd_musicdevice);\n    M_BindIntVariable(\"snd_sfxdevice\",           &snd_sfxdevice);\n    M_BindIntVariable(\"snd_sbport\",              &snd_sbport);\n    M_BindIntVariable(\"snd_sbirq\",               &snd_sbirq);\n    M_BindIntVariable(\"snd_sbdma\",               &snd_sbdma);\n    M_BindIntVariable(\"snd_mport\",               &snd_mport);\n    M_BindIntVariable(\"snd_maxslicetime_ms\",     &snd_maxslicetime_ms);\n    M_BindStringVariable(\"snd_musiccmd\",         &snd_musiccmd);\n    M_BindStringVariable(\"snd_dmxoption\",        &snd_dmxoption);\n    M_BindIntVariable(\"snd_samplerate\",          &snd_samplerate);\n    M_BindIntVariable(\"snd_cachesize\",           &snd_cachesize);\n    M_BindIntVariable(\"opl_io_port\",             &opl_io_port);\n    M_BindIntVariable(\"snd_pitchshift\",          &snd_pitchshift);\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\n\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include <stdarg.h>\n\n#include \"SDL.h\"\n\n#include \"config.h\"\n\n#include \"deh_str.h\"\n#include \"doomtype.h\"\n#include \"m_argv.h\"\n#include \"m_config.h\"\n#include \"m_misc.h\"\n#include \"i_joystick.h\"\n#include \"i_sound.h\"\n#include \"i_timer.h\"\n#include \"i_video.h\"\n\n#include \"i_system.h\"\n\n#include \"w_wad.h\"\n#include \"z_zone.h\"\n\n#include <emscripten.h>\n\n#define DEFAULT_RAM 16 /* MiB */\n#define MIN_RAM     4  /* MiB */\n\n\ntypedef struct atexit_listentry_s atexit_listentry_t;\n\nstruct atexit_listentry_s\n{\n    atexit_func_t func;\n    boolean run_on_error;\n    atexit_listentry_t *next;\n};\n\nstatic atexit_listentry_t *exit_funcs = NULL;\n\nvoid I_AtExit(atexit_func_t func, boolean run_on_error)\n{\n    atexit_listentry_t *entry;\n\n    entry = malloc(sizeof(*entry));\n\n    entry->func = func;\n    entry->run_on_error = run_on_error;\n    entry->next = exit_funcs;\n    exit_funcs = entry;\n}\n\n// Tactile feedback function, probably used for the Logitech Cyberman\n\nvoid I_Tactile(int on, int off, int total)\n{\n}\n\n// Zone memory auto-allocation function that allocates the zone size\n// by trying progressively smaller zone sizes until one is found that\n// works.\n\nstatic byte *AutoAllocMemory(int *size, int default_ram, int min_ram)\n{\n    byte *zonemem;\n\n    // Allocate the zone memory.  This loop tries progressively smaller\n    // zone sizes until a size is found that can be allocated.\n    // If we used the -mb command line parameter, only the parameter\n    // provided is accepted.\n\n    zonemem = NULL;\n\n    while (zonemem == NULL)\n    {\n        // We need a reasonable minimum amount of RAM to start.\n\n        if (default_ram < min_ram)\n        {\n            I_Error(\"Unable to allocate %i MiB of RAM for zone\", default_ram);\n        }\n\n        // Try to allocate the zone memory.\n\n        *size = default_ram * 1024 * 1024;\n\n        zonemem = malloc(*size);\n\n        // Failed to allocate?  Reduce zone size until we reach a size\n        // that is acceptable.\n\n        if (zonemem == NULL)\n        {\n            default_ram -= 1;\n        }\n    }\n\n    return zonemem;\n}\n\nbyte *I_ZoneBase (int *size)\n{\n    byte *zonemem;\n    int min_ram, default_ram;\n    int p;\n\n    //!\n    // @category obscure\n    // @arg <mb>\n    //\n    // Specify the heap size, in MiB (default 16).\n    //\n\n    p = M_CheckParmWithArgs(\"-mb\", 1);\n\n    if (p > 0)\n    {\n        default_ram = atoi(myargv[p+1]);\n        min_ram = default_ram;\n    }\n    else\n    {\n        default_ram = DEFAULT_RAM;\n        min_ram = MIN_RAM;\n    }\n\n    zonemem = AutoAllocMemory(size, default_ram, min_ram);\n\n    printf(\"zone memory: %p, %x allocated for zone\\n\",\n           zonemem, *size);\n\n    return zonemem;\n}\n\nvoid I_PrintBanner(const char *msg)\n{\n    int i;\n    int spaces = 35 - (strlen(msg) / 2);\n\n    for (i=0; i<spaces; ++i)\n        putchar(' ');\n\n    puts(msg);\n}\n\nvoid I_PrintDivider(void)\n{\n    int i;\n\n    for (i=0; i<75; ++i)\n    {\n        putchar('=');\n    }\n\n    putchar('\\n');\n}\n\nvoid I_PrintStartupBanner(const char *gamedescription)\n{\n    I_PrintDivider();\n    I_PrintBanner(gamedescription);\n    I_PrintDivider();\n\n    printf(\n    \" \" PACKAGE_NAME \" is free software, covered by the GNU General Public\\n\"\n    \" License.  There is NO warranty; not even for MERCHANTABILITY or FITNESS\\n\"\n    \" FOR A PARTICULAR PURPOSE. You are welcome to change and distribute\\n\"\n    \" copies under certain conditions. See the source for more information.\\n\");\n\n    I_PrintDivider();\n}\n\n//\n// I_ConsoleStdout\n//\n// Returns true if stdout is a real console, false if it is a file\n//\n\nboolean I_ConsoleStdout(void)\n{\n    return false;\n}\n\n//\n// I_Quit\n//\n\nvoid I_Quit (void)\n{\n    atexit_listentry_t *entry;\n\n    // Run through all exit functions\n\n    entry = exit_funcs;\n\n    while (entry != NULL)\n    {\n        entry->func();\n        entry = entry->next;\n    }\n}\n\n\n\n//\n// I_Error\n//\n\nstatic boolean already_quitting = false;\n\nvoid I_Error (const char *error, ...)\n{\n    char msgbuf[512];\n    va_list argptr;\n    atexit_listentry_t *entry;\n\n    if (already_quitting)\n    {\n        fprintf(stderr, \"Warning: recursive call to I_Error detected.\\n\");\n        exit(-1);\n    }\n    else\n    {\n        already_quitting = true;\n    }\n\n    // Message first.\n    va_start(argptr, error);\n    vfprintf(stderr, error, argptr);\n    fprintf(stderr, \"\\n\\n\");\n    va_end(argptr);\n    fflush(stderr);\n\n    // Write a copy of the message into buffer.\n    va_start(argptr, error);\n    memset(msgbuf, 0, sizeof(msgbuf));\n    M_vsnprintf(msgbuf, sizeof(msgbuf), error, argptr);\n    va_end(argptr);\n\n    EM_ASM_({\n        document.dispatchEvent(new CustomEvent(\"I_Error\", { detail: { errorMsg: Module.UTF8ToString($0) } }));\n    }, msgbuf);\n\n    // Shutdown. Here might be other errors.\n\n    entry = exit_funcs;\n\n    while (entry != NULL)\n    {\n        if (entry->run_on_error)\n        {\n            entry->func();\n        }\n\n        entry = entry->next;\n    }\n\n    SDL_Quit();\n\n    exit(-1);\n}\n\n//\n// I_Realloc\n//\n\nvoid *I_Realloc(void *ptr, size_t size)\n{\n    void *new_ptr;\n\n    new_ptr = realloc(ptr, size);\n\n    if (size != 0 && new_ptr == NULL)\n    {\n        I_Error (\"I_Realloc: failed on reallocation\");\n    }\n\n    return new_ptr;\n}\n\n//\n// Read Access Violation emulation.\n//\n// From PrBoom+, by entryway.\n//\n\n// C:\\>debug\n// -d 0:0\n//\n// DOS 6.22:\n// 0000:0000  (57 92 19 00) F4 06 70 00-(16 00)\n// DOS 7.1:\n// 0000:0000  (9E 0F C9 00) 65 04 70 00-(16 00)\n// Win98:\n// 0000:0000  (9E 0F C9 00) 65 04 70 00-(16 00)\n// DOSBox under XP:\n// 0000:0000  (00 00 00 F1) ?? ?? ?? 00-(07 00)\n\n#define DOS_MEM_DUMP_SIZE 10\n\nstatic const unsigned char mem_dump_dos622[DOS_MEM_DUMP_SIZE] = {\n  0x57, 0x92, 0x19, 0x00, 0xF4, 0x06, 0x70, 0x00, 0x16, 0x00};\nstatic const unsigned char mem_dump_win98[DOS_MEM_DUMP_SIZE] = {\n  0x9E, 0x0F, 0xC9, 0x00, 0x65, 0x04, 0x70, 0x00, 0x16, 0x00};\nstatic const unsigned char mem_dump_dosbox[DOS_MEM_DUMP_SIZE] = {\n  0x00, 0x00, 0x00, 0xF1, 0x00, 0x00, 0x00, 0x00, 0x07, 0x00};\nstatic unsigned char mem_dump_custom[DOS_MEM_DUMP_SIZE];\n\nstatic const unsigned char *dos_mem_dump = mem_dump_dos622;\n\nboolean I_GetMemoryValue(unsigned int offset, void *value, int size)\n{\n    static boolean firsttime = true;\n\n    if (firsttime)\n    {\n        int p, i, val;\n\n        firsttime = false;\n        i = 0;\n\n        //!\n        // @category compat\n        // @arg <version>\n        //\n        // Specify DOS version to emulate for NULL pointer dereference\n        // emulation.  Supported versions are: dos622, dos71, dosbox.\n        // The default is to emulate DOS 7.1 (Windows 98).\n        //\n\n        p = M_CheckParmWithArgs(\"-setmem\", 1);\n\n        if (p > 0)\n        {\n            if (!strcasecmp(myargv[p + 1], \"dos622\"))\n            {\n                dos_mem_dump = mem_dump_dos622;\n            }\n            if (!strcasecmp(myargv[p + 1], \"dos71\"))\n            {\n                dos_mem_dump = mem_dump_win98;\n            }\n            else if (!strcasecmp(myargv[p + 1], \"dosbox\"))\n            {\n                dos_mem_dump = mem_dump_dosbox;\n            }\n            else\n            {\n                for (i = 0; i < DOS_MEM_DUMP_SIZE; ++i)\n                {\n                    ++p;\n\n                    if (p >= myargc || myargv[p][0] == '-')\n                    {\n                        break;\n                    }\n\n                    M_StrToInt(myargv[p], &val);\n                    mem_dump_custom[i++] = (unsigned char) val;\n                }\n\n                dos_mem_dump = mem_dump_custom;\n            }\n        }\n    }\n\n    switch (size)\n    {\n    case 1:\n        *((unsigned char *) value) = dos_mem_dump[offset];\n        return true;\n    case 2:\n        *((unsigned short *) value) = dos_mem_dump[offset]\n                                    | (dos_mem_dump[offset + 1] << 8);\n        return true;\n    case 4:\n        *((unsigned int *) value) = dos_mem_dump[offset]\n                                  | (dos_mem_dump[offset + 1] << 8)\n                                  | (dos_mem_dump[offset + 2] << 16)\n                                  | (dos_mem_dump[offset + 3] << 24);\n        return true;\n    }\n\n    return false;\n}\n\nboolean I_IsMobile(void)\n{\n    return EM_ASM_INT(return +(typeof navigator.maxTouchPoints == \"number\" ? navigator.maxTouchPoints > 0 : \"ontouchstart\" in window));\n}","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Text mode emulation in SDL\n//\n\n#include \"SDL.h\"\n#include \"i_txt.h\"\n\nSDL_Window *TXT_SDLWindow;\nstatic SDL_Surface *screenbuffer;\nstatic unsigned char *screendata;\nstatic SDL_Renderer *renderer;\n\n// Dimensions of the screen image in screen coordinates (not pixels); this\n// is the value that was passed to SDL_CreateWindow().\nstatic int screen_image_w, screen_image_h;\n\n// Font we are using:\nstatic const txt_font_t *font = &small_font;\n\nstatic SDL_Color ega_colors[] =\n{\n    {0x00, 0x00, 0x00, 0xff},          // 0: Black\n    {0x00, 0x00, 0xa8, 0xff},          // 1: Blue\n    {0x00, 0xa8, 0x00, 0xff},          // 2: Green\n    {0x00, 0xa8, 0xa8, 0xff},          // 3: Cyan\n    {0xa8, 0x00, 0x00, 0xff},          // 4: Red\n    {0xa8, 0x00, 0xa8, 0xff},          // 5: Magenta\n    {0xa8, 0x54, 0x00, 0xff},          // 6: Brown\n    {0xa8, 0xa8, 0xa8, 0xff},          // 7: Grey\n    {0x54, 0x54, 0x54, 0xff},          // 8: Dark grey\n    {0x54, 0x54, 0xfe, 0xff},          // 9: Bright blue\n    {0x54, 0xfe, 0x54, 0xff},          // 10: Bright green\n    {0x54, 0xfe, 0xfe, 0xff},          // 11: Bright cyan\n    {0xfe, 0x54, 0x54, 0xff},          // 12: Bright red\n    {0xfe, 0x54, 0xfe, 0xff},          // 13: Bright magenta\n    {0xfe, 0xfe, 0x54, 0xff},          // 14: Yellow\n    {0xfe, 0xfe, 0xfe, 0xff},          // 15: Bright white\n};\n\n//\n// Initialize text mode screen\n//\n// Returns 1 if successful, 0 if an error occurred\n//\n\nint TXT_Init(void)\n{\n    int flags = 0;\n\n    if (SDL_Init(SDL_INIT_VIDEO) < 0)\n    {\n        return 0;\n    }\n\n    screen_image_w = TXT_SCREEN_W * font->w;\n    screen_image_h = TXT_SCREEN_H * font->h;\n\n    TXT_SDLWindow =\n        SDL_CreateWindow(\"\", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED,\n                         screen_image_w, screen_image_h, flags);\n\n    if (TXT_SDLWindow == NULL)\n        return 0;\n\n    renderer = SDL_CreateRenderer(TXT_SDLWindow, -1, 0);\n\n    // Instead, we draw everything into an intermediate 8-bit surface\n    // the same dimensions as the screen. SDL then takes care of all the\n    // 8->32 bit (or whatever depth) color conversions for us.\n    screenbuffer = SDL_CreateRGBSurface(0,\n                                        TXT_SCREEN_W * font->w,\n                                        TXT_SCREEN_H * font->h,\n                                        8, 0, 0, 0, 0);\n\n    SDL_LockSurface(screenbuffer);\n    SDL_SetPaletteColors(screenbuffer->format->palette, ega_colors, 0, 16);\n    SDL_UnlockSurface(screenbuffer);\n\n    screendata = malloc(TXT_SCREEN_W * TXT_SCREEN_H * 2);\n    memset(screendata, 0, TXT_SCREEN_W * TXT_SCREEN_H * 2);\n\n    return 1;\n}\n\nvoid TXT_Shutdown(void)\n{\n    free(screendata);\n    screendata = NULL;\n    SDL_FreeSurface(screenbuffer);\n    screenbuffer = NULL;\n    SDL_QuitSubSystem(SDL_INIT_VIDEO);\n}\n\nunsigned char *TXT_GetScreenData(void)\n{\n    return screendata;\n}\n\nstatic inline void UpdateCharacter(int x, int y)\n{\n    unsigned char character;\n    const uint8_t *p;\n    unsigned char *s, *s1;\n    unsigned int bit;\n    int bg, fg;\n    unsigned int x1, y1;\n\n    p = &screendata[(y * TXT_SCREEN_W + x) * 2];\n    character = p[0];\n\n    fg = p[1] & 0xf;\n    bg = (p[1] >> 4) & 0xf;\n\n    if (bg & 0x8)\n    {\n        // blinking\n        bg &= ~0x8;\n    }\n\n    // How many bytes per line?\n    p = &font->data[(character * font->w * font->h) / 8];\n    bit = 0;\n\n    s = ((unsigned char *) screenbuffer->pixels)\n      + (y * font->h * screenbuffer->pitch)\n      + (x * font->w);\n\n    for (y1=0; y1<font->h; ++y1)\n    {\n        s1 = s;\n\n        for (x1=0; x1<font->w; ++x1)\n        {\n            if (*p & (1 << bit))\n            {\n                *s1++ = fg;\n            }\n            else\n            {\n                *s1++ = bg;\n            }\n\n            ++bit;\n            if (bit == 8)\n            {\n                ++p;\n                bit = 0;\n            }\n        }\n\n        s += screenbuffer->pitch;\n    }\n}\n\nstatic int LimitToRange(int val, int min, int max)\n{\n    if (val < min)\n    {\n        return min;\n    }\n    else if (val > max)\n    {\n        return max;\n    }\n    else\n    {\n        return val;\n    }\n}\n\nstatic void GetDestRect(SDL_Rect *rect)\n{\n    int w, h;\n\n    SDL_GetRendererOutputSize(renderer, &w, &h);\n    rect->x = (w - screenbuffer->w) / 2;\n    rect->y = (h - screenbuffer->h) / 2;\n    rect->w = screenbuffer->w;\n    rect->h = screenbuffer->h;\n}\n\nvoid TXT_UpdateScreenArea(int x, int y, int w, int h)\n{\n    SDL_Texture *screentx;\n    SDL_Rect rect;\n    int x1, y1;\n    int x_end;\n    int y_end;\n\n    SDL_LockSurface(screenbuffer);\n\n    x_end = LimitToRange(x + w, 0, TXT_SCREEN_W);\n    y_end = LimitToRange(y + h, 0, TXT_SCREEN_H);\n    x = LimitToRange(x, 0, TXT_SCREEN_W);\n    y = LimitToRange(y, 0, TXT_SCREEN_H);\n\n    for (y1=y; y1<y_end; ++y1)\n    {\n        for (x1=x; x1<x_end; ++x1)\n        {\n            UpdateCharacter(x1, y1);\n        }\n    }\n\n    SDL_UnlockSurface(screenbuffer);\n\n    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, \"linear\");\n\n    // TODO: This is currently creating a new texture every time we render\n    // the screen; find a more efficient way to do it.\n    screentx = SDL_CreateTextureFromSurface(renderer, screenbuffer);\n\n    SDL_RenderClear(renderer);\n    GetDestRect(&rect);\n    SDL_RenderCopy(renderer, screentx, NULL, &rect);\n    SDL_RenderPresent(renderer);\n\n    SDL_DestroyTexture(screentx);\n}\n\nvoid TXT_UpdateScreen(void)\n{\n    TXT_UpdateScreenArea(0, 0, TXT_SCREEN_W, TXT_SCREEN_H);\n}","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tDOOM graphics stuff for SDL.\n//\n\n\n#include \"SDL.h\"\n\n#include <emscripten.h>\n\n#include \"config.h\"\n#include \"d_loop.h\"\n#include \"deh_str.h\"\n#include \"doomtype.h\"\n#include \"i_input.h\"\n#include \"i_joystick.h\"\n#include \"i_system.h\"\n#include \"i_timer.h\"\n#include \"i_video.h\"\n#include \"m_argv.h\"\n#include \"m_config.h\"\n#include \"m_misc.h\"\n#include \"tables.h\"\n#include \"v_diskicon.h\"\n#include \"v_video.h\"\n#include \"w_wad.h\"\n#include \"z_zone.h\"\n\n// These are (1) the window (or the full screen) that our game is rendered to\n// and (2) the renderer that scales the texture (see below) into this window.\n\nstatic SDL_Window *screen;\nstatic SDL_Renderer *renderer;\n\n// Window title\n\nstatic char *window_title = \"\";\n\n// These are (1) the 320x200x8 paletted buffer that we draw to (i.e. the one\n// that holds I_VideoBuffer), (2) the 320x200x32 RGBA intermediate buffer that\n// we blit the former buffer to, (3) the intermediate 320x200 texture that we\n// load the RGBA buffer to and that we render into another texture (4) which\n// is upscaled by an integer factor UPSCALE using \"nearest\" scaling and which\n// in turn is finally rendered to screen using \"linear\" scaling.\n\nstatic SDL_Surface *screenbuffer = NULL;\nstatic SDL_Surface *argbbuffer = NULL;\nstatic SDL_Texture *texture = NULL;\nstatic SDL_Texture *texture_upscaled = NULL;\n\nstatic SDL_Rect blit_rect = {\n    0,\n    0,\n    SCREENWIDTH,\n    SCREENHEIGHT\n};\n\nstatic uint32_t pixel_format;\n\n// palette\n\nstatic SDL_Color palette[256];\nstatic boolean palette_to_set;\n\n// display has been set up?\n\nstatic boolean initialized = false;\n\n// disable mouse?\n\nstatic boolean nomouse = false;\nint usemouse = 0;\n\n// Save screenshots in PNG format.\n\nint png_screenshots = 1;\n\n// SDL video driver name\n\nchar *video_driver = \"\";\n\n// Window position:\n\nchar *window_position = \"center\";\n\n// SDL display number on which to run.\n\nint video_display = 0;\n\n// Screen width and height, from configuration file.\n\nint window_width = SCREENWIDTH;\nint window_height = SCREENHEIGHT;\n\n// Fullscreen mode, 0x0 for SDL_WINDOW_FULLSCREEN_DESKTOP.\n\nint fullscreen_width = 0, fullscreen_height = 0;\n\n// Maximum number of pixels to use for intermediate scale buffer.\n\nstatic int max_scaling_buffer_pixels = 16000000;\n\n// Run in full screen mode?  (int type for config code)\n\nint fullscreen = false;\n\n// Aspect ratio correction mode\n\nint aspect_ratio_correct = true;\nstatic int actualheight;\n\n// Force integer scales for resolution-independent rendering\n\nint integer_scaling = false;\n\n// VGA Porch palette change emulation\n\nint vga_porch_flash = false;\n\n// Force software rendering, for systems which lack effective hardware\n// acceleration\n\nint force_software_renderer = false;\n\n// Time to wait for the screen to settle on startup before starting the\n// game (ms)\n\nstatic int startup_delay = 1000;\n\n// Grab the mouse? (int type for config code). nograbmouse_override allows\n// this to be temporarily disabled via the command line.\n\nstatic int grabmouse = true;\nstatic boolean nograbmouse_override = true;\n\n// The screen buffer; this is modified to draw things to the screen\n\npixel_t *I_VideoBuffer = NULL;\n\n// If true, game is running as a screensaver\n\nboolean screensaver_mode = false;\n\n// Flag indicating whether the screen is currently visible:\n// when the screen isnt visible, don't render the screen\n\nboolean screenvisible = true;\n\n// If true, we display dots at the bottom of the screen to \n// indicate FPS.\n\nstatic boolean display_fps_dots;\n\n// If this is true, the screen is rendered but not blitted to the\n// video buffer.\n\nstatic boolean noblit;\n\n// Callback function to invoke to determine whether to grab the \n// mouse pointer.\n\nstatic grabmouse_callback_t grabmouse_callback = NULL;\n\n// Does the window currently have focus?\n\nstatic boolean window_focused = true;\n\n// Window resize state.\n\nstatic boolean need_resize = false;\nstatic unsigned int last_resize_time;\n#define RESIZE_DELAY 500\n\n// Gamma correction level to use\n\nint usegamma = 0;\n\n// Joystick/gamepad hysteresis\nunsigned int joywait = 0;\n\nstatic boolean MouseShouldBeGrabbed()\n{\n    // never grab the mouse when in screensaver mode\n   \n    if (screensaver_mode)\n        return false;\n\n    // if the window doesn't have focus, never grab it\n\n    if (!window_focused)\n        return false;\n\n    // always grab the mouse when full screen (dont want to \n    // see the mouse pointer)\n\n    if (fullscreen)\n        return true;\n\n    // Don't grab the mouse if mouse input is disabled\n\n    if (!usemouse || nomouse)\n        return false;\n\n    // if we specify not to grab the mouse, never grab\n\n    if (nograbmouse_override || !grabmouse)\n        return false;\n\n    // Invoke the grabmouse callback function to determine whether\n    // the mouse should be grabbed\n\n    if (grabmouse_callback != NULL)\n    {\n        return grabmouse_callback();\n    }\n    else\n    {\n        return true;\n    }\n}\n\nvoid I_SetGrabMouseCallback(grabmouse_callback_t func)\n{\n    grabmouse_callback = func;\n}\n\n// Set the variable controlling FPS dots.\n\nvoid I_DisplayFPSDots(boolean dots_on)\n{\n    display_fps_dots = dots_on;\n}\n\nstatic void SetShowCursor(boolean show)\n{\n    if (!screensaver_mode)\n    {\n        // When the cursor is hidden, grab the input.\n        // Relative mode implicitly hides the cursor.\n        SDL_SetRelativeMouseMode(!show);\n        SDL_GetRelativeMouseState(NULL, NULL);\n    }\n}\n\nvoid I_ShutdownGraphics(void)\n{\n    if (initialized)\n    {\n        SetShowCursor(true);\n\n        SDL_QuitSubSystem(SDL_INIT_VIDEO);\n\n        initialized = false;\n    }\n}\n\n\n\n//\n// I_StartFrame\n//\nvoid I_StartFrame (void)\n{\n    // er?\n\n}\n\nstatic void HandleWindowEvent(SDL_WindowEvent *event)\n{\n    int i;\n\n    switch (event->event)\n    {\n        case SDL_WINDOWEVENT_EXPOSED:\n            palette_to_set = true;\n            break;\n\n        case SDL_WINDOWEVENT_RESIZED:\n            need_resize = true;\n            last_resize_time = SDL_GetTicks();\n            break;\n\n        // Don't render the screen when the window is minimized:\n\n        case SDL_WINDOWEVENT_MINIMIZED:\n            screenvisible = false;\n            break;\n\n        case SDL_WINDOWEVENT_MAXIMIZED:\n        case SDL_WINDOWEVENT_RESTORED:\n            screenvisible = true;\n            break;\n\n        // Update the value of window_focused when we get a focus event\n        //\n        // We try to make ourselves be well-behaved: the grab on the mouse\n        // is removed if we lose focus (such as a popup window appearing),\n        // and we dont move the mouse around if we aren't focused either.\n\n        case SDL_WINDOWEVENT_FOCUS_GAINED:\n            window_focused = true;\n            break;\n\n        case SDL_WINDOWEVENT_FOCUS_LOST:\n            window_focused = false;\n            break;\n\n        // We want to save the user's preferred monitor to use for running the\n        // game, so that next time we're run we start on the same display. So\n        // every time the window is moved, find which display we're now on and\n        // update the video_display config variable.\n\n        case SDL_WINDOWEVENT_MOVED:\n            i = SDL_GetWindowDisplayIndex(screen);\n            if (i >= 0)\n            {\n                video_display = i;\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n\nvoid I_GetEvent(void)\n{\n    extern void I_HandleKeyboardEvent(SDL_Event *sdlevent);\n    extern void I_HandleMouseEvent(SDL_Event *sdlevent);\n    SDL_Event sdlevent;\n\n    SDL_PumpEvents();\n\n    while (SDL_PollEvent(&sdlevent))\n    {\n        switch (sdlevent.type)\n        {\n            case SDL_KEYDOWN:\n                // deliberate fall-though\n\n            case SDL_KEYUP:\n\t\tI_HandleKeyboardEvent(&sdlevent);\n                break;\n\n            case SDL_FINGERDOWN:\n            case SDL_FINGERUP:\n            case SDL_FINGERMOTION:\n                break;\n\n            case SDL_MOUSEBUTTONDOWN:\n            case SDL_MOUSEBUTTONUP:\n            case SDL_MOUSEWHEEL:\n                if (usemouse && !nomouse && window_focused)\n                {\n                    I_HandleMouseEvent(&sdlevent);\n                }\n                break;\n\n            case SDL_QUIT:\n                if (screensaver_mode)\n                {\n                    I_Quit();\n                }\n                else\n                {\n                    event_t event;\n                    event.type = ev_quit;\n                    D_PostEvent(&event);\n                }\n                break;\n\n            case SDL_WINDOWEVENT:\n                if (sdlevent.window.windowID == SDL_GetWindowID(screen))\n                {\n                    HandleWindowEvent(&sdlevent.window);\n                }\n                break;\n\n            default:\n                break;\n        }\n    }\n}\n\n//\n// I_StartTic\n//\nvoid I_StartTic (void)\n{\n    if (!initialized)\n    {\n        return;\n    }\n\n    I_GetEvent();\n\n    if (usemouse && !nomouse && window_focused)\n    {\n        I_ReadMouse();\n    }\n\n    if (joywait < I_GetTime())\n    {\n        I_UpdateJoystick();\n    }\n}\n\n\n//\n// I_UpdateNoBlit\n//\nvoid I_UpdateNoBlit (void)\n{\n    // what is this?\n}\n\nstatic void UpdateGrab(void)\n{\n    static boolean currently_grabbed = false;\n    boolean grab;\n\n    grab = MouseShouldBeGrabbed();\n\n    currently_grabbed = grab;\n}\n\nstatic void LimitTextureSize(int *w_upscale, int *h_upscale)\n{\n    SDL_RendererInfo rinfo;\n    int orig_w, orig_h;\n\n    orig_w = *w_upscale;\n    orig_h = *h_upscale;\n\n    // Query renderer and limit to maximum texture dimensions of hardware:\n    if (SDL_GetRendererInfo(renderer, &rinfo) != 0)\n    {\n        I_Error(\"CreateUpscaledTexture: SDL_GetRendererInfo() call failed: %s\",\n                SDL_GetError());\n    }\n\n    while (*w_upscale * SCREENWIDTH > rinfo.max_texture_width)\n    {\n        --*w_upscale;\n    }\n    while (*h_upscale * SCREENHEIGHT > rinfo.max_texture_height)\n    {\n        --*h_upscale;\n    }\n\n    if ((*w_upscale < 1 && rinfo.max_texture_width > 0) ||\n        (*h_upscale < 1 && rinfo.max_texture_height > 0))\n    {\n        I_Error(\"CreateUpscaledTexture: Can't create a texture big enough for \"\n                \"the whole screen! Maximum texture size %dx%d\",\n                rinfo.max_texture_width, rinfo.max_texture_height);\n    }\n\n    // We limit the amount of texture memory used for the intermediate buffer,\n    // since beyond a certain point there are diminishing returns. Also,\n    // depending on the hardware there may be performance problems with very\n    // huge textures, so the user can use this to reduce the maximum texture\n    // size if desired.\n\n    if (max_scaling_buffer_pixels < SCREENWIDTH * SCREENHEIGHT)\n    {\n        I_Error(\"CreateUpscaledTexture: max_scaling_buffer_pixels too small \"\n                \"to create a texture buffer: %d < %d\",\n                max_scaling_buffer_pixels, SCREENWIDTH * SCREENHEIGHT);\n    }\n\n    while (*w_upscale * *h_upscale * SCREENWIDTH * SCREENHEIGHT\n           > max_scaling_buffer_pixels)\n    {\n        if (*w_upscale > *h_upscale)\n        {\n            --*w_upscale;\n        }\n        else\n        {\n            --*h_upscale;\n        }\n    }\n\n    if (*w_upscale != orig_w || *h_upscale != orig_h)\n    {\n        printf(\"CreateUpscaledTexture: Limited texture size to %dx%d \"\n               \"(max %d pixels, max texture size %dx%d)\\n\",\n               *w_upscale * SCREENWIDTH, *h_upscale * SCREENHEIGHT,\n               max_scaling_buffer_pixels,\n               rinfo.max_texture_width, rinfo.max_texture_height);\n    }\n}\n\nstatic void CreateUpscaledTexture(boolean force)\n{\n    int w, h;\n    int h_upscale, w_upscale;\n    static int h_upscale_old, w_upscale_old;\n\n    // Get the size of the renderer output. The units this gives us will be\n    // real world pixels, which are not necessarily equivalent to the screen's\n    // window size (because of highdpi).\n    if (SDL_GetRendererOutputSize(renderer, &w, &h) != 0)\n    {\n        I_Error(\"Failed to get renderer output size: %s\", SDL_GetError());\n    }\n\n    // When the screen or window dimensions do not match the aspect ratio\n    // of the texture, the rendered area is scaled down to fit. Calculate\n    // the actual dimensions of the rendered area.\n\n    if (w * actualheight < h * SCREENWIDTH)\n    {\n        // Tall window.\n\n        h = w * actualheight / SCREENWIDTH;\n    }\n    else\n    {\n        // Wide window.\n\n        w = h * SCREENWIDTH / actualheight;\n    }\n\n    // Pick texture size the next integer multiple of the screen dimensions.\n    // If one screen dimension matches an integer multiple of the original\n    // resolution, there is no need to overscale in this direction.\n\n    w_upscale = (w + SCREENWIDTH - 1) / SCREENWIDTH;\n    h_upscale = (h + SCREENHEIGHT - 1) / SCREENHEIGHT;\n\n    // Minimum texture dimensions of 320x200.\n\n    if (w_upscale < 1)\n    {\n        w_upscale = 1;\n    }\n    if (h_upscale < 1)\n    {\n        h_upscale = 1;\n    }\n\n    LimitTextureSize(&w_upscale, &h_upscale);\n\n    // Create a new texture only if the upscale factors have actually changed.\n\n    if (h_upscale == h_upscale_old && w_upscale == w_upscale_old && !force)\n    {\n        return;\n    }\n\n    h_upscale_old = h_upscale;\n    w_upscale_old = w_upscale;\n\n    if (texture_upscaled)\n    {\n        SDL_DestroyTexture(texture_upscaled);\n    }\n\n    // Set the scaling quality for rendering the upscaled texture to \"linear\",\n    // which looks much softer and smoother than \"nearest\" but does a better\n    // job at downscaling from the upscaled texture to screen.\n\n    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, \"linear\");\n\n    texture_upscaled = SDL_CreateTexture(renderer,\n                                pixel_format,\n                                SDL_TEXTUREACCESS_TARGET,\n                                w_upscale*SCREENWIDTH,\n                                h_upscale*SCREENHEIGHT);\n}\n\n//\n// I_FinishUpdate\n//\nvoid I_FinishUpdate (void)\n{\n    static int lasttic;\n    int tics;\n    int i;\n\n    if (!initialized)\n        return;\n\n    if (noblit)\n        return;\n\n    UpdateGrab();\n\n    // draws little dots on the bottom of the screen\n\n    if (display_fps_dots)\n    {\n\ti = I_GetTime();\n\ttics = i - lasttic;\n\tlasttic = i;\n\tif (tics > 20) tics = 20;\n\n\tfor (i=0 ; i<tics*4 ; i+=4)\n\t    I_VideoBuffer[ (SCREENHEIGHT-1)*SCREENWIDTH + i] = 0xff;\n\tfor ( ; i<20*4 ; i+=4)\n\t    I_VideoBuffer[ (SCREENHEIGHT-1)*SCREENWIDTH + i] = 0x0;\n    }\n\n    // Draw disk icon before blit, if necessary.\n    V_DrawDiskIcon();\n\n    if (palette_to_set)\n    {\n        SDL_SetPaletteColors(screenbuffer->format->palette, palette, 0, 256);\n        palette_to_set = false;\n\n        if (vga_porch_flash)\n        {\n            // \"flash\" the pillars/letterboxes with palette changes, emulating\n            // VGA \"porch\" behaviour (GitHub issue #832)\n            SDL_SetRenderDrawColor(renderer, palette[0].r, palette[0].g,\n                palette[0].b, SDL_ALPHA_OPAQUE);\n        }\n    }\n\n    // Blit from the paletted 8-bit screen buffer to the intermediate\n    // 32-bit RGBA buffer that we can load into the texture.\n\n    SDL_LowerBlit(screenbuffer, &blit_rect, argbbuffer, &blit_rect);\n\n    // Update the intermediate texture with the contents of the RGBA buffer.\n\n    SDL_UpdateTexture(texture, NULL, argbbuffer->pixels, argbbuffer->pitch);\n\n    // Make sure the pillarboxes are kept clear each frame.\n\n    SDL_RenderClear(renderer);\n\n    // Render this intermediate texture into the upscaled texture\n    // using \"nearest\" integer scaling.\n\n    SDL_SetRenderTarget(renderer, texture_upscaled);\n    SDL_RenderCopy(renderer, texture, NULL, NULL);\n\n    // Finally, render this upscaled texture to screen using linear scaling.\n\n    SDL_SetRenderTarget(renderer, NULL);\n    SDL_RenderCopy(renderer, texture_upscaled, NULL, NULL);\n\n    // Draw!\n\n    SDL_RenderPresent(renderer);\n\n    // Restore background and undo the disk indicator, if it was drawn.\n    V_RestoreDiskBackground();\n}\n\n\n//\n// I_ReadScreen\n//\nvoid I_ReadScreen (pixel_t* scr)\n{\n    memcpy(scr, I_VideoBuffer, SCREENWIDTH*SCREENHEIGHT*sizeof(*scr));\n}\n\n\n//\n// I_SetPalette\n//\nvoid I_SetPalette (byte *doompalette)\n{\n    int i;\n\n    for (i=0; i<256; ++i)\n    {\n        // Zero out the bottom two bits of each channel - the PC VGA\n        // controller only supports 6 bits of accuracy.\n\n        palette[i].r = gammatable[usegamma][*doompalette++] & ~3;\n        palette[i].g = gammatable[usegamma][*doompalette++] & ~3;\n        palette[i].b = gammatable[usegamma][*doompalette++] & ~3;\n    }\n\n    palette_to_set = true;\n}\n\n// Given an RGB value, find the closest matching palette index.\n\nint I_GetPaletteIndex(int r, int g, int b)\n{\n    int best, best_diff, diff;\n    int i;\n\n    best = 0; best_diff = INT_MAX;\n\n    for (i = 0; i < 256; ++i)\n    {\n        diff = (r - palette[i].r) * (r - palette[i].r)\n             + (g - palette[i].g) * (g - palette[i].g)\n             + (b - palette[i].b) * (b - palette[i].b);\n\n        if (diff < best_diff)\n        {\n            best = i;\n            best_diff = diff;\n        }\n\n        if (diff == 0)\n        {\n            break;\n        }\n    }\n\n    return best;\n}\n\n// \n// Set the window title\n//\n\nvoid I_SetWindowTitle(char *title)\n{\n    window_title = title;\n}\n\n//\n// Call the SDL function to set the window title, based on \n// the title set with I_SetWindowTitle.\n//\n\nvoid I_InitWindowTitle(void)\n{\n    SDL_SetWindowTitle(screen, window_title);\n}\n\n// Set video size to a particular scale factor (1x, 2x, 3x, etc.)\n\nstatic void SetScaleFactor(int factor)\n{\n}\n\nvoid I_GraphicsCheckCommandLine(void)\n{\n    // int i;\n\n    //!\n    // @category video\n    // @vanilla\n    //\n    // Disable blitting the screen.\n    //\n\n    noblit = M_CheckParm (\"-noblit\");\n\n    //!\n    // @category video \n    //\n    // Don't grab the mouse when running in windowed mode.\n    //\n\n    nograbmouse_override = M_ParmExists(\"-nograbmouse\");\n\n    // default to fullscreen mode, allow override with command line\n    // nofullscreen because we love prboom\n\n    //!\n    // @category video \n    //\n    // Run in a window.\n    //\n\n    if (M_CheckParm(\"-window\") || M_CheckParm(\"-nofullscreen\"))\n    {\n        fullscreen = false;\n    }\n\n    //!\n    // @category video \n    //\n    // Run in fullscreen mode.\n    //\n\n    if (M_CheckParm(\"-fullscreen\"))\n    {\n        fullscreen = true;\n    }\n\n    //!\n    // @category video \n    //\n    // Disable the mouse.\n    //\n\n    nomouse = M_CheckParm(\"-nomouse\") > 0;\n\n    //!\n    // @category video\n    //\n    // Don't scale up the screen. Implies -window.\n    //\n\n    if (M_CheckParm(\"-1\")) \n    {\n        SetScaleFactor(1);\n    }\n\n    //!\n    // @category video\n    //\n    // Double up the screen to 2x its normal size. Implies -window.\n    //\n\n    if (M_CheckParm(\"-2\")) \n    {\n        SetScaleFactor(2);\n    }\n\n    //!\n    // @category video\n    //\n    // Double up the screen to 3x its normal size. Implies -window.\n    //\n\n    if (M_CheckParm(\"-3\")) \n    {\n        SetScaleFactor(3);\n    }\n}\n\n// Check if we have been invoked as a screensaver by xscreensaver.\n\nvoid I_CheckIsScreensaver(void)\n{\n    char *env;\n\n    env = getenv(\"XSCREENSAVER_WINDOW\");\n\n    if (env != NULL)\n    {\n        screensaver_mode = true;\n    }\n}\n\nstatic void SetSDLVideoDriver(void)\n{\n    // Allow a default value for the SDL video driver to be specified\n    // in the configuration file.\n\n    if (strcmp(video_driver, \"\") != 0)\n    {\n        char *env_string;\n\n        env_string = M_StringJoin(\"SDL_VIDEODRIVER=\", video_driver, NULL);\n        putenv(env_string);\n        free(env_string);\n    }\n}\n\nstatic void SetVideoMode(void)\n{\n    int w, h;\n    int x = 0, y = 0;\n    unsigned int rmask, gmask, bmask, amask;\n    int unused_bpp;\n    int window_flags = 0, renderer_flags = 0;\n    SDL_DisplayMode mode;\n\n    w = window_width;\n    h = window_height;\n\n    // In windowed mode, the window can be resized while the game is\n    // running.\n    // window_flags = SDL_WINDOW_RESIZABLE;\n\n    // Set the highdpi flag - this makes a big difference on Macs with\n    // retina displays, especially when using small window sizes.\n    // window_flags = SDL_WINDOW_ALLOW_HIGHDPI;\n\n    if (fullscreen)\n    {\n        if (fullscreen_width == 0 && fullscreen_height == 0)\n        {\n            // This window_flags means \"Never change the screen resolution!\n            // Instead, draw to the entire screen by scaling the texture\n            // appropriately\".\n            window_flags |= SDL_WINDOW_FULLSCREEN_DESKTOP;\n        }\n        else\n        {\n            w = fullscreen_width;\n            h = fullscreen_height;\n            window_flags |= SDL_WINDOW_FULLSCREEN;\n        }\n    }\n\n    // I_GetWindowPosition(&x, &y, w, h);\n\n    // Create window and renderer contexts. We set the window title\n    // later anyway and leave the window position \"undefined\". If\n    // \"window_flags\" contains the fullscreen flag (see above), then\n    // w and h are ignored.\n\n    if (screen == NULL)\n    {\n        screen = SDL_CreateWindow(NULL, x, y, w, h, window_flags);\n\n        if (screen == NULL)\n        {\n            I_Error(\"Error creating window for video startup: %s\",\n            SDL_GetError());\n        }\n\n        pixel_format = SDL_GetWindowPixelFormat(screen);\n\n        I_InitWindowTitle();\n    }\n\n    // The SDL_RENDERER_TARGETTEXTURE flag is required to render the\n    // intermediate texture into the upscaled texture.\n    renderer_flags = SDL_RENDERER_TARGETTEXTURE;\n\t\n    if (SDL_GetCurrentDisplayMode(video_display, &mode) != 0)\n    {\n        I_Error(\"Could not get display mode for video display #%d: %s\",\n        video_display, SDL_GetError());\n    }\n\n    // Turn on vsync if we aren't in a -timedemo\n    if (!singletics && mode.refresh_rate > 0)\n    {\n        renderer_flags |= SDL_RENDERER_PRESENTVSYNC;\n    }\n\n    if (force_software_renderer)\n    {\n        renderer_flags |= SDL_RENDERER_SOFTWARE;\n        renderer_flags &= ~SDL_RENDERER_PRESENTVSYNC;\n    }\n\n    if (renderer != NULL)\n    {\n        SDL_DestroyRenderer(renderer);\n    }\n\n    renderer = SDL_CreateRenderer(screen, -1, renderer_flags);\n\n    if (renderer == NULL)\n    {\n        I_Error(\"Error creating renderer for screen window: %s\",\n                SDL_GetError());\n    }\n\n    // Important: Set the \"logical size\" of the rendering context. At the same\n    // time this also defines the aspect ratio that is preserved while scaling\n    // and stretching the texture into the window.\n\n    if (aspect_ratio_correct || integer_scaling)\n    {\n        SDL_RenderSetLogicalSize(renderer,\n                                 SCREENWIDTH,\n                                 actualheight);\n    }\n\n    // Force integer scales for resolution-independent rendering.\n\n#if SDL_VERSION_ATLEAST(2, 0, 5)\n    SDL_RenderSetIntegerScale(renderer, integer_scaling);\n#endif\n\n    // Blank out the full screen area in case there is any junk in\n    // the borders that won't otherwise be overwritten.\n\n    SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);\n    SDL_RenderClear(renderer);\n    SDL_RenderPresent(renderer);\n\n    // Create the 8-bit paletted and the 32-bit RGBA screenbuffer surfaces.\n\n    if (screenbuffer == NULL)\n    {\n        screenbuffer = SDL_CreateRGBSurface(0,\n                                            SCREENWIDTH, SCREENHEIGHT, 8,\n                                            0, 0, 0, 0);\n        SDL_FillRect(screenbuffer, NULL, 0);\n    }\n\n    // Format of argbbuffer must match the screen pixel format because we\n    // import the surface data into the texture.\n    if (argbbuffer == NULL)\n    {\n        SDL_PixelFormatEnumToMasks(pixel_format, &unused_bpp,\n                                   &rmask, &gmask, &bmask, &amask);\n        argbbuffer = SDL_CreateRGBSurface(0,\n                                          SCREENWIDTH, SCREENHEIGHT, 32,\n                                          rmask, gmask, bmask, amask);\n        SDL_FillRect(argbbuffer, NULL, 0);\n    }\n\n    if (texture != NULL)\n    {\n        SDL_DestroyTexture(texture);\n    }\n\n    // Set the scaling quality for rendering the intermediate texture into\n    // the upscaled texture to \"nearest\", which is gritty and pixelated and\n    // resembles software scaling pretty well.\n\n    SDL_SetHint(SDL_HINT_RENDER_SCALE_QUALITY, \"nearest\");\n\n    // Create the intermediate texture that the RGBA surface gets loaded into.\n    // The SDL_TEXTUREACCESS_STREAMING flag means that this texture's content\n    // is going to change frequently.\n\n    texture = SDL_CreateTexture(renderer,\n                                pixel_format,\n                                SDL_TEXTUREACCESS_STREAMING,\n                                SCREENWIDTH, SCREENHEIGHT);\n\n    // Initially create the upscaled texture for rendering to screen\n\n    CreateUpscaledTexture(true);\n}\n\nvoid I_InitGraphics(void)\n{\n    SDL_Event dummy;\n    byte *doompal;\n    char *env;\n\n    SDL_SetHint(SDL_HINT_RENDER_DRIVER, \"software\");\n\n    // Pass through the XSCREENSAVER_WINDOW environment variable to \n    // SDL_WINDOWID, to embed the SDL window into the Xscreensaver\n    // window.\n\n    env = getenv(\"XSCREENSAVER_WINDOW\");\n\n    if (env != NULL)\n    {\n        char winenv[30];\n        int winid;\n\n        sscanf(env, \"0x%x\", &winid);\n        M_snprintf(winenv, sizeof(winenv), \"SDL_WINDOWID=%i\", winid);\n\n        putenv(winenv);\n    }\n\n    SetSDLVideoDriver();\n\n    if (SDL_Init(SDL_INIT_VIDEO) < 0) \n    {\n        I_Error(\"Failed to initialize video: %s\", SDL_GetError());\n    }\n\n    // When in screensaver mode, run full screen and auto detect\n    // screen dimensions (don't change video mode)\n    if (screensaver_mode)\n    {\n        fullscreen = true;\n    }\n\n    actualheight = SCREENHEIGHT;\n\n    // Create the game window; this may switch graphic modes depending\n    // on configuration.\n    SetVideoMode();\n\n    // Start with a clear black screen\n    // (screen will be flipped after we set the palette)\n\n    SDL_FillRect(screenbuffer, NULL, 0);\n\n    // Set the palette\n\n    doompal = W_CacheLumpName(DEH_String(\"PLAYPAL\"), PU_CACHE);\n    I_SetPalette(doompal);\n    SDL_SetPaletteColors(screenbuffer->format->palette, palette, 0, 256);\n\n    // The actual 320x200 canvas that we draw to. This is the pixel buffer of\n    // the 8-bit paletted screen buffer that gets blit on an intermediate\n    // 32-bit RGBA screen buffer that gets loaded into a texture that gets\n    // finally rendered into our window or full screen in I_FinishUpdate().\n\n    I_VideoBuffer = screenbuffer->pixels;\n    V_RestoreBuffer();\n\n    // Clear the screen to black.\n\n    memset(I_VideoBuffer, 0, SCREENWIDTH * SCREENHEIGHT);\n\n    SDL_EventState(SDL_TEXTINPUT, SDL_DISABLE);\n\n    // clear out any events waiting at the start and center the mouse\n  \n    while (SDL_PollEvent(&dummy));\n\n    initialized = true;\n\n    // Call I_ShutdownGraphics on quit\n\n    I_AtExit(I_ShutdownGraphics, true);\n\n    EM_ASM(\n        if (Module && Module.canvas && typeof Module.canvas.calcRatio == \"function\"){\n            Module.canvas.calcRatio();\n        }\n    );\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid toggleMouse(const int state)\n{\n    usemouse = state;\n}\n\n// Bind all variables controlling video options into the configuration\n// file system.\nvoid I_BindVideoVariables(void)\n{\n    M_BindIntVariable(\"use_mouse\",                 &usemouse);\n    M_BindIntVariable(\"fullscreen\",                &fullscreen);\n    M_BindIntVariable(\"video_display\",             &video_display);\n    M_BindIntVariable(\"aspect_ratio_correct\",      &aspect_ratio_correct);\n    M_BindIntVariable(\"integer_scaling\",           &integer_scaling);\n    M_BindIntVariable(\"vga_porch_flash\",           &vga_porch_flash);\n    M_BindIntVariable(\"startup_delay\",             &startup_delay);\n    M_BindIntVariable(\"fullscreen_width\",          &fullscreen_width);\n    M_BindIntVariable(\"fullscreen_height\",         &fullscreen_height);\n    M_BindIntVariable(\"force_software_renderer\",   &force_software_renderer);\n    M_BindIntVariable(\"max_scaling_buffer_pixels\", &max_scaling_buffer_pixels);\n    M_BindIntVariable(\"window_width\",              &window_width);\n    M_BindIntVariable(\"window_height\",             &window_height);\n    M_BindIntVariable(\"grabmouse\",                 &grabmouse);\n    M_BindStringVariable(\"video_driver\",           &video_driver);\n    M_BindStringVariable(\"window_position\",        &window_position);\n    M_BindIntVariable(\"usegamma\",                  &usegamma);\n    M_BindIntVariable(\"png_screenshots\",           &png_screenshots);\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n// Copyright(C) 2018-2019 Viktor Lázár\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tSystem interface for music.\n//\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"SDL.h\"\n#include \"SDL_mixer.h\"\n\n#include \"config.h\"\n#include \"doomtype.h\"\n#include \"memio.h\"\n#include \"mus2mid.h\"\n\n#include \"deh_str.h\"\n#include \"i_sound.h\"\n#include \"i_system.h\"\n#include \"i_swap.h\"\n#include \"m_argv.h\"\n#include \"m_config.h\"\n#include \"m_misc.h\"\n#include \"sha1.h\"\n#include \"w_wad.h\"\n#include \"z_zone.h\"\n\n#include <emscripten.h>\n\n#define MAXMIDLENGTH (96 * 1024)\n#define MID_HEADER_MAGIC \"MThd\"\n#define MUS_HEADER_MAGIC \"MUS\\x1a\"\n\n#define FLAC_HEADER \"fLaC\"\n#define OGG_HEADER \"OggS\"\n\n// Looping Vorbis metadata tag names. These have been defined by ZDoom\n// for specifying the start and end positions for looping music tracks\n// in .ogg and .flac files.\n// More information is here: http://zdoom.org/wiki/Audio_loop\n#define LOOP_START_TAG \"LOOP_START\"\n#define LOOP_END_TAG   \"LOOP_END\"\n\n// FLAC metadata headers that we care about.\n#define FLAC_STREAMINFO      0\n#define FLAC_VORBIS_COMMENT  4\n\n// Ogg metadata headers that we care about.\n#define OGG_ID_HEADER        1\n#define OGG_COMMENT_HEADER   3\n\nstatic music_module_t *music_module;\nextern music_module_t music_opl_module;\n\n// Structure for music substitution.\n// We store a mapping based on SHA1 checksum -> filename of substitute music\n// file to play, so that substitution occurs based on content rather than\n// lump name. This has some inherent advantages:\n//  * Music for Plutonia (reused from Doom 1) works automatically.\n//  * If a PWAD replaces music, the replacement music is used rather than\n//    the substitute music for the IWAD.\n//  * If a PWAD reuses music from an IWAD (even from a different game), we get\n//    the high quality version of the music automatically (neat!)\n\ntypedef struct\n{\n    sha1_digest_t hash;\n    char *filename;\n} subst_music_t;\n\n// Structure containing parsed metadata read from a digital music track:\ntypedef struct\n{\n    boolean valid;\n    unsigned int samplerate_hz;\n    int start_time, end_time;\n} file_metadata_t;\n\nstatic subst_music_t *subst_music = NULL;\nstatic unsigned int subst_music_len = 0;\n\nstatic const char *subst_config_filenames[] =\n{\n    \"doom1-music.cfg\",\n    \"doom2-music.cfg\",\n    \"tnt-music.cfg\",\n    \"heretic-music.cfg\",\n    \"hexen-music.cfg\",\n    \"strife-music.cfg\",\n};\n\nstatic boolean music_initialized = false;\n\n// If this is true, this module initialized SDL sound and has the\n// responsibility to shut it down\n\nstatic boolean sdl_was_initialized = false;\n\nstatic boolean musicpaused = false;\nstatic int current_music_volume;\nstatic void *current_music_handle;\nstatic boolean current_music_looping = false;\nstatic boolean current_music_playing = false;\n\nchar *music_pack_path = \".\";\n\n// If true, we are playing a substitute digital track rather than in-WAD\n// MIDI/MUS track, and file_metadata contains loop metadata.\nstatic boolean playing_substitute = false;\nstatic char *current_filename = NULL;\nstatic file_metadata_t file_metadata;\n\n// Position (in samples) that we have reached in the current track.\n// This is updated by the TrackPositionCallback function.\n// static unsigned int current_track_pos;\n\n// If true, the currently playing track is being played on loop.\n// static boolean current_track_loop;\n\n// Given a time string (for LOOP_START/LOOP_END), parse it and return\n// the time (in # samples since start of track) it represents.\nstatic unsigned int ParseVorbisTime(unsigned int samplerate_hz, char *value)\n{\n    char *num_start, *p;\n    unsigned int result = 0;\n    char c;\n\n    if (strchr(value, ':') == NULL)\n    {\n\treturn atoi(value);\n    }\n\n    result = 0;\n    num_start = value;\n\n    for (p = value; *p != '\\0'; ++p)\n    {\n        if (*p == '.' || *p == ':')\n        {\n            c = *p; *p = '\\0';\n            result = result * 60 + atoi(num_start);\n            num_start = p + 1;\n            *p = c;\n        }\n\n        if (*p == '.')\n        {\n            return result * samplerate_hz\n\t         + (unsigned int) (atof(p) * samplerate_hz);\n        }\n    }\n\n    return (result * 60 + atoi(num_start)) * samplerate_hz;\n}\n\n// Given a vorbis comment string (eg. \"LOOP_START=12345\"), set fields\n// in the metadata structure as appropriate.\nstatic void ParseVorbisComment(file_metadata_t *metadata, char *comment)\n{\n    char *eq, *key, *value;\n\n    eq = strchr(comment, '=');\n\n    if (eq == NULL)\n    {\n        return;\n    }\n\n    key = comment;\n    *eq = '\\0';\n    value = eq + 1;\n\n    if (!strcmp(key, LOOP_START_TAG))\n    {\n        metadata->start_time = ParseVorbisTime(metadata->samplerate_hz, value);\n    }\n    else if (!strcmp(key, LOOP_END_TAG))\n    {\n        metadata->end_time = ParseVorbisTime(metadata->samplerate_hz, value);\n    }\n}\n\n// Parse a vorbis comments structure, reading from the given file.\nstatic void ParseVorbisComments(file_metadata_t *metadata, FILE *fs)\n{\n    uint32_t buf;\n    unsigned int num_comments, i, comment_len;\n    char *comment;\n\n    // We must have read the sample rate already from an earlier header.\n    if (metadata->samplerate_hz == 0)\n    {\n\treturn;\n    }\n\n    // Skip the starting part we don't care about.\n    if (fread(&buf, 4, 1, fs) < 1)\n    {\n        return;\n    }\n    if (fseek(fs, LONG(buf), SEEK_CUR) != 0)\n    {\n\treturn;\n    }\n\n    // Read count field for number of comments.\n    if (fread(&buf, 4, 1, fs) < 1)\n    {\n        return;\n    }\n    num_comments = LONG(buf);\n\n    // Read each individual comment.\n    for (i = 0; i < num_comments; ++i)\n    {\n        // Read length of comment.\n        if (fread(&buf, 4, 1, fs) < 1)\n\t{\n            return;\n\t}\n\n        comment_len = LONG(buf);\n\n        // Read actual comment data into string buffer.\n        comment = calloc(1, comment_len + 1);\n        if (comment == NULL\n         || fread(comment, 1, comment_len, fs) < comment_len)\n        {\n            free(comment);\n            break;\n        }\n\n        // Parse comment string.\n        ParseVorbisComment(metadata, comment);\n        free(comment);\n    }\n}\n\nstatic void ParseFlacStreaminfo(file_metadata_t *metadata, FILE *fs)\n{\n    byte buf[34];\n\n    // Read block data.\n    if (fread(buf, sizeof(buf), 1, fs) < 1)\n    {\n        return;\n    }\n\n    // We only care about sample rate and song length.\n    metadata->samplerate_hz = (buf[10] << 12) | (buf[11] << 4)\n                            | (buf[12] >> 4);\n    // Song length is actually a 36 bit field, but 32 bits should be\n    // enough for everybody.\n    //metadata->song_length = (buf[14] << 24) | (buf[15] << 16)\n    //                      | (buf[16] << 8) | buf[17];\n}\n\nstatic void ParseFlacFile(file_metadata_t *metadata, FILE *fs)\n{\n    byte header[4];\n    unsigned int block_type;\n    size_t block_len;\n    boolean last_block;\n\n    for (;;)\n    {\n        long pos = -1;\n\n        // Read METADATA_BLOCK_HEADER:\n        if (fread(header, 4, 1, fs) < 1)\n        {\n            return;\n        }\n\n        block_type = header[0] & ~0x80;\n        last_block = (header[0] & 0x80) != 0;\n        block_len = (header[1] << 16) | (header[2] << 8) | header[3];\n\n        pos = ftell(fs);\n        if (pos < 0)\n        {\n            return;\n        }\n\n        if (block_type == FLAC_STREAMINFO)\n        {\n            ParseFlacStreaminfo(metadata, fs);\n        }\n        else if (block_type == FLAC_VORBIS_COMMENT)\n        {\n            ParseVorbisComments(metadata, fs);\n        }\n\n        if (last_block)\n        {\n            break;\n        }\n\n        // Seek to start of next block.\n        if (fseek(fs, pos + block_len, SEEK_SET) != 0)\n        {\n            return;\n        }\n    }\n}\n\nstatic void ParseOggIdHeader(file_metadata_t *metadata, FILE *fs)\n{\n    byte buf[21];\n\n    if (fread(buf, sizeof(buf), 1, fs) < 1)\n    {\n        return;\n    }\n\n    metadata->samplerate_hz = (buf[8] << 24) | (buf[7] << 16)\n                            | (buf[6] << 8) | buf[5];\n}\n\nstatic void ParseOggFile(file_metadata_t *metadata, FILE *fs)\n{\n    byte buf[7];\n    unsigned int offset;\n\n    // Scan through the start of the file looking for headers. They\n    // begin '[byte]vorbis' where the byte value indicates header type.\n    memset(buf, 0, sizeof(buf));\n\n    for (offset = 0; offset < 100 * 1024; ++offset)\n    {\n\t// buf[] is used as a sliding window. Each iteration, we\n\t// move the buffer one byte to the left and read an extra\n\t// byte onto the end.\n        memmove(buf, buf + 1, sizeof(buf) - 1);\n\n        if (fread(&buf[6], 1, 1, fs) < 1)\n        {\n            return;\n        }\n\n        if (!memcmp(buf + 1, \"vorbis\", 6))\n        {\n            switch (buf[0])\n            {\n                case OGG_ID_HEADER:\n                    ParseOggIdHeader(metadata, fs);\n                    break;\n                case OGG_COMMENT_HEADER:\n\t\t    ParseVorbisComments(metadata, fs);\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid ReadLoopPoints(void)\n{\n    FILE *fs;\n    char header[4];\n\n    file_metadata_t *metadata = &file_metadata;\n    char *filename = current_filename;\n\n    metadata->valid = false;\n    metadata->samplerate_hz = 0;\n    metadata->start_time = 0;\n    metadata->end_time = -1;\n\n    fs = fopen(filename, \"rb\");\n\n    if (fs == NULL)\n    {\n        return;\n    }\n\n    // Check for a recognized file format; use the first four bytes\n    // of the file.\n\n    if (fread(header, 4, 1, fs) < 1)\n    {\n        fclose(fs);\n        return;\n    }\n\n    if (memcmp(header, FLAC_HEADER, 4) == 0)\n    {\n        ParseFlacFile(metadata, fs);\n    }\n    else if (memcmp(header, OGG_HEADER, 4) == 0)\n    {\n        ParseOggFile(metadata, fs);\n    }\n\n    fclose(fs);\n\n    // Only valid if at the very least we read the sample rate.\n    metadata->valid = metadata->samplerate_hz > 0;\n\n    // If start and end time are both zero, ignore the loop tags.\n    // This is consistent with other source ports.\n    if (metadata->start_time == 0 && metadata->end_time == 0)\n    {\n        metadata->valid = false;\n    }\n\n    EM_ASM({\n        if (window.doom_music){\n            window.doom_music.loopStart = $0;\n            window.doom_music.loopEnd = $1;\n        }\n    }, (double) file_metadata.start_time / file_metadata.samplerate_hz, (double) file_metadata.end_time / file_metadata.samplerate_hz);\n}\n\n// Given a MUS lump, look up a substitute MUS file to play instead\n// (or NULL to just use normal MIDI playback).\n\nstatic char *GetSubstituteMusicFile(void *data, size_t data_len)\n{\n    sha1_context_t context;\n    sha1_digest_t hash;\n    char *filename;\n    unsigned int i;\n\n    // Don't bother doing a hash if we're never going to find anything.\n    if (subst_music_len == 0)\n    {\n        return NULL;\n    }\n\n    SHA1_Init(&context);\n    SHA1_Update(&context, data, data_len);\n    SHA1_Final(hash, &context);\n\n    // Look for a hash that matches.\n    // The substitute mapping list can (intentionally) contain multiple\n    // filename mappings for the same hash. This allows us to try\n    // different files and fall back if our first choice isn't found.\n\n    filename = NULL;\n\n    for (i = 0; i < subst_music_len; ++i)\n    {\n        if (memcmp(hash, subst_music[i].hash, sizeof(hash)) == 0)\n        {\n            filename = subst_music[i].filename;\n\n            // If the file exists, then use this file in preference to\n            // any fallbacks. But we always return a filename if it's\n            // in the list, even if it's just so we can print an error\n            // message to the user saying it doesn't exist.\n            if (M_FileExists(filename))\n            {\n                break;\n            }\n        }\n    }\n\n    return filename;\n}\n\n// Add a substitute music file to the lookup list.\n\nstatic void AddSubstituteMusic(subst_music_t *subst)\n{\n    ++subst_music_len;\n    subst_music =\n        I_Realloc(subst_music, sizeof(subst_music_t) * subst_music_len);\n    memcpy(&subst_music[subst_music_len - 1], subst, sizeof(subst_music_t));\n}\n\nstatic int ParseHexDigit(char c)\n{\n    c = tolower(c);\n\n    if (c >= '0' && c <= '9')\n    {\n        return c - '0';\n    }\n    else if (c >= 'a' && c <= 'f')\n    {\n        return 10 + (c - 'a');\n    }\n    else\n    {\n        return -1;\n    }\n}\n\nstatic char *GetFullPath(char *base_filename, char *path)\n{\n    char *basedir, *result;\n    char *p;\n\n    // Starting with directory separator means we have an absolute path,\n    // so just return it.\n    if (path[0] == DIR_SEPARATOR)\n    {\n        return M_StringDuplicate(path);\n    }\n\n#ifdef _WIN32\n    // d:\\path\\...\n    if (isalpha(path[0]) && path[1] == ':' && path[2] == DIR_SEPARATOR)\n    {\n        return M_StringDuplicate(path);\n    }\n#endif\n\n    // Paths in the substitute filenames can contain Unix-style /\n    // path separators, but we should convert this to the separator\n    // for the native platform.\n    path = M_StringReplace(path, \"/\", DIR_SEPARATOR_S);\n\n    // Copy config filename and cut off the filename to just get the\n    // parent dir.\n    basedir = M_StringDuplicate(base_filename);\n    p = strrchr(basedir, DIR_SEPARATOR);\n    if (p != NULL)\n    {\n        p[1] = '\\0';\n        result = M_StringJoin(basedir, path, NULL);\n    }\n    else\n    {\n        result = M_StringDuplicate(path);\n    }\n    free(basedir);\n    free(path);\n\n    return result;\n}\n\n// Parse a line from substitute music configuration file; returns error\n// message or NULL for no error.\n\nstatic char *ParseSubstituteLine(char *filename, char *line)\n{\n    subst_music_t subst;\n    char *p;\n    int hash_index;\n\n    // Strip out comments if present.\n    p = strchr(line, '#');\n    if (p != NULL)\n    {\n        while (p > line && isspace(*(p - 1)))\n        {\n            --p;\n        }\n        *p = '\\0';\n    }\n\n    // Skip leading spaces.\n    for (p = line; *p != '\\0' && isspace(*p); ++p);\n\n    // Empty line? This includes comment lines now that comments have\n    // been stripped.\n    if (*p == '\\0')\n    {\n        return NULL;\n    }\n\n    // Read hash.\n    hash_index = 0;\n    while (*p != '\\0' && *p != '=' && !isspace(*p))\n    {\n        int d1, d2;\n\n        d1 = ParseHexDigit(p[0]);\n        d2 = ParseHexDigit(p[1]);\n\n        if (d1 < 0 || d2 < 0)\n        {\n            return \"Invalid hex digit in SHA1 hash\";\n        }\n        else if (hash_index >= sizeof(sha1_digest_t))\n        {\n            return \"SHA1 hash too long\";\n        }\n\n        subst.hash[hash_index] = (d1 << 4) | d2;\n        ++hash_index;\n\n        p += 2;\n    }\n\n    if (hash_index != sizeof(sha1_digest_t))\n    {\n        return \"SHA1 hash too short\";\n    }\n\n    // Skip spaces.\n    for (; *p != '\\0' && isspace(*p); ++p);\n\n    if (*p != '=')\n    {\n        return \"Expected '='\";\n    }\n\n    ++p;\n\n    // Skip spaces.\n    for (; *p != '\\0' && isspace(*p); ++p);\n\n    // We're now at the filename. Cut off trailing space characters.\n    while (strlen(p) > 0 && isspace(p[strlen(p) - 1]))\n    {\n        p[strlen(p) - 1] = '\\0';\n    }\n\n    if (strlen(p) == 0)\n    {\n        return \"No filename specified for music substitution\";\n    }\n\n    // Expand full path and add to our database of substitutes.\n    subst.filename = GetFullPath(filename, p);\n    AddSubstituteMusic(&subst);\n\n    return NULL;\n}\n\n// Read a substitute music configuration file.\n\nstatic boolean ReadSubstituteConfig(char *filename)\n{\n    char *buffer;\n    char *line;\n    int linenum = 1;\n\n    // This unnecessarily opens the file twice...\n    if (!M_FileExists(filename))\n    {\n        return false;\n    }\n\n    M_ReadFile(filename, (byte **) &buffer);\n\n    line = buffer;\n\n    while (line != NULL)\n    {\n        char *error;\n        char *next;\n\n        // find end of line\n        char *eol = strchr(line, '\\n');\n        if (eol != NULL)\n        {\n            // change the newline into NUL\n            *eol = '\\0';\n            next = eol + 1;\n        }\n        else\n        {\n            // end of buffer\n            next = NULL;\n        }\n\n        error = ParseSubstituteLine(filename, line);\n\n        if (error != NULL)\n        {\n            fprintf(stderr, \"%s:%i: Error: %s\\n\", filename, linenum, error);\n        }\n\n        ++linenum;\n        line = next;\n    }\n\n    Z_Free(buffer);\n\n    return true;\n}\n\n// Find substitute configs and try to load them.\n\nstatic void LoadSubstituteConfigs(void)\n{\n    char *musicdir;\n    char *path;\n    unsigned int i;\n\n    // We can configure the path to music packs using the music_pack_path\n    // configuration variable. Otherwise we use the current directory, or\n    // $configdir/music to look for .cfg files.\n    if (strcmp(music_pack_path, \"\") != 0)\n    {\n        musicdir = M_StringJoin(music_pack_path, DIR_SEPARATOR_S, NULL);\n    }\n    else if (!strcmp(configdir, \"\"))\n    {\n        musicdir = M_StringDuplicate(\"\");\n    }\n    else\n    {\n        musicdir = M_StringJoin(configdir, \"music\", DIR_SEPARATOR_S, NULL);\n    }\n\n    // Load all music packs. We always load all music substitution packs for\n    // all games. Why? Suppose we have a Doom PWAD that reuses some music from\n    // Heretic. If we have the Heretic music pack loaded, then we get an\n    // automatic substitution.\n    for (i = 0; i < arrlen(subst_config_filenames); ++i)\n    {\n        path = M_StringJoin(musicdir, subst_config_filenames[i], NULL);\n        ReadSubstituteConfig(path);\n        free(path);\n    }\n\n    free(musicdir);\n\n    if (subst_music_len > 0)\n    {\n        printf(\"Loaded %i music substitutions from config files.\\n\",\n               subst_music_len);\n    }\n}\n\n// Returns true if the given lump number is a music lump that should\n// be included in substitute configs.\n// Identifying music lumps by name is not feasible; some games (eg.\n// Heretic, Hexen) don't have a common naming pattern for music lumps.\n\nstatic boolean IsMusicLump(int lumpnum)\n{\n    byte *data;\n    boolean result;\n\n    if (W_LumpLength(lumpnum) < 4)\n    {\n        return false;\n    }\n\n    data = W_CacheLumpNum(lumpnum, PU_STATIC);\n\n    result = memcmp(data, MUS_HEADER_MAGIC, 4) == 0\n          || memcmp(data, MID_HEADER_MAGIC, 4) == 0;\n\n    W_ReleaseLumpNum(lumpnum);\n\n    return result;\n}\n\n// Dump an example config file containing checksums for all MIDI music\n// found in the WAD directory.\n\nstatic void DumpSubstituteConfig(char *filename)\n{\n    sha1_context_t context;\n    sha1_digest_t digest;\n    char name[9];\n    byte *data;\n    FILE *fs;\n    unsigned int lumpnum;\n    size_t h;\n\n    fs = fopen(filename, \"w\");\n\n    if (fs == NULL)\n    {\n        I_Error(\"Failed to open %s for writing\", filename);\n        return;\n    }\n\n    fprintf(fs, \"# Example %s substitute MIDI file.\\n\\n\", PACKAGE_NAME);\n    fprintf(fs, \"# SHA1 hash                              = filename\\n\");\n\n    for (lumpnum = 0; lumpnum < numlumps; ++lumpnum)\n    {\n        strncpy(name, lumpinfo[lumpnum]->name, 8);\n        name[8] = '\\0';\n\n        if (!IsMusicLump(lumpnum))\n        {\n            continue;\n        }\n\n        // Calculate hash.\n        data = W_CacheLumpNum(lumpnum, PU_STATIC);\n        SHA1_Init(&context);\n        SHA1_Update(&context, data, W_LumpLength(lumpnum));\n        SHA1_Final(digest, &context);\n        W_ReleaseLumpNum(lumpnum);\n\n        // Print line.\n        for (h = 0; h < sizeof(sha1_digest_t); ++h)\n        {\n            fprintf(fs, \"%02x\", digest[h]);\n        }\n\n        fprintf(fs, \" = %s.ogg\\n\", name);\n    }\n\n    fprintf(fs, \"\\n\");\n    fclose(fs);\n\n    printf(\"Substitute MIDI config file written to %s.\\n\", filename);\n    I_Quit();\n}\n\nstatic boolean SDLIsInitialized(void)\n{\n    int freq, channels;\n    Uint16 format;\n\n    return Mix_QuerySpec(&freq, &format, &channels) != 0;\n}\n\n// Initialize music subsystem\nstatic boolean I_WEB_InitMusic(void)\n{\n    int i;\n\n    //!\n    // @category obscure\n    // @arg <filename>\n    //\n    // Read all MIDI files from loaded WAD files, dump an example substitution\n    // music config file to the specified filename and quit.\n    //\n\n    i = M_CheckParmWithArgs(\"-dumpsubstconfig\", 1);\n\n    if (i > 0)\n    {\n        DumpSubstituteConfig(myargv[i + 1]);\n    }\n\n    // If SDL_mixer is not initialized, we have to initialize it\n    // and have the responsibility to shut it down later on.\n\n    if (SDLIsInitialized())\n    {\n        music_initialized = true;\n    }\n    else\n    {\n        if (SDL_Init(SDL_INIT_AUDIO) < 0)\n        {\n            fprintf(stderr, \"Unable to set up sound.\\n\");\n        }\n        else if (Mix_OpenAudio(snd_samplerate, AUDIO_S16SYS, 2, 1024) < 0)\n        {\n            fprintf(stderr, \"Error initializing SDL_mixer: %s\\n\",\n                    Mix_GetError());\n            SDL_QuitSubSystem(SDL_INIT_AUDIO);\n        }\n        else\n        {\n            SDL_PauseAudio(0);\n\n            sdl_was_initialized = true;\n            music_initialized = true;\n        }\n    }\n\n    LoadSubstituteConfigs();\n    music_module = &music_opl_module;\n    music_module->Init();\n\n    return music_initialized;\n}\n\nstatic void UpdateMusicVolume(void)\n{\n    int vol;\n\n    if (musicpaused)\n    {\n        vol = 0;\n    }\n    else\n    {\n        vol = (current_music_volume * MIX_MAX_VOLUME) / 127;\n    }\n\n    EM_ASM({\n        try{\n            if (window.doom_music && window.doom_music_gain) window.doom_music_gain.gain.value = $0 / 255;\n        }catch(err){}\n    }, vol);\n}\n\n// Set music volume (0 - 127)\n\nstatic void I_WEB_SetMusicVolume(int volume)\n{\n    // Internal state variable.\n    current_music_volume = volume;\n\n    if (playing_substitute)\n        UpdateMusicVolume();\n    else\n        music_module->SetMusicVolume(volume);\n}\n\n// Start playing a mid\n\nstatic void I_WEB_PlaySong(void *handle, boolean looping)\n{\n    current_music_looping = looping;\n    if (playing_substitute)\n    {\n        current_music_playing = true;\n        EM_ASM_({\n            window.doom_music_looping = $0;\n            if (window.doom_music_buffer){\n                const context = SDL2.audioContext;\n                const source = context.createBufferSource();\n                source.buffer = window.doom_music_buffer;\n                source.loop = !!window.doom_music_looping;\n                const gain = context.createGain();\n                source.connect(gain);\n                gain.connect(context.destination);\n                source.start(0);\n                window.doom_music = source;\n                window.doom_music_gain = gain;\n                window.doom_music_offset = 0;\n                window.doom_music_start = context.currentTime;\n                Module._ReadLoopPoints();\n            }\n        }, looping);\n\n        UpdateMusicVolume();\n    }\n    else\n        music_module->PlaySong(handle, looping);\n}\n\nstatic void I_WEB_StopSong(void)\n{\n    if (playing_substitute)\n    {\n        current_music_playing = false;\n        EM_ASM({\n            try{\n                if (window.doom_music){\n                    (window.doom_music.stop || window.doom_music.noteOff).call(window.doom_music, 0);\n                    window.doom_music.disconnect();\n                    window.doom_music_gain.disconnect();\n                    delete window.doom_music;\n                    delete window.doom_music_gain;\n                }\n            }catch(err){}\n        });\n    }\n    else\n        music_module->StopSong();\n}\n\nstatic void I_WEB_PauseSong(void)\n{\n    if (playing_substitute)\n    {\n        I_WEB_StopSong();\n\n        EM_ASM({\n            try{\n                window.doom_music_offset = SDL2.audioContext.currentTime - window.doom_music_start;\n            }catch(err){}\n        });\n    }\n    else\n        music_module->PauseMusic();\n}\n\nstatic void I_WEB_ResumeSong(void)\n{\n    if (playing_substitute)\n    {\n        current_music_playing = true;\n        EM_ASM_({\n            if (window.doom_music_buffer){\n                const context = SDL2.audioContext;\n                const source = context.createBufferSource();\n                source.buffer = window.doom_music_buffer;\n                source.loop = !!window.doom_music_looping;\n                const gain = context.createGain();\n                source.connect(gain);\n                gain.connect(context.destination);\n                source.start(0, window.doom_music_offset);\n                window.doom_music = source;\n                window.doom_music_gain = gain;\n                window.doom_music_start = context.currentTime - window.doom_music_offset;\n                Module._ReadLoopPoints();\n            }\n        });\n\n        UpdateMusicVolume();\n    }\n    else\n        music_module->ResumeMusic();\n}\n\nstatic void I_WEB_UnRegisterSong(void *handle)\n{\n    if (playing_substitute)\n    {\n        current_music_playing = false;\n        EM_ASM_({\n            try{\n                if (window.doom_music){\n                    (window.doom_music.stop || window.doom_music.noteOff).call(window.doom_music, 0);\n                    window.doom_music.disconnect();\n                    window.doom_music_gain.disconnect();\n                }\n                delete window.doom_music;\n                delete window.doom_music_buffer;\n                delete window.doom_music_gain;\n                delete window.doom_music_offset;\n                delete window.doom_music_start;\n                delete window.doom_music_looping;\n                var filename = Module.UTF8ToString($0);\n                Module.FS.unlink(\"./\" + filename);\n            }catch(err){}\n        }, current_filename);\n    }\n    else\n        music_module->UnRegisterSong(handle);\n}\n\nstatic void *I_WEB_RegisterSong(void *data, int len)\n{\n    char *filename;\n\n    if (!music_initialized)\n    {\n        return NULL;\n    }\n\n    playing_substitute = false;\n\n    // See if we're substituting this MUS for a high-quality replacement.\n    filename = GetSubstituteMusicFile(data, len);\n\n    if (filename != NULL)\n    {\n        playing_substitute = true;\n        current_filename = filename;\n        EM_ASM_({\n            var filename = Module.UTF8ToString($0);\n            window.doom_music_filename = filename;\n            fetch(filename).then(function(res){ return res.arrayBuffer(); }).then(function(audio){\n                var context = SDL2.audioContext;\n                var path = \"\";\n                filename.split(\"/\").slice(1, -1).forEach(function(dir){\n                    if (path) path += \"/\";\n                    path += dir;\n                    try{ Module.FS.mkdir(path); }catch(err){}\n                });\n                Module.FS.writeFile(\"./\" + filename, new Uint8Array(audio));\n                context.decodeAudioData(audio, function(buffer){\n                    if (window.doom_music_filename == filename){\n                        var source = context.createBufferSource();\n                        source.buffer = buffer;\n                        source.loop = !!window.doom_music_looping;\n                        var gain = context.createGain();\n                        source.connect(gain);\n                        gain.connect(context.destination);\n                        gain.gain.value = $1 / 255;\n                        source.start(0);\n                        window.doom_music_buffer = buffer;\n                        window.doom_music = source;\n                        window.doom_music_gain = gain;\n                        window.doom_music_offset = 0;\n                        window.doom_music_start = context.currentTime;\n                        Module._ReadLoopPoints();\n                    }\n                });\n            }).catch(function(){\n                Module._I_WEB_RegisterSongFallback();\n            });\n        }, filename, (current_music_volume * MIX_MAX_VOLUME) / 127);\n    }\n    current_music_handle = music_module->RegisterSong(data, len);\n    return current_music_handle;\n}\n\n// Shutdown music\n\nstatic void I_WEB_ShutdownMusic(void)\n{\n    if (music_initialized)\n    {\n        music_initialized = false;\n        I_WEB_StopSong();\n        music_module->Shutdown();\n\n        if (sdl_was_initialized)\n        {\n            Mix_CloseAudio();\n            SDL_QuitSubSystem(SDL_INIT_AUDIO);\n            sdl_was_initialized = false;\n        }\n    }\n}\n\n// Is the song playing?\nstatic boolean I_WEB_MusicIsPlaying(void)\n{\n    if (!music_initialized)\n    {\n        return false;\n    }\n\n    if (playing_substitute)\n        return EM_ASM_INT({ return +((!!window.doom_music) || $0); }, current_music_playing);\n    else\n        return music_module->MusicIsPlaying();\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid I_WEB_RegisterSongFallback()\n{\n    boolean isPlaying = I_WEB_MusicIsPlaying();\n    I_WEB_UnRegisterSong(current_music_handle);\n    if (isPlaying){\n        playing_substitute = false;\n        I_WEB_PlaySong(current_music_handle, isPlaying);\n    }\n}\n\nstatic snddevice_t music_web_devices[] =\n{\n    SNDDEVICE_WEBAUDIO,\n    SNDDEVICE_SB,\n};\n\nmusic_module_t music_web_module =\n{\n    music_web_devices,\n    arrlen(music_web_devices),\n    I_WEB_InitMusic,\n    I_WEB_ShutdownMusic,\n    I_WEB_SetMusicVolume,\n    I_WEB_PauseSong,\n    I_WEB_ResumeSong,\n    I_WEB_RegisterSong,\n    I_WEB_UnRegisterSong,\n    I_WEB_PlaySong,\n    I_WEB_StopSong,\n    I_WEB_MusicIsPlaying,\n    NULL, // Poll\n};\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tRefresh of things, i.e. objects represented by sprites.\n//\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n\n#include \"deh_main.h\"\n#include \"doomdef.h\"\n\n#include \"i_swap.h\"\n#include \"i_system.h\"\n#include \"z_zone.h\"\n#include \"w_wad.h\"\n\n#include \"r_local.h\"\n\n#include \"doomstat.h\"\n\n#include \"p_local.h\" // [crispy] MLOOKUNIT\n#include \"r_bmaps.h\" // [crispy] R_BrightmapForTexName()\n\n\n#define MINZ\t\t\t\t(FRACUNIT*4)\n#define BASEYCENTER\t\t\t(ORIGHEIGHT/2)\n\n\ntypedef struct\n{\n    int\t\tx1;\n    int\t\tx2;\n\t\n    int\t\tcolumn;\n    int\t\ttopclip;\n    int\t\tbottomclip;\n\n} maskdraw_t;\n\n\nstatic degenmobj_t laserspot_m = {{0}};\ndegenmobj_t *laserspot = &laserspot_m;\n\n// [crispy] extendable, but the last char element must be zero,\n// keep in sync with multiitem_t multiitem_crosshairtype[] in m_menu.c\nstatic laserpatch_t laserpatch_m[] = {\n\t{'+', \"cross1\", 0, 0, 0},\n\t{'^', \"cross2\", 0, 0, 0},\n\t{'.', \"cross3\", 0, 0, 0},\n\t{0, \"\", 0, 0, 0},\n};\nlaserpatch_t *laserpatch = laserpatch_m;\n\n//\n// Sprite rotation 0 is facing the viewer,\n//  rotation 1 is one angle turn CLOCKWISE around the axis.\n// This is not the same as the angle,\n//  which increases counter clockwise (protractor).\n// There was a lot of stuff grabbed wrong, so I changed it...\n//\nfixed_t\t\tpspritescale;\nfixed_t\t\tpspriteiscale;\n\nlighttable_t**\tspritelights;\n\n// constant arrays\n//  used for psprite clipping and initializing clipping\nint\t\tnegonearray[SCREENWIDTH]; // [crispy] 32-bit integer math\nint\t\tscreenheightarray[SCREENWIDTH]; // [crispy] 32-bit integer math\n\n\n//\n// INITIALIZATION FUNCTIONS\n//\n\n// variables used to look up\n//  and range check thing_t sprites patches\nspritedef_t*\tsprites;\nint\t\tnumsprites;\n\nspriteframe_t\tsprtemp[29];\nint\t\tmaxframe;\nconst char\t*spritename;\n\n\n\n\n//\n// R_InstallSpriteLump\n// Local function for R_InitSprites.\n//\nvoid\nR_InstallSpriteLump\n( int\t\tlump,\n  unsigned\tframe,\n  char\t\trot,\n  boolean\tflipped )\n{\n    int\t\tr;\n    // [crispy] support 16 sprite rotations\n    unsigned rotation = (rot >= 'A') ? rot - 'A' + 10 : (rot >= '0') ? rot - '0' : 17;\n\t\n    if (frame >= 29 || rotation > 16) // [crispy] support 16 sprite rotations\n\tI_Error(\"R_InstallSpriteLump: \"\n\t\t\"Bad frame characters in lump %i\", lump);\n\t\n    if ((int)frame > maxframe)\n\tmaxframe = frame;\n\t\t\n    if (rotation == 0)\n    {\n\t// the lump should be used for all rotations\n\t// [crispy] make non-fatal\n\tif (sprtemp[frame].rotate == false)\n\t    fprintf (stderr, \"R_InitSprites: Sprite %s frame %c has \"\n\t\t     \"multip rot=0 lump\\n\", spritename, 'A'+frame);\n\n\t// [crispy] make non-fatal\n\tif (sprtemp[frame].rotate == true)\n\t    fprintf (stderr, \"R_InitSprites: Sprite %s frame %c has rotations \"\n\t\t     \"and a rot=0 lump\\n\", spritename, 'A'+frame);\n\n\tfor (r=0 ; r<8 ; r++)\n\t{\n\t  // [crispy] only if not yet substituted\n\t  if (sprtemp[frame].lump[r] == -1)\n\t  {\n\t    sprtemp[frame].lump[r] = lump - firstspritelump;\n\t    sprtemp[frame].flip[r] = (byte)flipped;\n\t    // [crispy] ... here\n\t    sprtemp[frame].rotate = false;\n\t  }\n\t}\n\treturn;\n    }\n\t\n    // the lump is only used for one rotation\n    // [crispy] make non-fatal\n    if (sprtemp[frame].rotate == false)\n\tfprintf (stderr, \"R_InitSprites: Sprite %s frame %c has rotations \"\n\t\t \"and a rot=0 lump\\n\", spritename, 'A'+frame);\n\n    // make 0 based\n    rotation--;\t\t\n    if (sprtemp[frame].lump[rotation] != -1)\n    {\n\t// [crispy] make non-fatal\n\tfprintf (stderr, \"R_InitSprites: Sprite %s : %c : %c \"\n\t\t \"has two lumps mapped to it\\n\",\n\t\t spritename, 'A'+frame, '1'+rotation);\n\treturn;\n    }\n\t\t\n    sprtemp[frame].lump[rotation] = lump - firstspritelump;\n    sprtemp[frame].flip[rotation] = (byte)flipped;\n    // [crispy] ... here\n    sprtemp[frame].rotate = true;\n}\n\n\n\n\n//\n// R_InitSpriteDefs\n// Pass a null terminated list of sprite names\n//  (4 chars exactly) to be used.\n// Builds the sprite rotation matrixes to account\n//  for horizontally flipped sprites.\n// Will report an error if the lumps are inconsistant. \n// Only called at startup.\n//\n// Sprite lump names are 4 characters for the actor,\n//  a letter for the frame, and a number for the rotation.\n// A sprite that is flippable will have an additional\n//  letter/number appended.\n// The rotation character can be 0 to signify no rotations.\n//\nvoid R_InitSpriteDefs(const char **namelist)\n{ \n    const char **check;\n    int\t\ti;\n    int\t\tl;\n    int\t\tframe;\n    int\t\trotation;\n    int\t\tstart;\n    int\t\tend;\n    int\t\tpatched;\n\t\t\n    // count the number of sprite names\n    check = namelist;\n    while (*check != NULL)\n\tcheck++;\n\n    numsprites = check-namelist;\n\t\n    if (!numsprites)\n\treturn;\n\t\t\n    sprites = Z_Malloc(numsprites *sizeof(*sprites), PU_STATIC, NULL);\n\t\n    start = firstspritelump-1;\n    end = lastspritelump+1;\n\t\n    // scan all the lump names for each of the names,\n    //  noting the highest frame letter.\n    // Just compare 4 characters as ints\n    for (i=0 ; i<numsprites ; i++)\n    {\n\tspritename = DEH_String(namelist[i]);\n\tmemset (sprtemp,-1, sizeof(sprtemp));\n\t\t\n\tmaxframe = -1;\n\t\n\t// scan the lumps,\n\t//  filling in the frames for whatever is found\n\tfor (l=start+1 ; l<end ; l++)\n\t{\n\t    if (!strncasecmp(lumpinfo[l]->name, spritename, 4))\n\t    {\n\t\tframe = lumpinfo[l]->name[4] - 'A';\n\t\trotation = lumpinfo[l]->name[5];\n\n\t\tif (modifiedgame)\n\t\t    patched = W_GetNumForName (lumpinfo[l]->name);\n\t\telse\n\t\t    patched = l;\n\n\t\tR_InstallSpriteLump (patched, frame, rotation, false);\n\n\t\tif (lumpinfo[l]->name[6])\n\t\t{\n\t\t    frame = lumpinfo[l]->name[6] - 'A';\n\t\t    rotation = lumpinfo[l]->name[7];\n\t\t    R_InstallSpriteLump (l, frame, rotation, true);\n\t\t}\n\t    }\n\t}\n\t\n\t// check the frames that were found for completeness\n\tif (maxframe == -1)\n\t{\n\t    sprites[i].numframes = 0;\n\t    continue;\n\t}\n\t\t\n\tmaxframe++;\n\t\n\tfor (frame = 0 ; frame < maxframe ; frame++)\n\t{\n\t    switch ((int)sprtemp[frame].rotate)\n\t    {\n\t      case -1:\n\t\t// no rotations were found for that frame at all\n\t\t// [crispy] make non-fatal\n\t\tfprintf (stderr, \"R_InitSprites: No patches found \"\n\t\t\t \"for %s frame %c\\n\", spritename, frame+'A');\n\t\tbreak;\n\t\t\n\t      case 0:\n\t\t// only the first rotation is needed\n\t\tbreak;\n\t\t\t\n\t      case 1:\n\t\t// must have all 8 frames\n\t\tfor (rotation=0 ; rotation<8 ; rotation++)\n\t\t    if (sprtemp[frame].lump[rotation] == -1)\n\t\t\tI_Error (\"R_InitSprites: Sprite %s frame %c \"\n\t\t\t\t \"is missing rotations\",\n\t\t\t\t spritename, frame+'A');\n\n\t\t// [crispy] support 16 sprite rotations\n\t\tsprtemp[frame].rotate = 2;\n\t\tfor ( ; rotation<16 ; rotation++)\n\t\t    if (sprtemp[frame].lump[rotation] == -1)\n\t\t    {\n\t\t\tsprtemp[frame].rotate = 1;\n\t\t\tbreak;\n\t\t    }\n\n\t\tbreak;\n\t    }\n\t}\n\t\n\t// allocate space for the frames present and copy sprtemp to it\n\tsprites[i].numframes = maxframe;\n\tsprites[i].spriteframes = \n\t    Z_Malloc (maxframe * sizeof(spriteframe_t), PU_STATIC, NULL);\n\tmemcpy (sprites[i].spriteframes, sprtemp, maxframe*sizeof(spriteframe_t));\n    }\n\n}\n\n\n\n\n//\n// GAME FUNCTIONS\n//\nvissprite_t*\tvissprites = NULL;\nvissprite_t*\tvissprite_p;\nint\t\tnewvissprite;\nstatic int\tnumvissprites;\n\n\n\n//\n// R_InitSprites\n// Called at program start.\n//\nvoid R_InitSprites(const char **namelist)\n{\n    int\t\ti;\n\t\n    for (i=0 ; i<SCREENWIDTH ; i++)\n    {\n\tnegonearray[i] = -1;\n    }\n\t\n    R_InitSpriteDefs (namelist);\n}\n\n\n\n//\n// R_ClearSprites\n// Called at frame start.\n//\nvoid R_ClearSprites (void)\n{\n    vissprite_p = vissprites;\n}\n\n\n//\n// R_NewVisSprite\n//\nvissprite_t\toverflowsprite;\n\nvissprite_t* R_NewVisSprite (void)\n{\n    // [crispy] remove MAXVISSPRITE Vanilla limit\n    if (vissprite_p == &vissprites[numvissprites])\n    {\n\tstatic int max;\n\tint numvissprites_old = numvissprites;\n\n\t// [crispy] cap MAXVISSPRITES limit at 4096\n\tif (!max && numvissprites == 32 * MAXVISSPRITES)\n\t{\n\t    fprintf(stderr, \"R_NewVisSprite: MAXVISSPRITES limit capped at %d.\\n\", numvissprites);\n\t    max++;\n\t}\n\n\tif (max)\n\treturn &overflowsprite;\n\n\tnumvissprites = numvissprites ? 2 * numvissprites : MAXVISSPRITES;\n\tvissprites = I_Realloc(vissprites, numvissprites * sizeof(*vissprites));\n\tmemset(vissprites + numvissprites_old, 0, (numvissprites - numvissprites_old) * sizeof(*vissprites));\n\n\tvissprite_p = vissprites + numvissprites_old;\n\n\tif (numvissprites_old)\n\t    fprintf(stderr, \"R_NewVisSprite: Hit MAXVISSPRITES limit at %d, raised to %d.\\n\", numvissprites_old, numvissprites);\n    }\n    \n    vissprite_p++;\n    return vissprite_p-1;\n}\n\n\n\n//\n// R_DrawMaskedColumn\n// Used for sprites and masked mid textures.\n// Masked means: partly transparent, i.e. stored\n//  in posts/runs of opaque pixels.\n//\nint*\t\tmfloorclip; // [crispy] 32-bit integer math\nint*\t\tmceilingclip; // [crispy] 32-bit integer math\n\nfixed_t\t\tspryscale;\nint64_t\t\tsprtopscreen; // [crispy] WiggleFix\n\nvoid R_DrawMaskedColumn (column_t* column)\n{\n    int64_t\ttopscreen; // [crispy] WiggleFix\n    int64_t \tbottomscreen; // [crispy] WiggleFix\n    fixed_t\tbasetexturemid;\n    int\t\ttop = -1;\n\t\n    basetexturemid = dc_texturemid;\n    dc_texheight = 0; // [crispy] Tutti-Frutti fix\n\t\n    for ( ; column->topdelta != 0xff ; ) \n    {\n\t// [crispy] support for DeePsea tall patches\n\tif (column->topdelta <= top)\n\t{\n\t\ttop += column->topdelta;\n\t}\n\telse\n\t{\n\t\ttop = column->topdelta;\n\t}\n\t// calculate unclipped screen coordinates\n\t//  for post\n\ttopscreen = sprtopscreen + spryscale*top;\n\tbottomscreen = topscreen + spryscale*column->length;\n\n\tdc_yl = (int)((topscreen+FRACUNIT-1)>>FRACBITS); // [crispy] WiggleFix\n\tdc_yh = (int)((bottomscreen-1)>>FRACBITS); // [crispy] WiggleFix\n\t\t\n\tif (dc_yh >= mfloorclip[dc_x])\n\t    dc_yh = mfloorclip[dc_x]-1;\n\tif (dc_yl <= mceilingclip[dc_x])\n\t    dc_yl = mceilingclip[dc_x]+1;\n\n\tif (dc_yl <= dc_yh)\n\t{\n\t    dc_source = (byte *)column + 3;\n\t    dc_texturemid = basetexturemid - (top<<FRACBITS);\n\n\t    // Drawn by either R_DrawColumn\n\t    //  or (SHADOW) R_DrawFuzzColumn.\n\t    colfunc ();\t\n\t}\n\tcolumn = (column_t *)(  (byte *)column + column->length + 4);\n    }\n\t\n    dc_texturemid = basetexturemid;\n}\n\n\n\n//\n// R_DrawVisSprite\n//  mfloorclip and mceilingclip should also be set.\n//\nvoid\nR_DrawVisSprite\n( vissprite_t*\t\tvis,\n  int\t\t\tx1,\n  int\t\t\tx2 )\n{\n    column_t*\t\tcolumn;\n    int\t\t\ttexturecolumn;\n    fixed_t\t\tfrac;\n    patch_t*\t\tpatch;\n\t\n\t\n    patch = W_CacheLumpNum (vis->patch+firstspritelump, PU_CACHE);\n\n    // [crispy] brightmaps for select sprites\n    dc_colormap[0] = vis->colormap[0];\n    dc_colormap[1] = vis->colormap[1];\n    dc_brightmap = vis->brightmap;\n    \n    if (!dc_colormap[0])\n    {\n\t// NULL colormap = shadow draw\n\tcolfunc = fuzzcolfunc;\n    }\n    else if (vis->mobjflags & MF_TRANSLATION)\n    {\n\tcolfunc = transcolfunc;\n\tdc_translation = translationtables - 256 +\n\t    ( (vis->mobjflags & MF_TRANSLATION) >> (MF_TRANSSHIFT-8) );\n    }\n    // [crispy] color-translated sprites (i.e. blood)\n    else if (vis->translation)\n    {\n\tcolfunc = transcolfunc;\n\tdc_translation = vis->translation;\n    }\n\t\n    dc_iscale = abs(vis->xiscale)>>detailshift;\n    dc_texturemid = vis->texturemid;\n    frac = vis->startfrac;\n    spryscale = vis->scale;\n    sprtopscreen = centeryfrac - FixedMul(dc_texturemid,spryscale);\n\t\n    for (dc_x=vis->x1 ; dc_x<=vis->x2 ; dc_x++, frac += vis->xiscale)\n    {\n\tstatic boolean error = false;\n\ttexturecolumn = frac>>FRACBITS;\n#ifdef RANGECHECK\n\tif (texturecolumn < 0 || texturecolumn >= SHORT(patch->width))\n\t{\n\t    // [crispy] make non-fatal\n\t    if (!error)\n\t    {\n\t    fprintf (stderr, \"R_DrawSpriteRange: bad texturecolumn\\n\");\n\t    error = true;\n\t    }\n\t    continue;\n\t}\n#endif\n\tcolumn = (column_t *) ((byte *)patch +\n\t\t\t       LONG(patch->columnofs[texturecolumn]));\n\tR_DrawMaskedColumn (column);\n    }\n\n    colfunc = basecolfunc;\n}\n\n\n\n//\n// R_ProjectSprite\n// Generates a vissprite for a thing\n//  if it might be visible.\n//\nvoid R_ProjectSprite (mobj_t* thing)\n{\n    fixed_t\t\ttr_x;\n    fixed_t\t\ttr_y;\n    \n    fixed_t\t\tgxt;\n    fixed_t\t\tgyt;\n    \n    fixed_t\t\ttx;\n    fixed_t\t\ttz;\n\n    fixed_t\t\txscale;\n    \n    int\t\t\tx1;\n    int\t\t\tx2;\n\n    spritedef_t*\tsprdef;\n    spriteframe_t*\tsprframe;\n    int\t\t\tlump;\n    \n    unsigned\t\trot;\n    boolean\t\tflip;\n    \n    int\t\t\tindex;\n\n    vissprite_t*\tvis;\n    \n    angle_t\t\tang;\n    fixed_t\t\tiscale;\n    \n    fixed_t             interpx;\n    fixed_t             interpy;\n    fixed_t             interpz;\n    fixed_t             interpangle;\n\n    // [AM] Interpolate between current and last position,\n    //      if prudent.\n    interpx = thing->x;\n    interpy = thing->y;\n    interpz = thing->z;\n    interpangle = thing->angle;\n\n    // transform the origin point\n    tr_x = interpx - viewx;\n    tr_y = interpy - viewy;\n\t\n    gxt = FixedMul(tr_x,viewcos); \n    gyt = -FixedMul(tr_y,viewsin);\n    \n    tz = gxt-gyt; \n\n    // thing is behind view plane?\n    if (tz < MINZ)\n\treturn;\n    \n    xscale = FixedDiv(projection, tz);\n\t\n    gxt = -FixedMul(tr_x,viewsin); \n    gyt = FixedMul(tr_y,viewcos); \n    tx = -(gyt+gxt); \n\n    // too far off the side?\n    if (abs(tx)>(tz<<2))\n\treturn;\n    \n    // decide which patch to use for sprite relative to player\n#ifdef RANGECHECK\n    if ((unsigned int) thing->sprite >= (unsigned int) numsprites)\n\tI_Error (\"R_ProjectSprite: invalid sprite number %i \",\n\t\t thing->sprite);\n#endif\n    sprdef = &sprites[thing->sprite];\n    // [crispy] the TNT1 sprite is not supposed to be rendered anyway\n    if (!sprdef->numframes && thing->sprite == SPR_TNT1)\n    {\n\treturn;\n    }\n#ifdef RANGECHECK\n    if ( (thing->frame&FF_FRAMEMASK) >= sprdef->numframes )\n\tI_Error (\"R_ProjectSprite: invalid sprite frame %i : %i \",\n\t\t thing->sprite, thing->frame);\n#endif\n    sprframe = &sprdef->spriteframes[ thing->frame & FF_FRAMEMASK];\n\n    if (sprframe->rotate)\n    {\n\t// choose a different rotation based on player view\n\tang = R_PointToAngle (interpx, interpy);\n\t// [crispy] now made non-fatal\n\tif (sprframe->rotate == -1)\n\t{\n\t    return;\n\t}\n\telse\n\t// [crispy] support 16 sprite rotations\n\tif (sprframe->rotate == 2)\n\t{\n\t    const unsigned rot2 = (ang-interpangle+(unsigned)(ANG45/4)*17);\n\t    rot = (rot2>>29) + ((rot2>>25)&8);\n\t}\n\telse\n\t{\n\trot = (ang-interpangle+(unsigned)(ANG45/2)*9)>>29;\n\t}\n\tlump = sprframe->lump[rot];\n\tflip = (boolean)sprframe->flip[rot];\n    }\n    else\n    {\n\t// use single rotation for all views\n\tlump = sprframe->lump[0];\n\tflip = (boolean)sprframe->flip[0];\n    }\n    \n    // calculate edges of the shape\n    // [crispy] fix sprite offsets for mirrored sprites\n    tx -= flip ? spritewidth[lump] - spriteoffset[lump] : spriteoffset[lump];\n    x1 = (centerxfrac + FixedMul (tx,xscale) ) >>FRACBITS;\n\n    // off the right side?\n    if (x1 > viewwidth)\n\treturn;\n    \n    tx +=  spritewidth[lump];\n    x2 = ((centerxfrac + FixedMul (tx,xscale) ) >>FRACBITS) - 1;\n\n    // off the left side\n    if (x2 < 0)\n\treturn;\n\n    int heightsec = thing->subsector->sector->heightsec;\n\n    if (heightsec != -1)   // only clip things which are in special sectors\n    {\n        fixed_t   gzt;               // killough 3/27/98\n        gzt = interpz + spritetopoffset[lump];\n    int phs = viewplayer->mo->subsector->sector->heightsec;\n    if (phs != -1 && viewz < sectors[phs].floorheight ?\n        interpz >= sectors[heightsec].floorheight :\n        gzt < sectors[heightsec].floorheight)\n        return;\n    if (phs != -1 && viewz > sectors[phs].ceilingheight ?\n        gzt < sectors[heightsec].ceilingheight &&\n        viewz >= sectors[heightsec].ceilingheight :\n        interpz >= sectors[heightsec].ceilingheight)\n        return;\n    }\n    \n    // store information in a vissprite\n    vis = R_NewVisSprite ();\n    vis->heightsec = heightsec;\n    vis->translation = NULL; // [crispy] no color translation\n    vis->mobjflags = thing->flags;\n    vis->scale = xscale<<detailshift;\n    vis->gx = interpx;\n    vis->gy = interpy;\n    vis->gz = interpz;\n    vis->gzt = interpz + spritetopoffset[lump];\n    vis->texturemid = vis->gzt - viewz;\n    vis->x1 = x1 < 0 ? 0 : x1;\n    vis->x2 = x2 >= viewwidth ? viewwidth-1 : x2;\t\n    iscale = FixedDiv (FRACUNIT, xscale);\n\n    if (flip)\n    {\n\tvis->startfrac = spritewidth[lump]-1;\n\tvis->xiscale = -iscale;\n    }\n    else\n    {\n\tvis->startfrac = 0;\n\tvis->xiscale = iscale;\n    }\n\n    if (vis->x1 > x1)\n\tvis->startfrac += vis->xiscale*(vis->x1-x1);\n    vis->patch = lump;\n    \n    // get light level\n    if (thing->flags & MF_SHADOW)\n    {\n\t// shadow draw\n\tvis->colormap[0] = vis->colormap[1] = NULL;\n    }\n    else if (fixedcolormap)\n    {\n\t// fixed map\n\tvis->colormap[0] = vis->colormap[1] = fixedcolormap;\n    }\n    else if (thing->frame & FF_FULLBRIGHT)\n    {\n\t// full bright\n\tvis->colormap[0] = vis->colormap[1] = fullcolormap;\n    }\n    \n    else\n    {\n\t// diminished light\n\tindex = xscale>>(LIGHTSCALESHIFT-detailshift/*+crispy->hires*/);\n\n\tif (index >= MAXLIGHTSCALE) \n\t    index = MAXLIGHTSCALE-1;\n\n\t// [crispy] brightmaps for select sprites\n\tvis->colormap[0] = spritelights[index];\n\tvis->colormap[1] = scalelight[LIGHTLEVELS-1][MAXLIGHTSCALE-1];\n    }\t\n    vis->brightmap = R_BrightmapForSprite(thing->sprite);\n}\n\nextern void P_LineLaser (mobj_t* t1, angle_t angle, fixed_t distance, fixed_t slope);\n\nbyte *R_LaserspotColor (void)\n{\n\treturn NULL;\n}\n\n//\n// R_AddSprites\n// During BSP traversal, this adds sprites by sector.\n//\nvoid R_AddSprites (sector_t* sec)\n{\n    mobj_t*\t\tthing;\n    int\t\t\tlightnum;\n\n    // BSP is traversed by subsector.\n    // A sector might have been split into several\n    //  subsectors during BSP building.\n    // Thus we check whether its already added.\n    if (sec->validcount == validcount)\n\treturn;\t\t\n\n    // Well, now it will be done.\n    sec->validcount = validcount;\n\t\n    lightnum = (sec->lightlevel >> LIGHTSEGSHIFT)+(extralight * LIGHTBRIGHT);\n\n    if (lightnum < 0)\t\t\n\tspritelights = scalelight[0];\n    else if (lightnum >= LIGHTLEVELS)\n\tspritelights = scalelight[LIGHTLEVELS-1];\n    else\n\tspritelights = scalelight[lightnum];\n\n    // Handle all things in sector.\n    for (thing = sec->thinglist ; thing ; thing = thing->snext)\n\tR_ProjectSprite (thing);\n}\n\n//\n// R_DrawPSprite\n//\nvoid R_DrawPSprite (pspdef_t* psp, psprnum_t psprnum) // [crispy] differentiate gun from flash sprites\n{\n    fixed_t\t\ttx;\n    int\t\t\tx1;\n    int\t\t\tx2;\n    spritedef_t*\tsprdef;\n    spriteframe_t*\tsprframe;\n    int\t\t\tlump;\n    boolean\t\tflip;\n    vissprite_t*\tvis;\n    vissprite_t\t\tavis;\n    fixed_t\t\tpsp_sx = psp->sx, psp_sy = psp->sy;\n    const int state = viewplayer->psprites[ps_weapon].state - states;\n    \n    // decide which patch to use\n#ifdef RANGECHECK\n    if ( (unsigned)psp->state->sprite >= (unsigned int) numsprites)\n\tI_Error (\"R_ProjectSprite: invalid sprite number %i \",\n\t\t psp->state->sprite);\n#endif\n    sprdef = &sprites[psp->state->sprite];\n    // [crispy] the TNT1 sprite is not supposed to be rendered anyway\n    if (!sprdef->numframes && psp->state->sprite == SPR_TNT1)\n    {\n\treturn;\n    }\n#ifdef RANGECHECK\n    if ( (psp->state->frame & FF_FRAMEMASK)  >= sprdef->numframes)\n\tI_Error (\"R_ProjectSprite: invalid sprite frame %i : %i \",\n\t\t psp->state->sprite, psp->state->frame);\n#endif\n    sprframe = &sprdef->spriteframes[ psp->state->frame & FF_FRAMEMASK ];\n\n    lump = sprframe->lump[0];\n    flip = (boolean)sprframe->flip[0] ^ 0; //crispy->flipweapons;\n\n    tx = psp_sx-(ORIGWIDTH/2)*FRACUNIT;\n\t\n    // [crispy] fix sprite offsets for mirrored sprites\n    tx -= flip ? 2 * tx - spriteoffset[lump] + spritewidth[lump] : spriteoffset[lump];\n    x1 = (centerxfrac + FixedMul (tx,pspritescale) ) >>FRACBITS;\n\n    // off the right side\n    if (x1 > viewwidth)\n\treturn;\t\t\n\n    tx +=  spritewidth[lump];\n    x2 = ((centerxfrac + FixedMul (tx, pspritescale) ) >>FRACBITS) - 1;\n\n    // off the left side\n    if (x2 < 0)\n\treturn;\n    \n    // store information in a vissprite\n    vis = &avis;\n    vis->translation = NULL; // [crispy] no color translation\n    vis->mobjflags = 0;\n    // [crispy] weapons drawn 1 pixel too high when player is idle\n    vis->texturemid = (BASEYCENTER<<FRACBITS)+FRACUNIT/4-(psp_sy-spritetopoffset[lump]);\n    vis->x1 = x1 < 0 ? 0 : x1;\n    vis->x2 = x2 >= viewwidth ? viewwidth-1 : x2;\t\n    vis->scale = pspritescale<<detailshift;\n    \n    if (flip)\n    {\n\tvis->xiscale = -pspriteiscale;\n\tvis->startfrac = spritewidth[lump]-1;\n    }\n    else\n    {\n\tvis->xiscale = pspriteiscale;\n\tvis->startfrac = 0;\n    }\n    \n    // [crispy] free look\n    vis->texturemid += FixedMul(((centery - viewheight / 2) << FRACBITS), pspriteiscale) >> detailshift;\n\n    if (vis->x1 > x1)\n\tvis->startfrac += vis->xiscale*(vis->x1-x1);\n\n    vis->patch = lump;\n\n    if (viewplayer->powers[pw_invisibility] > 4*32\n\t|| viewplayer->powers[pw_invisibility] & 8)\n    {\n\t// shadow draw\n\tvis->colormap[0] = vis->colormap[1] = NULL;\n    }\n    else if (fixedcolormap)\n    {\n\t// fixed color\n\tvis->colormap[0] = vis->colormap[1] = fixedcolormap;\n    }\n    else if (psp->state->frame & FF_FULLBRIGHT)\n    {\n\t// full bright\n\tvis->colormap[0] = vis->colormap[1] = fullcolormap;\n    }\n    else\n    {\n\t// local light\n\tvis->colormap[0] = spritelights[MAXLIGHTSCALE-1];\n\tvis->colormap[1] = scalelight[LIGHTLEVELS-1][MAXLIGHTSCALE-1];\n    }\n    vis->brightmap = R_BrightmapForState(state);\n\t\n    // [crispy] translucent gun flash sprites\n    if (psprnum == ps_flash)\n        vis->mobjflags |= MF_TRANSLUCENT;\n\n    R_DrawVisSprite (vis, vis->x1, vis->x2);\n}\n\n\n\n//\n// R_DrawPlayerSprites\n//\nvoid R_DrawPlayerSprites (void)\n{\n    int\t\ti;\n    int\t\tlightnum;\n    pspdef_t*\tpsp;\n    \n    // get light level\n    lightnum =\n\t(viewplayer->mo->subsector->sector->lightlevel >> LIGHTSEGSHIFT) \n\t+(extralight * LIGHTBRIGHT);\n\n    if (lightnum < 0)\t\t\n\tspritelights = scalelight[0];\n    else if (lightnum >= LIGHTLEVELS)\n\tspritelights = scalelight[LIGHTLEVELS-1];\n    else\n\tspritelights = scalelight[lightnum];\n    \n    // clip to screen bounds\n    mfloorclip = screenheightarray;\n    mceilingclip = negonearray;\n\n    // add all active psprites\n    for (i=0, psp=viewplayer->psprites;\n\t i<NUMPSPRITES;\n\t i++,psp++)\n    {\n\tif (psp->state)\n\t    R_DrawPSprite (psp, i); // [crispy] pass gun or flash sprite\n    }\n}\n\n\n\n\n//\n// R_SortVisSprites\n//\n#ifdef HAVE_QSORT\n// [crispy] use stdlib's qsort() function for sorting the vissprites[] array\nstatic inline int cmp_vissprites (const void *a, const void *b)\n{\n    const vissprite_t *vsa = (const vissprite_t *) a;\n    const vissprite_t *vsb = (const vissprite_t *) b;\n\n    const int ret = vsa->scale - vsb->scale;\n\n    return ret ? ret : vsa->next - vsb->next;\n}\n\nvoid R_SortVisSprites (void)\n{\n    int count;\n    vissprite_t *ds;\n\n    count = vissprite_p - vissprites;\n\n    if (!count)\n\treturn;\n\n    // [crispy] maintain a stable sort for deliberately overlaid sprites\n    for (ds = vissprites; ds < vissprite_p; ds++)\n    {\n\tds->next = ds + 1;\n    }\n\n    qsort(vissprites, count, sizeof(*vissprites), cmp_vissprites);\n}\n#else\nvissprite_t\tvsprsortedhead;\n\n\nvoid R_SortVisSprites (void)\n{\n    int\t\t\ti;\n    int\t\t\tcount;\n    vissprite_t*\tds;\n    vissprite_t*\tbest;\n    vissprite_t\t\tunsorted;\n    fixed_t\t\tbestscale;\n\n    count = vissprite_p - vissprites;\n\t\n    unsorted.next = unsorted.prev = &unsorted;\n\n    if (!count)\n\treturn;\n\t\t\n    for (ds=vissprites ; ds<vissprite_p ; ds++)\n    {\n\tds->next = ds+1;\n\tds->prev = ds-1;\n    }\n    \n    vissprites[0].prev = &unsorted;\n    unsorted.next = &vissprites[0];\n    (vissprite_p-1)->next = &unsorted;\n    unsorted.prev = vissprite_p-1;\n    \n    // pull the vissprites out by scale\n\n    vsprsortedhead.next = vsprsortedhead.prev = &vsprsortedhead;\n    for (i=0 ; i<count ; i++)\n    {\n\tbestscale = INT_MAX;\n        best = unsorted.next;\n\tfor (ds=unsorted.next ; ds!= &unsorted ; ds=ds->next)\n\t{\n\t    if (ds->scale < bestscale)\n\t    {\n\t\tbestscale = ds->scale;\n\t\tbest = ds;\n\t    }\n\t}\n\tbest->next->prev = best->prev;\n\tbest->prev->next = best->next;\n\tbest->next = &vsprsortedhead;\n\tbest->prev = vsprsortedhead.prev;\n\tvsprsortedhead.prev->next = best;\n\tvsprsortedhead.prev = best;\n    }\n}\n#endif\n\n\n\n//\n// R_DrawSprite\n//\nvoid R_DrawSprite (vissprite_t* spr)\n{\n    drawseg_t*\t\tds;\n    int\t\tclipbot[SCREENWIDTH]; // [crispy] 32-bit integer math\n    int\t\tcliptop[SCREENWIDTH]; // [crispy] 32-bit integer math\n    int\t\t\tx;\n    int\t\t\tr1;\n    int\t\t\tr2;\n    fixed_t\t\tscale;\n    fixed_t\t\tlowscale;\n    int\t\t\tsilhouette;\n\t\t\n    for (x = spr->x1 ; x<=spr->x2 ; x++)\n\tclipbot[x] = cliptop[x] = -2;\n    \n    // Scan drawsegs from end to start for obscuring segs.\n    // The first drawseg that has a greater scale\n    //  is the clip seg.\n    for (ds=ds_p-1 ; ds >= drawsegs ; ds--)\n    {\n\t// determine if the drawseg obscures the sprite\n\tif (ds->x1 > spr->x2\n\t    || ds->x2 < spr->x1\n\t    || (!ds->silhouette\n\t\t&& !ds->maskedtexturecol) )\n\t{\n\t    // does not cover sprite\n\t    continue;\n\t}\n\t\t\t\n\tr1 = ds->x1 < spr->x1 ? spr->x1 : ds->x1;\n\tr2 = ds->x2 > spr->x2 ? spr->x2 : ds->x2;\n\n\tif (ds->scale1 > ds->scale2)\n\t{\n\t    lowscale = ds->scale2;\n\t    scale = ds->scale1;\n\t}\n\telse\n\t{\n\t    lowscale = ds->scale1;\n\t    scale = ds->scale2;\n\t}\n\t\t\n\tif (scale < spr->scale\n\t    || ( lowscale < spr->scale\n\t\t && !R_PointOnSegSide (spr->gx, spr->gy, ds->curline) ) )\n\t{\n\t    // masked mid texture?\n\t    if (ds->maskedtexturecol)\t\n\t\tR_RenderMaskedSegRange (ds, r1, r2);\n\t    // seg is behind sprite\n\t    continue;\t\t\t\n\t}\n\n\t\n\t// clip this piece of the sprite\n\tsilhouette = ds->silhouette;\n\t\n\tif (spr->gz >= ds->bsilheight)\n\t    silhouette &= ~SIL_BOTTOM;\n\n\tif (spr->gzt <= ds->tsilheight)\n\t    silhouette &= ~SIL_TOP;\n\t\t\t\n\tif (silhouette == 1)\n\t{\n\t    // bottom sil\n\t    for (x=r1 ; x<=r2 ; x++)\n\t\tif (clipbot[x] == -2)\n\t\t    clipbot[x] = ds->sprbottomclip[x];\n\t}\n\telse if (silhouette == 2)\n\t{\n\t    // top sil\n\t    for (x=r1 ; x<=r2 ; x++)\n\t\tif (cliptop[x] == -2)\n\t\t    cliptop[x] = ds->sprtopclip[x];\n\t}\n\telse if (silhouette == 3)\n\t{\n\t    // both\n\t    for (x=r1 ; x<=r2 ; x++)\n\t    {\n\t\tif (clipbot[x] == -2)\n\t\t    clipbot[x] = ds->sprbottomclip[x];\n\t\tif (cliptop[x] == -2)\n\t\t    cliptop[x] = ds->sprtopclip[x];\n\t    }\n\t}\n\t\t\n    }\n    \n    // killough 3/27/98:\n    // Clip the sprite against deep water and/or fake ceilings.\n    // killough 4/9/98: optimize by adding mh\n    // killough 4/11/98: improve sprite clipping for underwater/fake ceilings\n    // killough 11/98: fix disappearing sprites\n\n    if (spr->heightsec != -1)  // only things in specially marked sectors\n        {\n        fixed_t h,mh;\n        int phs = viewplayer->mo->subsector->sector->heightsec;\n        if ((mh = sectors[spr->heightsec].floorheight) > spr->gz &&\n            (h = centeryfrac - FixedMul(mh-=viewz, spr->scale)) >= 0 &&\n            (h >>= FRACBITS) < viewheight) {\n            if (mh <= 0 || (phs != -1 && viewz > sectors[phs].floorheight))\n            {                          // clip bottom\n                for (x=spr->x1 ; x<=spr->x2 ; x++)\n                if (clipbot[x] == -2 || h < clipbot[x])\n                    clipbot[x] = h;\n            }\n            else                        // clip top\n        if (phs != -1 && viewz <= sectors[phs].floorheight) // killough 11/98\n        for (x=spr->x1 ; x<=spr->x2 ; x++)\n            if (cliptop[x] == -2 || h > cliptop[x])\n        cliptop[x] = h;\n        }\n\n        if ((mh = sectors[spr->heightsec].ceilingheight) < spr->gzt &&\n            (h = centeryfrac - FixedMul(mh-viewz, spr->scale)) >= 0 &&\n            (h >>= FRACBITS) < viewheight) {\n            if (phs != -1 && viewz >= sectors[phs].ceilingheight)\n            {                         // clip bottom\n                for (x=spr->x1 ; x<=spr->x2 ; x++)\n                if (clipbot[x] == -2 || h < clipbot[x])\n                    clipbot[x] = h;\n            }\n            else                       // clip top\n            for (x=spr->x1 ; x<=spr->x2 ; x++)\n                if (cliptop[x] == -2 || h > cliptop[x])\n                cliptop[x] = h;\n        }\n        }\n    // killough 3/27/98: end special clipping for deep water / fake ceilings\n\n    // all clipping has been performed, so draw the sprite\n\n    // check for unclipped columns\n    for (x = spr->x1 ; x<=spr->x2 ; x++)\n    {\n\tif (clipbot[x] == -2)\t\t\n\t    clipbot[x] = viewheight;\n\n\tif (cliptop[x] == -2)\n\t    cliptop[x] = -1;\n    }\n\t\t\n    mfloorclip = clipbot;\n    mceilingclip = cliptop;\n    R_DrawVisSprite (spr, spr->x1, spr->x2);\n}\n\n\n\n\n//\n// R_DrawMasked\n//\nvoid R_DrawMasked (void)\n{\n    vissprite_t*\tspr;\n    drawseg_t*\t\tds;\n\t\n    R_SortVisSprites ();\n\n    if (vissprite_p > vissprites)\n    {\n\t// draw all vissprites back to front\n#ifdef HAVE_QSORT\n\tfor (spr = vissprites;\n\t     spr < vissprite_p;\n\t     spr++)\n#else\n\tfor (spr = vsprsortedhead.next ;\n\t     spr != &vsprsortedhead ;\n\t     spr=spr->next)\n#endif\n\t{\n\t    \n\t    R_DrawSprite (spr);\n\t}\n    }\n    \n    // render any remaining masked mid textures\n    for (ds=ds_p-1 ; ds >= drawsegs ; ds--)\n\tif (ds->maskedtexturecol)\n\t    R_RenderMaskedSegRange (ds, ds->x1, ds->x2);\n    \n    // if (crispy->cleanscreenshot == 2)\n    //     return;\n\n    // draw the psprites on top of everything\n    //  but does not draw on side views\n    if (!viewangleoffset)\t\t\n\tR_DrawPlayerSprites ();\n}\n\n\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:  none\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"i_sound.h\"\n#include \"i_system.h\"\n\n#include \"deh_str.h\"\n\n#include \"doomstat.h\"\n#include \"doomtype.h\"\n\n#include \"sounds.h\"\n#include \"s_sound.h\"\n\n#include \"m_misc.h\"\n#include \"m_random.h\"\n#include \"m_argv.h\"\n\n#include \"p_local.h\"\n#include \"w_wad.h\"\n#include \"z_zone.h\"\n\n// when to clip out sounds\n// Does not fit the large outdoor areas.\n\n#define S_CLIPPING_DIST (1200 * FRACUNIT)\n\n// Distance tp origin when sounds should be maxed out.\n// This should relate to movement clipping resolution\n// (see BLOCKMAP handling).\n// In the source code release: (160*FRACUNIT).  Changed back to the\n// Vanilla value of 200 (why was this changed?)\n\n#define S_CLOSE_DIST (200 * FRACUNIT)\n\n// The range over which sound attenuates\n\n#define S_ATTENUATOR ((S_CLIPPING_DIST - S_CLOSE_DIST) >> FRACBITS)\n\n// Stereo separation\n\n#define S_STEREO_SWING (96 * FRACUNIT)\n\n#define NORM_PRIORITY 64\n#define NORM_SEP 128\n\ntypedef struct\n{\n    // sound information (if null, channel avail.)\n    sfxinfo_t *sfxinfo;\n\n    // origin of sound\n    mobj_t *origin;\n\n    // handle of the sound being played\n    int handle;\n\n    int pitch;\n\n} channel_t;\n\n// The set of channels available\n\nstatic channel_t *channels;\n\n// Maximum volume of a sound effect.\n// Internal default is max out of 0-15.\n\nint sfxVolume = 8;\n\n// Maximum volume of music.\n\nint musicVolume = 8;\n\n// Internal volume level, ranging from 0-127\n\nstatic int snd_SfxVolume;\n\n// Whether songs are mus_paused\n\nstatic boolean mus_paused;\n\n// Music currently being played\n\nstatic musicinfo_t *mus_playing = NULL;\n\n// Number of channels to use\n\nint snd_channels = 8;\n\n//\n// Initializes sound stuff, including volume\n// Sets channels, SFX and music volume,\n//  allocates channel buffer, sets S_sfx lookup.\n//\n\nvoid S_Init(int sfxVolume, int musicVolume)\n{\n    int i;\n\n    if (gameversion == exe_doom_1_666)\n    {\n        if (logical_gamemission == doom)\n        {\n            I_SetOPLDriverVer(opl_doom1_1_666);\n        }\n        else\n        {\n            I_SetOPLDriverVer(opl_doom2_1_666);\n        }\n    }\n    else\n    {\n        I_SetOPLDriverVer(opl_doom_1_9);\n    }\n\n    I_PrecacheSounds(S_sfx, NUMSFX);\n\n    S_SetSfxVolume(sfxVolume);\n    S_SetMusicVolume(musicVolume);\n\n    // Allocating the internal channels for mixing\n    // (the maximum numer of sounds rendered\n    // simultaneously) within zone memory.\n    channels = Z_Malloc(snd_channels*sizeof(channel_t), PU_STATIC, 0);\n\n    // Free all channels for use\n    for (i=0 ; i<snd_channels ; i++)\n    {\n        channels[i].sfxinfo = 0;\n    }\n\n    // no sounds are playing, and they are not mus_paused\n    mus_paused = 0;\n\n    // Note that sounds have not been cached (yet).\n    for (i=1 ; i<NUMSFX ; i++)\n    {\n        S_sfx[i].lumpnum = S_sfx[i].usefulness = -1;\n    }\n\n    // Doom defaults to pitch-shifting off.\n    if (snd_pitchshift == -1)\n    {\n        snd_pitchshift = 0;\n    }\n\n    I_AtExit(S_Shutdown, true);\n}\n\nvoid S_Shutdown(void)\n{\n    I_ShutdownSound();\n    I_ShutdownMusic();\n}\n\nstatic void S_StopChannel(int cnum)\n{\n    int i;\n    channel_t *c;\n\n    c = &channels[cnum];\n\n    if (c->sfxinfo)\n    {\n        // stop the sound playing\n\n        if (I_SoundIsPlaying(c->handle))\n        {\n            I_StopSound(c->handle);\n        }\n\n        // check to see if other channels are playing the sound\n\n        for (i=0; i<snd_channels; i++)\n        {\n            if (cnum != i && c->sfxinfo == channels[i].sfxinfo)\n            {\n                break;\n            }\n        }\n\n        // degrade usefulness of sound data\n\n        c->sfxinfo->usefulness--;\n        c->sfxinfo = NULL;\n        c->origin = NULL;\n    }\n}\n\n//\n// Per level startup code.\n// Kills playing sounds at start of level,\n//  determines music if any, changes music.\n//\n\nvoid S_Start(void)\n{\n    int cnum;\n    int mnum;\n\n    // kill all playing sounds at start of level\n    //  (trust me - a good idea)\n    for (cnum=0 ; cnum<snd_channels ; cnum++)\n    {\n        if (channels[cnum].sfxinfo)\n        {\n            S_StopChannel(cnum);\n        }\n    }\n\n    // start new music for the level\n    mus_paused = 0;\n\n    if (gamemode == commercial)\n    {\n        const int nmus[] =\n        {\n            mus_messag,\n            mus_ddtblu,\n            mus_doom,\n            mus_shawn,\n            mus_in_cit,\n            mus_the_da,\n            mus_in_cit,\n            mus_shawn2,\n            mus_ddtbl2,\n        };\n\n        if ((gameepisode == 2 || gamemission == pack_nerve) &&\n            gamemap <= arrlen(nmus))\n        {\n            mnum = nmus[gamemap - 1];\n        }\n        else\n        mnum = mus_runnin + gamemap - 1;\n    }\n    else\n    {\n        int spmus[]=\n        {\n            // Song - Who? - Where?\n\n            mus_e3m4,        // American     e4m1\n            mus_e3m2,        // Romero       e4m2\n            mus_e3m3,        // Shawn        e4m3\n            mus_e1m5,        // American     e4m4\n            mus_e2m7,        // Tim          e4m5\n            mus_e2m4,        // Romero       e4m6\n            mus_e2m6,        // J.Anderson   e4m7 CHIRON.WAD\n            mus_e2m5,        // Shawn        e4m8\n            mus_e1m9,        // Tim          e4m9\n        };\n\n        if (gameepisode < 4)\n        {\n            mnum = mus_e1m1 + (gameepisode-1)*9 + gamemap-1;\n        }\n        else\n        {\n            mnum = spmus[gamemap-1];\n        }\n    }\n\n    S_ChangeMusic(mnum, true);\n}\n\nvoid S_StopSound(mobj_t *origin)\n{\n    int cnum;\n\n    for (cnum=0 ; cnum<snd_channels ; cnum++)\n    {\n        if (channels[cnum].sfxinfo && channels[cnum].origin == origin)\n        {\n            S_StopChannel(cnum);\n            break;\n        }\n    }\n}\n\n//\n// S_GetChannel :\n//   If none available, return -1.  Otherwise channel #.\n//\n\nstatic int S_GetChannel(mobj_t *origin, sfxinfo_t *sfxinfo)\n{\n    // channel number to use\n    int                cnum;\n\n    channel_t*        c;\n\n    // Find an open channel\n    for (cnum=0 ; cnum<snd_channels ; cnum++)\n    {\n        if (!channels[cnum].sfxinfo)\n        {\n            break;\n        }\n        else if (origin && channels[cnum].origin == origin)\n        {\n            S_StopChannel(cnum);\n            break;\n        }\n    }\n\n    // None available\n    if (cnum == snd_channels)\n    {\n        // Look for lower priority\n        for (cnum=0 ; cnum<snd_channels ; cnum++)\n        {\n            if (channels[cnum].sfxinfo->priority >= sfxinfo->priority)\n            {\n                break;\n            }\n        }\n\n        if (cnum == snd_channels)\n        {\n            // FUCK!  No lower priority.  Sorry, Charlie.\n            return -1;\n        }\n        else\n        {\n            // Otherwise, kick out lower priority.\n            S_StopChannel(cnum);\n        }\n    }\n\n    c = &channels[cnum];\n\n    // channel is decided to be cnum.\n    c->sfxinfo = sfxinfo;\n    c->origin = origin;\n\n    return cnum;\n}\n\n//\n// Changes volume and stereo-separation variables\n//  from the norm of a sound effect to be played.\n// If the sound is not audible, returns a 0.\n// Otherwise, modifies parameters and returns 1.\n//\n\nstatic int S_AdjustSoundParams(mobj_t *listener, mobj_t *source,\n                               int *vol, int *sep)\n{\n    fixed_t        approx_dist;\n    fixed_t        adx;\n    fixed_t        ady;\n    angle_t        angle;\n\n    // calculate the distance to sound origin\n    //  and clip it if necessary\n    adx = abs(listener->x - source->x);\n    ady = abs(listener->y - source->y);\n\n    // From _GG1_ p.428. Appox. eucledian distance fast.\n    approx_dist = adx + ady - ((adx < ady ? adx : ady)>>1);\n\n    if (gamemap != 8 && approx_dist > S_CLIPPING_DIST)\n    {\n        return 0;\n    }\n\n    // angle of source to listener\n    angle = R_PointToAngle2(listener->x,\n                            listener->y,\n                            source->x,\n                            source->y);\n\n    if (angle > listener->angle)\n    {\n        angle = angle - listener->angle;\n    }\n    else\n    {\n        angle = angle + (0xffffffff - listener->angle);\n    }\n\n    angle >>= ANGLETOFINESHIFT;\n\n    // stereo separation\n    *sep = 128 - (FixedMul(S_STEREO_SWING, finesine[angle]) >> FRACBITS);\n\n    // volume calculation\n    if (approx_dist < S_CLOSE_DIST)\n    {\n        *vol = snd_SfxVolume;\n    }\n    else if (gamemap == 8)\n    {\n        if (approx_dist > S_CLIPPING_DIST)\n        {\n            approx_dist = S_CLIPPING_DIST;\n        }\n\n        *vol = 15+ ((snd_SfxVolume-15)\n                    *((S_CLIPPING_DIST - approx_dist)>>FRACBITS))\n            / S_ATTENUATOR;\n    }\n    else\n    {\n        // distance effect\n        *vol = (snd_SfxVolume\n                * ((S_CLIPPING_DIST - approx_dist)>>FRACBITS))\n            / S_ATTENUATOR;\n    }\n\n    return (*vol > 0);\n}\n\n// clamp supplied integer to the range 0 <= x <= 255.\n\nstatic int Clamp(int x)\n{\n    if (x < 0)\n    {\n        return 0;\n    }\n    else if (x > 255)\n    {\n        return 255;\n    }\n    return x;\n}\n\nvoid S_StartSound(void *origin_p, int sfx_id)\n{\n    sfxinfo_t *sfx;\n    mobj_t *origin;\n    int rc;\n    int sep;\n    int pitch;\n    int cnum;\n    int volume;\n\n    origin = (mobj_t *) origin_p;\n    volume = snd_SfxVolume;\n\n    // check for bogus sound #\n    if (sfx_id < 1 || sfx_id > NUMSFX)\n    {\n        I_Error(\"Bad sfx #: %d\", sfx_id);\n    }\n\n    sfx = &S_sfx[sfx_id];\n\n    // Initialize sound parameters\n    pitch = NORM_PITCH;\n    if (sfx->link)\n    {\n        volume += sfx->volume;\n        pitch = sfx->pitch;\n\n        if (volume < 1)\n        {\n            return;\n        }\n\n        if (volume > snd_SfxVolume)\n        {\n            volume = snd_SfxVolume;\n        }\n    }\n\n\n    // Check to see if it is audible,\n    //  and if not, modify the params\n    if (origin && origin != players[consoleplayer].mo)\n    {\n        rc = S_AdjustSoundParams(players[consoleplayer].mo,\n                                 origin,\n                                 &volume,\n                                 &sep);\n\n        if (origin->x == players[consoleplayer].mo->x\n         && origin->y == players[consoleplayer].mo->y)\n        {\n            sep = NORM_SEP;\n        }\n\n        if (!rc)\n        {\n            return;\n        }\n    }\n    else\n    {\n        sep = NORM_SEP;\n    }\n\n    // hacks to vary the sfx pitches\n    if (sfx_id >= sfx_sawup && sfx_id <= sfx_sawhit)\n    {\n        pitch += 8 - (M_Random()&15);\n    }\n    else if (sfx_id != sfx_itemup && sfx_id != sfx_tink)\n    {\n        pitch += 16 - (M_Random()&31);\n    }\n    pitch = Clamp(pitch);\n\n    // kill old sound\n    S_StopSound(origin);\n\n    // try to find a channel\n    cnum = S_GetChannel(origin, sfx);\n\n    if (cnum < 0)\n    {\n        return;\n    }\n\n    // increase the usefulness\n    if (sfx->usefulness++ < 0)\n    {\n        sfx->usefulness = 1;\n    }\n\n    if (sfx->lumpnum < 0)\n    {\n        sfx->lumpnum = I_GetSfxLumpNum(sfx);\n    }\n\n    channels[cnum].pitch = pitch;\n    channels[cnum].handle = I_StartSound(sfx, cnum, volume, sep, channels[cnum].pitch);\n}\n\nvoid S_StartSoundOnce (void *origin_p, int sfx_id)\n{\n    int cnum;\n    const sfxinfo_t *const sfx = &S_sfx[sfx_id];\n\n    for (cnum = 0; cnum < snd_channels; cnum++)\n    {\n        if (channels[cnum].sfxinfo == sfx &&\n            channels[cnum].origin == origin_p)\n        {\n            return;\n        }\n    }\n\n    S_StartSound(origin_p, sfx_id);\n}\n\n//\n// Stop and resume music, during game PAUSE.\n//\n\nvoid S_PauseSound(void)\n{\n    if (mus_playing && !mus_paused)\n    {\n        I_PauseSong();\n        mus_paused = true;\n    }\n}\n\nvoid S_ResumeSound(void)\n{\n    if (mus_playing && mus_paused)\n    {\n        I_ResumeSong();\n        mus_paused = false;\n    }\n}\n\n//\n// Updates music & sounds\n//\n\nvoid S_UpdateSounds(mobj_t *listener)\n{\n    int                audible;\n    int                cnum;\n    int                volume;\n    int                sep;\n    sfxinfo_t*        sfx;\n    channel_t*        c;\n\n    I_UpdateSound();\n\n    for (cnum=0; cnum<snd_channels; cnum++)\n    {\n        c = &channels[cnum];\n        sfx = c->sfxinfo;\n\n        if (c->sfxinfo)\n        {\n            if (I_SoundIsPlaying(c->handle))\n            {\n                // initialize parameters\n                volume = snd_SfxVolume;\n                sep = NORM_SEP;\n\n                if (sfx->link)\n                {\n                    volume += sfx->volume;\n                    if (volume < 1)\n                    {\n                        S_StopChannel(cnum);\n                        continue;\n                    }\n                    else if (volume > snd_SfxVolume)\n                    {\n                        volume = snd_SfxVolume;\n                    }\n                }\n\n                // check non-local sounds for distance clipping\n                //  or modify their params\n                if (c->origin && listener != c->origin)\n                {\n                    audible = S_AdjustSoundParams(listener,\n                                                  c->origin,\n                                                  &volume,\n                                                  &sep);\n\n                    if (!audible)\n                    {\n                        S_StopChannel(cnum);\n                    }\n                    else\n                    {\n                        I_UpdateSoundParams(c->handle, volume, sep);\n                    }\n                }\n            }\n            else\n            {\n                // if channel is allocated but sound has stopped,\n                //  free it\n                S_StopChannel(cnum);\n            }\n        }\n    }\n}\n\nvoid S_SetMusicVolume(int volume)\n{\n    if (volume < 0 || volume > 127)\n    {\n        I_Error(\"Attempt to set music volume at %d\",\n                volume);\n    }\n\n    I_SetMusicVolume(volume);\n}\n\nvoid S_SetSfxVolume(int volume)\n{\n    if (volume < 0 || volume > 127)\n    {\n        I_Error(\"Attempt to set sfx volume at %d\", volume);\n    }\n\n    snd_SfxVolume = volume;\n}\n\n//\n// Starts some music with the music id found in sounds.h.\n//\n\nvoid S_StartMusic(int m_id)\n{\n    S_ChangeMusic(m_id, false);\n}\n\nvoid S_ChangeMusic(int musicnum, int looping)\n{\n    musicinfo_t *music = NULL;\n    char namebuf[9];\n    void *handle;\n\n    // The Doom IWAD file has two versions of the intro music: d_intro\n    // and d_introa.  The latter is used for OPL playback.\n\n    if (musicnum == mus_intro && (snd_musicdevice == SNDDEVICE_ADLIB\n                               || snd_musicdevice == SNDDEVICE_SB\n                               || snd_musicdevice == SNDDEVICE_WEBAUDIO))\n    {\n        musicnum = mus_introa;\n    }\n\n    if (musicnum <= mus_None || musicnum >= NUMMUSIC)\n    {\n        I_Error(\"Bad music number %d\", musicnum);\n    }\n    else\n    {\n        music = &S_music[musicnum];\n    }\n\n    if (mus_playing == music)\n    {\n        return;\n    }\n\n    // shutdown old music\n    S_StopMusic();\n\n    // get lumpnum if neccessary\n    if (!music->lumpnum)\n    {\n        M_snprintf(namebuf, sizeof(namebuf), \"d_%s\", DEH_String(music->name));\n        music->lumpnum = W_GetNumForName(namebuf);\n    }\n\n    music->data = W_CacheLumpNum(music->lumpnum, PU_STATIC);\n\n    handle = I_RegisterSong(music->data, W_LumpLength(music->lumpnum));\n    music->handle = handle;\n    I_PlaySong(handle, looping);\n\n    mus_playing = music;\n}\n\nboolean S_MusicPlaying(void)\n{\n    return I_MusicIsPlaying();\n}\n\nvoid S_StopMusic(void)\n{\n    if (mus_playing)\n    {\n        if (mus_paused)\n        {\n            I_ResumeSong();\n        }\n\n        I_StopSong();\n        I_UnRegisterSong(mus_playing->handle);\n        W_ReleaseLumpNum(mus_playing->lumpnum);\n        mus_playing->data = NULL;\n        mus_playing = NULL;\n    }\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tThe status bar widget code.\n//\n\n\n#include <stdio.h>\n#include <ctype.h>\n\n#include \"deh_main.h\"\n#include \"doomdef.h\"\n\n#include \"z_zone.h\"\n#include \"v_video.h\"\n\n#include \"i_swap.h\"\n#include \"i_system.h\"\n\n#include \"w_wad.h\"\n\n#include \"st_stuff.h\"\n#include \"st_lib.h\"\n#include \"r_local.h\"\n\n#include \"i_video.h\"\n\n\n// in AM_map.c\nextern boolean\t\tautomapactive; \n\n\n\n\n//\n// Hack display negative frags.\n//  Loads and store the stminus lump.\n//\npatch_t*\t\tsttminus;\n\nvoid STlib_init(void)\n{\n    sttminus = (patch_t *) W_CacheLumpName(DEH_String(\"STTMINUS\"), PU_STATIC);\n}\n\n\n// ?\nvoid\nSTlib_initNum\n( st_number_t*\t\tn,\n  int\t\t\tx,\n  int\t\t\ty,\n  patch_t**\t\tpl,\n  int*\t\t\tnum,\n  boolean*\t\ton,\n  int\t\t\twidth )\n{\n    n->x\t= x;\n    n->y\t= y;\n    n->oldnum\t= 0;\n    n->width\t= width;\n    n->num\t= num;\n    n->on\t= on;\n    n->p\t= pl;\n}\n\n\n// \n// A fairly efficient way to draw a number\n//  based on differences from the old number.\n// Note: worth the trouble?\n//\nvoid\nSTlib_drawNum\n( st_number_t*\tn,\n  boolean\trefresh )\n{\n\n    int\t\tnumdigits = n->width;\n    int\t\tnum = *n->num;\n    \n    int\t\tw = SHORT(n->p[0]->width);\n    int\t\th = SHORT(n->p[0]->height);\n    int\t\tx = n->x;\n    \n    int\t\tneg;\n\n    n->oldnum = *n->num;\n\n    neg = num < 0;\n\n    if (neg)\n    {\n\tif (numdigits == 2 && num < -9)\n\t    num = -9;\n\telse if (numdigits == 3 && num < -99)\n\t    num = -99;\n\t\n\tnum = -num;\n    }\n\n    // clear the area\n    x = n->x - numdigits*w;\n\n    if (n->y - ST_Y < 0)\n\tI_Error(\"drawNum: n->y - ST_Y < 0\");\n\n    V_CopyRect(x, n->y - ST_Y, st_backing_screen, w*numdigits, h, x, n->y);\n\n    // if non-number, do not draw it\n    if (num == 1994)\n\treturn;\n\n    x = n->x;\n\n    // in the special case of 0, you draw 0\n    if (!num)\n\tV_DrawPatch(x - w, n->y, n->p[ 0 ]);\n\n    // draw the new number\n    while (num && numdigits--)\n    {\n\tx -= w;\n\tV_DrawPatch(x, n->y, n->p[ num % 10 ]);\n\tnum /= 10;\n    }\n\n    // draw a minus sign if necessary\n    if (neg)\n\tV_DrawPatch(x - 8, n->y, sttminus);\n}\n\n\n//\nvoid\nSTlib_updateNum\n( st_number_t*\t\tn,\n  boolean\t\trefresh )\n{\n    if (*n->on) STlib_drawNum(n, refresh);\n}\n\n\n//\nvoid\nSTlib_initPercent\n( st_percent_t*\t\tp,\n  int\t\t\tx,\n  int\t\t\ty,\n  patch_t**\t\tpl,\n  int*\t\t\tnum,\n  boolean*\t\ton,\n  patch_t*\t\tpercent )\n{\n    STlib_initNum(&p->n, x, y, pl, num, on, 3);\n    p->p = percent;\n}\n\n\n\n\nvoid\nSTlib_updatePercent\n( st_percent_t*\t\tper,\n  int\t\t\trefresh )\n{\n    if (refresh && *per->n.on)\n\tV_DrawPatch(per->n.x, per->n.y, per->p);\n    \n    STlib_updateNum(&per->n, refresh);\n}\n\n\n\nvoid\nSTlib_initMultIcon\n( st_multicon_t*\ti,\n  int\t\t\tx,\n  int\t\t\ty,\n  patch_t**\t\til,\n  int*\t\t\tinum,\n  boolean*\t\ton )\n{\n    i->x\t= x;\n    i->y\t= y;\n    i->oldinum \t= -1;\n    i->inum\t= inum;\n    i->on\t= on;\n    i->p\t= il;\n}\n\n\n\nvoid\nSTlib_updateMultIcon\n( st_multicon_t*\tmi,\n  boolean\t\trefresh )\n{\n    int\t\t\tw;\n    int\t\t\th;\n    int\t\t\tx;\n    int\t\t\ty;\n\n    if (*mi->on\n\t&& (mi->oldinum != *mi->inum || refresh)\n\t&& (*mi->inum!=-1))\n    {\n\tif (mi->oldinum != -1)\n\t{\n\t    x = mi->x - SHORT(mi->p[mi->oldinum]->leftoffset);\n\t    y = mi->y - SHORT(mi->p[mi->oldinum]->topoffset);\n\t    w = SHORT(mi->p[mi->oldinum]->width);\n\t    h = SHORT(mi->p[mi->oldinum]->height);\n\n\t    if (y - ST_Y < 0)\n\t\tI_Error(\"updateMultIcon: y - ST_Y < 0\");\n\n\t    V_CopyRect(x, y-ST_Y, st_backing_screen, w, h, x, y);\n\t}\n\tV_DrawPatch(mi->x, mi->y, mi->p[*mi->inum]);\n\tmi->oldinum = *mi->inum;\n    }\n}\n\n\n\nvoid\nSTlib_initBinIcon\n( st_binicon_t*\t\tb,\n  int\t\t\tx,\n  int\t\t\ty,\n  patch_t*\t\ti,\n  boolean*\t\tval,\n  boolean*\t\ton )\n{\n    b->x\t= x;\n    b->y\t= y;\n    b->oldval\t= false;\n    b->val\t= val;\n    b->on\t= on;\n    b->p\t= i;\n}\n\n\n\nvoid\nSTlib_updateBinIcon\n( st_binicon_t*\t\tbi,\n  boolean\t\trefresh )\n{\n    int\t\t\tx;\n    int\t\t\ty;\n    int\t\t\tw;\n    int\t\t\th;\n\n    if (*bi->on\n     && (bi->oldval != *bi->val || refresh))\n    {\n\tx = bi->x - SHORT(bi->p->leftoffset);\n\ty = bi->y - SHORT(bi->p->topoffset);\n\tw = SHORT(bi->p->width);\n\th = SHORT(bi->p->height);\n\n\tif (y - ST_Y < 0)\n\t    I_Error(\"updateBinIcon: y - ST_Y < 0\");\n\n\tif (*bi->val)\n\t    V_DrawPatch(bi->x, bi->y, bi->p);\n\telse\n\t    V_CopyRect(x, y-ST_Y, st_backing_screen, w, h, x, y);\n\n\tbi->oldval = *bi->val;\n    }\n\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tStatus bar code.\n//\tDoes the face/direction indicator animatin.\n//\tDoes palette indicators as well (red pain/berserk, bright pickup)\n//\n\n\n\n#include <stdio.h>\n\n#include \"i_system.h\"\n#include \"i_video.h\"\n#include \"z_zone.h\"\n#include \"m_misc.h\"\n#include \"m_random.h\"\n#include \"w_wad.h\"\n\n#include \"deh_main.h\"\n#include \"deh_misc.h\"\n#include \"doomdef.h\"\n#include \"doomkeys.h\"\n\n#include \"g_game.h\"\n\n#include \"st_stuff.h\"\n#include \"st_lib.h\"\n#include \"r_local.h\"\n\n#include \"p_local.h\"\n#include \"p_inter.h\"\n\n#include \"am_map.h\"\n#include \"m_cheat.h\"\n\n#include \"s_sound.h\"\n\n// Needs access to LFB.\n#include \"v_video.h\"\n\n// State.\n#include \"doomstat.h\"\n\n// Data.\n#include \"dstrings.h\"\n#include \"sounds.h\"\n\n//\n// STATUS BAR DATA\n//\n\n\n// Palette indices.\n// For damage/bonus red-/gold-shifts\n#define STARTREDPALS\t\t1\n#define STARTBONUSPALS\t\t9\n#define NUMREDPALS\t\t\t8\n#define NUMBONUSPALS\t\t4\n// Radiation suit, green shift.\n#define RADIATIONPAL\t\t13\n\n// N/256*100% probability\n//  that the normal face state will change\n#define ST_FACEPROBABILITY\t\t96\n\n// For Responder\n#define ST_TOGGLECHAT\t\tKEY_ENTER\n\n// Location of status bar\n#define ST_X\t\t\t\t0\n#define ST_X2\t\t\t\t104\n\n#define ST_FX  \t\t\t143\n#define ST_FY  \t\t\t169\n\n// Should be set to patch width\n//  for tall numbers later on\n#define ST_TALLNUMWIDTH\t\t(tallnum[0]->width)\n\n// Number of status faces.\n#define ST_NUMPAINFACES\t\t5\n#define ST_NUMSTRAIGHTFACES\t3\n#define ST_NUMTURNFACES\t\t2\n#define ST_NUMSPECIALFACES\t\t3\n\n#define ST_FACESTRIDE \\\n          (ST_NUMSTRAIGHTFACES+ST_NUMTURNFACES+ST_NUMSPECIALFACES)\n\n#define ST_NUMEXTRAFACES\t\t2\n\n#define ST_NUMFACES \\\n          (ST_FACESTRIDE*ST_NUMPAINFACES+ST_NUMEXTRAFACES)\n\n#define ST_TURNOFFSET\t\t(ST_NUMSTRAIGHTFACES)\n#define ST_OUCHOFFSET\t\t(ST_TURNOFFSET + ST_NUMTURNFACES)\n#define ST_EVILGRINOFFSET\t\t(ST_OUCHOFFSET + 1)\n#define ST_RAMPAGEOFFSET\t\t(ST_EVILGRINOFFSET + 1)\n#define ST_GODFACE\t\t\t(ST_NUMPAINFACES*ST_FACESTRIDE)\n#define ST_DEADFACE\t\t\t(ST_GODFACE+1)\n\n#define ST_FACESX\t\t\t143\n#define ST_FACESY\t\t\t168\n\n#define ST_EVILGRINCOUNT\t\t(2*TICRATE)\n#define ST_STRAIGHTFACECOUNT\t(TICRATE/2)\n#define ST_TURNCOUNT\t\t(1*TICRATE)\n#define ST_OUCHCOUNT\t\t(1*TICRATE)\n#define ST_RAMPAGEDELAY\t\t(2*TICRATE)\n\n#define ST_MUCHPAIN\t\t\t20\n\n\n// Location and size of statistics,\n//  justified according to widget type.\n// Problem is, within which space? STbar? Screen?\n// Note: this could be read in by a lump.\n//       Problem is, is the stuff rendered\n//       into a buffer,\n//       or into the frame buffer?\n\n// AMMO number pos.\n#define ST_AMMOWIDTH\t\t3\t\n#define ST_AMMOX\t\t\t44\n#define ST_AMMOY\t\t\t171\n\n// HEALTH number pos.\n#define ST_HEALTHWIDTH\t\t3\t\n#define ST_HEALTHX\t\t\t90\n#define ST_HEALTHY\t\t\t171\n\n// Weapon pos.\n#define ST_ARMSX\t\t\t111\n#define ST_ARMSY\t\t\t172\n#define ST_ARMSBGX\t\t\t104\n#define ST_ARMSBGY\t\t\t168\n#define ST_ARMSXSPACE\t\t12\n#define ST_ARMSYSPACE\t\t10\n\n// Frags pos.\n#define ST_FRAGSX\t\t\t138\n#define ST_FRAGSY\t\t\t171\t\n#define ST_FRAGSWIDTH\t\t2\n\n// ARMOR number pos.\n#define ST_ARMORWIDTH\t\t3\n#define ST_ARMORX\t\t\t221\n#define ST_ARMORY\t\t\t171\n\n// Key icon positions.\n#define ST_KEY0WIDTH\t\t8\n#define ST_KEY0HEIGHT\t\t5\n#define ST_KEY0X\t\t\t239\n#define ST_KEY0Y\t\t\t171\n#define ST_KEY1WIDTH\t\tST_KEY0WIDTH\n#define ST_KEY1X\t\t\t239\n#define ST_KEY1Y\t\t\t181\n#define ST_KEY2WIDTH\t\tST_KEY0WIDTH\n#define ST_KEY2X\t\t\t239\n#define ST_KEY2Y\t\t\t191\n\n// Ammunition counter.\n#define ST_AMMO0WIDTH\t\t3\n#define ST_AMMO0HEIGHT\t\t6\n#define ST_AMMO0X\t\t\t288\n#define ST_AMMO0Y\t\t\t173\n#define ST_AMMO1WIDTH\t\tST_AMMO0WIDTH\n#define ST_AMMO1X\t\t\t288\n#define ST_AMMO1Y\t\t\t179\n#define ST_AMMO2WIDTH\t\tST_AMMO0WIDTH\n#define ST_AMMO2X\t\t\t288\n#define ST_AMMO2Y\t\t\t191\n#define ST_AMMO3WIDTH\t\tST_AMMO0WIDTH\n#define ST_AMMO3X\t\t\t288\n#define ST_AMMO3Y\t\t\t185\n\n// Indicate maximum ammunition.\n// Only needed because backpack exists.\n#define ST_MAXAMMO0WIDTH\t\t3\n#define ST_MAXAMMO0HEIGHT\t\t5\n#define ST_MAXAMMO0X\t\t314\n#define ST_MAXAMMO0Y\t\t173\n#define ST_MAXAMMO1WIDTH\t\tST_MAXAMMO0WIDTH\n#define ST_MAXAMMO1X\t\t314\n#define ST_MAXAMMO1Y\t\t179\n#define ST_MAXAMMO2WIDTH\t\tST_MAXAMMO0WIDTH\n#define ST_MAXAMMO2X\t\t314\n#define ST_MAXAMMO2Y\t\t191\n#define ST_MAXAMMO3WIDTH\t\tST_MAXAMMO0WIDTH\n#define ST_MAXAMMO3X\t\t314\n#define ST_MAXAMMO3Y\t\t185\n\n// pistol\n#define ST_WEAPON0X\t\t\t110 \n#define ST_WEAPON0Y\t\t\t172\n\n// shotgun\n#define ST_WEAPON1X\t\t\t122 \n#define ST_WEAPON1Y\t\t\t172\n\n// chain gun\n#define ST_WEAPON2X\t\t\t134 \n#define ST_WEAPON2Y\t\t\t172\n\n// missile launcher\n#define ST_WEAPON3X\t\t\t110 \n#define ST_WEAPON3Y\t\t\t181\n\n// plasma gun\n#define ST_WEAPON4X\t\t\t122 \n#define ST_WEAPON4Y\t\t\t181\n\n // bfg\n#define ST_WEAPON5X\t\t\t134\n#define ST_WEAPON5Y\t\t\t181\n\n// WPNS title\n#define ST_WPNSX\t\t\t109 \n#define ST_WPNSY\t\t\t191\n\n // DETH title\n#define ST_DETHX\t\t\t109\n#define ST_DETHY\t\t\t191\n\n//Incoming messages window location\n//UNUSED\n// #define ST_MSGTEXTX\t   (viewwindowx)\n// #define ST_MSGTEXTY\t   (viewwindowy+viewheight-18)\n#define ST_MSGTEXTX\t\t\t0\n#define ST_MSGTEXTY\t\t\t0\n// Dimensions given in characters.\n#define ST_MSGWIDTH\t\t\t52\n// Or shall I say, in lines?\n#define ST_MSGHEIGHT\t\t1\n\n#define ST_OUTTEXTX\t\t\t0\n#define ST_OUTTEXTY\t\t\t6\n\n// Width, in characters again.\n#define ST_OUTWIDTH\t\t\t52 \n // Height, in lines. \n#define ST_OUTHEIGHT\t\t1\n\n#define ST_MAPTITLEX \\\n    (SCREENWIDTH - ST_MAPWIDTH * ST_CHATFONTWIDTH)\n\n#define ST_MAPTITLEY\t\t0\n#define ST_MAPHEIGHT\t\t1\n\n// Crispy\nextern boolean havee1m10;\n\n// graphics are drawn to a backing screen and blitted to the real screen\npixel_t\t\t\t*st_backing_screen;\n\t    \n// main player in game\nstatic player_t*\tplyr; \n\n// ST_Start() has just been called\nstatic boolean\t\tst_firsttime;\n\n// lump number for PLAYPAL\nstatic int\t\tlu_palette;\n\n// used for timing\nstatic unsigned int\tst_clock;\n\n// used for making messages go away\nstatic int\t\tst_msgcounter=0;\n\n// used when in chat \nstatic st_chatstateenum_t\tst_chatstate;\n\n// whether in automap or first-person\nstatic st_stateenum_t\tst_gamestate;\n\n// whether left-side main status bar is active\nstatic boolean\t\tst_statusbaron;\n\n// whether status bar chat is active\nstatic boolean\t\tst_chat;\n\n// value of st_chat before message popped up\nstatic boolean\t\tst_oldchat;\n\n// whether chat window has the cursor on\nstatic boolean\t\tst_cursoron;\n\n// !deathmatch\nstatic boolean\t\tst_notdeathmatch; \n\n// !deathmatch && st_statusbaron\nstatic boolean\t\tst_armson;\n\n// !deathmatch\nstatic boolean\t\tst_fragson; \n\n// main bar left\nstatic patch_t*\t\tsbar;\n\n// 0-9, tall numbers\nstatic patch_t*\t\ttallnum[10];\n\n// tall % sign\nstatic patch_t*\t\ttallpercent;\n\n// 0-9, short, yellow (,different!) numbers\nstatic patch_t*\t\tshortnum[10];\n\n// 3 key-cards, 3 skulls\nstatic patch_t*\t\tkeys[NUMCARDS]; \n\n// face status patches\nstatic patch_t*\t\tfaces[ST_NUMFACES];\n\n// face background\nstatic patch_t*\t\tfaceback;\n\n // main bar right\nstatic patch_t*\t\tarmsbg;\n\n// weapon ownership patches\nstatic patch_t*\t\tarms[6][2]; \n\n// ready-weapon widget\nstatic st_number_t\tw_ready;\n\n // in deathmatch only, summary of frags stats\nstatic st_number_t\tw_frags;\n\n// health widget\nstatic st_percent_t\tw_health;\n\n// arms background\nstatic st_binicon_t\tw_armsbg; \n\n\n// weapon ownership widgets\nstatic st_multicon_t\tw_arms[6];\n\n// face status widget\nstatic st_multicon_t\tw_faces; \n\n// keycard widgets\nstatic st_multicon_t\tw_keyboxes[3];\n\n// armor widget\nstatic st_percent_t\tw_armor;\n\n// ammo widgets\nstatic st_number_t\tw_ammo[4];\n\n// max ammo widgets\nstatic st_number_t\tw_maxammo[4]; \n\n\n\n // number of frags so far in deathmatch\nstatic int\tst_fragscount;\n\n// used to use appopriately pained face\nstatic int\tst_oldhealth = -1;\n\n// used for evil grin\nstatic boolean\toldweaponsowned[NUMWEAPONS]; \n\n // count until face changes\nstatic int\tst_facecount = 0;\n\n// current face index, used by w_faces\nstatic int\tst_faceindex = 0;\n\n// holds key-type for each key box on bar\nstatic int\tkeyboxes[3]; \n\n// a random number per tick\nstatic int\tst_randomnumber;  \n\ncheatseq_t cheat_mus = CHEAT(\"idmus\", 2);\ncheatseq_t cheat_god = CHEAT(\"iddqd\", 0);\ncheatseq_t cheat_ammo = CHEAT(\"idkfa\", 0);\ncheatseq_t cheat_ammonokey = CHEAT(\"idfa\", 0);\ncheatseq_t cheat_noclip = CHEAT(\"idspispopd\", 0);\ncheatseq_t cheat_commercial_noclip = CHEAT(\"idclip\", 0);\n\ncheatseq_t\tcheat_powerup[7] =\n{\n    CHEAT(\"idbeholdv\", 0),\n    CHEAT(\"idbeholds\", 0),\n    CHEAT(\"idbeholdi\", 0),\n    CHEAT(\"idbeholdr\", 0),\n    CHEAT(\"idbeholda\", 0),\n    CHEAT(\"idbeholdl\", 0),\n    CHEAT(\"idbehold\", 0),\n};\n\ncheatseq_t cheat_choppers = CHEAT(\"idchoppers\", 0);\ncheatseq_t cheat_clev = CHEAT(\"idclev\", 2);\ncheatseq_t cheat_mypos = CHEAT(\"idmypos\", 0);\n\n\n//\n// STATUS BAR CODE\n//\nvoid ST_Stop(void);\n\nvoid ST_refreshBackground(void)\n{\n\n    if (st_statusbaron)\n    {\n        V_UseBuffer(st_backing_screen);\n\n\tV_DrawPatch(ST_X, 0, sbar);\n\n\tif (netgame)\n\t    V_DrawPatch(ST_FX, 0, faceback);\n\n        V_RestoreBuffer();\n\n\tV_CopyRect(ST_X, 0, st_backing_screen, ST_WIDTH, ST_HEIGHT, ST_X, ST_Y);\n    }\n\n}\n\n\n// Respond to keyboard input events,\n//  intercept cheats.\nboolean\nST_Responder (event_t* ev)\n{\n  int\t\ti;\n    \n  // Filter automap on/off.\n  if (ev->type == ev_keyup\n      && ((ev->data1 & 0xffff0000) == AM_MSGHEADER))\n  {\n    switch(ev->data1)\n    {\n      case AM_MSGENTERED:\n\tst_gamestate = AutomapState;\n\tst_firsttime = true;\n\tbreak;\n\t\n      case AM_MSGEXITED:\n\t//\tfprintf(stderr, \"AM exited\\n\");\n\tst_gamestate = FirstPersonState;\n\tbreak;\n    }\n  }\n\n  // if a user keypress...\n  else if (ev->type == ev_keydown)\n  {\n    if (!netgame && gameskill != sk_nightmare)\n    {\n      // 'dqd' cheat for toggleable god mode\n      if (cht_CheckCheat(&cheat_god, ev->data2))\n      {\n\tplyr->cheats ^= CF_GODMODE;\n\tif (plyr->cheats & CF_GODMODE)\n\t{\n\t  if (plyr->mo)\n\t    plyr->mo->health = 100;\n\t  \n\t  plyr->health = deh_god_mode_health;\n\t  plyr->message = DEH_String(STSTR_DQDON);\n\t}\n\telse \n\t  plyr->message = DEH_String(STSTR_DQDOFF);\n      }\n      // 'fa' cheat for killer fucking arsenal\n      else if (cht_CheckCheat(&cheat_ammonokey, ev->data2))\n      {\n\tplyr->armorpoints = deh_idfa_armor;\n\tplyr->armortype = deh_idfa_armor_class;\n\t\n\tfor (i=0;i<NUMWEAPONS;i++)\n\t  plyr->weaponowned[i] = true;\n\t\n\tfor (i=0;i<NUMAMMO;i++)\n\t  plyr->ammo[i] = plyr->maxammo[i];\n\t\n\tplyr->message = DEH_String(STSTR_FAADDED);\n      }\n      // 'kfa' cheat for key full ammo\n      else if (cht_CheckCheat(&cheat_ammo, ev->data2))\n      {\n\tplyr->armorpoints = deh_idkfa_armor;\n\tplyr->armortype = deh_idkfa_armor_class;\n\t\n\tfor (i=0;i<NUMWEAPONS;i++)\n\t  plyr->weaponowned[i] = true;\n\t\n\tfor (i=0;i<NUMAMMO;i++)\n\t  plyr->ammo[i] = plyr->maxammo[i];\n\t\n\tfor (i=0;i<NUMCARDS;i++)\n\t  plyr->cards[i] = true;\n\t\n\tplyr->message = DEH_String(STSTR_KFAADDED);\n      }\n      // 'mus' cheat for changing music\n      else if (cht_CheckCheat(&cheat_mus, ev->data2))\n      {\n\t\n\tchar\tbuf[3];\n\tint\t\tmusnum;\n\t\n\tplyr->message = DEH_String(STSTR_MUS);\n\tcht_GetParam(&cheat_mus, buf);\n\n        // Note: The original v1.9 had a bug that tried to play back\n        // the Doom II music regardless of gamemode.  This was fixed\n        // in the Ultimate Doom executable so that it would work for\n        // the Doom 1 music as well.\n\n\tif (gamemode == commercial || gameversion < exe_ultimate)\n\t{\n\t  musnum = mus_runnin + (buf[0]-'0')*10 + buf[1]-'0' - 1;\n\t  \n\t  if (((buf[0]-'0')*10 + buf[1]-'0') > 35\n       && gameversion >= exe_doom_1_8)\n\t    plyr->message = DEH_String(STSTR_NOMUS);\n\t  else\n\t    S_ChangeMusic(musnum, 1);\n\t}\n\telse\n\t{\n\t  musnum = mus_e1m1 + (buf[0]-'1')*9 + (buf[1]-'1');\n\t  \n\t  if (((buf[0]-'1')*9 + buf[1]-'1') > 31)\n\t    plyr->message = DEH_String(STSTR_NOMUS);\n\t  else\n\t    S_ChangeMusic(musnum, 1);\n\t}\n      }\n      else if ( (logical_gamemission == doom \n                 && cht_CheckCheat(&cheat_noclip, ev->data2))\n             || (logical_gamemission != doom \n                 && cht_CheckCheat(&cheat_commercial_noclip,ev->data2)))\n      {\t\n        // Noclip cheat.\n        // For Doom 1, use the idspipsopd cheat; for all others, use\n        // idclip\n\n\tplyr->cheats ^= CF_NOCLIP;\n\t\n\tif (plyr->cheats & CF_NOCLIP)\n\t  plyr->message = DEH_String(STSTR_NCON);\n\telse\n\t  plyr->message = DEH_String(STSTR_NCOFF);\n      }\n      // 'behold?' power-up cheats\n      for (i=0;i<6;i++)\n      {\n\tif (cht_CheckCheat(&cheat_powerup[i], ev->data2))\n\t{\n\t  if (!plyr->powers[i])\n\t    P_GivePower( plyr, i);\n\t  else if (i!=pw_strength)\n\t    plyr->powers[i] = 1;\n\t  else\n\t    plyr->powers[i] = 0;\n\t  \n\t  plyr->message = DEH_String(STSTR_BEHOLDX);\n\t}\n      }\n      \n      // 'behold' power-up menu\n      if (cht_CheckCheat(&cheat_powerup[6], ev->data2))\n      {\n\tplyr->message = DEH_String(STSTR_BEHOLD);\n      }\n      // 'choppers' invulnerability & chainsaw\n      else if (cht_CheckCheat(&cheat_choppers, ev->data2))\n      {\n\tplyr->weaponowned[wp_chainsaw] = true;\n\tplyr->powers[pw_invulnerability] = true;\n\tplyr->message = DEH_String(STSTR_CHOPPERS);\n      }\n      // 'mypos' for player position\n      else if (cht_CheckCheat(&cheat_mypos, ev->data2))\n      {\n        static char buf[ST_MSGWIDTH];\n        M_snprintf(buf, sizeof(buf), \"ang=0x%x;x,y=(0x%x,0x%x)\",\n                   players[consoleplayer].mo->angle,\n                   players[consoleplayer].mo->x,\n                   players[consoleplayer].mo->y);\n        plyr->message = buf;\n      }\n    }\n    \n    // 'clev' change-level cheat\n    if (!netgame && cht_CheckCheat(&cheat_clev, ev->data2))\n    {\n      char\t\tbuf[3];\n      int\t\tepsd;\n      int\t\tmap;\n      \n      cht_GetParam(&cheat_clev, buf);\n      \n      if (gamemode == commercial)\n      {\n    if (gamemission == pack_nerve)\n\t    epsd = 2;\n\telse\n\tepsd = 0;\n\tmap = (buf[0] - '0')*10 + buf[1] - '0';\n      }\n      else\n      {\n\tepsd = buf[0] - '0';\n\tmap = buf[1] - '0';\n\n        // Chex.exe always warps to episode 1.\n\n        if (gameversion == exe_chex)\n        {\n            if (epsd > 1)\n            {\n                epsd = 1;\n            }\n            if (map > 5)\n            {\n                map = 5;\n            }\n        }\n      }\n\n      // Catch invalid maps.\n      if (gamemode != commercial)\n      {\n          if (epsd < 1)\n          {\n              return false;\n          }\n          if (epsd > 4)\n          {\n              return false;\n          }\n          if (epsd == 4 && gameversion < exe_ultimate)\n          {\n              return false;\n          }\n          // [crispy] IDCLEV00 restarts current map\n          if ((map == 0) && (buf[0] - '0' == 0))\n          {\n              map = gamemap;\n          }\n          // [crispy] support E1M10 \"Sewers\"\n          if ((map == 0) && havee1m10 && epsd == 1)\n          {\n              map = 10;\n          }\n          if (map < 1)\n          {\n              return false;\n          }\n          if (map > 9)\n          {\n              // [crispy] support E1M10 \"Sewers\"\n              if (!(havee1m10 && epsd == 1 && map == 10))\n              return false;\n          }\n      }\n      else\n      {\n          // [crispy] IDCLEV00 restarts current map\n          if ((map == 0) && (buf[0] - '0' == 0))\n          {\n              map = gamemap;\n          }\n          if (map < 1)\n          {\n              return false;\n          }\n          if (map > 40)\n          {\n              return false;\n          }\n          if (map > 9 && gamemission == pack_nerve)\n          {\n              return false;\n          }\n          if (map > 21 && gamemission == pack_master)\n          {\n              return false;\n          }\n      }\n\n      // So be it.\n      plyr->message = DEH_String(STSTR_CLEV);\n      G_DeferedInitNew(gameskill, epsd, map);\n    }\n  }\n  return false;\n}\n\n\n\nint ST_calcPainOffset(void)\n{\n    int\t\thealth;\n    static int\tlastcalc;\n    static int\toldhealth = -1;\n    \n    health = plyr->health > 100 ? 100 : plyr->health;\n\n    if (health != oldhealth)\n    {\n\tlastcalc = ST_FACESTRIDE * (((100 - health) * ST_NUMPAINFACES) / 101);\n\toldhealth = health;\n    }\n    return lastcalc;\n}\n\n\n//\n// This is a not-very-pretty routine which handles\n//  the face states and their timing.\n// the precedence of expressions is:\n//  dead > evil grin > turned head > straight ahead\n//\nvoid ST_updateFaceWidget(void)\n{\n    int\t\ti;\n    angle_t\tbadguyangle;\n    angle_t\tdiffang;\n    static int\tlastattackdown = -1;\n    static int\tpriority = 0;\n    boolean\tdoevilgrin;\n\n    if (priority < 10)\n    {\n\t// dead\n\tif (!plyr->health)\n\t{\n\t    priority = 9;\n\t    st_faceindex = ST_DEADFACE;\n\t    st_facecount = 1;\n\t}\n    }\n\n    if (priority < 9)\n    {\n\tif (plyr->bonuscount)\n\t{\n\t    // picking up bonus\n\t    doevilgrin = false;\n\n\t    for (i=0;i<NUMWEAPONS;i++)\n\t    {\n\t\tif (oldweaponsowned[i] != plyr->weaponowned[i])\n\t\t{\n\t\t    doevilgrin = true;\n\t\t    oldweaponsowned[i] = plyr->weaponowned[i];\n\t\t}\n\t    }\n\t    if (doevilgrin) \n\t    {\n\t\t// evil grin if just picked up weapon\n\t\tpriority = 8;\n\t\tst_facecount = ST_EVILGRINCOUNT;\n\t\tst_faceindex = ST_calcPainOffset() + ST_EVILGRINOFFSET;\n\t    }\n\t}\n\n    }\n  \n    if (priority < 8)\n    {\n\tif (plyr->damagecount\n\t    && plyr->attacker\n\t    && plyr->attacker != plyr->mo)\n\t{\n\t    // being attacked\n\t    priority = 7;\n\t    \n\t    if (plyr->health - st_oldhealth > ST_MUCHPAIN)\n\t    {\n\t\tst_facecount = ST_TURNCOUNT;\n\t\tst_faceindex = ST_calcPainOffset() + ST_OUCHOFFSET;\n\t    }\n\t    else\n\t    {\n\t\tbadguyangle = R_PointToAngle2(plyr->mo->x,\n\t\t\t\t\t      plyr->mo->y,\n\t\t\t\t\t      plyr->attacker->x,\n\t\t\t\t\t      plyr->attacker->y);\n\t\t\n\t\tif (badguyangle > plyr->mo->angle)\n\t\t{\n\t\t    // whether right or left\n\t\t    diffang = badguyangle - plyr->mo->angle;\n\t\t    i = diffang > ANG180; \n\t\t}\n\t\telse\n\t\t{\n\t\t    // whether left or right\n\t\t    diffang = plyr->mo->angle - badguyangle;\n\t\t    i = diffang <= ANG180; \n\t\t} // confusing, aint it?\n\n\t\t\n\t\tst_facecount = ST_TURNCOUNT;\n\t\tst_faceindex = ST_calcPainOffset();\n\t\t\n\t\tif (diffang < ANG45)\n\t\t{\n\t\t    // head-on    \n\t\t    st_faceindex += ST_RAMPAGEOFFSET;\n\t\t}\n\t\telse if (i)\n\t\t{\n\t\t    // turn face right\n\t\t    st_faceindex += ST_TURNOFFSET;\n\t\t}\n\t\telse\n\t\t{\n\t\t    // turn face left\n\t\t    st_faceindex += ST_TURNOFFSET+1;\n\t\t}\n\t    }\n\t}\n    }\n  \n    if (priority < 7)\n    {\n\t// getting hurt because of your own damn stupidity\n\tif (plyr->damagecount)\n\t{\n\t    if (plyr->health - st_oldhealth > ST_MUCHPAIN)\n\t    {\n\t\tpriority = 7;\n\t\tst_facecount = ST_TURNCOUNT;\n\t\tst_faceindex = ST_calcPainOffset() + ST_OUCHOFFSET;\n\t    }\n\t    else\n\t    {\n\t\tpriority = 6;\n\t\tst_facecount = ST_TURNCOUNT;\n\t\tst_faceindex = ST_calcPainOffset() + ST_RAMPAGEOFFSET;\n\t    }\n\n\t}\n\n    }\n  \n    if (priority < 6)\n    {\n\t// rapid firing\n\tif (plyr->attackdown)\n\t{\n\t    if (lastattackdown==-1)\n\t\tlastattackdown = ST_RAMPAGEDELAY;\n\t    else if (!--lastattackdown)\n\t    {\n\t\tpriority = 5;\n\t\tst_faceindex = ST_calcPainOffset() + ST_RAMPAGEOFFSET;\n\t\tst_facecount = 1;\n\t\tlastattackdown = 1;\n\t    }\n\t}\n\telse\n\t    lastattackdown = -1;\n\n    }\n  \n    if (priority < 5)\n    {\n\t// invulnerability\n\tif ((plyr->cheats & CF_GODMODE)\n\t    || plyr->powers[pw_invulnerability])\n\t{\n\t    priority = 4;\n\n\t    st_faceindex = ST_GODFACE;\n\t    st_facecount = 1;\n\n\t}\n\n    }\n\n    // look left or look right if the facecount has timed out\n    if (!st_facecount)\n    {\n\tst_faceindex = ST_calcPainOffset() + (st_randomnumber % 3);\n\tst_facecount = ST_STRAIGHTFACECOUNT;\n\tpriority = 0;\n    }\n\n    st_facecount--;\n\n}\n\nvoid ST_updateWidgets(void)\n{\n    static int\tlargeammo = 1994; // means \"n/a\"\n    int\t\ti;\n\n    // must redirect the pointer if the ready weapon has changed.\n    //  if (w_ready.data != plyr->readyweapon)\n    //  {\n    if (weaponinfo[plyr->readyweapon].ammo == am_noammo)\n\tw_ready.num = &largeammo;\n    else\n\tw_ready.num = &plyr->ammo[weaponinfo[plyr->readyweapon].ammo];\n    w_ready.data = plyr->readyweapon;\n\n    // update keycard multiple widgets\n    for (i=0;i<3;i++)\n    {\n\tkeyboxes[i] = plyr->cards[i] ? i : -1;\n\n\tif (plyr->cards[i+3])\n\t    keyboxes[i] = i+3;\n    }\n\n    // refresh everything if this is him coming back to life\n    ST_updateFaceWidget();\n\n    // used by the w_armsbg widget\n    st_notdeathmatch = !deathmatch;\n    \n    // used by w_arms[] widgets\n    st_armson = st_statusbaron && !deathmatch; \n\n    // used by w_frags widget\n    st_fragson = deathmatch && st_statusbaron; \n    st_fragscount = 0;\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (i != consoleplayer)\n\t    st_fragscount += plyr->frags[i];\n\telse\n\t    st_fragscount -= plyr->frags[i];\n    }\n\n    // get rid of chat window if up because of message\n    if (!--st_msgcounter)\n\tst_chat = st_oldchat;\n\n}\n\nvoid ST_Ticker (void)\n{\n\n    st_clock++;\n    st_randomnumber = M_Random();\n    ST_updateWidgets();\n    st_oldhealth = plyr->health;\n\n}\n\nstatic int st_palette = 0;\n\nvoid ST_doPaletteStuff(void)\n{\n\n    int\t\tpalette;\n    byte*\tpal;\n    int\t\tcnt;\n    int\t\tbzc;\n\n    cnt = plyr->damagecount;\n\n    if (plyr->powers[pw_strength])\n    {\n\t// slowly fade the berzerk out\n  \tbzc = 12 - (plyr->powers[pw_strength]>>6);\n\n\tif (bzc > cnt)\n\t    cnt = bzc;\n    }\n\t\n    if (cnt)\n    {\n\tpalette = (cnt+7)>>3;\n\t\n\tif (palette >= NUMREDPALS)\n\t    palette = NUMREDPALS-1;\n\n\tpalette += STARTREDPALS;\n    }\n\n    else if (plyr->bonuscount)\n    {\n\tpalette = (plyr->bonuscount+7)>>3;\n\n\tif (palette >= NUMBONUSPALS)\n\t    palette = NUMBONUSPALS-1;\n\n\tpalette += STARTBONUSPALS;\n    }\n\n    else if ( plyr->powers[pw_ironfeet] > 4*32\n\t      || plyr->powers[pw_ironfeet]&8)\n\tpalette = RADIATIONPAL;\n    else\n\tpalette = 0;\n\n    // In Chex Quest, the player never sees red.  Instead, the\n    // radiation suit palette is used to tint the screen green,\n    // as though the player is being covered in goo by an\n    // attacking flemoid.\n\n    if (gameversion == exe_chex\n     && palette >= STARTREDPALS && palette < STARTREDPALS + NUMREDPALS)\n    {\n        palette = RADIATIONPAL;\n    }\n\n    if (palette != st_palette)\n    {\n\tst_palette = palette;\n\tpal = (byte *) W_CacheLumpNum (lu_palette, PU_CACHE)+palette*768;\n\tI_SetPalette (pal);\n    }\n\n}\n\nvoid ST_drawWidgets(boolean refresh)\n{\n    int\t\ti;\n\n    // used by w_arms[] widgets\n    st_armson = st_statusbaron && !deathmatch;\n\n    // used by w_frags widget\n    st_fragson = deathmatch && st_statusbaron; \n\n    STlib_updateNum(&w_ready, refresh);\n\n    for (i=0;i<4;i++)\n    {\n\tSTlib_updateNum(&w_ammo[i], refresh);\n\tSTlib_updateNum(&w_maxammo[i], refresh);\n    }\n\n    STlib_updatePercent(&w_health, refresh);\n    STlib_updatePercent(&w_armor, refresh);\n\n    STlib_updateBinIcon(&w_armsbg, refresh);\n\n    for (i=0;i<6;i++)\n\tSTlib_updateMultIcon(&w_arms[i], refresh);\n\n    STlib_updateMultIcon(&w_faces, refresh);\n\n    for (i=0;i<3;i++)\n\tSTlib_updateMultIcon(&w_keyboxes[i], refresh);\n\n    STlib_updateNum(&w_frags, refresh);\n\n}\n\nvoid ST_doRefresh(void)\n{\n\n    st_firsttime = false;\n\n    // draw status bar background to off-screen buff\n    ST_refreshBackground();\n\n    // and refresh all widgets\n    ST_drawWidgets(true);\n\n}\n\nvoid ST_diffDraw(void)\n{\n    // update all widgets\n    ST_drawWidgets(false);\n}\n\nvoid ST_Drawer (boolean fullscreen, boolean refresh)\n{\n  \n    st_statusbaron = (!fullscreen) || automapactive;\n    st_firsttime = st_firsttime || refresh;\n\n    // Do red-/gold-shifts from damage/items\n    ST_doPaletteStuff();\n\n    // If just after ST_Start(), refresh all\n    if (st_firsttime) ST_doRefresh();\n    // Otherwise, update as little as possible\n    else ST_diffDraw();\n\n}\n\ntypedef void (*load_callback_t)(const char *lumpname, patch_t **variable);\n\n// Iterates through all graphics to be loaded or unloaded, along with\n// the variable they use, invoking the specified callback function.\n\nstatic void ST_loadUnloadGraphics(load_callback_t callback)\n{\n\n    int\t\ti;\n    int\t\tj;\n    int\t\tfacenum;\n    \n    char\tnamebuf[9];\n\n    // Load the numbers, tall and short\n    for (i=0;i<10;i++)\n    {\n\tDEH_snprintf(namebuf, 9, \"STTNUM%d\", i);\n        callback(namebuf, &tallnum[i]);\n\n\tDEH_snprintf(namebuf, 9, \"STYSNUM%d\", i);\n        callback(namebuf, &shortnum[i]);\n    }\n\n    // Load percent key.\n    //Note: why not load STMINUS here, too?\n\n    callback(DEH_String(\"STTPRCNT\"), &tallpercent);\n\n    // key cards\n    for (i=0;i<NUMCARDS;i++)\n    {\n\tDEH_snprintf(namebuf, 9, \"STKEYS%d\", i);\n        callback(namebuf, &keys[i]);\n    }\n\n    // arms background\n    callback(DEH_String(\"STARMS\"), &armsbg);\n\n    // arms ownership widgets\n    for (i=0; i<6; i++)\n    {\n\tDEH_snprintf(namebuf, 9, \"STGNUM%d\", i+2);\n\n\t// gray #\n        callback(namebuf, &arms[i][0]);\n\n\t// yellow #\n\tarms[i][1] = shortnum[i+2]; \n    }\n\n    // face backgrounds for different color players\n    DEH_snprintf(namebuf, 9, \"STFB%d\", consoleplayer);\n    callback(namebuf, &faceback);\n\n    // status bar background bits\n    callback(DEH_String(\"STBAR\"), &sbar);\n\n    // face states\n    facenum = 0;\n    for (i=0; i<ST_NUMPAINFACES; i++)\n    {\n\tfor (j=0; j<ST_NUMSTRAIGHTFACES; j++)\n\t{\n\t    DEH_snprintf(namebuf, 9, \"STFST%d%d\", i, j);\n            callback(namebuf, &faces[facenum]);\n            ++facenum;\n\t}\n\tDEH_snprintf(namebuf, 9, \"STFTR%d0\", i);\t// turn right\n        callback(namebuf, &faces[facenum]);\n        ++facenum;\n\tDEH_snprintf(namebuf, 9, \"STFTL%d0\", i);\t// turn left\n        callback(namebuf, &faces[facenum]);\n        ++facenum;\n\tDEH_snprintf(namebuf, 9, \"STFOUCH%d\", i);\t// ouch!\n        callback(namebuf, &faces[facenum]);\n        ++facenum;\n\tDEH_snprintf(namebuf, 9, \"STFEVL%d\", i);\t// evil grin ;)\n        callback(namebuf, &faces[facenum]);\n        ++facenum;\n\tDEH_snprintf(namebuf, 9, \"STFKILL%d\", i);\t// pissed off\n        callback(namebuf, &faces[facenum]);\n        ++facenum;\n    }\n\n    callback(DEH_String(\"STFGOD0\"), &faces[facenum]);\n    ++facenum;\n    callback(DEH_String(\"STFDEAD0\"), &faces[facenum]);\n    ++facenum;\n}\n\nstatic void ST_loadCallback(const char *lumpname, patch_t **variable)\n{\n    *variable = W_CacheLumpName(lumpname, PU_STATIC);\n}\n\nvoid ST_loadGraphics(void)\n{\n    ST_loadUnloadGraphics(ST_loadCallback);\n}\n\nvoid ST_loadData(void)\n{\n    lu_palette = W_GetNumForName (DEH_String(\"PLAYPAL\"));\n    ST_loadGraphics();\n}\n\nstatic void ST_unloadCallback(const char *lumpname, patch_t **variable)\n{\n    W_ReleaseLumpName(lumpname);\n    *variable = NULL;\n}\n\nvoid ST_unloadGraphics(void)\n{\n    ST_loadUnloadGraphics(ST_unloadCallback);\n}\n\nvoid ST_unloadData(void)\n{\n    ST_unloadGraphics();\n}\n\nvoid ST_initData(void)\n{\n\n    int\t\ti;\n\n    st_firsttime = true;\n    plyr = &players[consoleplayer];\n\n    st_clock = 0;\n    st_chatstate = StartChatState;\n    st_gamestate = FirstPersonState;\n\n    st_statusbaron = true;\n    st_oldchat = st_chat = false;\n    st_cursoron = false;\n\n    st_faceindex = 0;\n    st_palette = -1;\n\n    st_oldhealth = -1;\n\n    for (i=0;i<NUMWEAPONS;i++)\n\toldweaponsowned[i] = plyr->weaponowned[i];\n\n    for (i=0;i<3;i++)\n\tkeyboxes[i] = -1;\n\n    STlib_init();\n\n}\n\n\n\nvoid ST_createWidgets(void)\n{\n\n    int i;\n\n    // ready weapon ammo\n    STlib_initNum(&w_ready,\n\t\t  ST_AMMOX,\n\t\t  ST_AMMOY,\n\t\t  tallnum,\n\t\t  &plyr->ammo[weaponinfo[plyr->readyweapon].ammo],\n\t\t  &st_statusbaron,\n\t\t  ST_AMMOWIDTH );\n\n    // the last weapon type\n    w_ready.data = plyr->readyweapon; \n\n    // health percentage\n    STlib_initPercent(&w_health,\n\t\t      ST_HEALTHX,\n\t\t      ST_HEALTHY,\n\t\t      tallnum,\n\t\t      &plyr->health,\n\t\t      &st_statusbaron,\n\t\t      tallpercent);\n\n    // arms background\n    STlib_initBinIcon(&w_armsbg,\n\t\t      ST_ARMSBGX,\n\t\t      ST_ARMSBGY,\n\t\t      armsbg,\n\t\t      &st_notdeathmatch,\n\t\t      &st_statusbaron);\n\n    // weapons owned\n    for(i=0;i<6;i++)\n    {\n        STlib_initMultIcon(&w_arms[i],\n                           ST_ARMSX+(i%3)*ST_ARMSXSPACE,\n                           ST_ARMSY+(i/3)*ST_ARMSYSPACE,\n                           arms[i],\n                           &plyr->weaponowned[i+1],\n                           &st_armson);\n    }\n\n    // frags sum\n    STlib_initNum(&w_frags,\n\t\t  ST_FRAGSX,\n\t\t  ST_FRAGSY,\n\t\t  tallnum,\n\t\t  &st_fragscount,\n\t\t  &st_fragson,\n\t\t  ST_FRAGSWIDTH);\n\n    // faces\n    STlib_initMultIcon(&w_faces,\n\t\t       ST_FACESX,\n\t\t       ST_FACESY,\n\t\t       faces,\n\t\t       &st_faceindex,\n\t\t       &st_statusbaron);\n\n    // armor percentage - should be colored later\n    STlib_initPercent(&w_armor,\n\t\t      ST_ARMORX,\n\t\t      ST_ARMORY,\n\t\t      tallnum,\n\t\t      &plyr->armorpoints,\n\t\t      &st_statusbaron, tallpercent);\n\n    // keyboxes 0-2\n    STlib_initMultIcon(&w_keyboxes[0],\n\t\t       ST_KEY0X,\n\t\t       ST_KEY0Y,\n\t\t       keys,\n\t\t       &keyboxes[0],\n\t\t       &st_statusbaron);\n    \n    STlib_initMultIcon(&w_keyboxes[1],\n\t\t       ST_KEY1X,\n\t\t       ST_KEY1Y,\n\t\t       keys,\n\t\t       &keyboxes[1],\n\t\t       &st_statusbaron);\n\n    STlib_initMultIcon(&w_keyboxes[2],\n\t\t       ST_KEY2X,\n\t\t       ST_KEY2Y,\n\t\t       keys,\n\t\t       &keyboxes[2],\n\t\t       &st_statusbaron);\n\n    // ammo count (all four kinds)\n    STlib_initNum(&w_ammo[0],\n\t\t  ST_AMMO0X,\n\t\t  ST_AMMO0Y,\n\t\t  shortnum,\n\t\t  &plyr->ammo[0],\n\t\t  &st_statusbaron,\n\t\t  ST_AMMO0WIDTH);\n\n    STlib_initNum(&w_ammo[1],\n\t\t  ST_AMMO1X,\n\t\t  ST_AMMO1Y,\n\t\t  shortnum,\n\t\t  &plyr->ammo[1],\n\t\t  &st_statusbaron,\n\t\t  ST_AMMO1WIDTH);\n\n    STlib_initNum(&w_ammo[2],\n\t\t  ST_AMMO2X,\n\t\t  ST_AMMO2Y,\n\t\t  shortnum,\n\t\t  &plyr->ammo[2],\n\t\t  &st_statusbaron,\n\t\t  ST_AMMO2WIDTH);\n    \n    STlib_initNum(&w_ammo[3],\n\t\t  ST_AMMO3X,\n\t\t  ST_AMMO3Y,\n\t\t  shortnum,\n\t\t  &plyr->ammo[3],\n\t\t  &st_statusbaron,\n\t\t  ST_AMMO3WIDTH);\n\n    // max ammo count (all four kinds)\n    STlib_initNum(&w_maxammo[0],\n\t\t  ST_MAXAMMO0X,\n\t\t  ST_MAXAMMO0Y,\n\t\t  shortnum,\n\t\t  &plyr->maxammo[0],\n\t\t  &st_statusbaron,\n\t\t  ST_MAXAMMO0WIDTH);\n\n    STlib_initNum(&w_maxammo[1],\n\t\t  ST_MAXAMMO1X,\n\t\t  ST_MAXAMMO1Y,\n\t\t  shortnum,\n\t\t  &plyr->maxammo[1],\n\t\t  &st_statusbaron,\n\t\t  ST_MAXAMMO1WIDTH);\n\n    STlib_initNum(&w_maxammo[2],\n\t\t  ST_MAXAMMO2X,\n\t\t  ST_MAXAMMO2Y,\n\t\t  shortnum,\n\t\t  &plyr->maxammo[2],\n\t\t  &st_statusbaron,\n\t\t  ST_MAXAMMO2WIDTH);\n    \n    STlib_initNum(&w_maxammo[3],\n\t\t  ST_MAXAMMO3X,\n\t\t  ST_MAXAMMO3Y,\n\t\t  shortnum,\n\t\t  &plyr->maxammo[3],\n\t\t  &st_statusbaron,\n\t\t  ST_MAXAMMO3WIDTH);\n\n}\n\nstatic boolean\tst_stopped = true;\n\n\nvoid ST_Start (void)\n{\n\n    if (!st_stopped)\n\tST_Stop();\n\n    ST_initData();\n    ST_createWidgets();\n    st_stopped = false;\n\n}\n\nvoid ST_Stop (void)\n{\n    if (st_stopped)\n\treturn;\n\n    I_SetPalette (W_CacheLumpNum (lu_palette, PU_CACHE));\n\n    st_stopped = true;\n}\n\nvoid ST_Init (void)\n{\n    ST_loadData();\n    st_backing_screen = (pixel_t *) Z_Malloc(ST_WIDTH * ST_HEIGHT * sizeof(*st_backing_screen), PU_STATIC, 0);\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tArchiving: SaveGame I/O.\n//\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"dstrings.h\"\n#include \"deh_main.h\"\n#include \"i_system.h\"\n#include \"z_zone.h\"\n#include \"p_local.h\"\n#include \"p_saveg.h\"\n\n// State.\n#include \"doomstat.h\"\n#include \"g_game.h\"\n#include \"m_misc.h\"\n#include \"r_state.h\"\n\nFILE *save_stream;\nint savegamelength;\nboolean savegame_error;\n\n// Get the filename of a temporary file to write the savegame to.  After\n// the file has been successfully saved, it will be renamed to the \n// real file.\n\nchar *P_TempSaveGameFile(void)\n{\n    static char *filename = NULL;\n\n    if (filename == NULL)\n    {\n        filename = M_StringJoin(savegamedir, \"temp.dsg\", NULL);\n    }\n\n    return filename;\n}\n\n// Get the filename of the save game file to use for the specified slot.\n\nchar *P_SaveGameFile(int slot)\n{\n    static char *filename = NULL;\n    static size_t filename_size = 0;\n    char basename[32];\n\n    if (filename == NULL)\n    {\n        filename_size = strlen(savegamedir) + 32;\n        filename = malloc(filename_size);\n    }\n\n    DEH_snprintf(basename, 32, SAVEGAMENAME \"%d.dsg\", slot);\n    M_snprintf(filename, filename_size, \"%s%s\", savegamedir, basename);\n\n    return filename;\n}\n\n// Endian-safe integer read/write functions\n\nstatic byte saveg_read8(void)\n{\n    byte result = -1;\n\n    if (fread(&result, 1, 1, save_stream) < 1)\n    {\n        if (!savegame_error)\n        {\n            fprintf(stderr, \"saveg_read8: Unexpected end of file while \"\n                            \"reading save game\\n\");\n\n            savegame_error = true;\n        }\n    }\n\n    return result;\n}\n\nstatic void saveg_write8(byte value)\n{\n    if (fwrite(&value, 1, 1, save_stream) < 1)\n    {\n        if (!savegame_error)\n        {\n            fprintf(stderr, \"saveg_write8: Error while writing save game\\n\");\n\n            savegame_error = true;\n        }\n    }\n}\n\nstatic short saveg_read16(void)\n{\n    int result;\n\n    result = saveg_read8();\n    result |= saveg_read8() << 8;\n\n    return result;\n}\n\nstatic void saveg_write16(short value)\n{\n    saveg_write8(value & 0xff);\n    saveg_write8((value >> 8) & 0xff);\n}\n\nstatic int saveg_read32(void)\n{\n    int result;\n\n    result = saveg_read8();\n    result |= saveg_read8() << 8;\n    result |= saveg_read8() << 16;\n    result |= saveg_read8() << 24;\n\n    return result;\n}\n\nstatic void saveg_write32(int value)\n{\n    saveg_write8(value & 0xff);\n    saveg_write8((value >> 8) & 0xff);\n    saveg_write8((value >> 16) & 0xff);\n    saveg_write8((value >> 24) & 0xff);\n}\n\n// Pad to 4-byte boundaries\n\nstatic void saveg_read_pad(void)\n{\n    unsigned long pos;\n    int padding;\n    int i;\n\n    pos = ftell(save_stream);\n\n    padding = (4 - (pos & 3)) & 3;\n\n    for (i=0; i<padding; ++i)\n    {\n        saveg_read8();\n    }\n}\n\nstatic void saveg_write_pad(void)\n{\n    unsigned long pos;\n    int padding;\n    int i;\n\n    pos = ftell(save_stream);\n\n    padding = (4 - (pos & 3)) & 3;\n\n    for (i=0; i<padding; ++i)\n    {\n        saveg_write8(0);\n    }\n}\n\n\n// Pointers\n\nstatic void *saveg_readp(void)\n{\n    return (void *) (intptr_t) saveg_read32();\n}\n\nstatic void saveg_writep(const void *p)\n{\n    saveg_write32((intptr_t) p);\n}\n\n// Enum values are 32-bit integers.\n\n#define saveg_read_enum saveg_read32\n#define saveg_write_enum saveg_write32\n\n//\n// Structure read/write functions\n//\n\n//\n// mapthing_t\n//\n\nstatic void saveg_read_mapthing_t(mapthing_t *str)\n{\n    // short x;\n    str->x = saveg_read16();\n\n    // short y;\n    str->y = saveg_read16();\n\n    // short angle;\n    str->angle = saveg_read16();\n\n    // short type;\n    str->type = saveg_read16();\n\n    // short options;\n    str->options = saveg_read16();\n}\n\nstatic void saveg_write_mapthing_t(mapthing_t *str)\n{\n    // short x;\n    saveg_write16(str->x);\n\n    // short y;\n    saveg_write16(str->y);\n\n    // short angle;\n    saveg_write16(str->angle);\n\n    // short type;\n    saveg_write16(str->type);\n\n    // short options;\n    saveg_write16(str->options);\n}\n\n//\n// actionf_t\n// \n\nstatic void saveg_read_actionf_t(actionf_t *str)\n{\n    // actionf_p1 acp1;\n    str->acp1 = saveg_readp();\n}\n\nstatic void saveg_write_actionf_t(actionf_t *str)\n{\n    // actionf_p1 acp1;\n    saveg_writep(str->acp1);\n}\n\n//\n// think_t\n//\n// This is just an actionf_t.\n//\n\n#define saveg_read_think_t saveg_read_actionf_t\n#define saveg_write_think_t saveg_write_actionf_t\n\n//\n// thinker_t\n//\n\nstatic void saveg_read_thinker_t(thinker_t *str)\n{\n    // struct thinker_s* prev;\n    str->prev = saveg_readp();\n\n    // struct thinker_s* next;\n    str->next = saveg_readp();\n\n    // think_t function;\n    saveg_read_think_t(&str->function);\n}\n\nstatic void saveg_write_thinker_t(thinker_t *str)\n{\n    // struct thinker_s* prev;\n    saveg_writep(str->prev);\n\n    // struct thinker_s* next;\n    saveg_writep(str->next);\n\n    // think_t function;\n    saveg_write_think_t(&str->function);\n}\n\n//\n// mobj_t\n//\n\nstatic void saveg_read_mobj_t(mobj_t *str)\n{\n    int pl;\n\n    // thinker_t thinker;\n    saveg_read_thinker_t(&str->thinker);\n\n    // fixed_t x;\n    str->x = saveg_read32();\n\n    // fixed_t y;\n    str->y = saveg_read32();\n\n    // fixed_t z;\n    str->z = saveg_read32();\n\n    // struct mobj_s* snext;\n    str->snext = saveg_readp();\n\n    // struct mobj_s* sprev;\n    str->sprev = saveg_readp();\n\n    // angle_t angle;\n    str->angle = saveg_read32();\n\n    // spritenum_t sprite;\n    str->sprite = saveg_read_enum();\n\n    // int frame;\n    str->frame = saveg_read32();\n\n    // struct mobj_s* bnext;\n    str->bnext = saveg_readp();\n\n    // struct mobj_s* bprev;\n    str->bprev = saveg_readp();\n\n    // struct subsector_s* subsector;\n    str->subsector = saveg_readp();\n\n    // fixed_t floorz;\n    str->floorz = saveg_read32();\n\n    // fixed_t ceilingz;\n    str->ceilingz = saveg_read32();\n\n    // fixed_t radius;\n    str->radius = saveg_read32();\n\n    // fixed_t height;\n    str->height = saveg_read32();\n\n    // fixed_t momx;\n    str->momx = saveg_read32();\n\n    // fixed_t momy;\n    str->momy = saveg_read32();\n\n    // fixed_t momz;\n    str->momz = saveg_read32();\n\n    // int validcount;\n    str->validcount = saveg_read32();\n\n    // mobjtype_t type;\n    str->type = saveg_read_enum();\n\n    // mobjinfo_t* info;\n    str->info = saveg_readp();\n\n    // int tics;\n    str->tics = saveg_read32();\n\n    // state_t* state;\n    str->state = &states[saveg_read32()];\n\n    // int flags;\n    str->flags = saveg_read32();\n\n    // int health;\n    str->health = saveg_read32();\n\n    // int movedir;\n    str->movedir = saveg_read32();\n\n    // int movecount;\n    str->movecount = saveg_read32();\n\n    // struct mobj_s* target;\n    str->target = saveg_readp();\n\n    // int reactiontime;\n    str->reactiontime = saveg_read32();\n\n    // int threshold;\n    str->threshold = saveg_read32();\n\n    // struct player_s* player;\n    pl = saveg_read32();\n\n    if (pl > 0)\n    {\n        str->player = &players[pl - 1];\n        str->player->mo = str;\n    }\n    else\n    {\n        str->player = NULL;\n    }\n\n    // int lastlook;\n    str->lastlook = saveg_read32();\n\n    // mapthing_t spawnpoint;\n    saveg_read_mapthing_t(&str->spawnpoint);\n\n    // struct mobj_s* tracer;\n    str->tracer = saveg_readp();\n}\n\nstatic void saveg_write_mobj_t(mobj_t *str)\n{\n    // thinker_t thinker;\n    saveg_write_thinker_t(&str->thinker);\n\n    // fixed_t x;\n    saveg_write32(str->x);\n\n    // fixed_t y;\n    saveg_write32(str->y);\n\n    // fixed_t z;\n    saveg_write32(str->z);\n\n    // struct mobj_s* snext;\n    saveg_writep(str->snext);\n\n    // struct mobj_s* sprev;\n    saveg_writep(str->sprev);\n\n    // angle_t angle;\n    saveg_write32(str->angle);\n\n    // spritenum_t sprite;\n    saveg_write_enum(str->sprite);\n\n    // int frame;\n    saveg_write32(str->frame);\n\n    // struct mobj_s* bnext;\n    saveg_writep(str->bnext);\n\n    // struct mobj_s* bprev;\n    saveg_writep(str->bprev);\n\n    // struct subsector_s* subsector;\n    saveg_writep(str->subsector);\n\n    // fixed_t floorz;\n    saveg_write32(str->floorz);\n\n    // fixed_t ceilingz;\n    saveg_write32(str->ceilingz);\n\n    // fixed_t radius;\n    saveg_write32(str->radius);\n\n    // fixed_t height;\n    saveg_write32(str->height);\n\n    // fixed_t momx;\n    saveg_write32(str->momx);\n\n    // fixed_t momy;\n    saveg_write32(str->momy);\n\n    // fixed_t momz;\n    saveg_write32(str->momz);\n\n    // int validcount;\n    saveg_write32(str->validcount);\n\n    // mobjtype_t type;\n    saveg_write_enum(str->type);\n\n    // mobjinfo_t* info;\n    saveg_writep(str->info);\n\n    // int tics;\n    saveg_write32(str->tics);\n\n    // state_t* state;\n    saveg_write32(str->state - states);\n\n    // int flags;\n    saveg_write32(str->flags);\n\n    // int health;\n    saveg_write32(str->health);\n\n    // int movedir;\n    saveg_write32(str->movedir);\n\n    // int movecount;\n    saveg_write32(str->movecount);\n\n    // struct mobj_s* target;\n    saveg_writep(str->target);\n\n    // int reactiontime;\n    saveg_write32(str->reactiontime);\n\n    // int threshold;\n    saveg_write32(str->threshold);\n\n    // struct player_s* player;\n    if (str->player)\n    {\n        saveg_write32(str->player - players + 1);\n    }\n    else\n    {\n        saveg_write32(0);\n    }\n\n    // int lastlook;\n    saveg_write32(str->lastlook);\n\n    // mapthing_t spawnpoint;\n    saveg_write_mapthing_t(&str->spawnpoint);\n\n    // struct mobj_s* tracer;\n    saveg_writep(str->tracer);\n}\n\n\n//\n// ticcmd_t\n//\n\nstatic void saveg_read_ticcmd_t(ticcmd_t *str)\n{\n\n    // signed char forwardmove;\n    str->forwardmove = saveg_read8();\n\n    // signed char sidemove;\n    str->sidemove = saveg_read8();\n\n    // short angleturn;\n    str->angleturn = saveg_read16();\n\n    // short consistancy;\n    str->consistancy = saveg_read16();\n\n    // byte chatchar;\n    str->chatchar = saveg_read8();\n\n    // byte buttons;\n    str->buttons = saveg_read8();\n}\n\nstatic void saveg_write_ticcmd_t(ticcmd_t *str)\n{\n\n    // signed char forwardmove;\n    saveg_write8(str->forwardmove);\n\n    // signed char sidemove;\n    saveg_write8(str->sidemove);\n\n    // short angleturn;\n    saveg_write16(str->angleturn);\n\n    // short consistancy;\n    saveg_write16(str->consistancy);\n\n    // byte chatchar;\n    saveg_write8(str->chatchar);\n\n    // byte buttons;\n    saveg_write8(str->buttons);\n}\n\n//\n// pspdef_t\n//\n\nstatic void saveg_read_pspdef_t(pspdef_t *str)\n{\n    int state;\n\n    // state_t* state;\n    state = saveg_read32();\n\n    if (state > 0)\n    {\n        str->state = &states[state];\n    }\n    else\n    {\n        str->state = NULL;\n    }\n\n    // int tics;\n    str->tics = saveg_read32();\n\n    // fixed_t sx;\n    str->sx = saveg_read32();\n\n    // fixed_t sy;\n    str->sy = saveg_read32();\n}\n\nstatic void saveg_write_pspdef_t(pspdef_t *str)\n{\n    // state_t* state;\n    if (str->state)\n    {\n        saveg_write32(str->state - states);\n    }\n    else\n    {\n        saveg_write32(0);\n    }\n\n    // int tics;\n    saveg_write32(str->tics);\n\n    // fixed_t sx;\n    saveg_write32(str->sx);\n\n    // fixed_t sy;\n    saveg_write32(str->sy);\n}\n\n//\n// player_t\n//\n\nstatic void saveg_read_player_t(player_t *str)\n{\n    int i;\n\n    // mobj_t* mo;\n    str->mo = saveg_readp();\n\n    // playerstate_t playerstate;\n    str->playerstate = saveg_read_enum();\n\n    // ticcmd_t cmd;\n    saveg_read_ticcmd_t(&str->cmd);\n\n    // fixed_t viewz;\n    str->viewz = saveg_read32();\n\n    // fixed_t viewheight;\n    str->viewheight = saveg_read32();\n\n    // fixed_t deltaviewheight;\n    str->deltaviewheight = saveg_read32();\n\n    // fixed_t bob;\n    str->bob = saveg_read32();\n\n    // int health;\n    str->health = saveg_read32();\n\n    // int armorpoints;\n    str->armorpoints = saveg_read32();\n\n    // int armortype;\n    str->armortype = saveg_read32();\n\n    // int powers[NUMPOWERS];\n    for (i=0; i<NUMPOWERS; ++i)\n    {\n        str->powers[i] = saveg_read32();\n    }\n\n    // boolean cards[NUMCARDS];\n    for (i=0; i<NUMCARDS; ++i)\n    {\n        str->cards[i] = saveg_read32();\n    }\n\n    // boolean backpack;\n    str->backpack = saveg_read32();\n\n    // int frags[MAXPLAYERS];\n    for (i=0; i<MAXPLAYERS; ++i)\n    {\n        str->frags[i] = saveg_read32();\n    }\n\n    // weapontype_t readyweapon;\n    str->readyweapon = saveg_read_enum();\n\n    // weapontype_t pendingweapon;\n    str->pendingweapon = saveg_read_enum();\n\n    // boolean weaponowned[NUMWEAPONS];\n    for (i=0; i<NUMWEAPONS; ++i)\n    {\n        str->weaponowned[i] = saveg_read32();\n    }\n\n    // int ammo[NUMAMMO];\n    for (i=0; i<NUMAMMO; ++i)\n    {\n        str->ammo[i] = saveg_read32();\n    }\n\n    // int maxammo[NUMAMMO];\n    for (i=0; i<NUMAMMO; ++i)\n    {\n        str->maxammo[i] = saveg_read32();\n    }\n\n    // int attackdown;\n    str->attackdown = saveg_read32();\n\n    // int usedown;\n    str->usedown = saveg_read32();\n\n    // int cheats;\n    str->cheats = saveg_read32();\n\n    // int refire;\n    str->refire = saveg_read32();\n\n    // int killcount;\n    str->killcount = saveg_read32();\n\n    // int itemcount;\n    str->itemcount = saveg_read32();\n\n    // int secretcount;\n    str->secretcount = saveg_read32();\n\n    // char* message;\n    str->message = saveg_readp();\n\n    // int damagecount;\n    str->damagecount = saveg_read32();\n\n    // int bonuscount;\n    str->bonuscount = saveg_read32();\n\n    // mobj_t* attacker;\n    str->attacker = saveg_readp();\n\n    // int extralight;\n    str->extralight = saveg_read32();\n\n    // int fixedcolormap;\n    str->fixedcolormap = saveg_read32();\n\n    // int colormap;\n    str->colormap = saveg_read32();\n\n    // pspdef_t psprites[NUMPSPRITES];\n    for (i=0; i<NUMPSPRITES; ++i)\n    {\n        saveg_read_pspdef_t(&str->psprites[i]);\n    }\n\n    // boolean didsecret;\n    str->didsecret = saveg_read32();\n}\n\nstatic void saveg_write_player_t(player_t *str)\n{\n    int i;\n\n    // mobj_t* mo;\n    saveg_writep(str->mo);\n\n    // playerstate_t playerstate;\n    saveg_write_enum(str->playerstate);\n\n    // ticcmd_t cmd;\n    saveg_write_ticcmd_t(&str->cmd);\n\n    // fixed_t viewz;\n    saveg_write32(str->viewz);\n\n    // fixed_t viewheight;\n    saveg_write32(str->viewheight);\n\n    // fixed_t deltaviewheight;\n    saveg_write32(str->deltaviewheight);\n\n    // fixed_t bob;\n    saveg_write32(str->bob);\n\n    // int health;\n    saveg_write32(str->health);\n\n    // int armorpoints;\n    saveg_write32(str->armorpoints);\n\n    // int armortype;\n    saveg_write32(str->armortype);\n\n    // int powers[NUMPOWERS];\n    for (i=0; i<NUMPOWERS; ++i)\n    {\n        saveg_write32(str->powers[i]);\n    }\n\n    // boolean cards[NUMCARDS];\n    for (i=0; i<NUMCARDS; ++i)\n    {\n        saveg_write32(str->cards[i]);\n    }\n\n    // boolean backpack;\n    saveg_write32(str->backpack);\n\n    // int frags[MAXPLAYERS];\n    for (i=0; i<MAXPLAYERS; ++i)\n    {\n        saveg_write32(str->frags[i]);\n    }\n\n    // weapontype_t readyweapon;\n    saveg_write_enum(str->readyweapon);\n\n    // weapontype_t pendingweapon;\n    saveg_write_enum(str->pendingweapon);\n\n    // boolean weaponowned[NUMWEAPONS];\n    for (i=0; i<NUMWEAPONS; ++i)\n    {\n        saveg_write32(str->weaponowned[i]);\n    }\n\n    // int ammo[NUMAMMO];\n    for (i=0; i<NUMAMMO; ++i)\n    {\n        saveg_write32(str->ammo[i]);\n    }\n\n    // int maxammo[NUMAMMO];\n    for (i=0; i<NUMAMMO; ++i)\n    {\n        saveg_write32(str->maxammo[i]);\n    }\n\n    // int attackdown;\n    saveg_write32(str->attackdown);\n\n    // int usedown;\n    saveg_write32(str->usedown);\n\n    // int cheats;\n    saveg_write32(str->cheats);\n\n    // int refire;\n    saveg_write32(str->refire);\n\n    // int killcount;\n    saveg_write32(str->killcount);\n\n    // int itemcount;\n    saveg_write32(str->itemcount);\n\n    // int secretcount;\n    saveg_write32(str->secretcount);\n\n    // char* message;\n    saveg_writep(str->message);\n\n    // int damagecount;\n    saveg_write32(str->damagecount);\n\n    // int bonuscount;\n    saveg_write32(str->bonuscount);\n\n    // mobj_t* attacker;\n    saveg_writep(str->attacker);\n\n    // int extralight;\n    saveg_write32(str->extralight);\n\n    // int fixedcolormap;\n    saveg_write32(str->fixedcolormap);\n\n    // int colormap;\n    saveg_write32(str->colormap);\n\n    // pspdef_t psprites[NUMPSPRITES];\n    for (i=0; i<NUMPSPRITES; ++i)\n    {\n        saveg_write_pspdef_t(&str->psprites[i]);\n    }\n\n    // boolean didsecret;\n    saveg_write32(str->didsecret);\n}\n\n\n//\n// ceiling_t\n//\n\nstatic void saveg_read_ceiling_t(ceiling_t *str)\n{\n    int sector;\n\n    // thinker_t thinker;\n    saveg_read_thinker_t(&str->thinker);\n\n    // ceiling_e type;\n    str->type = saveg_read_enum();\n\n    // sector_t* sector;\n    sector = saveg_read32();\n    str->sector = &sectors[sector];\n\n    // fixed_t bottomheight;\n    str->bottomheight = saveg_read32();\n\n    // fixed_t topheight;\n    str->topheight = saveg_read32();\n\n    // fixed_t speed;\n    str->speed = saveg_read32();\n\n    // boolean crush;\n    str->crush = saveg_read32();\n\n    // int direction;\n    str->direction = saveg_read32();\n\n    // int tag;\n    str->tag = saveg_read32();\n\n    // int olddirection;\n    str->olddirection = saveg_read32();\n}\n\nstatic void saveg_write_ceiling_t(ceiling_t *str)\n{\n    // thinker_t thinker;\n    saveg_write_thinker_t(&str->thinker);\n\n    // ceiling_e type;\n    saveg_write_enum(str->type);\n\n    // sector_t* sector;\n    saveg_write32(str->sector - sectors);\n\n    // fixed_t bottomheight;\n    saveg_write32(str->bottomheight);\n\n    // fixed_t topheight;\n    saveg_write32(str->topheight);\n\n    // fixed_t speed;\n    saveg_write32(str->speed);\n\n    // boolean crush;\n    saveg_write32(str->crush);\n\n    // int direction;\n    saveg_write32(str->direction);\n\n    // int tag;\n    saveg_write32(str->tag);\n\n    // int olddirection;\n    saveg_write32(str->olddirection);\n}\n\n//\n// vldoor_t\n//\n\nstatic void saveg_read_vldoor_t(vldoor_t *str)\n{\n    int sector;\n\n    // thinker_t thinker;\n    saveg_read_thinker_t(&str->thinker);\n\n    // vldoor_e type;\n    str->type = saveg_read_enum();\n\n    // sector_t* sector;\n    sector = saveg_read32();\n    str->sector = &sectors[sector];\n\n    // fixed_t topheight;\n    str->topheight = saveg_read32();\n\n    // fixed_t speed;\n    str->speed = saveg_read32();\n\n    // int direction;\n    str->direction = saveg_read32();\n\n    // int topwait;\n    str->topwait = saveg_read32();\n\n    // int topcountdown;\n    str->topcountdown = saveg_read32();\n}\n\nstatic void saveg_write_vldoor_t(vldoor_t *str)\n{\n    // thinker_t thinker;\n    saveg_write_thinker_t(&str->thinker);\n\n    // vldoor_e type;\n    saveg_write_enum(str->type);\n\n    // sector_t* sector;\n    saveg_write32(str->sector - sectors);\n\n    // fixed_t topheight;\n    saveg_write32(str->topheight);\n\n    // fixed_t speed;\n    saveg_write32(str->speed);\n\n    // int direction;\n    saveg_write32(str->direction);\n\n    // int topwait;\n    saveg_write32(str->topwait);\n\n    // int topcountdown;\n    saveg_write32(str->topcountdown);\n}\n\n//\n// floormove_t\n//\n\nstatic void saveg_read_floormove_t(floormove_t *str)\n{\n    int sector;\n\n    // thinker_t thinker;\n    saveg_read_thinker_t(&str->thinker);\n\n    // floor_e type;\n    str->type = saveg_read_enum();\n\n    // boolean crush;\n    str->crush = saveg_read32();\n\n    // sector_t* sector;\n    sector = saveg_read32();\n    str->sector = &sectors[sector];\n\n    // int direction;\n    str->direction = saveg_read32();\n\n    // int newspecial;\n    str->newspecial = saveg_read32();\n\n    // short texture;\n    str->texture = saveg_read16();\n\n    // fixed_t floordestheight;\n    str->floordestheight = saveg_read32();\n\n    // fixed_t speed;\n    str->speed = saveg_read32();\n}\n\nstatic void saveg_write_floormove_t(floormove_t *str)\n{\n    // thinker_t thinker;\n    saveg_write_thinker_t(&str->thinker);\n\n    // floor_e type;\n    saveg_write_enum(str->type);\n\n    // boolean crush;\n    saveg_write32(str->crush);\n\n    // sector_t* sector;\n    saveg_write32(str->sector - sectors);\n\n    // int direction;\n    saveg_write32(str->direction);\n\n    // int newspecial;\n    saveg_write32(str->newspecial);\n\n    // short texture;\n    saveg_write16(str->texture);\n\n    // fixed_t floordestheight;\n    saveg_write32(str->floordestheight);\n\n    // fixed_t speed;\n    saveg_write32(str->speed);\n}\n\n//\n// plat_t\n//\n\nstatic void saveg_read_plat_t(plat_t *str)\n{\n    int sector;\n\n    // thinker_t thinker;\n    saveg_read_thinker_t(&str->thinker);\n\n    // sector_t* sector;\n    sector = saveg_read32();\n    str->sector = &sectors[sector];\n\n    // fixed_t speed;\n    str->speed = saveg_read32();\n\n    // fixed_t low;\n    str->low = saveg_read32();\n\n    // fixed_t high;\n    str->high = saveg_read32();\n\n    // int wait;\n    str->wait = saveg_read32();\n\n    // int count;\n    str->count = saveg_read32();\n\n    // plat_e status;\n    str->status = saveg_read_enum();\n\n    // plat_e oldstatus;\n    str->oldstatus = saveg_read_enum();\n\n    // boolean crush;\n    str->crush = saveg_read32();\n\n    // int tag;\n    str->tag = saveg_read32();\n\n    // plattype_e type;\n    str->type = saveg_read_enum();\n}\n\nstatic void saveg_write_plat_t(plat_t *str)\n{\n    // thinker_t thinker;\n    saveg_write_thinker_t(&str->thinker);\n\n    // sector_t* sector;\n    saveg_write32(str->sector - sectors);\n\n    // fixed_t speed;\n    saveg_write32(str->speed);\n\n    // fixed_t low;\n    saveg_write32(str->low);\n\n    // fixed_t high;\n    saveg_write32(str->high);\n\n    // int wait;\n    saveg_write32(str->wait);\n\n    // int count;\n    saveg_write32(str->count);\n\n    // plat_e status;\n    saveg_write_enum(str->status);\n\n    // plat_e oldstatus;\n    saveg_write_enum(str->oldstatus);\n\n    // boolean crush;\n    saveg_write32(str->crush);\n\n    // int tag;\n    saveg_write32(str->tag);\n\n    // plattype_e type;\n    saveg_write_enum(str->type);\n}\n\n//\n// lightflash_t\n//\n\nstatic void saveg_read_lightflash_t(lightflash_t *str)\n{\n    int sector;\n\n    // thinker_t thinker;\n    saveg_read_thinker_t(&str->thinker);\n\n    // sector_t* sector;\n    sector = saveg_read32();\n    str->sector = &sectors[sector];\n\n    // int count;\n    str->count = saveg_read32();\n\n    // int maxlight;\n    str->maxlight = saveg_read32();\n\n    // int minlight;\n    str->minlight = saveg_read32();\n\n    // int maxtime;\n    str->maxtime = saveg_read32();\n\n    // int mintime;\n    str->mintime = saveg_read32();\n}\n\nstatic void saveg_write_lightflash_t(lightflash_t *str)\n{\n    // thinker_t thinker;\n    saveg_write_thinker_t(&str->thinker);\n\n    // sector_t* sector;\n    saveg_write32(str->sector - sectors);\n\n    // int count;\n    saveg_write32(str->count);\n\n    // int maxlight;\n    saveg_write32(str->maxlight);\n\n    // int minlight;\n    saveg_write32(str->minlight);\n\n    // int maxtime;\n    saveg_write32(str->maxtime);\n\n    // int mintime;\n    saveg_write32(str->mintime);\n}\n\n//\n// strobe_t\n//\n\nstatic void saveg_read_strobe_t(strobe_t *str)\n{\n    int sector;\n\n    // thinker_t thinker;\n    saveg_read_thinker_t(&str->thinker);\n\n    // sector_t* sector;\n    sector = saveg_read32();\n    str->sector = &sectors[sector];\n\n    // int count;\n    str->count = saveg_read32();\n\n    // int minlight;\n    str->minlight = saveg_read32();\n\n    // int maxlight;\n    str->maxlight = saveg_read32();\n\n    // int darktime;\n    str->darktime = saveg_read32();\n\n    // int brighttime;\n    str->brighttime = saveg_read32();\n}\n\nstatic void saveg_write_strobe_t(strobe_t *str)\n{\n    // thinker_t thinker;\n    saveg_write_thinker_t(&str->thinker);\n\n    // sector_t* sector;\n    saveg_write32(str->sector - sectors);\n\n    // int count;\n    saveg_write32(str->count);\n\n    // int minlight;\n    saveg_write32(str->minlight);\n\n    // int maxlight;\n    saveg_write32(str->maxlight);\n\n    // int darktime;\n    saveg_write32(str->darktime);\n\n    // int brighttime;\n    saveg_write32(str->brighttime);\n}\n\n//\n// glow_t\n//\n\nstatic void saveg_read_glow_t(glow_t *str)\n{\n    int sector;\n\n    // thinker_t thinker;\n    saveg_read_thinker_t(&str->thinker);\n\n    // sector_t* sector;\n    sector = saveg_read32();\n    str->sector = &sectors[sector];\n\n    // int minlight;\n    str->minlight = saveg_read32();\n\n    // int maxlight;\n    str->maxlight = saveg_read32();\n\n    // int direction;\n    str->direction = saveg_read32();\n}\n\nstatic void saveg_write_glow_t(glow_t *str)\n{\n    // thinker_t thinker;\n    saveg_write_thinker_t(&str->thinker);\n\n    // sector_t* sector;\n    saveg_write32(str->sector - sectors);\n\n    // int minlight;\n    saveg_write32(str->minlight);\n\n    // int maxlight;\n    saveg_write32(str->maxlight);\n\n    // int direction;\n    saveg_write32(str->direction);\n}\n\n//\n// Write the header for a savegame\n//\n\nvoid P_WriteSaveGameHeader(char *description)\n{\n    char name[VERSIONSIZE]; \n    int i; \n\t\n    for (i=0; description[i] != '\\0'; ++i)\n        saveg_write8(description[i]);\n    for (; i<SAVESTRINGSIZE; ++i)\n        saveg_write8(0);\n\n    memset(name, 0, sizeof(name));\n    M_snprintf(name, sizeof(name), \"version %i\", G_VanillaVersionCode());\n\n    for (i=0; i<VERSIONSIZE; ++i)\n        saveg_write8(name[i]);\n\t \n    saveg_write8(gameskill);\n    saveg_write8(gameepisode);\n    saveg_write8(gamemap);\n\n    for (i=0 ; i<MAXPLAYERS ; i++) \n        saveg_write8(playeringame[i]);\n\n    saveg_write8((leveltime >> 16) & 0xff);\n    saveg_write8((leveltime >> 8) & 0xff);\n    saveg_write8(leveltime & 0xff);\n}\n\n// \n// Read the header for a savegame\n//\n\nboolean P_ReadSaveGameHeader(void)\n{\n    int\t i; \n    byte a, b, c; \n    char vcheck[VERSIONSIZE]; \n    char read_vcheck[VERSIONSIZE];\n\t \n    // skip the description field \n\n    for (i=0; i<SAVESTRINGSIZE; ++i)\n        saveg_read8();\n    \n    for (i=0; i<VERSIONSIZE; ++i)\n        read_vcheck[i] = saveg_read8();\n\n    memset(vcheck, 0, sizeof(vcheck));\n    M_snprintf(vcheck, sizeof(vcheck), \"version %i\", G_VanillaVersionCode());\n    if (strcmp(read_vcheck, vcheck) != 0)\n\treturn false;\t\t\t\t// bad version \n\n    gameskill = saveg_read8();\n    gameepisode = saveg_read8();\n    gamemap = saveg_read8();\n\n    for (i=0 ; i<MAXPLAYERS ; i++) \n\tplayeringame[i] = saveg_read8();\n\n    // get the times \n    a = saveg_read8();\n    b = saveg_read8();\n    c = saveg_read8();\n    leveltime = (a<<16) + (b<<8) + c; \n\n    return true;\n}\n\n//\n// Read the end of file marker.  Returns true if read successfully.\n// \n\nboolean P_ReadSaveGameEOF(void)\n{\n    int value;\n\n    value = saveg_read8();\n\n    return value == SAVEGAME_EOF;\n}\n\n//\n// Write the end of file marker\n//\n\nvoid P_WriteSaveGameEOF(void)\n{\n    saveg_write8(SAVEGAME_EOF);\n}\n\n//\n// P_ArchivePlayers\n//\nvoid P_ArchivePlayers (void)\n{\n    int\t\ti;\n\t\t\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (!playeringame[i])\n\t    continue;\n\t\n\tsaveg_write_pad();\n\n        saveg_write_player_t(&players[i]);\n    }\n}\n\n\n\n//\n// P_UnArchivePlayers\n//\nvoid P_UnArchivePlayers (void)\n{\n    int\t\ti;\n\t\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (!playeringame[i])\n\t    continue;\n\t\n\tsaveg_read_pad();\n\n        saveg_read_player_t(&players[i]);\n\t\n\t// will be set when unarc thinker\n\tplayers[i].mo = NULL;\t\n\tplayers[i].message = NULL;\n\tplayers[i].attacker = NULL;\n    }\n}\n\n\n//\n// P_ArchiveWorld\n//\nvoid P_ArchiveWorld (void)\n{\n    int\t\t\ti;\n    int\t\t\tj;\n    sector_t*\t\tsec;\n    line_t*\t\tli;\n    side_t*\t\tsi;\n    \n    // do sectors\n    for (i=0, sec = sectors ; i<numsectors ; i++,sec++)\n    {\n\tsaveg_write16(sec->floorheight >> FRACBITS);\n\tsaveg_write16(sec->ceilingheight >> FRACBITS);\n\tsaveg_write16(sec->floorpic);\n\tsaveg_write16(sec->ceilingpic);\n\tsaveg_write16(sec->lightlevel);\n\tsaveg_write16(sec->special);\t\t// needed?\n\tsaveg_write16(sec->tag);\t\t// needed?\n    }\n\n    \n    // do lines\n    for (i=0, li = lines ; i<numlines ; i++,li++)\n    {\n\tsaveg_write16(li->flags);\n\tsaveg_write16(li->special);\n\tsaveg_write16(li->tag);\n\tfor (j=0 ; j<2 ; j++)\n\t{\n\t    if ((short)(li->sidenum[j]) == -1)\n\t\tcontinue;\n\t    \n\t    si = &sides[li->sidenum[j]];\n\n\t    saveg_write16(si->textureoffset >> FRACBITS);\n\t    saveg_write16(si->rowoffset >> FRACBITS);\n\t    saveg_write16(si->toptexture);\n\t    saveg_write16(si->bottomtexture);\n\t    saveg_write16(si->midtexture);\t\n\t}\n    }\n}\n\n\n\n//\n// P_UnArchiveWorld\n//\nvoid P_UnArchiveWorld (void)\n{\n    int\t\t\ti;\n    int\t\t\tj;\n    sector_t*\t\tsec;\n    line_t*\t\tli;\n    side_t*\t\tsi;\n    \n    // do sectors\n    for (i=0, sec = sectors ; i<numsectors ; i++,sec++)\n    {\n\tsec->floorheight = saveg_read16() << FRACBITS;\n\tsec->ceilingheight = saveg_read16() << FRACBITS;\n\tsec->floorpic = saveg_read16();\n\tsec->ceilingpic = saveg_read16();\n\tsec->lightlevel = saveg_read16();\n\tsec->special = saveg_read16();\t\t// needed?\n\tsec->tag = saveg_read16();\t\t// needed?\n\tsec->floordata = 0;\n\tsec->ceilingdata = 0;\n\tsec->lightingdata = 0;\n\tsec->soundtarget = 0;\n    }\n    \n    // do lines\n    for (i=0, li = lines ; i<numlines ; i++,li++)\n    {\n\tli->flags = saveg_read16();\n\tli->special = saveg_read16();\n\tli->tag = saveg_read16();\n\tfor (j=0 ; j<2 ; j++)\n\t{\n\t    if ((short)(li->sidenum[j]) == -1)\n\t\tcontinue;\n\t    si = &sides[li->sidenum[j]];\n\t    si->textureoffset = saveg_read16() << FRACBITS;\n\t    si->rowoffset = saveg_read16() << FRACBITS;\n\t    si->toptexture = saveg_read16();\n\t    si->bottomtexture = saveg_read16();\n\t    si->midtexture = saveg_read16();\n\t}\n    }\n}\n\n\n\n\n\n//\n// Thinkers\n//\ntypedef enum\n{\n    tc_end,\n    tc_mobj\n\n} thinkerclass_t;\n\n\n//\n// P_ArchiveThinkers\n//\nvoid P_ArchiveThinkers (void)\n{\n    thinker_t*\t\tth;\n\n    // save off the current thinkers\n    for (th = thinkercap.next ; th != &thinkercap ; th=th->next)\n    {\n\tif (th->function.acp1 == (actionf_p1)P_MobjThinker)\n\t{\n            saveg_write8(tc_mobj);\n\t    saveg_write_pad();\n            saveg_write_mobj_t((mobj_t *) th);\n\n\t    continue;\n\t}\n\t\t\n\t// I_Error (\"P_ArchiveThinkers: Unknown thinker function\");\n    }\n\n    // add a terminating marker\n    saveg_write8(tc_end);\n}\n\n\n\n//\n// P_UnArchiveThinkers\n//\nvoid P_UnArchiveThinkers (void)\n{\n    byte\t\ttclass;\n    thinker_t*\t\tcurrentthinker;\n    thinker_t*\t\tnext;\n    mobj_t*\t\tmobj;\n    \n    // remove all the current thinkers\n    currentthinker = thinkercap.next;\n    while (currentthinker != &thinkercap)\n    {\n\tnext = currentthinker->next;\n\t\n\tif (currentthinker->function.acp1 == (actionf_p1)P_MobjThinker)\n\t    P_RemoveMobj ((mobj_t *)currentthinker);\n\telse\n\t    Z_Free (currentthinker);\n\n\tcurrentthinker = next;\n    }\n    P_InitThinkers ();\n    \n    // read in saved thinkers\n    while (1)\n    {\n\ttclass = saveg_read8();\n\tswitch (tclass)\n\t{\n\t  case tc_end:\n\t    return; \t// end of list\n\t\t\t\n\t  case tc_mobj:\n\t    saveg_read_pad();\n\t    mobj = Z_Malloc (sizeof(*mobj), PU_LEVEL, NULL);\n            saveg_read_mobj_t(mobj);\n\n\t    mobj->target = NULL;\n            mobj->tracer = NULL;\n\t    P_SetThingPosition (mobj);\n\t    mobj->info = &mobjinfo[mobj->type];\n\t    mobj->floorz = mobj->subsector->sector->floorheight;\n\t    mobj->ceilingz = mobj->subsector->sector->ceilingheight;\n\t    mobj->thinker.function.acp1 = (actionf_p1)P_MobjThinker;\n\t    P_AddThinker (&mobj->thinker);\n\t    break;\n\n\t  default:\n\t    I_Error (\"Unknown tclass %i in savegame\",tclass);\n\t}\n\t\n    }\n\n}\n\n\n//\n// P_ArchiveSpecials\n//\nenum\n{\n    tc_ceiling,\n    tc_door,\n    tc_floor,\n    tc_plat,\n    tc_flash,\n    tc_strobe,\n    tc_glow,\n    tc_endspecials\n\n} specials_e;\t\n\n\n\n//\n// Things to handle:\n//\n// T_MoveCeiling, (ceiling_t: sector_t * swizzle), - active list\n// T_VerticalDoor, (vldoor_t: sector_t * swizzle),\n// T_MoveFloor, (floormove_t: sector_t * swizzle),\n// T_LightFlash, (lightflash_t: sector_t * swizzle),\n// T_StrobeFlash, (strobe_t: sector_t *),\n// T_Glow, (glow_t: sector_t *),\n// T_PlatRaise, (plat_t: sector_t *), - active list\n//\nvoid P_ArchiveSpecials (void)\n{\n    thinker_t*\t\tth;\n    int\t\t\ti;\n\t\n    // save off the current thinkers\n    for (th = thinkercap.next ; th != &thinkercap ; th=th->next)\n    {\n\tif (th->function.acv == (actionf_v)NULL)\n\t{\n\t    for (i = 0; i < MAXCEILINGS;i++)\n\t\tif (activeceilings[i] == (ceiling_t *)th)\n\t\t    break;\n\t    \n\t    if (i<MAXCEILINGS)\n\t    {\n                saveg_write8(tc_ceiling);\n\t\tsaveg_write_pad();\n                saveg_write_ceiling_t((ceiling_t *) th);\n\t    }\n\t    continue;\n\t}\n\t\t\t\n\tif (th->function.acp1 == (actionf_p1)T_MoveCeiling)\n\t{\n            saveg_write8(tc_ceiling);\n\t    saveg_write_pad();\n            saveg_write_ceiling_t((ceiling_t *) th);\n\t    continue;\n\t}\n\t\t\t\n\tif (th->function.acp1 == (actionf_p1)T_VerticalDoor)\n\t{\n            saveg_write8(tc_door);\n\t    saveg_write_pad();\n            saveg_write_vldoor_t((vldoor_t *) th);\n\t    continue;\n\t}\n\t\t\t\n\tif (th->function.acp1 == (actionf_p1)T_MoveFloor)\n\t{\n            saveg_write8(tc_floor);\n\t    saveg_write_pad();\n            saveg_write_floormove_t((floormove_t *) th);\n\t    continue;\n\t}\n\t\t\t\n\tif (th->function.acp1 == (actionf_p1)T_PlatRaise)\n\t{\n            saveg_write8(tc_plat);\n\t    saveg_write_pad();\n            saveg_write_plat_t((plat_t *) th);\n\t    continue;\n\t}\n\t\t\t\n\tif (th->function.acp1 == (actionf_p1)T_LightFlash)\n\t{\n            saveg_write8(tc_flash);\n\t    saveg_write_pad();\n            saveg_write_lightflash_t((lightflash_t *) th);\n\t    continue;\n\t}\n\t\t\t\n\tif (th->function.acp1 == (actionf_p1)T_StrobeFlash)\n\t{\n            saveg_write8(tc_strobe);\n\t    saveg_write_pad();\n            saveg_write_strobe_t((strobe_t *) th);\n\t    continue;\n\t}\n\t\t\t\n\tif (th->function.acp1 == (actionf_p1)T_Glow)\n\t{\n            saveg_write8(tc_glow);\n\t    saveg_write_pad();\n            saveg_write_glow_t((glow_t *) th);\n\t    continue;\n\t}\n    }\n\t\n    // add a terminating marker\n    saveg_write8(tc_endspecials);\n\n}\n\n\n//\n// P_UnArchiveSpecials\n//\nvoid P_UnArchiveSpecials (void)\n{\n    byte\t\ttclass;\n    ceiling_t*\t\tceiling;\n    vldoor_t*\t\tdoor;\n    floormove_t*\tfloor;\n    plat_t*\t\tplat;\n    lightflash_t*\tflash;\n    strobe_t*\t\tstrobe;\n    glow_t*\t\tglow;\n\t\n\t\n    // read in saved thinkers\n    while (1)\n    {\n\ttclass = saveg_read8();\n\n\tswitch (tclass)\n\t{\n\t  case tc_endspecials:\n\t    return;\t// end of list\n\t\t\t\n\t  case tc_ceiling:\n\t    saveg_read_pad();\n\t    ceiling = Z_Malloc (sizeof(*ceiling), PU_LEVEL, NULL);\n            saveg_read_ceiling_t(ceiling);\n\t    ceiling->sector->ceilingdata = ceiling;\n\n\t    if (ceiling->thinker.function.acp1)\n\t\tceiling->thinker.function.acp1 = (actionf_p1)T_MoveCeiling;\n\n\t    P_AddThinker (&ceiling->thinker);\n\t    P_AddActiveCeiling(ceiling);\n\t    break;\n\t\t\t\t\n\t  case tc_door:\n\t    saveg_read_pad();\n\t    door = Z_Malloc (sizeof(*door), PU_LEVEL, NULL);\n            saveg_read_vldoor_t(door);\n\t    door->sector->ceilingdata = door;\n\t    door->thinker.function.acp1 = (actionf_p1)T_VerticalDoor;\n\t    P_AddThinker (&door->thinker);\n\t    break;\n\t\t\t\t\n\t  case tc_floor:\n\t    saveg_read_pad();\n\t    floor = Z_Malloc (sizeof(*floor), PU_LEVEL, NULL);\n            saveg_read_floormove_t(floor);\n\t    floor->sector->floordata = floor;\n\t    floor->thinker.function.acp1 = (actionf_p1)T_MoveFloor;\n\t    P_AddThinker (&floor->thinker);\n\t    break;\n\t\t\t\t\n\t  case tc_plat:\n\t    saveg_read_pad();\n\t    plat = Z_Malloc (sizeof(*plat), PU_LEVEL, NULL);\n            saveg_read_plat_t(plat);\n\t    plat->sector->floordata = plat;\n\n\t    if (plat->thinker.function.acp1)\n\t\tplat->thinker.function.acp1 = (actionf_p1)T_PlatRaise;\n\n\t    P_AddThinker (&plat->thinker);\n\t    P_AddActivePlat(plat);\n\t    break;\n\t\t\t\t\n\t  case tc_flash:\n\t    saveg_read_pad();\n\t    flash = Z_Malloc (sizeof(*flash), PU_LEVEL, NULL);\n            saveg_read_lightflash_t(flash);\n\t    flash->thinker.function.acp1 = (actionf_p1)T_LightFlash;\n\t    P_AddThinker (&flash->thinker);\n\t    break;\n\t\t\t\t\n\t  case tc_strobe:\n\t    saveg_read_pad();\n\t    strobe = Z_Malloc (sizeof(*strobe), PU_LEVEL, NULL);\n            saveg_read_strobe_t(strobe);\n\t    strobe->thinker.function.acp1 = (actionf_p1)T_StrobeFlash;\n\t    P_AddThinker (&strobe->thinker);\n\t    break;\n\t\t\t\t\n\t  case tc_glow:\n\t    saveg_read_pad();\n\t    glow = Z_Malloc (sizeof(*glow), PU_LEVEL, NULL);\n            saveg_read_glow_t(glow);\n\t    glow->thinker.function.acp1 = (actionf_p1)T_Glow;\n\t    P_AddThinker (&glow->thinker);\n\t    break;\n\t\t\t\t\n\t  default:\n\t    I_Error (\"P_UnarchiveSpecials:Unknown tclass %i \"\n\t\t     \"in savegame\",tclass);\n\t}\n\t\n    }\n\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//      Timer functions.\n//\n\n#include \"SDL.h\"\n\n#include \"i_timer.h\"\n#include \"doomtype.h\"\n\n//\n// I_GetTime\n// returns time in 1/35th second tics\n//\n\nstatic Uint32 basetime = 0;\n\nint  I_GetTime (void)\n{\n    Uint32 ticks;\n\n    ticks = SDL_GetTicks();\n\n    if (basetime == 0)\n        basetime = ticks;\n\n    ticks -= basetime;\n\n    return (ticks * TICRATE) / 1000;    \n}\n\n//\n// Same as I_GetTime, but returns time in milliseconds\n//\n\nint I_GetTimeMS(void)\n{\n    Uint32 ticks;\n\n    ticks = SDL_GetTicks();\n\n    if (basetime == 0)\n        basetime = ticks;\n\n    return ticks - basetime;\n}\n\n// Sleep for a specified number of ms\n\nvoid I_Sleep(int ms)\n{\n    SDL_Delay(ms);\n}\n\nvoid I_WaitVBL(int count)\n{\n    I_Sleep((count * 1000) / 70);\n}\n\n\nvoid I_InitTimer(void)\n{\n    // initialize timer\n\n#if SDL_VERSION_ATLEAST(2, 0, 5)\n    SDL_SetHint(SDL_HINT_WINDOWS_DISABLE_THREAD_NAMING, \"1\");\n#endif\n    SDL_Init(SDL_INIT_TIMER);\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\n\n\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"doomtype.h\"\n#include \"i_system.h\"\n#include \"m_misc.h\"\n#include \"m_argv.h\"  // haleyjd 20110212: warning fix\n\nint\t\tmyargc;\nchar**\t\tmyargv;\n\n\n\n\n//\n// M_CheckParm\n// Checks for the given parameter\n// in the program's command line arguments.\n// Returns the argument number (1 to argc-1)\n// or 0 if not present\n//\n\nint M_CheckParmWithArgs(const char *check, int num_args)\n{\n    int i;\n\n    for (i = 1; i < myargc - num_args; i++)\n    {\n\tif (!strcasecmp(check, myargv[i]))\n\t    return i;\n    }\n\n    return 0;\n}\n\n//\n// M_ParmExists\n//\n// Returns true if the given parameter exists in the program's command\n// line arguments, false if not.\n//\n\nboolean M_ParmExists(const char *check)\n{\n    return M_CheckParm(check) != 0;\n}\n\nint M_CheckParm(const char *check)\n{\n    return M_CheckParmWithArgs(check, 0);\n}\n\n#define MAXARGVS        100\n\nstatic void LoadResponseFile(int argv_index)\n{\n    FILE *handle;\n    int size;\n    char *infile;\n    char *file;\n    char *response_filename;\n    char **newargv;\n    int newargc;\n    int i, k;\n\n    response_filename = myargv[argv_index] + 1;\n\n    // Read the response file into memory\n    handle = fopen(response_filename, \"rb\");\n\n    if (handle == NULL)\n    {\n        printf (\"\\nNo such response file!\");\n        exit(1);\n    }\n\n    printf(\"Found response file %s!\\n\", response_filename);\n\n    size = M_FileLength(handle);\n\n    // Read in the entire file\n    // Allocate one byte extra - this is in case there is an argument\n    // at the end of the response file, in which case a '\\0' will be\n    // needed.\n\n    file = malloc(size + 1);\n\n    i = 0;\n\n    while (i < size)\n    {\n        k = fread(file + i, 1, size - i, handle);\n\n        if (k < 0)\n        {\n            I_Error(\"Failed to read full contents of '%s'\", response_filename);\n        }\n\n        i += k;\n    }\n\n    fclose(handle);\n\n    // Create new arguments list array\n\n    newargv = malloc(sizeof(char *) * MAXARGVS);\n    newargc = 0;\n    memset(newargv, 0, sizeof(char *) * MAXARGVS);\n\n    // Copy all the arguments in the list up to the response file\n\n    for (i=0; i<argv_index; ++i)\n    {\n        newargv[i] = myargv[i];\n        ++newargc;\n    }\n\n    infile = file;\n    k = 0;\n\n    while(k < size)\n    {\n        // Skip past space characters to the next argument\n\n        while(k < size && isspace(infile[k]))\n        {\n            ++k;\n        }\n\n        if (k >= size)\n        {\n            break;\n        }\n\n        // If the next argument is enclosed in quote marks, treat\n        // the contents as a single argument.  This allows long filenames\n        // to be specified.\n\n        if (infile[k] == '\\\"')\n        {\n            // Skip the first character(\")\n            ++k;\n\n            newargv[newargc++] = &infile[k];\n\n            // Read all characters between quotes\n\n            while (k < size && infile[k] != '\\\"' && infile[k] != '\\n')\n            {\n                ++k;\n            }\n\n            if (k >= size || infile[k] == '\\n')\n            {\n                I_Error(\"Quotes unclosed in response file '%s'\",\n                        response_filename);\n            }\n\n            // Cut off the string at the closing quote\n\n            infile[k] = '\\0';\n            ++k;\n        }\n        else\n        {\n            // Read in the next argument until a space is reached\n\n            newargv[newargc++] = &infile[k];\n\n            while(k < size && !isspace(infile[k]))\n            {\n                ++k;\n            }\n\n            // Cut off the end of the argument at the first space\n\n            infile[k] = '\\0';\n\n            ++k;\n        }\n    }\n\n    // Add arguments following the response file argument\n\n    for (i=argv_index + 1; i<myargc; ++i)\n    {\n        newargv[newargc] = myargv[i];\n        ++newargc;\n    }\n\n    myargv = newargv;\n    myargc = newargc;\n\n#if 0\n    // Disabled - Vanilla Doom does not do this.\n    // Display arguments\n\n    printf(\"%d command-line args:\\n\", myargc);\n\n    for (k=1; k<myargc; k++)\n    {\n        printf(\"'%s'\\n\", myargv[k]);\n    }\n#endif\n}\n\n//\n// Find a Response File\n//\n\nvoid M_FindResponseFile(void)\n{\n    int             i;\n\n    for (i = 1; i < myargc; i++)\n    {\n        if (myargv[i][0] == '@')\n        {\n            LoadResponseFile(i);\n        }\n    }\n}\n\n// Return the name of the executable used to start the program:\n\nchar *M_GetExecutableName(void)\n{\n    char *sep;\n\n    sep = strrchr(myargv[0], DIR_SEPARATOR);\n\n    if (sep == NULL)\n    {\n        return myargv[0];\n    }\n    else\n    {\n        return sep + 1;\n    }\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tMain loop menu stuff.\n//\tRandom number LUT.\n//\tDefault Config File.\n//\tPCX Screenshots.\n//\n\n\n\n#include \"m_bbox.h\"\n\n\n\n\nvoid M_ClearBox (fixed_t *box)\n{\n    box[BOXTOP] = box[BOXRIGHT] = INT_MIN;\n    box[BOXBOTTOM] = box[BOXLEFT] = INT_MAX;\n}\n\nvoid\nM_AddToBox\n( fixed_t*\tbox,\n  fixed_t\tx,\n  fixed_t\ty )\n{\n    if (x<box[BOXLEFT])\n\tbox[BOXLEFT] = x;\n    else if (x>box[BOXRIGHT])\n\tbox[BOXRIGHT] = x;\n    if (y<box[BOXBOTTOM])\n\tbox[BOXBOTTOM] = y;\n    else if (y>box[BOXTOP])\n\tbox[BOXTOP] = y;\n}\n\n\n\n\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tCheat sequence checking.\n//\n\n\n\n#include <string.h>\n\n#include \"doomtype.h\"\n#include \"m_cheat.h\"\n\n//\n// CHEAT SEQUENCE PACKAGE\n//\n\n//\n// Called in st_stuff module, which handles the input.\n// Returns a 1 if the cheat was successful, 0 if failed.\n//\nint\ncht_CheckCheat\n( cheatseq_t*\tcht,\n  char\t\tkey )\n{\n    // if we make a short sequence on a cheat with parameters, this \n    // will not work in vanilla doom.  behave the same.\n\n    if (cht->parameter_chars > 0 && strlen(cht->sequence) < cht->sequence_len)\n        return false;\n\n    if (cht->chars_read < 0)\n        cht->chars_read = 0;\n    \n    if (cht->chars_read < strlen(cht->sequence))\n    {\n        // still reading characters from the cheat code\n        // and verifying.  reset back to the beginning \n        // if a key is wrong\n\n        if (key == cht->sequence[cht->chars_read])\n            ++cht->chars_read;\n        else\n            cht->chars_read = 0;\n        \n        cht->param_chars_read = 0;\n    }\n    else if (cht->param_chars_read < cht->parameter_chars)\n    {\n        // we have passed the end of the cheat sequence and are \n        // entering parameters now \n        \n        cht->parameter_buf[cht->param_chars_read] = key;\n        \n        ++cht->param_chars_read;\n    }\n\n    if (cht->chars_read >= strlen(cht->sequence)\n     && cht->param_chars_read >= cht->parameter_chars)\n    {\n        cht->chars_read = cht->param_chars_read = 0;\n        return true;\n    }\n    \n    // cheat not matched yet\n\n    return false;\n}\n\nvoid\ncht_GetParam\n( cheatseq_t*\tcht,\n  char*\t\tbuffer )\n{\n    memcpy(buffer, cht->parameter_buf, cht->parameter_chars);\n}\n\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 1993-2008 Raven Software\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//    Configuration file interface.\n//\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#include <assert.h>\n\n#include \"SDL_filesystem.h\"\n\n#include \"config.h\"\n\n#include \"doomtype.h\"\n#include \"doomkeys.h\"\n#include \"i_system.h\"\n#include \"m_argv.h\"\n#include \"m_misc.h\"\n\n#include \"z_zone.h\"\n\n//\n// DEFAULTS\n//\n\n// Location where all configuration data is stored - \n// default.cfg, savegames, etc.\n\nconst char *configdir;\n\n// Default filenames for configuration files.\n\nstatic char *default_main_config;\nstatic char *default_extra_config;\n\ntypedef enum \n{\n    DEFAULT_INT,\n    DEFAULT_INT_HEX,\n    DEFAULT_STRING,\n    DEFAULT_FLOAT,\n    DEFAULT_KEY,\n} default_type_t;\n\ntypedef struct\n{\n    // Name of the variable\n    char *name;\n\n    // Pointer to the location in memory of the variable\n    union {\n        int *i;\n        char **s;\n        float *f;\n    } location;\n\n    // Type of the variable\n    default_type_t type;\n\n    // If this is a key value, the original integer scancode we read from\n    // the config file before translating it to the internal key value.\n    // If zero, we didn't read this value from a config file.\n    int untranslated;\n\n    // The value we translated the scancode into when we read the \n    // config file on startup.  If the variable value is different from\n    // this, it has been changed and needs to be converted; otherwise,\n    // use the 'untranslated' value.\n    int original_translated;\n\n    // If true, this config variable has been bound to a variable\n    // and is being used.\n    boolean bound;\n} default_t;\n\ntypedef struct\n{\n    default_t *defaults;\n    int numdefaults;\n    char *filename;\n} default_collection_t;\n\n#define CONFIG_VARIABLE_GENERIC(name, type) \\\n    { #name, {NULL}, type, 0, 0, false }\n\n#define CONFIG_VARIABLE_KEY(name) \\\n    CONFIG_VARIABLE_GENERIC(name, DEFAULT_KEY)\n#define CONFIG_VARIABLE_INT(name) \\\n    CONFIG_VARIABLE_GENERIC(name, DEFAULT_INT)\n#define CONFIG_VARIABLE_INT_HEX(name) \\\n    CONFIG_VARIABLE_GENERIC(name, DEFAULT_INT_HEX)\n#define CONFIG_VARIABLE_FLOAT(name) \\\n    CONFIG_VARIABLE_GENERIC(name, DEFAULT_FLOAT)\n#define CONFIG_VARIABLE_STRING(name) \\\n    CONFIG_VARIABLE_GENERIC(name, DEFAULT_STRING)\n\n//! @begin_config_file default\n\nstatic default_t\tdoom_defaults_list[] =\n{\n    //!\n    // Mouse sensitivity.  This value is used to multiply input mouse\n    // movement to control the effect of moving the mouse.\n    //\n    // The \"normal\" maximum value available for this through the\n    // in-game options menu is 9. A value of 31 or greater will cause\n    // the game to crash when entering the options menu.\n    //\n\n    CONFIG_VARIABLE_INT(mouse_sensitivity),\n\n    //!\n    // Volume of sound effects, range 0-15.\n    //\n\n    CONFIG_VARIABLE_INT(sfx_volume),\n\n    //!\n    // Volume of in-game music, range 0-15.\n    //\n\n    CONFIG_VARIABLE_INT(music_volume),\n\n    //!\n    // @game strife\n    //\n    // If non-zero, dialogue text is displayed over characters' pictures\n    // when engaging actors who have voices.\n    //\n\n    CONFIG_VARIABLE_INT(show_talk),\n\n    //!\n    // @game strife\n    //\n    // Volume of voice sound effects, range 0-15.\n    //\n\n    CONFIG_VARIABLE_INT(voice_volume),\n\n    //!\n    // @game doom\n    //\n    // If non-zero, messages are displayed on the heads-up display\n    // in the game (\"picked up a clip\", etc).  If zero, these messages\n    // are not displayed.\n    //\n\n    CONFIG_VARIABLE_INT(show_messages),\n\n    //!\n    // Keyboard key to turn right.\n    //\n\n    CONFIG_VARIABLE_KEY(key_right),\n\n    //!\n    // Keyboard key to turn left.\n    //\n\n    CONFIG_VARIABLE_KEY(key_left),\n\n    //!\n    // Keyboard key to move forward.\n    //\n\n    CONFIG_VARIABLE_KEY(key_up),\n\n    //!\n    // Keyboard key to move backward.\n    //\n\n    CONFIG_VARIABLE_KEY(key_down),\n\n    //!\n    // Keyboard key to strafe left.\n    //\n\n    CONFIG_VARIABLE_KEY(key_strafeleft),\n\n    //!\n    // Keyboard key to strafe right.\n    //\n\n    CONFIG_VARIABLE_KEY(key_straferight),\n\n    //!\n    // @game strife\n    //\n    // Keyboard key to use health.\n    //\n\n    CONFIG_VARIABLE_KEY(key_useHealth),\n\n    //!\n    // @game hexen\n    //\n    // Keyboard key to jump.\n    //\n\n    CONFIG_VARIABLE_KEY(key_jump),\n\n    //!\n    // @game heretic hexen\n    //\n    // Keyboard key to fly upward.\n    //\n\n    CONFIG_VARIABLE_KEY(key_flyup),\n\n    //!\n    // @game heretic hexen\n    //\n    // Keyboard key to fly downwards.\n    //\n\n    CONFIG_VARIABLE_KEY(key_flydown),\n\n    //!\n    // @game heretic hexen\n    //\n    // Keyboard key to center flying.\n    //\n\n    CONFIG_VARIABLE_KEY(key_flycenter),\n\n    //!\n    // @game heretic hexen\n    //\n    // Keyboard key to look up.\n    //\n\n    CONFIG_VARIABLE_KEY(key_lookup),\n\n    //!\n    // @game heretic hexen\n    //\n    // Keyboard key to look down.\n    //\n\n    CONFIG_VARIABLE_KEY(key_lookdown),\n\n    //!\n    // @game heretic hexen\n    //\n    // Keyboard key to center the view.\n    //\n\n    CONFIG_VARIABLE_KEY(key_lookcenter),\n\n    //!\n    // @game strife\n    //\n    // Keyboard key to query inventory.\n    //\n\n    CONFIG_VARIABLE_KEY(key_invquery),\n\n    //!\n    // @game strife\n    //\n    // Keyboard key to display mission objective.\n    //\n\n    CONFIG_VARIABLE_KEY(key_mission),\n\n    //!\n    // @game strife\n    //\n    // Keyboard key to display inventory popup.\n    //\n\n    CONFIG_VARIABLE_KEY(key_invPop),\n\n    //!\n    // @game strife\n    //\n    // Keyboard key to display keys popup.\n    //\n\n    CONFIG_VARIABLE_KEY(key_invKey),\n\n    //!\n    // @game strife\n    //\n    // Keyboard key to jump to start of inventory.\n    //\n\n    CONFIG_VARIABLE_KEY(key_invHome),\n\n    //!\n    // @game strife\n    //\n    // Keyboard key to jump to end of inventory.\n    //\n\n    CONFIG_VARIABLE_KEY(key_invEnd),\n\n    //!\n    // @game heretic hexen\n    //\n    // Keyboard key to scroll left in the inventory.\n    //\n\n    CONFIG_VARIABLE_KEY(key_invleft),\n\n    //!\n    // @game heretic hexen\n    //\n    // Keyboard key to scroll right in the inventory.\n    //\n\n    CONFIG_VARIABLE_KEY(key_invright),\n\n    //!\n    // @game strife\n    //\n    // Keyboard key to scroll left in the inventory.\n    //\n\n    CONFIG_VARIABLE_KEY(key_invLeft),\n\n    //!\n    // @game strife\n    //\n    // Keyboard key to scroll right in the inventory.\n    //\n\n    CONFIG_VARIABLE_KEY(key_invRight),\n\n    //!\n    // @game heretic hexen\n    //\n    // Keyboard key to use the current item in the inventory.\n    //\n\n    CONFIG_VARIABLE_KEY(key_useartifact),\n\n    //!\n    // @game strife\n    //\n    // Keyboard key to use inventory item.\n    //\n\n    CONFIG_VARIABLE_KEY(key_invUse),\n\n    //!\n    // @game strife\n    //\n    // Keyboard key to drop an inventory item.\n    //\n\n    CONFIG_VARIABLE_KEY(key_invDrop),\n\n    //!\n    // @game strife\n    //\n    // Keyboard key to look up.\n    //\n\n    CONFIG_VARIABLE_KEY(key_lookUp),\n\n    //!\n    // @game strife\n    //\n    // Keyboard key to look down.\n    //\n\n    CONFIG_VARIABLE_KEY(key_lookDown),\n\n    //!\n    // Keyboard key to fire the currently selected weapon.\n    //\n\n    CONFIG_VARIABLE_KEY(key_fire),\n\n    //!\n    // Keyboard key to \"use\" an object, eg. a door or switch.\n    //\n\n    CONFIG_VARIABLE_KEY(key_use),\n\n    //!\n    // Keyboard key to turn on strafing.  When held down, pressing the\n    // key to turn left or right causes the player to strafe left or\n    // right instead.\n    //\n\n    CONFIG_VARIABLE_KEY(key_strafe),\n\n    //!\n    // Keyboard key to make the player run.\n    //\n\n    CONFIG_VARIABLE_KEY(key_speed),\n\n    //!\n    // If non-zero, mouse input is enabled.  If zero, mouse input is\n    // disabled.\n    //\n\n    CONFIG_VARIABLE_INT(use_mouse),\n\n    //!\n    // Mouse button to fire the currently selected weapon.\n    //\n\n    CONFIG_VARIABLE_INT(mouseb_fire),\n\n    //!\n    // Mouse button to turn on strafing.  When held down, the player\n    // will strafe left and right instead of turning left and right.\n    //\n\n    CONFIG_VARIABLE_INT(mouseb_strafe),\n\n    //!\n    // Mouse button to move forward.\n    //\n\n    CONFIG_VARIABLE_INT(mouseb_forward),\n\n    //!\n    // @game hexen strife\n    //\n    // Mouse button to jump.\n    //\n\n    CONFIG_VARIABLE_INT(mouseb_jump),\n\n    //!\n    // If non-zero, joystick input is enabled.\n    //\n\n    CONFIG_VARIABLE_INT(use_joystick),\n\n    //!\n    // Joystick virtual button that fires the current weapon.\n    //\n\n    CONFIG_VARIABLE_INT(joyb_fire),\n\n    //!\n    // Joystick virtual button that makes the player strafe while\n    // held down.\n    //\n\n    CONFIG_VARIABLE_INT(joyb_strafe),\n\n    //!\n    // Joystick virtual button to \"use\" an object, eg. a door or switch.\n    //\n\n    CONFIG_VARIABLE_INT(joyb_use),\n\n    //!\n    // Joystick virtual button that makes the player run while held\n    // down.\n    //\n    // If this has a value of 20 or greater, the player will always run,\n    // even if use_joystick is 0.\n    //\n\n    CONFIG_VARIABLE_INT(joyb_speed),\n\n    //!\n    // @game hexen strife\n    //\n    // Joystick virtual button that makes the player jump.\n    //\n\n    CONFIG_VARIABLE_INT(joyb_jump),\n\n    //!\n    // @game doom heretic hexen\n    //\n    // Screen size, range 3-11.\n    //\n    // A value of 11 gives a full-screen view with the status bar not\n    // displayed.  A value of 10 gives a full-screen view with the\n    // status bar displayed.\n    //\n\n    CONFIG_VARIABLE_INT(screenblocks),\n\n    //!\n    // @game strife\n    //\n    // Screen size, range 3-11.\n    //\n    // A value of 11 gives a full-screen view with the status bar not\n    // displayed.  A value of 10 gives a full-screen view with the\n    // status bar displayed.\n    //\n\n    CONFIG_VARIABLE_INT(screensize),\n\n    //!\n    // @game doom\n    //\n    // Screen detail.  Zero gives normal \"high detail\" mode, while\n    // a non-zero value gives \"low detail\" mode.\n    //\n\n    CONFIG_VARIABLE_INT(detaillevel),\n\n    //!\n    // Number of sounds that will be played simultaneously.\n    //\n\n    CONFIG_VARIABLE_INT(snd_channels),\n\n    //!\n    // Music output device.  A non-zero value gives MIDI sound output,\n    // while a value of zero disables music.\n    //\n\n    CONFIG_VARIABLE_INT(snd_musicdevice),\n\n    //!\n    // Sound effects device.  A value of zero disables in-game sound\n    // effects, a value of 1 enables PC speaker sound effects, while\n    // a value in the range 2-9 enables the \"normal\" digital sound\n    // effects.\n    //\n\n    CONFIG_VARIABLE_INT(snd_sfxdevice),\n\n    //!\n    // SoundBlaster I/O port. Unused.\n    //\n\n    CONFIG_VARIABLE_INT(snd_sbport),\n\n    //!\n    // SoundBlaster IRQ.  Unused.\n    //\n\n    CONFIG_VARIABLE_INT(snd_sbirq),\n\n    //!\n    // SoundBlaster DMA channel.  Unused.\n    //\n\n    CONFIG_VARIABLE_INT(snd_sbdma),\n\n    //!\n    // Output port to use for OPL MIDI playback.  Unused.\n    //\n\n    CONFIG_VARIABLE_INT(snd_mport),\n\n    //!\n    // Gamma correction level.  A value of zero disables gamma\n    // correction, while a value in the range 1-4 gives increasing\n    // levels of gamma correction.\n    //\n\n    CONFIG_VARIABLE_INT(usegamma),\n\n    //!\n    // @game hexen\n    //\n    // Directory in which to store savegames.\n    //\n\n    CONFIG_VARIABLE_STRING(savedir),\n\n    //!\n    // @game hexen\n    //\n    // Controls whether messages are displayed in the heads-up display.\n    // If this has a non-zero value, messages are displayed.\n    //\n\n    CONFIG_VARIABLE_INT(messageson),\n\n    //!\n    // @game strife\n    //\n    // Name of background flat used by view border.\n    //\n\n    CONFIG_VARIABLE_STRING(back_flat),\n\n    //!\n    // @game strife\n    //\n    // Multiplayer nickname (?).\n    //\n\n    CONFIG_VARIABLE_STRING(nickname),\n\n    //!\n    // Multiplayer chat macro: message to send when alt+0 is pressed.\n    //\n\n    CONFIG_VARIABLE_STRING(chatmacro0),\n\n    //!\n    // Multiplayer chat macro: message to send when alt+1 is pressed.\n    //\n\n    CONFIG_VARIABLE_STRING(chatmacro1),\n\n    //!\n    // Multiplayer chat macro: message to send when alt+2 is pressed.\n    //\n\n    CONFIG_VARIABLE_STRING(chatmacro2),\n\n    //!\n    // Multiplayer chat macro: message to send when alt+3 is pressed.\n    //\n\n    CONFIG_VARIABLE_STRING(chatmacro3),\n\n    //!\n    // Multiplayer chat macro: message to send when alt+4 is pressed.\n    //\n\n    CONFIG_VARIABLE_STRING(chatmacro4),\n\n    //!\n    // Multiplayer chat macro: message to send when alt+5 is pressed.\n    //\n\n    CONFIG_VARIABLE_STRING(chatmacro5),\n\n    //!\n    // Multiplayer chat macro: message to send when alt+6 is pressed.\n    //\n\n    CONFIG_VARIABLE_STRING(chatmacro6),\n\n    //!\n    // Multiplayer chat macro: message to send when alt+7 is pressed.\n    //\n\n    CONFIG_VARIABLE_STRING(chatmacro7),\n\n    //!\n    // Multiplayer chat macro: message to send when alt+8 is pressed.\n    //\n\n    CONFIG_VARIABLE_STRING(chatmacro8),\n\n    //!\n    // Multiplayer chat macro: message to send when alt+9 is pressed.\n    //\n\n    CONFIG_VARIABLE_STRING(chatmacro9),\n\n    //!\n    // @game strife\n    //\n    // Serial port number to use for SERSETUP.EXE (unused).\n    //\n\n    CONFIG_VARIABLE_INT(comport),\n};\n\nstatic default_collection_t doom_defaults =\n{\n    doom_defaults_list,\n    arrlen(doom_defaults_list),\n    NULL,\n};\n\n//! @begin_config_file extended\n\nstatic default_t extra_defaults_list[] =\n{\n    //!\n    // Name of the SDL video driver to use.  If this is an empty string,\n    // the default video driver is used.\n    //\n\n    CONFIG_VARIABLE_STRING(video_driver),\n\n    //!\n    // Position of the window on the screen when running in windowed\n    // mode. Accepted values are: \"\" (empty string) - don't care,\n    // \"center\" - place window at center of screen, \"x,y\" - place\n    // window at the specified coordinates.\n    //\n\n    CONFIG_VARIABLE_STRING(window_position),\n\n    //!\n    // If non-zero, the game will run in full screen mode.  If zero,\n    // the game will run in a window.\n    //\n\n    CONFIG_VARIABLE_INT(fullscreen),\n\n    //!\n    // Index of the display on which the game should run. This has no\n    // effect if running in windowed mode (fullscreen=0) and\n    // window_position is not set to \"center\".\n    //\n\n    CONFIG_VARIABLE_INT(video_display),\n\n    //!\n    // If non-zero, the screen will be stretched vertically to display\n    // correctly on a square pixel video mode.\n    //\n\n    CONFIG_VARIABLE_INT(aspect_ratio_correct),\n\n    //!\n    // If non-zero, forces integer scales for resolution-independent rendering.\n    //\n\n    CONFIG_VARIABLE_INT(integer_scaling),\n\n    // If non-zero, any pillar/letter boxes drawn around the game area\n    // will \"flash\" when the game palette changes, simulating the VGA\n    // \"porch\"\n\n    CONFIG_VARIABLE_INT(vga_porch_flash),\n\n    //!\n    // Window width when running in windowed mode.\n    //\n\n    CONFIG_VARIABLE_INT(window_width),\n\n    //!\n    // Window height when running in windowed mode.\n    //\n\n    CONFIG_VARIABLE_INT(window_height),\n\n    //!\n    // Width for screen mode when running fullscreen.\n    // If this and fullscreen_height are both set to zero, we run\n    // fullscreen as a desktop window that covers the entire screen,\n    // rather than ever switching screen modes. It should usually\n    // be unnecessary to set this value.\n    //\n\n    CONFIG_VARIABLE_INT(fullscreen_width),\n\n    //!\n    // Height for screen mode when running fullscreen.\n    // See documentation for fullscreen_width.\n    //\n\n    CONFIG_VARIABLE_INT(fullscreen_height),\n\n    //!\n    // If non-zero, force the use of a software renderer. For use on\n    // systems lacking hardware acceleration.\n    //\n\n    CONFIG_VARIABLE_INT(force_software_renderer),\n\n    //!\n    // Maximum number of pixels to use for intermediate scaling buffer.\n    // More pixels mean that the screen can be rendered more precisely,\n    // but there are diminishing returns on quality. The default limits to\n    // 16,000,000 pixels, which is enough to cover 4K monitor standards.\n\n    CONFIG_VARIABLE_INT(max_scaling_buffer_pixels),\n\n    //!\n    // Number of milliseconds to wait on startup after the video mode\n    // has been set, before the game will start.  This allows the\n    // screen to settle on some monitors that do not display an image\n    // for a brief interval after changing video modes.\n    //\n\n    CONFIG_VARIABLE_INT(startup_delay),\n\n    //!\n    // @game heretic hexen strife\n    //\n    // If non-zero, display the graphical startup screen.\n    //\n\n    CONFIG_VARIABLE_INT(graphical_startup),\n\n    //!\n    // @game doom heretic strife\n    //\n    // If non-zero, the ENDOOM text screen is displayed when exiting the\n    // game. If zero, the ENDOOM screen is not displayed.\n    //\n\n    CONFIG_VARIABLE_INT(show_endoom),\n\n    //!\n    // @game doom strife\n    //\n    // If non-zero, a disk activity indicator is displayed when data is read\n    // from disk. If zero, the disk activity indicator is not displayed.\n    //\n\n    CONFIG_VARIABLE_INT(show_diskicon),\n\n    //!\n    // If non-zero, save screenshots in PNG format. If zero, screenshots are\n    // saved in PCX format, as Vanilla Doom does.\n    //\n\n    CONFIG_VARIABLE_INT(png_screenshots),\n\n    //!\n    // Sound output sample rate, in Hz.  Typical values to use are\n    // 11025, 22050, 44100 and 48000.\n    //\n\n    CONFIG_VARIABLE_INT(snd_samplerate),\n\n    //!\n    // Maximum number of bytes to allocate for caching converted sound\n    // effects in memory. If set to zero, there is no limit applied.\n    //\n\n    CONFIG_VARIABLE_INT(snd_cachesize),\n\n    //!\n    // Maximum size of the output sound buffer size in milliseconds.\n    // Sound output is generated periodically in slices. Higher values\n    // might be more efficient but will introduce latency to the\n    // sound output. The default is 28ms (one slice per tic with the\n    // 35fps timer).\n    //\n\n    CONFIG_VARIABLE_INT(snd_maxslicetime_ms),\n\n    //!\n    // If non-zero, sound effects will have their pitch varied up or\n    // down by a random amount during play. If zero, sound effects\n    // play back at their default pitch.\n    //\n\n    CONFIG_VARIABLE_INT(snd_pitchshift),\n\n    //!\n    // External command to invoke to perform MIDI playback. If set to\n    // the empty string, SDL_mixer's internal MIDI playback is used.\n    // This only has any effect when snd_musicdevice is set to General\n    // MIDI output.\n    //\n\n    CONFIG_VARIABLE_STRING(snd_musiccmd),\n\n    //!\n    // Value to set for the DMXOPTION environment variable. If this contains\n    // \"-opl3\", output for an OPL3 chip is generated when in OPL MIDI\n    // playback mode.\n    //\n\n    CONFIG_VARIABLE_STRING(snd_dmxoption),\n\n    //!\n    // The I/O port to use to access the OPL chip.  Only relevant when\n    // using native OPL music playback.\n    //\n\n    CONFIG_VARIABLE_INT_HEX(opl_io_port),\n\n    //!\n    // Full path to a directory containing configuration files for\n    // substitute music packs. These packs contain high quality renderings\n    // of game music to be played instead of using the system's built-in\n    // MIDI playback.\n    //\n\n    CONFIG_VARIABLE_STRING(music_pack_path),\n\n    //!\n    // Full path to a Timidity configuration file to use for MIDI\n    // playback. The file will be evaluated from the directory where\n    // it is evaluated, so there is no need to add \"dir\" commands\n    // into it.\n    //\n\n    CONFIG_VARIABLE_STRING(timidity_cfg_path),\n\n    //!\n    // Path to GUS patch files to use when operating in GUS emulation\n    // mode.\n    //\n\n    CONFIG_VARIABLE_STRING(gus_patch_path),\n\n    //!\n    // Number of kilobytes of RAM to use in GUS emulation mode. Valid\n    // values are 256, 512, 768 or 1024.\n    //\n\n    CONFIG_VARIABLE_INT(gus_ram_kb),\n\n    //!\n    // @game doom strife\n    //\n    // If non-zero, the Vanilla savegame limit is enforced; if the\n    // savegame exceeds 180224 bytes in size, the game will exit with\n    // an error.  If this has a value of zero, there is no limit to\n    // the size of savegames.\n    //\n\n    CONFIG_VARIABLE_INT(vanilla_savegame_limit),\n\n    //!\n    // @game doom strife\n    //\n    // If non-zero, the Vanilla demo size limit is enforced; the game\n    // exits with an error when a demo exceeds the demo size limit\n    // (128KiB by default).  If this has a value of zero, there is no\n    // limit to the size of demos.\n    //\n\n    CONFIG_VARIABLE_INT(vanilla_demo_limit),\n\n    //!\n    // If non-zero, the game behaves like Vanilla Doom, always assuming\n    // an American keyboard mapping.  If this has a value of zero, the\n    // native keyboard mapping of the keyboard is used.\n    //\n\n    CONFIG_VARIABLE_INT(vanilla_keyboard_mapping),\n\n    //!\n    // Name to use in network games for identification.  This is only\n    // used on the \"waiting\" screen while waiting for the game to start.\n    //\n\n    CONFIG_VARIABLE_STRING(player_name),\n\n    //!\n    // If this is non-zero, the mouse will be \"grabbed\" when running\n    // in windowed mode so that it can be used as an input device.\n    // When running full screen, this has no effect.\n    //\n\n    CONFIG_VARIABLE_INT(grabmouse),\n\n    //!\n    // If non-zero, all vertical mouse movement is ignored.  This\n    // emulates the behavior of the \"novert\" tool available under DOS\n    // that performs the same function.\n    //\n\n    CONFIG_VARIABLE_INT(novert),\n\n    //!\n    // Mouse acceleration factor.  When the speed of mouse movement\n    // exceeds the threshold value (mouse_threshold), the speed is\n    // multiplied by this value.\n    //\n\n    CONFIG_VARIABLE_FLOAT(mouse_acceleration),\n\n    //!\n    // Mouse acceleration threshold.  When the speed of mouse movement\n    // exceeds this threshold value, the speed is multiplied by an\n    // acceleration factor (mouse_acceleration).\n    //\n\n    CONFIG_VARIABLE_INT(mouse_threshold),\n\n    //!\n    // Mouse button to strafe left.\n    //\n\n    CONFIG_VARIABLE_INT(mouseb_strafeleft),\n\n    //!\n    // Mouse button to strafe right.\n    //\n\n    CONFIG_VARIABLE_INT(mouseb_straferight),\n\n    //!\n    // Mouse button to \"use\" an object, eg. a door or switch.\n    //\n\n    CONFIG_VARIABLE_INT(mouseb_use),\n\n    //!\n    // Mouse button to move backwards.\n    //\n\n    CONFIG_VARIABLE_INT(mouseb_backward),\n\n    //!\n    // Mouse button to cycle to the previous weapon.\n    //\n\n    CONFIG_VARIABLE_INT(mouseb_prevweapon),\n\n    //!\n    // Mouse button to cycle to the next weapon.\n    //\n\n    CONFIG_VARIABLE_INT(mouseb_nextweapon),\n\n    //!\n    // If non-zero, double-clicking a mouse button acts like pressing\n    // the \"use\" key to use an object in-game, eg. a door or switch.\n    //\n\n    CONFIG_VARIABLE_INT(dclick_use),\n\n    //!\n    // SDL GUID string indicating the joystick to use. An empty string\n    // indicates that no joystick is configured.\n    //\n\n    CONFIG_VARIABLE_STRING(joystick_guid),\n\n    //!\n    // Index of SDL joystick to use; this is only used in the case where\n    // multiple identical joystick devices are connected which have the\n    // same GUID, to distinguish between devices.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_index),\n\n    //!\n    // Joystick axis to use to for horizontal (X) movement.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_x_axis),\n\n    //!\n    // If non-zero, movement on the horizontal joystick axis is inverted.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_x_invert),\n\n    //!\n    // Joystick axis to use to for vertical (Y) movement.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_y_axis),\n\n    //!\n    // If non-zero, movement on the vertical joystick axis is inverted.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_y_invert),\n\n    //!\n    // Joystick axis to use to for strafing movement.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_strafe_axis),\n\n    //!\n    // If non-zero, movement on the joystick axis used for strafing\n    // is inverted.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_strafe_invert),\n\n    //!\n    // Joystick axis to use to for looking up and down.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_look_axis),\n\n    //!\n    // If non-zero, movement on the joystick axis used for looking\n    // is inverted.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_look_invert),\n\n    //!\n    // The physical joystick button that corresponds to joystick\n    // virtual button #0.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_physical_button0),\n\n    //!\n    // The physical joystick button that corresponds to joystick\n    // virtual button #1.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_physical_button1),\n\n    //!\n    // The physical joystick button that corresponds to joystick\n    // virtual button #2.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_physical_button2),\n\n    //!\n    // The physical joystick button that corresponds to joystick\n    // virtual button #3.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_physical_button3),\n\n    //!\n    // The physical joystick button that corresponds to joystick\n    // virtual button #4.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_physical_button4),\n\n    //!\n    // The physical joystick button that corresponds to joystick\n    // virtual button #5.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_physical_button5),\n\n    //!\n    // The physical joystick button that corresponds to joystick\n    // virtual button #6.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_physical_button6),\n\n    //!\n    // The physical joystick button that corresponds to joystick\n    // virtual button #7.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_physical_button7),\n\n    //!\n    // The physical joystick button that corresponds to joystick\n    // virtual button #8.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_physical_button8),\n\n    //!\n    // The physical joystick button that corresponds to joystick\n    // virtual button #9.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_physical_button9),\n\n    //!\n    // The physical joystick button that corresponds to joystick\n    // virtual button #10.\n    //\n\n    CONFIG_VARIABLE_INT(joystick_physical_button10),\n\n    //!\n    // Joystick virtual button to make the player strafe left.\n    //\n\n    CONFIG_VARIABLE_INT(joyb_strafeleft),\n\n    //!\n    // Joystick virtual button to make the player strafe right.\n    //\n\n    CONFIG_VARIABLE_INT(joyb_straferight),\n\n    //!\n    // Joystick virtual button to activate the menu.\n    //\n\n    CONFIG_VARIABLE_INT(joyb_menu_activate),\n\n    //!\n    // Joystick virtual button to toggle the automap.\n    //\n\n    CONFIG_VARIABLE_INT(joyb_toggle_automap),\n\n    //!\n    // Joystick virtual button that cycles to the previous weapon.\n    //\n\n    CONFIG_VARIABLE_INT(joyb_prevweapon),\n\n    //!\n    // Joystick virtual button that cycles to the next weapon.\n    //\n\n    CONFIG_VARIABLE_INT(joyb_nextweapon),\n\n    //!\n    // Key to pause or unpause the game.\n    //\n\n    CONFIG_VARIABLE_KEY(key_pause),\n\n    //!\n    // Key that activates the menu when pressed.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_activate),\n\n    //!\n    // Key that moves the cursor up on the menu.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_up),\n\n    //!\n    // Key that moves the cursor down on the menu.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_down),\n\n    //!\n    // Key that moves the currently selected slider on the menu left.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_left),\n\n    //!\n    // Key that moves the currently selected slider on the menu right.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_right),\n\n    //!\n    // Key to go back to the previous menu.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_back),\n\n    //!\n    // Key to activate the currently selected menu item.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_forward),\n\n    //!\n    // Key to answer 'yes' to a question in the menu.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_confirm),\n\n    //!\n    // Key to answer 'no' to a question in the menu.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_abort),\n\n    //!\n    // Keyboard shortcut to bring up the help screen.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_help),\n\n    //!\n    // Keyboard shortcut to bring up the save game menu.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_save),\n\n    //!\n    // Keyboard shortcut to bring up the load game menu.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_load),\n\n    //!\n    // Keyboard shortcut to bring up the sound volume menu.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_volume),\n\n    //!\n    // Keyboard shortcut to toggle the detail level.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_detail),\n\n    //!\n    // Keyboard shortcut to quicksave the current game.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_qsave),\n\n    //!\n    // Keyboard shortcut to end the game.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_endgame),\n\n    //!\n    // Keyboard shortcut to toggle heads-up messages.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_messages),\n\n    //!\n    // Keyboard shortcut to load the last quicksave.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_qload),\n\n    //!\n    // Keyboard shortcut to quit the game.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_quit),\n\n    //!\n    // Keyboard shortcut to toggle the gamma correction level.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_gamma),\n\n    //!\n    // Keyboard shortcut to switch view in multiplayer.\n    //\n\n    CONFIG_VARIABLE_KEY(key_spy),\n\n    //!\n    // Keyboard shortcut to increase the screen size.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_incscreen),\n\n    //!\n    // Keyboard shortcut to decrease the screen size.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_decscreen),\n\n    //!\n    // Keyboard shortcut to save a screenshot.\n    //\n\n    CONFIG_VARIABLE_KEY(key_menu_screenshot),\n\n    //!\n    // Key to toggle the map view.\n    //\n\n    CONFIG_VARIABLE_KEY(key_map_toggle),\n\n    //!\n    // Key to pan north when in the map view.\n    //\n\n    CONFIG_VARIABLE_KEY(key_map_north),\n\n    //!\n    // Key to pan south when in the map view.\n    //\n\n    CONFIG_VARIABLE_KEY(key_map_south),\n\n    //!\n    // Key to pan east when in the map view.\n    //\n\n    CONFIG_VARIABLE_KEY(key_map_east),\n\n    //!\n    // Key to pan west when in the map view.\n    //\n\n    CONFIG_VARIABLE_KEY(key_map_west),\n\n    //!\n    // Key to zoom in when in the map view.\n    //\n\n    CONFIG_VARIABLE_KEY(key_map_zoomin),\n\n    //!\n    // Key to zoom out when in the map view.\n    //\n\n    CONFIG_VARIABLE_KEY(key_map_zoomout),\n\n    //!\n    // Key to zoom out the maximum amount when in the map view.\n    //\n\n    CONFIG_VARIABLE_KEY(key_map_maxzoom),\n\n    //!\n    // Key to toggle follow mode when in the map view.\n    //\n\n    CONFIG_VARIABLE_KEY(key_map_follow),\n\n    //!\n    // Key to toggle the grid display when in the map view.\n    //\n\n    CONFIG_VARIABLE_KEY(key_map_grid),\n\n    //!\n    // Key to set a mark when in the map view.\n    //\n\n    CONFIG_VARIABLE_KEY(key_map_mark),\n\n    //!\n    // Key to clear all marks when in the map view.\n    //\n\n    CONFIG_VARIABLE_KEY(key_map_clearmark),\n\n    //!\n    // Key to select weapon 1.\n    //\n\n    CONFIG_VARIABLE_KEY(key_weapon1),\n\n    //!\n    // Key to select weapon 2.\n    //\n\n    CONFIG_VARIABLE_KEY(key_weapon2),\n\n    //!\n    // Key to select weapon 3.\n    //\n\n    CONFIG_VARIABLE_KEY(key_weapon3),\n\n    //!\n    // Key to select weapon 4.\n    //\n\n    CONFIG_VARIABLE_KEY(key_weapon4),\n\n    //!\n    // Key to select weapon 5.\n    //\n\n    CONFIG_VARIABLE_KEY(key_weapon5),\n\n    //!\n    // Key to select weapon 6.\n    //\n\n    CONFIG_VARIABLE_KEY(key_weapon6),\n\n    //!\n    // Key to select weapon 7.\n    //\n\n    CONFIG_VARIABLE_KEY(key_weapon7),\n\n    //!\n    // Key to select weapon 8.\n    //\n\n    CONFIG_VARIABLE_KEY(key_weapon8),\n\n    //!\n    // Key to cycle to the previous weapon.\n    //\n\n    CONFIG_VARIABLE_KEY(key_prevweapon),\n\n    //!\n    // Key to cycle to the next weapon.\n    //\n\n    CONFIG_VARIABLE_KEY(key_nextweapon),\n\n    //!\n    // @game hexen\n    //\n    // Key to use one of each artifact.\n    //\n\n    CONFIG_VARIABLE_KEY(key_arti_all),\n\n    //!\n    // @game hexen\n    //\n    // Key to use \"quartz flask\" artifact.\n    //\n\n    CONFIG_VARIABLE_KEY(key_arti_health),\n\n    //!\n    // @game hexen\n    //\n    // Key to use \"flechette\" artifact.\n    //\n\n    CONFIG_VARIABLE_KEY(key_arti_poisonbag),\n\n    //!\n    // @game hexen\n    //\n    // Key to use \"disc of repulsion\" artifact.\n    //\n\n    CONFIG_VARIABLE_KEY(key_arti_blastradius),\n\n    //!\n    // @game hexen\n    //\n    // Key to use \"chaos device\" artifact.\n    //\n\n    CONFIG_VARIABLE_KEY(key_arti_teleport),\n\n    //!\n    // @game hexen\n    //\n    // Key to use \"banishment device\" artifact.\n    //\n\n    CONFIG_VARIABLE_KEY(key_arti_teleportother),\n\n    //!\n    // @game hexen\n    //\n    // Key to use \"porkalator\" artifact.\n    //\n\n    CONFIG_VARIABLE_KEY(key_arti_egg),\n\n    //!\n    // @game hexen\n    //\n    // Key to use \"icon of the defender\" artifact.\n    //\n\n    CONFIG_VARIABLE_KEY(key_arti_invulnerability),\n\n    //!\n    // Key to re-display last message.\n    //\n\n    CONFIG_VARIABLE_KEY(key_message_refresh),\n\n    //!\n    // Key to quit the game when recording a demo.\n    //\n\n    CONFIG_VARIABLE_KEY(key_demo_quit),\n\n    //!\n    // Key to send a message during multiplayer games.\n    //\n\n    CONFIG_VARIABLE_KEY(key_multi_msg),\n\n    //!\n    // Key to send a message to player 1 during multiplayer games.\n    //\n\n    CONFIG_VARIABLE_KEY(key_multi_msgplayer1),\n\n    //!\n    // Key to send a message to player 2 during multiplayer games.\n    //\n\n    CONFIG_VARIABLE_KEY(key_multi_msgplayer2),\n\n    //!\n    // Key to send a message to player 3 during multiplayer games.\n    //\n\n    CONFIG_VARIABLE_KEY(key_multi_msgplayer3),\n\n    //!\n    // Key to send a message to player 4 during multiplayer games.\n    //\n\n    CONFIG_VARIABLE_KEY(key_multi_msgplayer4),\n\n    //!\n    // @game hexen strife\n    //\n    // Key to send a message to player 5 during multiplayer games.\n    //\n\n    CONFIG_VARIABLE_KEY(key_multi_msgplayer5),\n\n    //!\n    // @game hexen strife\n    //\n    // Key to send a message to player 6 during multiplayer games.\n    //\n\n    CONFIG_VARIABLE_KEY(key_multi_msgplayer6),\n\n    //!\n    // @game hexen strife\n    //\n    // Key to send a message to player 7 during multiplayer games.\n    //\n\n    CONFIG_VARIABLE_KEY(key_multi_msgplayer7),\n\n    //!\n    // @game hexen strife\n    //\n    // Key to send a message to player 8 during multiplayer games.\n    //\n\n    CONFIG_VARIABLE_KEY(key_multi_msgplayer8),\n};\n\nstatic default_collection_t extra_defaults =\n{\n    extra_defaults_list,\n    arrlen(extra_defaults_list),\n    NULL,\n};\n\n// Search a collection for a variable\n\nstatic default_t *SearchCollection(default_collection_t *collection, char *name)\n{\n    int i;\n\n    for (i=0; i<collection->numdefaults; ++i) \n    {\n        if (!strcmp(name, collection->defaults[i].name))\n        {\n            return &collection->defaults[i];\n        }\n    }\n\n    return NULL;\n}\n\n// Mapping from DOS keyboard scan code to internal key code (as defined\n// in doomkey.h). I think I (fraggle) reused this from somewhere else\n// but I can't find where. Anyway, notes:\n//  * KEY_PAUSE is wrong - it's in the KEY_NUMLOCK spot. This shouldn't\n//    matter in terms of Vanilla compatibility because neither of\n//    those were valid for key bindings.\n//  * There is no proper scan code for PrintScreen (on DOS machines it\n//    sends an interrupt). So I added a fake scan code of 126 for it.\n//    The presence of this is important so we can bind PrintScreen as\n//    a screenshot key.\nstatic const int scantokey[128] =\n{\n    0  ,    27,     '1',    '2',    '3',    '4',    '5',    '6',\n    '7',    '8',    '9',    '0',    '-',    '=',    KEY_BACKSPACE, 9,\n    'q',    'w',    'e',    'r',    't',    'y',    'u',    'i',\n    'o',    'p',    '[',    ']',    13,\t\tKEY_RCTRL, 'a',    's',\n    'd',    'f',    'g',    'h',    'j',    'k',    'l',    ';',\n    '\\'',   '`',    KEY_RSHIFT,'\\\\',   'z',    'x',    'c',    'v',\n    'b',    'n',    'm',    ',',    '.',    '/',    KEY_RSHIFT,KEYP_MULTIPLY,\n    KEY_RALT,  ' ',  KEY_CAPSLOCK,KEY_F1,  KEY_F2,   KEY_F3,   KEY_F4,   KEY_F5,\n    KEY_F6,   KEY_F7,   KEY_F8,   KEY_F9,   KEY_F10,  /*KEY_NUMLOCK?*/KEY_PAUSE,KEY_SCRLCK,KEY_HOME,\n    KEY_UPARROW,KEY_PGUP,KEY_MINUS,KEY_LEFTARROW,KEYP_5,KEY_RIGHTARROW,KEYP_PLUS,KEY_END,\n    KEY_DOWNARROW,KEY_PGDN,KEY_INS,KEY_DEL,0,   0,      0,      KEY_F11,\n    KEY_F12,  0,      0,      0,      0,      0,      0,      0,\n    0,      0,      0,      0,      0,      0,      0,      0,\n    0,      0,      0,      0,      0,      0,      0,      0,\n    0,      0,      0,      0,      0,      0,      0,      0,\n    0,      0,      0,      0,      0,      0,      KEY_PRTSCR, 0\n};\n\n\nstatic void SaveDefaultCollection(default_collection_t *collection)\n{\n    default_t *defaults;\n    int i, v;\n    FILE *f;\n\t\n    f = fopen (collection->filename, \"w\");\n    if (!f)\n\treturn; // can't write the file, but don't complain\n\n    defaults = collection->defaults;\n\t\t\n    for (i=0 ; i<collection->numdefaults ; i++)\n    {\n        int chars_written;\n\n        // Ignore unbound variables\n\n        if (!defaults[i].bound)\n        {\n            continue;\n        }\n\n        // Print the name and line up all values at 30 characters\n\n        chars_written = fprintf(f, \"%s \", defaults[i].name);\n\n        for (; chars_written < 30; ++chars_written)\n            fprintf(f, \" \");\n\n        // Print the value\n\n        switch (defaults[i].type) \n        {\n            case DEFAULT_KEY:\n\n                // use the untranslated version if we can, to reduce\n                // the possibility of screwing up the user's config\n                // file\n                \n                v = *defaults[i].location.i;\n\n                if (v == KEY_RSHIFT)\n                {\n                    // Special case: for shift, force scan code for\n                    // right shift, as this is what Vanilla uses.\n                    // This overrides the change check below, to fix\n                    // configuration files made by old versions that\n                    // mistakenly used the scan code for left shift.\n\n                    v = 54;\n                }\n                else if (defaults[i].untranslated\n                      && v == defaults[i].original_translated)\n                {\n                    // Has not been changed since the last time we\n                    // read the config file.\n\n                    v = defaults[i].untranslated;\n                }\n                else\n                {\n                    // search for a reverse mapping back to a scancode\n                    // in the scantokey table\n\n                    int s;\n\n                    for (s=0; s<128; ++s)\n                    {\n                        if (scantokey[s] == v)\n                        {\n                            v = s;\n                            break;\n                        }\n                    }\n                }\n\n\t        fprintf(f, \"%i\", v);\n                break;\n\n            case DEFAULT_INT:\n\t        fprintf(f, \"%i\", *defaults[i].location.i);\n                break;\n\n            case DEFAULT_INT_HEX:\n\t        fprintf(f, \"0x%x\", *defaults[i].location.i);\n                break;\n\n            case DEFAULT_FLOAT:\n                fprintf(f, \"%f\", *defaults[i].location.f);\n                break;\n\n            case DEFAULT_STRING:\n\t        fprintf(f,\"\\\"%s\\\"\", *defaults[i].location.s);\n                break;\n        }\n\n        fprintf(f, \"\\n\");\n    }\n\n    fclose (f);\n}\n\n// Parses integer values in the configuration file\n\nstatic int ParseIntParameter(char *strparm)\n{\n    int parm;\n\n    if (strparm[0] == '0' && strparm[1] == 'x')\n        sscanf(strparm+2, \"%x\", &parm);\n    else\n        sscanf(strparm, \"%i\", &parm);\n\n    return parm;\n}\n\nstatic void SetVariable(default_t *def, char *value)\n{\n    int intparm;\n\n    // parameter found\n\n    switch (def->type)\n    {\n        case DEFAULT_STRING:\n            *def->location.s = M_StringDuplicate(value);\n            break;\n\n        case DEFAULT_INT:\n        case DEFAULT_INT_HEX:\n            *def->location.i = ParseIntParameter(value);\n            break;\n\n        case DEFAULT_KEY:\n\n            // translate scancodes read from config\n            // file (save the old value in untranslated)\n\n            intparm = ParseIntParameter(value);\n            def->untranslated = intparm;\n            if (intparm >= 0 && intparm < 128)\n            {\n                intparm = scantokey[intparm];\n            }\n            else\n            {\n                intparm = 0;\n            }\n\n            def->original_translated = intparm;\n            *def->location.i = intparm;\n            break;\n\n        case DEFAULT_FLOAT:\n            *def->location.f = (float) atof(value);\n            break;\n    }\n}\n\nstatic void LoadDefaultCollection(default_collection_t *collection)\n{\n    FILE *f;\n    default_t *def;\n    char defname[80];\n    char strparm[100];\n\n    // read the file in, overriding any set defaults\n    f = fopen(collection->filename, \"r\");\n\n    if (f == NULL)\n    {\n        // File not opened, but don't complain. \n        // It's probably just the first time they ran the game.\n\n        return;\n    }\n\n    while (!feof(f))\n    {\n        if (fscanf(f, \"%79s %99[^\\n]\\n\", defname, strparm) != 2)\n        {\n            // This line doesn't match\n\n            continue;\n        }\n\n        // Find the setting in the list\n\n        def = SearchCollection(collection, defname);\n\n        if (def == NULL || !def->bound)\n        {\n            // Unknown variable?  Unbound variables are also treated\n            // as unknown.\n\n            continue;\n        }\n\n        // Strip off trailing non-printable characters (\\r characters\n        // from DOS text files)\n\n        while (strlen(strparm) > 0 && !isprint(strparm[strlen(strparm)-1]))\n        {\n            strparm[strlen(strparm)-1] = '\\0';\n        }\n\n        // Surrounded by quotes? If so, remove them.\n        if (strlen(strparm) >= 2\n         && strparm[0] == '\"' && strparm[strlen(strparm) - 1] == '\"')\n        {\n            strparm[strlen(strparm) - 1] = '\\0';\n            memmove(strparm, strparm + 1, sizeof(strparm) - 1);\n        }\n\n        SetVariable(def, strparm);\n    }\n\n    fclose (f);\n}\n\n// Set the default filenames to use for configuration files.\n\nvoid M_SetConfigFilenames(char *main_config, char *extra_config)\n{\n    default_main_config = main_config;\n    default_extra_config = extra_config;\n}\n\n//\n// M_SaveDefaults\n//\n\nvoid M_SaveDefaults (void)\n{\n    SaveDefaultCollection(&doom_defaults);\n    SaveDefaultCollection(&extra_defaults);\n}\n\n//\n// Save defaults to alternate filenames\n//\n\nvoid M_SaveDefaultsAlternate(char *main, char *extra)\n{\n    char *orig_main;\n    char *orig_extra;\n\n    // Temporarily change the filenames\n\n    orig_main = doom_defaults.filename;\n    orig_extra = extra_defaults.filename;\n\n    doom_defaults.filename = main;\n    extra_defaults.filename = extra;\n\n    M_SaveDefaults();\n\n    // Restore normal filenames\n\n    doom_defaults.filename = orig_main;\n    extra_defaults.filename = orig_extra;\n}\n\n//\n// M_LoadDefaults\n//\n\nvoid M_LoadDefaults (void)\n{\n    int i;\n \n    // check for a custom default file\n\n    //!\n    // @arg <file>\n    // @vanilla\n    //\n    // Load main configuration from the specified file, instead of the\n    // default.\n    //\n\n    i = M_CheckParmWithArgs(\"-config\", 1);\n\n    if (i)\n    {\n\tdoom_defaults.filename = myargv[i+1];\n\tprintf (\"\tdefault file: %s\\n\",doom_defaults.filename);\n    }\n    else\n    {\n        doom_defaults.filename\n            = M_StringJoin(configdir, default_main_config, NULL);\n    }\n\n    printf(\"saving config in %s\\n\", doom_defaults.filename);\n\n    //!\n    // @arg <file>\n    //\n    // Load additional configuration from the specified file, instead of\n    // the default.\n    //\n\n    i = M_CheckParmWithArgs(\"-extraconfig\", 1);\n\n    if (i)\n    {\n        extra_defaults.filename = myargv[i+1];\n        printf(\"        extra configuration file: %s\\n\", \n               extra_defaults.filename);\n    }\n    else\n    {\n        extra_defaults.filename\n            = M_StringJoin(configdir, default_extra_config, NULL);\n    }\n\n    LoadDefaultCollection(&doom_defaults);\n    LoadDefaultCollection(&extra_defaults);\n}\n\n// Get a configuration file variable by its name\n\nstatic default_t *GetDefaultForName(char *name)\n{\n    default_t *result;\n\n    // Try the main list and the extras\n\n    result = SearchCollection(&doom_defaults, name);\n\n    if (result == NULL)\n    {\n        result = SearchCollection(&extra_defaults, name);\n    }\n\n    // Not found? Internal error.\n\n    if (result == NULL)\n    {\n        I_Error(\"Unknown configuration variable: '%s'\", name);\n    }\n\n    return result;\n}\n\n//\n// Bind a variable to a given configuration file variable, by name.\n//\n\nvoid M_BindIntVariable(char *name, int *location)\n{\n    default_t *variable;\n\n    variable = GetDefaultForName(name);\n    assert(variable->type == DEFAULT_INT\n        || variable->type == DEFAULT_INT_HEX\n        || variable->type == DEFAULT_KEY);\n\n    variable->location.i = location;\n    variable->bound = true;\n}\n\nvoid M_BindFloatVariable(char *name, float *location)\n{\n    default_t *variable;\n\n    variable = GetDefaultForName(name);\n    assert(variable->type == DEFAULT_FLOAT);\n\n    variable->location.f = location;\n    variable->bound = true;\n}\n\nvoid M_BindStringVariable(char *name, char **location)\n{\n    default_t *variable;\n\n    variable = GetDefaultForName(name);\n    assert(variable->type == DEFAULT_STRING);\n\n    variable->location.s = location;\n    variable->bound = true;\n}\n\n// Set the value of a particular variable; an API function for other\n// parts of the program to assign values to config variables by name.\n\nboolean M_SetVariable(char *name, char *value)\n{\n    default_t *variable;\n\n    variable = GetDefaultForName(name);\n\n    if (variable == NULL || !variable->bound)\n    {\n        return false;\n    }\n\n    SetVariable(variable, value);\n\n    return true;\n}\n\n// Get the value of a variable.\n\nint M_GetIntVariable(char *name)\n{\n    default_t *variable;\n\n    variable = GetDefaultForName(name);\n\n    if (variable == NULL || !variable->bound\n     || (variable->type != DEFAULT_INT && variable->type != DEFAULT_INT_HEX))\n    {\n        return 0;\n    }\n\n    return *variable->location.i;\n}\n\nconst char *M_GetStringVariable(char *name)\n{\n    default_t *variable;\n\n    variable = GetDefaultForName(name);\n\n    if (variable == NULL || !variable->bound\n     || variable->type != DEFAULT_STRING)\n    {\n        return NULL;\n    }\n\n    return *variable->location.s;\n}\n\nfloat M_GetFloatVariable(char *name)\n{\n    default_t *variable;\n\n    variable = GetDefaultForName(name);\n\n    if (variable == NULL || !variable->bound\n     || variable->type != DEFAULT_FLOAT)\n    {\n        return 0;\n    }\n\n    return *variable->location.f;\n}\n\n// \n// SetConfigDir:\n//\n// Sets the location of the configuration directory, where configuration\n// files are stored - default.cfg, chocolate-doom.cfg, savegames, etc.\n//\n\nvoid M_SetConfigDir(const char *dir)\n{\n    // Use the directory that was passed, or find the default.\n    configdir = \".\";\n    printf(\"Using MemFS for configuration and saves\\n\");\n}\n\n//\n// Calculate the path to the directory to use to store save games.\n// Creates the directory as necessary.\n//\n\nchar *M_GetSaveGameDir(char *iwadname)\n{\n    char *savegamedir;\n    char *topdir;\n    int p;\n\n    //!\n    // @arg <directory>\n    //\n    // Specify a path from which to load and save games. If the directory\n    // does not exist then it will automatically be created.\n    //\n\n    p = M_CheckParmWithArgs(\"-savedir\", 1);\n    if (p)\n    {\n        savegamedir = myargv[p + 1];\n        if (!M_FileExists(savegamedir))\n        {\n            M_MakeDirectory(savegamedir);\n        }\n\n        // add separator at end just in case\n        savegamedir = M_StringJoin(savegamedir, DIR_SEPARATOR_S, NULL);\n\n        printf(\"Save directory changed to %s.\\n\", savegamedir);\n    }\n    // If not \"doing\" a configuration directory (Windows), don't \"do\"\n    // a savegame directory, either.\n    else if (!strcmp(configdir, \"\"))\n    {\n\tsavegamedir = M_StringDuplicate(\"\");\n    }\n    else\n    {\n        // ~/.local/share/chocolate-doom/savegames\n\n        topdir = M_StringJoin(configdir, \"savegames\", NULL);\n        M_MakeDirectory(topdir);\n\n        // eg. ~/.local/share/chocolate-doom/savegames/doom2.wad/\n\n        savegamedir = M_StringJoin(topdir, DIR_SEPARATOR_S, iwadname,\n                                   DIR_SEPARATOR_S, NULL);\n\n        M_MakeDirectory(savegamedir);\n\n        free(topdir);\n    }\n\n    return savegamedir;\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tDo all the WAD I/O, get map description,\n//\tset up initial state and misc. LUTs.\n//\n\n\n\n#include <math.h>\n\n#include \"z_zone.h\"\n\n#include \"deh_main.h\"\n#include \"i_swap.h\"\n#include \"m_argv.h\"\n#include \"m_bbox.h\"\n#include \"m_misc.h\" // [crispy] M_StringJoin()\n\n#include \"g_game.h\"\n\n#include \"i_system.h\"\n#include \"w_wad.h\"\n\n#include \"doomdef.h\"\n#include \"p_local.h\"\n\n#include \"s_sound.h\"\n\n#include \"doomstat.h\"\n\n#include \"p_extnodes.h\" // [crispy] support extended node formats\n\n#include \"v_patch.h\"\n\nvoid\tP_SpawnMapThing (mapthing_t*\tmthing);\n\n\n//\n// MAP related Lookup tables.\n// Store VERTEXES, LINEDEFS, SIDEDEFS, etc.\n//\nint\t\tnumvertexes;\nvertex_t*\tvertexes;\n\nint\t\tnumsegs;\nseg_t*\t\tsegs;\n\nint\t\tnumsectors;\nsector_t*\tsectors;\n\nint\t\tnumsubsectors;\nsubsector_t*\tsubsectors;\n\nint\t\tnumnodes;\nnode_t*\t\tnodes;\n\nint\t\tnumlines;\nline_t*\t\tlines;\n\nint\t\tnumsides;\nside_t*\t\tsides;\n\nstatic int      totallines;\n\n// BLOCKMAP\n// Created from axis aligned bounding box\n// of the map, a rectangular array of\n// blocks of size ...\n// Used to speed up collision detection\n// by spatial subdivision in 2D.\n//\n// Blockmap size.\nint\t\tbmapwidth;\nint\t\tbmapheight;\t// size in mapblocks\nint32_t*\tblockmap;\t// int for larger maps // [crispy] BLOCKMAP limit\n// offsets in blockmap are from here\nint32_t*\tblockmaplump; // [crispy] BLOCKMAP limit\n// origin of block map\nfixed_t\t\tbmaporgx;\nfixed_t\t\tbmaporgy;\n// for thing chains\nmobj_t**\tblocklinks;\t\t\n\n\n// REJECT\n// For fast sight rejection.\n// Speeds up enemy AI by skipping detailed\n//  LineOf Sight calculation.\n// Without special effect, this could be\n//  used as a PVS lookup as well.\n//\nbyte*\t\trejectmatrix;\n\n\n// Maintain single and multi player starting spots.\n#define MAX_DEATHMATCH_STARTS\t10\n\nmapthing_t\tdeathmatchstarts[MAX_DEATHMATCH_STARTS];\nmapthing_t*\tdeathmatch_p;\nmapthing_t\tplayerstarts[MAXPLAYERS];\nboolean     playerstartsingame[MAXPLAYERS];\n\n// [crispy] recalculate seg offsets\n// adapted from prboom-plus/src/p_setup.c:474-482\nfixed_t GetOffset(vertex_t *v1, vertex_t *v2)\n{\n    fixed_t dx, dy;\n    fixed_t r;\n\n    dx = (v1->x - v2->x)>>FRACBITS;\n    dy = (v1->y - v2->y)>>FRACBITS;\n    r = (fixed_t)(sqrt(dx*dx + dy*dy))<<FRACBITS;\n\n    return r;\n}\n\n\n\n\n//\n// P_LoadVertexes\n//\nvoid P_LoadVertexes (int lump)\n{\n    byte*\t\tdata;\n    int\t\t\ti;\n    mapvertex_t*\tml;\n    vertex_t*\t\tli;\n\n    // Determine number of lumps:\n    //  total lump length / vertex record length.\n    numvertexes = W_LumpLength (lump) / sizeof(mapvertex_t);\n\n    // Allocate zone memory for buffer.\n    vertexes = Z_Malloc (numvertexes*sizeof(vertex_t),PU_LEVEL,0);\t\n\n    // Load data into cache.\n    data = W_CacheLumpNum (lump, PU_STATIC);\n\t\n    ml = (mapvertex_t *)data;\n    li = vertexes;\n\n    // Copy and convert vertex coordinates,\n    // internal representation as fixed.\n    for (i=0 ; i<numvertexes ; i++, li++, ml++)\n    {\n\tli->x = SHORT(ml->x)<<FRACBITS;\n\tli->y = SHORT(ml->y)<<FRACBITS;\n\n\t// [crispy] initialize vertex coordinates *only* used in rendering\n\tli->r_x = li->x;\n\tli->r_y = li->y;\n\tli->moved = false;\n    }\n\n    // Free buffer memory.\n    W_ReleaseLumpNum(lump);\n}\n\n//\n// GetSectorAtNullAddress\n//\nsector_t* GetSectorAtNullAddress(void)\n{\n    static boolean null_sector_is_initialized = false;\n    static sector_t null_sector;\n\n    if (!null_sector_is_initialized)\n    {\n        memset(&null_sector, 0, sizeof(null_sector));\n        I_GetMemoryValue(0, &null_sector.floorheight, 4);\n        I_GetMemoryValue(4, &null_sector.ceilingheight, 4);\n        null_sector_is_initialized = true;\n    }\n\n    return &null_sector;\n}\n\n//\n// P_LoadSegs\n//\nvoid P_LoadSegs (int lump)\n{\n    byte*\t\tdata;\n    int\t\t\ti;\n    mapseg_t*\t\tml;\n    seg_t*\t\tli;\n    line_t*\t\tldef;\n    int\t\t\tlinedef;\n    int\t\t\tside;\n    int                 sidenum;\n\t\n    numsegs = W_LumpLength (lump) / sizeof(mapseg_t);\n    segs = Z_Malloc (numsegs*sizeof(seg_t),PU_LEVEL,0);\t\n    memset (segs, 0, numsegs*sizeof(seg_t));\n    data = W_CacheLumpNum (lump,PU_STATIC);\n\t\n    ml = (mapseg_t *)data;\n    li = segs;\n    for (i=0 ; i<numsegs ; i++, li++, ml++)\n    {\n\tli->v1 = &vertexes[(unsigned short)SHORT(ml->v1)]; // [crispy] extended nodes\n\tli->v2 = &vertexes[(unsigned short)SHORT(ml->v2)]; // [crispy] extended nodes\n\n\tli->angle = (SHORT(ml->angle))<<FRACBITS;\n\n\tlinedef = (unsigned short)SHORT(ml->linedef); // [crispy] extended nodes\n\tldef = &lines[linedef];\n\tli->linedef = ldef;\n\tside = SHORT(ml->side);\n\n        // e6y: check for wrong indexes\n        if ((unsigned)ldef->sidenum[side] >= (unsigned)numsides)\n        {\n            I_Error(\"P_LoadSegs: linedef %d for seg %d references a non-existent sidedef %d\",\n                    linedef, i, (unsigned)ldef->sidenum[side]);\n        }\n\n\tli->sidedef = &sides[ldef->sidenum[side]];\n\tli->frontsector = sides[ldef->sidenum[side]].sector;\n\t// [crispy] recalculate\n\tli->offset = GetOffset(li->v1, ((ml->side ^ 0) ? ldef->v2 : ldef->v1));\n\n        if (ldef-> flags & ML_TWOSIDED)\n        {\n            sidenum = ldef->sidenum[side ^ 1];\n\n            // If the sidenum is out of range, this may be a \"glass hack\"\n            // impassible window.  Point at side #0 (this may not be\n            // the correct Vanilla behavior; however, it seems to work for\n            // OTTAWAU.WAD, which is the one place I've seen this trick\n            // used).\n\n            if (sidenum < 0 || sidenum >= numsides)\n            {\n                // [crispy] linedef has two-sided flag set, but no valid second sidedef;\n                // but since it has a midtexture, it is supposed to be rendered just\n                // like a regular one-sided linedef\n                if (li->sidedef->midtexture)\n                {\n                    li->backsector = 0;\n                    fprintf(stderr, \"P_LoadSegs: Linedef %d has two-sided flag set, but no second sidedef\\n\", i);\n                }\n                else\n                li->backsector = GetSectorAtNullAddress();\n            }\n            else\n            {\n                li->backsector = sides[sidenum].sector;\n            }\n        }\n        else\n        {\n\t    li->backsector = 0;\n        }\n    }\n\t\n    W_ReleaseLumpNum(lump);\n}\n\n// [crispy] fix long wall wobble\nvoid P_SegLengths (boolean contrast_only)\n{\n    int i;\n    const int rightangle = abs(finesine[(ANG60/2) >> ANGLETOFINESHIFT]);\n\n    for (i = 0; i < numsegs; i++)\n    {\n\tseg_t *const li = &segs[i];\n\tint64_t dx, dy;\n\n\tdx = li->v2->r_x - li->v1->r_x;\n\tdy = li->v2->r_y - li->v1->r_y;\n\n\tif (!contrast_only)\n\t{\n\t\tli->length = (uint32_t)(sqrt((double)dx*dx + (double)dy*dy)/2);\n\n\t\t// [crispy] re-calculate angle used for rendering\n\t\tviewx = li->v1->r_x;\n\t\tviewy = li->v1->r_y;\n\t\tli->r_angle = R_PointToAngleCrispy(li->v2->r_x, li->v2->r_y);\n\t}\n\n\t// [crispy] smoother fake contrast\n\tif (!dy)\n\t    li->fakecontrast = -LIGHTBRIGHT;\n\telse\n\tif (abs(finesine[li->r_angle >> ANGLETOFINESHIFT]) < rightangle)\n\t    li->fakecontrast = -(LIGHTBRIGHT >> 1);\n\telse\n\tif (!dx)\n\t    li->fakecontrast = LIGHTBRIGHT;\n\telse\n\tif (abs(finecosine[li->r_angle >> ANGLETOFINESHIFT]) < rightangle)\n\t    li->fakecontrast = LIGHTBRIGHT >> 1;\n\telse\n\t    li->fakecontrast = 0;\n    }\n}\n\n//\n// P_LoadSubsectors\n//\nvoid P_LoadSubsectors (int lump)\n{\n    byte*\t\tdata;\n    int\t\t\ti;\n    mapsubsector_t*\tms;\n    subsector_t*\tss;\n\t\n    numsubsectors = W_LumpLength (lump) / sizeof(mapsubsector_t);\n    subsectors = Z_Malloc (numsubsectors*sizeof(subsector_t),PU_LEVEL,0);\t\n    data = W_CacheLumpNum (lump,PU_STATIC);\n\t\n    // [crispy] fail on missing subsectors\n    if (!data || !numsubsectors)\n\tI_Error(\"P_LoadSubsectors: No subsectors in map!\");\n\n    ms = (mapsubsector_t *)data;\n    memset (subsectors,0, numsubsectors*sizeof(subsector_t));\n    ss = subsectors;\n    \n    for (i=0 ; i<numsubsectors ; i++, ss++, ms++)\n    {\n\tss->numlines = (unsigned short)SHORT(ms->numsegs); // [crispy] extended nodes\n\tss->firstline = (unsigned short)SHORT(ms->firstseg); // [crispy] extended nodes\n    }\n\t\n    W_ReleaseLumpNum(lump);\n}\n\n\n\n//\n// P_LoadSectors\n//\nvoid P_LoadSectors (int lump)\n{\n    byte*\t\tdata;\n    int\t\t\ti;\n    mapsector_t*\tms;\n    sector_t*\t\tss;\n\t\n    // [crispy] fail on missing sectors\n    if (lump >= numlumps)\n\tI_Error(\"P_LoadSectors: No sectors in map!\");\n\n    numsectors = W_LumpLength (lump) / sizeof(mapsector_t);\n    sectors = Z_Malloc (numsectors*sizeof(sector_t),PU_LEVEL,0);\t\n    memset (sectors, 0, numsectors*sizeof(sector_t));\n    data = W_CacheLumpNum (lump,PU_STATIC);\n\t\n    // [crispy] fail on missing sectors\n    if (!data || !numsectors)\n\tI_Error(\"P_LoadSectors: No sectors in map!\");\n\n    ms = (mapsector_t *)data;\n    ss = sectors;\n    for (i=0 ; i<numsectors ; i++, ss++, ms++)\n    {\n    ss->id = i;\n\tss->floorheight = SHORT(ms->floorheight)<<FRACBITS;\n\tss->ceilingheight = SHORT(ms->ceilingheight)<<FRACBITS;\n\tss->floorpic = R_FlatNumForName(ms->floorpic);\n\tss->ceilingpic = R_FlatNumForName(ms->ceilingpic);\n\tss->lightlevel = SHORT(ms->lightlevel);\n\tss->special = SHORT(ms->special);\n\tss->tag = SHORT(ms->tag);\n\tss->thinglist = NULL;\n\t// [crispy] WiggleFix: [kb] for R_FixWiggle()\n\tss->cachedheight = 0;\n    // [AM] Sector interpolation.  Even if we're\n    //      not running uncapped, the renderer still\n    //      uses this data.\n    ss->oldfloorheight = ss->floorheight;\n    ss->interpfloorheight = ss->floorheight;\n    ss->oldceilingheight = ss->ceilingheight;\n    ss->interpceilingheight = ss->ceilingheight;\n    // [crispy] inhibit sector interpolation during the 0th gametic\n    ss->oldgametic = -1;\n\n    ss->nextsec = -1; //jff 2/26/98 add fields to support locking out\n    ss->prevsec = -1; // stair retriggering until build completes\n\n    // killough 3/7/98:\n    ss->floor_xoffs = 0;\n    ss->floor_yoffs = 0;      // floor and ceiling flats offsets\n    ss->ceiling_xoffs = 0;\n    ss->ceiling_yoffs = 0;\n    ss->heightsec = -1;       // sector used to get floor and ceiling height\n    ss->floorlightsec = -1;   // sector used to get floor lighting\n    // killough 3/7/98: end changes\n\n    // killough 4/11/98 sector used to get ceiling lighting:\n    ss->ceilinglightsec = -1;\n\n    // killough 4/4/98: colormaps:\n    ss->bottommap = ss->midmap = ss->topmap = 0;\n\n    // killough 10/98: sky textures coming from sidedefs:\n    ss->sky = 0;\n\n    // [kb] For R_WiggleFix\n    ss->cachedheight = 0;\n    ss->scaleindex = 0;\n    }\n\t\n    W_ReleaseLumpNum(lump);\n}\n\n\n//\n// P_LoadNodes\n//\nvoid P_LoadNodes (int lump)\n{\n    byte*\tdata;\n    int\t\ti;\n    int\t\tj;\n    int\t\tk;\n    mapnode_t*\tmn;\n    node_t*\tno;\n\t\n    numnodes = W_LumpLength (lump) / sizeof(mapnode_t);\n    nodes = Z_Malloc (numnodes*sizeof(node_t),PU_LEVEL,0);\t\n    data = W_CacheLumpNum (lump,PU_STATIC);\n\t\n    // [crispy] warn about missing nodes\n    if (!data || !numnodes)\n    {\n\tif (numsubsectors == 1)\n\t    fprintf(stderr, \"P_LoadNodes: No nodes in map, but only one subsector.\\n\");\n\telse\n\t    I_Error(\"P_LoadNodes: No nodes in map!\");\n    }\n\n    mn = (mapnode_t *)data;\n    no = nodes;\n    \n    for (i=0 ; i<numnodes ; i++, no++, mn++)\n    {\n\tno->x = SHORT(mn->x)<<FRACBITS;\n\tno->y = SHORT(mn->y)<<FRACBITS;\n\tno->dx = SHORT(mn->dx)<<FRACBITS;\n\tno->dy = SHORT(mn->dy)<<FRACBITS;\n\n\tfor (j=0 ; j<2 ; j++)\n\t{\n\t    no->children[j] = (unsigned short)SHORT(mn->children[j]); // [crispy] extended nodes\n\n\t    // [crispy] add support for extended nodes\n\t    // from prboom-plus/src/p_setup.c:937-957\n\t    if (no->children[j] == 0xFFFF)\n\t\tno->children[j] = -1;\n\t    else\n\t    if (no->children[j] & 0x8000)\n\t    {\n\t\tno->children[j] &= ~0x8000;\n\n\t\tif (no->children[j] >= numsubsectors)\n\t\t    no->children[j] = 0;\n\n\t\tno->children[j] |= NF_SUBSECTOR;\n\t    }\n\n\t    for (k=0 ; k<4 ; k++)\n\t\tno->bbox[j][k] = SHORT(mn->bbox[j][k])<<FRACBITS;\n\t}\n    }\n\t\n    W_ReleaseLumpNum(lump);\n}\n\n\n//\n// P_LoadThings\n//\nvoid P_LoadThings (int lump)\n{\n    byte               *data;\n    int\t\t\ti;\n    mapthing_t         *mt;\n    mapthing_t          spawnthing;\n    int\t\t\tnumthings;\n    boolean\t\tspawn;\n\n    data = W_CacheLumpNum (lump,PU_STATIC);\n    numthings = W_LumpLength (lump) / sizeof(mapthing_t);\n\t\n    mt = (mapthing_t *)data;\n    for (i=0 ; i<numthings ; i++, mt++)\n    {\n\tspawn = true;\n\n\t// Do not spawn cool, new monsters if !commercial\n\tif (gamemode != commercial)\n\t{\n\t    switch (SHORT(mt->type))\n\t    {\n\t      case 68:\t// Arachnotron\n\t      case 64:\t// Archvile\n\t      case 88:\t// Boss Brain\n\t      case 89:\t// Boss Shooter\n\t      case 69:\t// Hell Knight\n\t      case 67:\t// Mancubus\n\t      case 71:\t// Pain Elemental\n\t      case 65:\t// Former Human Commando\n\t      case 66:\t// Revenant\n\t      case 84:\t// Wolf SS\n\t\tspawn = false;\n\t\tbreak;\n\t    }\n\t}\n\tif (spawn == false)\n\t    break;\n\n\t// Do spawn all other stuff. \n\tspawnthing.x = SHORT(mt->x);\n\tspawnthing.y = SHORT(mt->y);\n\tspawnthing.angle = SHORT(mt->angle);\n\tspawnthing.type = SHORT(mt->type);\n\tspawnthing.options = SHORT(mt->options);\n\n\tP_SpawnMapThing(&spawnthing);\n    }\n\n    if (!deathmatch)\n    {\n        for (i = 0; i < MAXPLAYERS; i++)\n        {\n            playerstartsingame[i] = false;\n        }\n    }\n\n    W_ReleaseLumpNum(lump);\n}\n\n\n//\n// P_LoadLineDefs\n// Also counts secret lines for intermissions.\n//\nvoid P_LoadLineDefs (int lump)\n{\n    byte*\t\tdata;\n    int\t\t\ti;\n    maplinedef_t*\tmld;\n    line_t*\t\tld;\n    vertex_t*\t\tv1;\n    vertex_t*\t\tv2;\n    int warn, warn2; // [crispy] warn about invalid linedefs\n\t\n    numlines = W_LumpLength (lump) / sizeof(maplinedef_t);\n    lines = Z_Malloc (numlines*sizeof(line_t),PU_LEVEL,0);\t\n    memset (lines, 0, numlines*sizeof(line_t));\n    data = W_CacheLumpNum (lump,PU_STATIC);\n\t\n    mld = (maplinedef_t *)data;\n    ld = lines;\n    warn = warn2 = 0; // [crispy] warn about invalid linedefs\n    for (i=0 ; i<numlines ; i++, mld++, ld++)\n    {\n    ld->tranlump = -1;\n\tld->flags = (unsigned short)SHORT(mld->flags); // [crispy] extended nodes\n\tld->special = SHORT(mld->special);\n\t// [crispy] warn about unknown linedef types\n\t// if ((unsigned short) ld->special > 141)\n\t// {\n\t//     fprintf(stderr, \"P_LoadLineDefs: Unknown special %d at line %d.\\n\", ld->special, i);\n\t//     warn++;\n\t// }\n\tld->tag = SHORT(mld->tag);\n\t// [crispy] warn about special linedefs without tag\n\t// if (ld->special && !ld->tag)\n\t// {\n\t//     switch (ld->special)\n\t//     {\n\t// \tcase 1:\t// Vertical Door\n\t// \tcase 26:\t// Blue Door/Locked\n\t// \tcase 27:\t// Yellow Door /Locked\n\t// \tcase 28:\t// Red Door /Locked\n\t// \tcase 31:\t// Manual door open\n\t// \tcase 32:\t// Blue locked door open\n\t// \tcase 33:\t// Red locked door open\n\t// \tcase 34:\t// Yellow locked door open\n\t// \tcase 117:\t// Blazing door raise\n\t// \tcase 118:\t// Blazing door open\n\t// \tcase 271:\t// MBF sky transfers\n\t// \tcase 272:\n\t// \tcase 48:\t// Scroll Wall Left\n\t// \tcase 85:\t// [crispy] [JN] (Boom) Scroll Texture Right\n\t// \tcase 11:\t// s1 Exit level\n\t// \tcase 51:\t// s1 Secret exit\n\t// \tcase 52:\t// w1 Exit level\n\t// \tcase 124:\t// w1 Secret exit\n\t// \t    break;\n\t// \tdefault:\n\t// \t    fprintf(stderr, \"P_LoadLineDefs: Special linedef %d without tag.\\n\", i);\n\t// \t    warn2++;\n\t// \t    break;\n\t//     }\n\t// }\n\n\tv1 = ld->v1 = &vertexes[(unsigned short)SHORT(mld->v1)]; // [crispy] extended nodes\n\tv2 = ld->v2 = &vertexes[(unsigned short)SHORT(mld->v2)]; // [crispy] extended nodes\n\tld->dx = v2->x - v1->x;\n\tld->dy = v2->y - v1->y;\n\t\n\tif (!ld->dx)\n\t    ld->slopetype = ST_VERTICAL;\n\telse if (!ld->dy)\n\t    ld->slopetype = ST_HORIZONTAL;\n\telse\n\t{\n\t    if (FixedDiv (ld->dy , ld->dx) > 0)\n\t\tld->slopetype = ST_POSITIVE;\n\t    else\n\t\tld->slopetype = ST_NEGATIVE;\n\t}\n\t\t\n\tif (v1->x < v2->x)\n\t{\n\t    ld->bbox[BOXLEFT] = v1->x;\n\t    ld->bbox[BOXRIGHT] = v2->x;\n\t}\n\telse\n\t{\n\t    ld->bbox[BOXLEFT] = v2->x;\n\t    ld->bbox[BOXRIGHT] = v1->x;\n\t}\n\n\tif (v1->y < v2->y)\n\t{\n\t    ld->bbox[BOXBOTTOM] = v1->y;\n\t    ld->bbox[BOXTOP] = v2->y;\n\t}\n\telse\n\t{\n\t    ld->bbox[BOXBOTTOM] = v2->y;\n\t    ld->bbox[BOXTOP] = v1->y;\n\t}\n\n\t// [crispy] calculate sound origin of line to be its midpoint\n\tld->soundorg.x = ld->bbox[BOXLEFT] / 2 + ld->bbox[BOXRIGHT] / 2;\n\tld->soundorg.y = ld->bbox[BOXTOP] / 2 + ld->bbox[BOXBOTTOM] / 2;\n\n\tld->sidenum[0] = SHORT(mld->sidenum[0]);\n\tld->sidenum[1] = SHORT(mld->sidenum[1]);\n\n\t// [crispy] substitute dummy sidedef for missing right side\n\tif (ld->sidenum[0] == NO_INDEX)\n\t{\n\t    ld->sidenum[0] = 0;\n\t    // fprintf(stderr, \"P_LoadLineDefs: linedef %d without first sidedef!\\n\", i);\n\t}\n\n\tif (ld->sidenum[0] != NO_INDEX) // [crispy] extended nodes\n\t    ld->frontsector = sides[ld->sidenum[0]].sector;\n\telse\n\t    ld->frontsector = 0;\n\n\tif (ld->sidenum[1] != NO_INDEX) // [crispy] extended nodes\n\t    ld->backsector = sides[ld->sidenum[1]].sector;\n\telse\n\t    ld->backsector = 0;\n\n    if (ld->sidenum[0] != NO_INDEX && ld->special)\n        sides[ld->sidenum[0]].special = ld->special;\n    }\n\n    // [crispy] warn about unknown linedef types\n    // if (warn)\n    // {\n\t// fprintf(stderr, \"P_LoadLineDefs: Found %d line%s with unknown linedef type.\\n\", warn, (warn > 1) ? \"s\" : \"\");\n    // }\n    // // [crispy] warn about special linedefs without tag\n    // if (warn2)\n    // {\n\t// fprintf(stderr, \"P_LoadLineDefs: Found %d special linedef%s without tag.\\n\", warn2, (warn2 > 1) ? \"s\" : \"\");\n    // }\n    // if (warn || warn2)\n    // {\n\t// fprintf(stderr, \"THIS MAP MAY NOT WORK AS EXPECTED!\\n\");\n    // }\n\n    W_ReleaseLumpNum(lump);\n}\n\n// killough 4/4/98: delay using sidedefs until they are loaded\n// killough 5/3/98: reformatted, cleaned up\n\nstatic void P_LoadLineDefs2(int lump)\n{\n  int i = numlines;\n  line_t *ld = lines;\n  for (;i--;ld++)\n    {\n    //   ld->frontsector = sides[ld->sidenum[0]].sector; //e6y: Can't be NO_INDEX here\n    //   ld->backsector  = ld->sidenum[1]!=NO_INDEX ? sides[ld->sidenum[1]].sector : 0;\n      switch (ld->special)\n        {                       // killough 4/11/98: handle special types\n          int lump, j;\n\n        case 260:               // killough 4/11/98: translucent 2s textures\n            // transparentpresent = true;//e6y\n            lump = sides[*ld->sidenum].special; // translucency from sidedef\n            if (!ld->tag)                       // if tag==0,\n              ld->tranlump = lump;              // affect this linedef only\n            else\n              for (j=0;j<numlines;j++)          // if tag!=0,\n                if (lines[j].tag == ld->tag)    // affect all matching linedefs\n                  lines[j].tranlump = lump;\n            break;\n        }\n    }\n}\n\n\n//\n// P_LoadSideDefs\n//\nvoid P_LoadSideDefs (int lump)\n{\n    byte*\t\tdata;\n    int\t\t\ti;\n    mapsidedef_t*\tmsd;\n    side_t*\t\tsd;\n    numsides = W_LumpLength (lump) / sizeof(mapsidedef_t);\n    sides = Z_Malloc (numsides*sizeof(side_t),PU_LEVEL,0);\t\n    memset (sides, 0, numsides*sizeof(side_t));\n    data = W_CacheLumpNum (lump,PU_STATIC);\n\t\n    msd = (mapsidedef_t *)data;\n    sd = sides;\n    for (i=0 ; i<numsides ; i++, msd++, sd++)\n    {\n\tsd->textureoffset = SHORT(msd->textureoffset)<<FRACBITS;\n\tsd->rowoffset = SHORT(msd->rowoffset)<<FRACBITS;\n\tsd->toptexture = R_TextureNumForName(msd->toptexture);\n\tsd->bottomtexture = R_TextureNumForName(msd->bottomtexture);\n\tsd->midtexture = R_TextureNumForName(msd->midtexture);\n\t// sd->sector = &sectors[SHORT(msd->sector)];\n\n    { /* cph 2006/09/30 - catch out-of-range sector numbers; use sector 0 instead */\n    unsigned short sector_num = SHORT(msd->sector);\n    if (sector_num >= numsectors) {\n        fprintf(stderr,\"P_LoadSideDefs2: sidedef %i has out-of-range sector num %u\\n\", i, sector_num);\n        sector_num = 0;\n    }\n    sd->sector = &sectors[sector_num];\n    }\n\n\t// [crispy] smooth texture scrolling\n\tsd->basetextureoffset = sd->textureoffset;\n    sd->baserowoffset = sd->rowoffset;\n    }\n\n    W_ReleaseLumpNum(lump);\n}\n\n// killough 4/4/98: delay using texture names until\n// after linedefs are loaded, to allow overloading.\n// killough 5/3/98: reformatted, cleaned up\n\nvoid P_LoadSideDefs2(int lump)\n{\n  int  i;\n  byte*\tdata = W_CacheLumpNum (lump,PU_STATIC);\n  side_t* sd = sides;\n  mapsidedef_t* msd = (mapsidedef_t *)data;\n  for (i=0; i<numsides; i++, msd++, sd++)\n    {\n      sector_t *sec = sd->sector;\n\n      // killough 4/4/98: allow sidedef texture names to be overloaded\n      // killough 4/11/98: refined to allow colormaps to work as wall\n      // textures if invalid as colormaps but valid as textures.\n      switch (sd->special)\n        {\n        case 242:                       // variable colormap via 242 linedef\n          sd->bottomtexture =\n            (sec->bottommap =   R_ColormapNumForName(msd->bottomtexture)) < 0 ?\n            sec->bottommap = 0, R_TextureNumForName(msd->bottomtexture): 0 ;\n          sd->midtexture =\n            (sec->midmap =   R_ColormapNumForName(msd->midtexture)) < 0 ?\n            sec->midmap = 0, R_TextureNumForName(msd->midtexture)  : 0 ;\n          sd->toptexture =\n            (sec->topmap =   R_ColormapNumForName(msd->toptexture)) < 0 ?\n            sec->topmap = 0, R_TextureNumForName(msd->toptexture)  : 0 ;\n          break;\n\n        case 260: // killough 4/11/98: apply translucency to 2s normal texture\n          sd->midtexture = strncasecmp(\"TRANMAP\", msd->midtexture, 8) ?\n            (sd->special = W_CheckNumForName(msd->midtexture)) < 0 ||\n            W_LumpLength(sd->special) != 65536 ?\n            sd->special=0, R_TextureNumForName(msd->midtexture) :\n              (sd->special++, 0) : (sd->special=0);\n          sd->toptexture = R_TextureNumForName(msd->toptexture);\n          sd->bottomtexture = R_TextureNumForName(msd->bottomtexture);\n          break;\n\n        default:                        // normal cases\n          sd->midtexture = R_TextureNumForName(msd->midtexture);\n          sd->toptexture = R_TextureNumForName(msd->toptexture);\n          sd->bottomtexture = R_TextureNumForName(msd->bottomtexture);\n          break;\n        }\n    }\n\n    W_ReleaseLumpNum(lump);\n}\n\n//\n// P_LoadBlockMap\n//\nboolean P_LoadBlockMap (int lump)\n{\n    int i;\n    int count;\n    int lumplen;\n    short *wadblockmaplump;\n\n    // [crispy] (re-)create BLOCKMAP if necessary\n    if (M_CheckParm(\"-blockmap\") ||\n        lump >= numlumps ||\n        (lumplen = W_LumpLength(lump)) < 8 ||\n        (count = lumplen / 2) >= 0x10000)\n    {\n\treturn false;\n    }\n\t\n    // [crispy] remove BLOCKMAP limit\n    // adapted from boom202s/P_SETUP.C:1025-1076\n    wadblockmaplump = Z_Malloc(lumplen, PU_LEVEL, NULL);\n    W_ReadLump(lump, wadblockmaplump);\n    blockmaplump = Z_Malloc(sizeof(*blockmaplump) * count, PU_LEVEL, NULL);\n    blockmap = blockmaplump + 4;\n\n    blockmaplump[0] = SHORT(wadblockmaplump[0]);\n    blockmaplump[1] = SHORT(wadblockmaplump[1]);\n    blockmaplump[2] = (int32_t)(SHORT(wadblockmaplump[2])) & 0xffff;\n    blockmaplump[3] = (int32_t)(SHORT(wadblockmaplump[3])) & 0xffff;\n\n    // Swap all short integers to native byte ordering.\n  \n    for (i=4; i<count; i++)\n    {\n\tshort t = SHORT(wadblockmaplump[i]);\n\tblockmaplump[i] = (t == -1) ? -1l : (int32_t) t & 0xffff;\n    }\n\n    Z_Free(wadblockmaplump);\n\t\t\n    // Read the header\n\n    bmaporgx = blockmaplump[0]<<FRACBITS;\n    bmaporgy = blockmaplump[1]<<FRACBITS;\n    bmapwidth = blockmaplump[2];\n    bmapheight = blockmaplump[3];\n\n    // Clear out mobj chains\n\n    count = sizeof(*blocklinks) * bmapwidth * bmapheight;\n    blocklinks = Z_Malloc(count, PU_LEVEL, 0);\n    memset(blocklinks, 0, count);\n\n    // [crispy] (re-)create BLOCKMAP if necessary\n    return true;\n}\n\n\n\n//\n// P_GroupLines\n// Builds sector line lists and subsector sector numbers.\n// Finds block bounding boxes for sectors.\n//\nvoid P_GroupLines (void)\n{\n    line_t**\t\tlinebuffer;\n    int\t\t\ti;\n    int\t\t\tj;\n    line_t*\t\tli;\n    sector_t*\t\tsector;\n    subsector_t*\tss;\n    seg_t*\t\tseg;\n    fixed_t\t\tbbox[4];\n    int\t\t\tblock;\n\t\n    // look up sector number for each subsector\n    ss = subsectors;\n    for (i=0 ; i<numsubsectors ; i++, ss++)\n    {\n\tseg = &segs[ss->firstline];\n\tss->sector = seg->sidedef->sector;\n    }\n\n    // count number of lines in each sector\n    li = lines;\n    totallines = 0;\n    for (i=0 ; i<numlines ; i++, li++)\n    {\n\ttotallines++;\n\tli->frontsector->linecount++;\n\n\tif (li->backsector && li->backsector != li->frontsector)\n\t{\n\t    li->backsector->linecount++;\n\t    totallines++;\n\t}\n    }\n\n    // build line tables for each sector\t\n    linebuffer = Z_Malloc (totallines*sizeof(line_t *), PU_LEVEL, 0);\n\n    for (i=0; i<numsectors; ++i)\n    {\n        // Assign the line buffer for this sector\n\n        sectors[i].lines = linebuffer;\n        linebuffer += sectors[i].linecount;\n\n        // Reset linecount to zero so in the next stage we can count\n        // lines into the list.\n\n        sectors[i].linecount = 0;\n    }\n\n    // Assign lines to sectors\n\n    for (i=0; i<numlines; ++i)\n    { \n        li = &lines[i];\n\n        if (li->frontsector != NULL)\n        {\n            sector = li->frontsector;\n\n            sector->lines[sector->linecount] = li;\n            ++sector->linecount;\n        }\n\n        if (li->backsector != NULL && li->frontsector != li->backsector)\n        {\n            sector = li->backsector;\n\n            sector->lines[sector->linecount] = li;\n            ++sector->linecount;\n        }\n    }\n    \n    // Generate bounding boxes for sectors\n\t\n    sector = sectors;\n    for (i=0 ; i<numsectors ; i++, sector++)\n    {\n\tM_ClearBox (bbox);\n\n\tfor (j=0 ; j<sector->linecount; j++)\n\t{\n            li = sector->lines[j];\n\n            M_AddToBox (bbox, li->v1->x, li->v1->y);\n            M_AddToBox (bbox, li->v2->x, li->v2->y);\n\t}\n\n\t// set the degenmobj_t to the middle of the bounding box\n\tsector->soundorg.x = (bbox[BOXRIGHT]+bbox[BOXLEFT])/2;\n\tsector->soundorg.y = (bbox[BOXTOP]+bbox[BOXBOTTOM])/2;\n\t\t\n\t// adjust bounding box to map blocks\n\tblock = (bbox[BOXTOP]-bmaporgy+MAXRADIUS)>>MAPBLOCKSHIFT;\n\tblock = block >= bmapheight ? bmapheight-1 : block;\n\tsector->blockbox[BOXTOP]=block;\n\n\tblock = (bbox[BOXBOTTOM]-bmaporgy-MAXRADIUS)>>MAPBLOCKSHIFT;\n\tblock = block < 0 ? 0 : block;\n\tsector->blockbox[BOXBOTTOM]=block;\n\n\tblock = (bbox[BOXRIGHT]-bmaporgx+MAXRADIUS)>>MAPBLOCKSHIFT;\n\tblock = block >= bmapwidth ? bmapwidth-1 : block;\n\tsector->blockbox[BOXRIGHT]=block;\n\n\tblock = (bbox[BOXLEFT]-bmaporgx-MAXRADIUS)>>MAPBLOCKSHIFT;\n\tblock = block < 0 ? 0 : block;\n\tsector->blockbox[BOXLEFT]=block;\n    }\n\t\n}\n\n// [crispy] remove slime trails\n// mostly taken from Lee Killough's implementation in mbfsrc/P_SETUP.C:849-924,\n// with the exception that not the actual vertex coordinates are modified,\n// but separate coordinates that are *only* used in rendering,\n// i.e. r_bsp.c:R_AddLine()\n\nstatic void P_RemoveSlimeTrails(void)\n{\n    int i;\n\n    for (i = 0; i < numsegs; i++)\n    {\n\tconst line_t *l = segs[i].linedef;\n\tvertex_t *v = segs[i].v1;\n\n\t// [crispy] ignore exactly vertical or horizontal linedefs\n\tif (l->dx && l->dy)\n\t{\n\t    do\n\t    {\n\t\t// [crispy] vertex wasn't already moved\n\t\tif (!v->moved)\n\t\t{\n\t\t    v->moved = true;\n\t\t    // [crispy] ignore endpoints of linedefs\n\t\t    if (v != l->v1 && v != l->v2)\n\t\t    {\n\t\t\t// [crispy] move the vertex towards the linedef\n\t\t\t// by projecting it using the law of cosines\n\t\t\tint64_t dx2 = (l->dx >> FRACBITS) * (l->dx >> FRACBITS);\n\t\t\tint64_t dy2 = (l->dy >> FRACBITS) * (l->dy >> FRACBITS);\n\t\t\tint64_t dxy = (l->dx >> FRACBITS) * (l->dy >> FRACBITS);\n\t\t\tint64_t s = dx2 + dy2;\n\n\t\t\t// [crispy] MBF actually overrides v->x and v->y here\n\t\t\tv->r_x = (fixed_t)((dx2 * v->x + dy2 * l->v1->x + dxy * (v->y - l->v1->y)) / s);\n\t\t\tv->r_y = (fixed_t)((dy2 * v->y + dx2 * l->v1->y + dxy * (v->x - l->v1->x)) / s);\n\n\t\t\t// [crispy] wait a minute... moved more than 8 map units?\n\t\t\t// maybe that's a linguortal then, back to the original coordinates\n\t\t\tif (abs(v->r_x - v->x) > 8*FRACUNIT || abs(v->r_y - v->y) > 8*FRACUNIT)\n\t\t\t{\n\t\t\t    v->r_x = v->x;\n\t\t\t    v->r_y = v->y;\n\t\t\t}\n\t\t    }\n\t\t}\n\t    // [crispy] if v doesn't point to the second vertex of the seg already, point it there\n\t    } while ((v != segs[i].v2) && (v = segs[i].v2));\n\t}\n    }\n}\n\n// static void R_CalcSegsLength(void)\n// {\n//   int i;\n//   for (i=0; i<numsegs; i++)\n//   {\n//     seg_t *li = segs+i;\n//     int64_t dx = (int64_t)li->v2->r_x - li->v1->r_x;\n//     int64_t dy = (int64_t)li->v2->r_y - li->v1->r_y;\n//     li->length = (int64_t)sqrt((double)dx*dx + (double)dy*dy);\n//     // [crispy] re-calculate angle used for rendering\n//     li->pangle = R_PointToAngleEx2(li->v1->r_x, li->v1->r_y, li->v2->r_x, li->v2->r_y);\n//   }\n// }\n\n// Pad the REJECT lump with extra data when the lump is too small,\n// to simulate a REJECT buffer overflow in Vanilla Doom.\n\nstatic void PadRejectArray(byte *array, unsigned int len)\n{\n    unsigned int i;\n    unsigned int byte_num;\n    byte *dest;\n    unsigned int padvalue;\n\n    // Values to pad the REJECT array with:\n\n    unsigned int rejectpad[4] =\n    {\n        0,                                    // Size\n        0,                                    // Part of z_zone block header\n        50,                                   // PU_LEVEL\n        0x1d4a11                              // DOOM_CONST_ZONEID\n    };\n\n    rejectpad[0] = ((totallines * 4 + 3) & ~3) + 24;\n\n    // Copy values from rejectpad into the destination array.\n\n    dest = array;\n\n    for (i=0; i<len && i<sizeof(rejectpad); ++i)\n    {\n        byte_num = i % 4;\n        *dest = (rejectpad[i / 4] >> (byte_num * 8)) & 0xff;\n        ++dest;\n    }\n\n    // We only have a limited pad size.  Print a warning if the\n    // REJECT lump is too small.\n\n    if (len > sizeof(rejectpad))\n    {\n        fprintf(stderr, \"PadRejectArray: REJECT lump too short to pad! (%i > %i)\\n\",\n                        len, (int) sizeof(rejectpad));\n\n        // Pad remaining space with 0 (or 0xff, if specified on command line).\n\n        if (M_CheckParm(\"-reject_pad_with_ff\"))\n        {\n            padvalue = 0xff;\n        }\n        else\n        {\n            padvalue = 0xf00;\n        }\n\n        memset(array + sizeof(rejectpad), padvalue, len - sizeof(rejectpad));\n    }\n}\n\nstatic void P_LoadReject(int lumpnum)\n{\n    int minlength;\n    int lumplen;\n\n    // Calculate the size that the REJECT lump *should* be.\n\n    minlength = (numsectors * numsectors + 7) / 8;\n\n    // If the lump meets the minimum length, it can be loaded directly.\n    // Otherwise, we need to allocate a buffer of the correct size\n    // and pad it with appropriate data.\n\n    lumplen = W_LumpLength(lumpnum);\n\n    if (lumplen >= minlength)\n    {\n        rejectmatrix = W_CacheLumpNum(lumpnum, PU_LEVEL);\n    }\n    else\n    {\n        rejectmatrix = Z_Malloc(minlength, PU_LEVEL, &rejectmatrix);\n        W_ReadLump(lumpnum, rejectmatrix);\n\n        PadRejectArray(rejectmatrix + lumplen, minlength - lumplen);\n    }\n}\n\n// [crispy] log game skill in plain text\nconst char *skilltable[] =\n{\n    \"No Items\",\n    \"ITYTD\",\n    \"HNTR\",\n    \"HMP\",\n    \"UV\",\n    \"NM\"\n};\n\nextern boolean havee1m10;\n// [crispy] factor out map lump name and number finding into a separate function\nint P_GetNumForMap (int episode, int map, boolean critical)\n{\n    char\tlumpname[9];\n    int\t\tlumpnum;\n\n    // find map name\n    if ( gamemode == commercial)\n    {\n\tif (map<10)\n\t    DEH_snprintf(lumpname, 9, \"map0%i\", map);\n\telse\n\t    DEH_snprintf(lumpname, 9, \"map%i\", map);\n    }\n    else\n    {\n\tlumpname[0] = 'E';\n\tlumpname[1] = '0' + episode;\n\tlumpname[2] = 'M';\n\tlumpname[3] = '0' + map;\n\tlumpname[4] = 0;\n    }\n\n    // [crispy] special-casing for E1M10 \"Sewers\" support\n    if (havee1m10 && episode == 1 && map == 10)\n\tDEH_snprintf(lumpname, 9, \"E1M10\");\n\n    lumpnum = critical ? W_GetNumForName (lumpname) : W_CheckNumForName (lumpname);\n\n    if (nervewadfile && episode != 2 && map <= 9)\n    {\n        lumpnum = W_CheckNumForNameFromTo (lumpname, lumpnum - 1, 0);\n    }\n\n    return lumpnum;\n}\n\n// pointer to the current map lump info struct\nlumpinfo_t *maplumpinfo;\n\n//\n// P_SetupLevel\n//\nvoid\nP_SetupLevel\n( int\t\tepisode,\n  int\t\tmap,\n  int\t\tplayermask,\n  skill_t\tskill)\n{\n    int\t\ti;\n    char\tlumpname[9];\n    int\t\tlumpnum;\n    boolean\tcrispy_validblockmap;\n    mapformat_t\tcrispy_mapformat;\n\t\n    totalkills = totalitems = totalsecret = wminfo.maxfrags = 0;\n    // [crispy] count spawned monsters\n    extrakills = 0;\n    wminfo.partime = 180;\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tplayers[i].killcount = players[i].secretcount \n\t    = players[i].itemcount = 0;\n    }\n\n    // [crispy] No Rest for the Living ...\n    if (nervewadfile)\n    {\n        if (episode == 2)\n        {\n            gamemission = pack_nerve;\n        }\n        else\n        {\n            gamemission = doom2;\n        }\n    }\n    else\n    {\n        if (gamemission == pack_nerve)\n        {\n            episode = gameepisode = 2;\n        }\n    }\n\n    // Initial height of PointOfView\n    // will be set by player think.\n    players[consoleplayer].viewz = 1; \n\n    // Make sure all sounds are stopped before Z_FreeTags.\n    S_Start ();\n\n    Z_FreeTags (PU_LEVEL, PU_PURGELEVEL-1);\n\n    // UNUSED W_Profile ();\n    P_InitThinkers ();\n\n    // if working with a devlopment map, reload it\n    W_Reload ();\n\n    lumpnum = P_GetNumForMap (episode, map, true);\n\t\n    maplumpinfo = lumpinfo[lumpnum];\n    strncpy(lumpname, maplumpinfo->name, 8);\n\n    leveltime = 0;\n    \n    // [crispy] check and log map and nodes format\n    crispy_mapformat = P_CheckMapFormat(lumpnum);\n\n    // note: most of this ordering is important\t\n    crispy_validblockmap = P_LoadBlockMap (lumpnum+ML_BLOCKMAP); // [crispy] (re-)create BLOCKMAP if necessary\n    P_LoadVertexes (lumpnum+ML_VERTEXES);\n    P_LoadSectors (lumpnum+ML_SECTORS);\n    P_LoadSideDefs (lumpnum+ML_SIDEDEFS);\n\n    if (crispy_mapformat & MFMT_HEXEN)\n\tP_LoadLineDefs_Hexen (lumpnum+ML_LINEDEFS);\n    else\n    P_LoadLineDefs (lumpnum+ML_LINEDEFS);\n\n    // translucent 2s textures\n    P_LoadLineDefs2(lumpnum+ML_LINEDEFS);\n    // special sidedefs\n    P_LoadSideDefs2(lumpnum+ML_SIDEDEFS);\n\n    // [crispy] (re-)create BLOCKMAP if necessary\n    if (!crispy_validblockmap)\n    {\n\textern void P_CreateBlockMap (void);\n\tP_CreateBlockMap();\n    }\n    if (crispy_mapformat & (MFMT_ZDBSPX | MFMT_ZDBSPZ))\n\tP_LoadNodes_ZDBSP (lumpnum+ML_NODES, crispy_mapformat & MFMT_ZDBSPZ);\n    else\n    if (crispy_mapformat & MFMT_DEEPBSP)\n    {\n\tP_LoadSubsectors_DeePBSP (lumpnum+ML_SSECTORS);\n\tP_LoadNodes_DeePBSP (lumpnum+ML_NODES);\n\tP_LoadSegs_DeePBSP (lumpnum+ML_SEGS);\n    }\n    else\n    {\n    P_LoadSubsectors (lumpnum+ML_SSECTORS);\n    P_LoadNodes (lumpnum+ML_NODES);\n    P_LoadSegs (lumpnum+ML_SEGS);\n    }\n\n    P_GroupLines ();\n    P_LoadReject (lumpnum+ML_REJECT);\n\n    // [crispy] remove slime trails\n    P_RemoveSlimeTrails();\n    // R_CalcSegsLength();\n    // [crispy] fix long wall wobble\n    P_SegLengths(false);\n\n    bodyqueslot = 0;\n    deathmatch_p = deathmatchstarts;\n    if (crispy_mapformat & MFMT_HEXEN)\n\tP_LoadThings_Hexen (lumpnum+ML_THINGS);\n    else\n    P_LoadThings (lumpnum+ML_THINGS);\n    \n    // if deathmatch, randomly spawn the active players\n    if (deathmatch)\n    {\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t    if (playeringame[i])\n\t    {\n\t\tplayers[i].mo = NULL;\n\t\tG_DeathMatchSpawnPlayer (i);\n\t    }\n\t\t\t\n    }\n\n    // clear special respawning que\n    iquehead = iquetail = 0;\t\t\n\t\n    // set up world state\n    P_SpawnSpecials ();\n\n    // preload graphics\n    if (precache)\n\tR_PrecacheLevel ();\n\n}\n\n// [crispy] height of the spawnstate's first sprite in pixels\nstatic void P_InitActualHeights (void)\n{\n\tint i;\n\n\tfor (i = 0; i < NUMMOBJTYPES; i++)\n\t{\n\t\tstate_t *state;\n\t\tspritedef_t *sprdef;\n\t\tspriteframe_t *sprframe;\n\t\tint lump;\n\t\tpatch_t *patch;\n\n\t\tstate = &states[mobjinfo[i].spawnstate];\n\t\tsprdef = &sprites[state->sprite];\n\n\t\tif (!sprdef->numframes || !(mobjinfo[i].flags & (MF_SOLID|MF_SHOOTABLE)))\n\t\t{\n\t\t\tmobjinfo[i].actualheight = mobjinfo[i].height;\n\t\t\tcontinue;\n\t\t}\n\n\t\tsprframe = &sprdef->spriteframes[state->frame & FF_FRAMEMASK];\n\t\tlump = sprframe->lump[0];\n\t\tpatch = W_CacheLumpNum (lump + firstspritelump, PU_CACHE);\n\n\t\t// [crispy] round to the next integer multiple of 8\n\t\tmobjinfo[i].actualheight = ((patch->height + 7) & (~7)) << FRACBITS;\n\t}\n}\n\n\n//\n// P_Init\n//\nvoid P_Init (void)\n{\n    P_InitSwitchList ();\n    P_InitPicAnims ();\n    R_InitSprites (sprnames);\n    P_InitActualHeights();\n}\n\n\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard, Andrey Budko\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tMovement, collision handling.\n//\tShooting and aiming.\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"deh_misc.h\"\n\n#include \"m_bbox.h\"\n#include \"m_random.h\"\n#include \"i_system.h\"\n\n#include \"doomdef.h\"\n#include \"m_argv.h\"\n#include \"m_misc.h\"\n#include \"p_local.h\"\n\n#include \"s_sound.h\"\n\n// State.\n#include \"doomstat.h\"\n#include \"r_state.h\"\n// Data.\n#include \"sounds.h\"\n\n#include \"i_video.h\"\n\n// Spechit overrun magic value.\n//\n// This is the value used by PrBoom-plus.  I think the value below is \n// actually better and works with more demos.  However, I think\n// it's better for the spechits emulation to be compatible with\n// PrBoom-plus, at least so that the big spechits emulation list\n// on Doomworld can also be used with Chocolate Doom.\n\n#define DEFAULT_SPECHIT_MAGIC 0x01C09C98\n\n// This is from a post by myk on the Doomworld forums, \n// outputted from entryway's spechit_magic generator for\n// s205n546.lmp.  The _exact_ value of this isn't too\n// important; as long as it is in the right general\n// range, it will usually work.  Otherwise, we can use\n// the generator (hacked doom2.exe) and provide it \n// with -spechit.\n\n//#define DEFAULT_SPECHIT_MAGIC 0x84f968e8\n\n\nfixed_t\t\ttmbbox[4];\nmobj_t*\t\ttmthing;\nint\t\ttmflags;\nfixed_t\t\ttmx;\nfixed_t\t\ttmy;\n\n\n// If \"floatok\" true, move would be ok\n// if within \"tmfloorz - tmceilingz\".\nboolean\t\tfloatok;\n\nfixed_t\t\ttmfloorz;\nfixed_t\t\ttmceilingz;\nfixed_t\t\ttmdropoffz;\n\n// keep track of the line that lowers the ceiling,\n// so missiles don't explode against sky hack walls\nline_t*\t\tceilingline;\n\n// keep track of special lines as they are hit,\n// but don't process them until the move is proven valid\n\nline_t*\t\tspechit[MAXSPECIALCROSS];\nint\t\tnumspechit;\n\n\n\n//\n// TELEPORT MOVE\n// \n\n//\n// PIT_StompThing\n//\nboolean PIT_StompThing (mobj_t* thing)\n{\n    fixed_t\tblockdist;\n\t\t\n    if (!(thing->flags & MF_SHOOTABLE) )\n\treturn true;\n\t\t\n    blockdist = thing->radius + tmthing->radius;\n    \n    if ( abs(thing->x - tmx) >= blockdist\n\t || abs(thing->y - tmy) >= blockdist )\n    {\n\t// didn't hit it\n\treturn true;\n    }\n    \n    // don't clip against self\n    if (thing == tmthing)\n\treturn true;\n    \n    // monsters don't stomp things except on boss level\n    if ( !tmthing->player && gamemap != 30)\n\treturn false;\t\n\t\t\n    P_DamageMobj (thing, tmthing, tmthing, 10000);\n\t\n    return true;\n}\n\n\n//\n// P_TeleportMove\n//\nboolean\nP_TeleportMove\n( mobj_t*\tthing,\n  fixed_t\tx,\n  fixed_t\ty )\n{\n    int\t\t\txl;\n    int\t\t\txh;\n    int\t\t\tyl;\n    int\t\t\tyh;\n    int\t\t\tbx;\n    int\t\t\tby;\n    \n    subsector_t*\tnewsubsec;\n    \n    // kill anything occupying the position\n    tmthing = thing;\n    tmflags = thing->flags;\n\t\n    tmx = x;\n    tmy = y;\n\t\n    tmbbox[BOXTOP] = y + tmthing->radius;\n    tmbbox[BOXBOTTOM] = y - tmthing->radius;\n    tmbbox[BOXRIGHT] = x + tmthing->radius;\n    tmbbox[BOXLEFT] = x - tmthing->radius;\n\n    newsubsec = R_PointInSubsector (x,y);\n    ceilingline = NULL;\n    \n    // The base floor/ceiling is from the subsector\n    // that contains the point.\n    // Any contacted lines the step closer together\n    // will adjust them.\n    tmfloorz = tmdropoffz = newsubsec->sector->floorheight;\n    tmceilingz = newsubsec->sector->ceilingheight;\n\t\t\t\n    validcount++;\n    numspechit = 0;\n    \n    // stomp on any things contacted\n    xl = (tmbbox[BOXLEFT] - bmaporgx - MAXRADIUS)>>MAPBLOCKSHIFT;\n    xh = (tmbbox[BOXRIGHT] - bmaporgx + MAXRADIUS)>>MAPBLOCKSHIFT;\n    yl = (tmbbox[BOXBOTTOM] - bmaporgy - MAXRADIUS)>>MAPBLOCKSHIFT;\n    yh = (tmbbox[BOXTOP] - bmaporgy + MAXRADIUS)>>MAPBLOCKSHIFT;\n\n    for (bx=xl ; bx<=xh ; bx++)\n\tfor (by=yl ; by<=yh ; by++)\n\t    if (!P_BlockThingsIterator(bx,by,PIT_StompThing))\n\t\treturn false;\n    \n    // the move is ok,\n    // so link the thing into its new position\n    P_UnsetThingPosition (thing);\n\n    thing->floorz = tmfloorz;\n    thing->ceilingz = tmceilingz;\t\n    thing->x = x;\n    thing->y = y;\n\n    P_SetThingPosition (thing);\n\t\n    return true;\n}\n\n\n//\n// MOVEMENT ITERATOR FUNCTIONS\n//\n\nstatic void SpechitOverrun(line_t *ld);\n\n//\n// PIT_CheckLine\n// Adjusts tmfloorz and tmceilingz as lines are contacted\n//\nboolean PIT_CheckLine (line_t* ld)\n{\n    if (tmbbox[BOXRIGHT] <= ld->bbox[BOXLEFT]\n\t|| tmbbox[BOXLEFT] >= ld->bbox[BOXRIGHT]\n\t|| tmbbox[BOXTOP] <= ld->bbox[BOXBOTTOM]\n\t|| tmbbox[BOXBOTTOM] >= ld->bbox[BOXTOP] )\n\treturn true;\n\n    if (P_BoxOnLineSide (tmbbox, ld) != -1)\n\treturn true;\n\t\t\n    // A line has been hit\n    \n    // The moving thing's destination position will cross\n    // the given line.\n    // If this should not be allowed, return false.\n    // If the line is special, keep track of it\n    // to process later if the move is proven ok.\n    // NOTE: specials are NOT sorted by order,\n    // so two special lines that are only 8 pixels apart\n    // could be crossed in either order.\n    \n    if (!ld->backsector)\n\treturn false;\t\t// one sided line\n\t\t\n    if (!(tmthing->flags & MF_MISSILE) )\n    {\n\tif ( ld->flags & ML_BLOCKING )\n\t    return false;\t// explicitly blocking everything\n\n\tif ( !tmthing->player && ld->flags & ML_BLOCKMONSTERS )\n\t    return false;\t// block monsters only\n    }\n\n    // set openrange, opentop, openbottom\n    P_LineOpening (ld);\t\n\t\n    // adjust floor / ceiling heights\n    if (opentop < tmceilingz)\n    {\n\ttmceilingz = opentop;\n\tceilingline = ld;\n    }\n\n    if (openbottom > tmfloorz)\n\ttmfloorz = openbottom;\t\n\n    if (lowfloor < tmdropoffz)\n\ttmdropoffz = lowfloor;\n\t\t\n    // if contacted a special line, add it to the list\n    if (ld->special)\n    {\n        spechit[numspechit] = ld;\n\tnumspechit++;\n\n        // fraggle: spechits overrun emulation code from prboom-plus\n        if (numspechit > MAXSPECIALCROSS_ORIGINAL)\n        {\n            SpechitOverrun(ld);\n        }\n    }\n\n    return true;\n}\n\n//\n// PIT_CheckThing\n//\nboolean PIT_CheckThing (mobj_t* thing)\n{\n    fixed_t\t\tblockdist;\n    boolean\t\tsolid;\n    int\t\t\tdamage;\n\t\t\n    if (!(thing->flags & (MF_SOLID|MF_SPECIAL|MF_SHOOTABLE) ))\n\treturn true;\n    \n    blockdist = thing->radius + tmthing->radius;\n\n    if ( abs(thing->x - tmx) >= blockdist\n\t || abs(thing->y - tmy) >= blockdist )\n    {\n\t// didn't hit it\n\treturn true;\t\n    }\n    \n    // don't clip against self\n    if (thing == tmthing)\n\treturn true;\n    \n    // check for skulls slamming into things\n    if (tmthing->flags & MF_SKULLFLY)\n    {\n\tdamage = ((P_Random()%8)+1)*tmthing->info->damage;\n\t\n\tP_DamageMobj (thing, tmthing, tmthing, damage);\n\t\n\ttmthing->flags &= ~MF_SKULLFLY;\n\ttmthing->momx = tmthing->momy = tmthing->momz = 0;\n\t\n\tP_SetMobjState (tmthing, tmthing->info->spawnstate);\n\t\n\treturn false;\t\t// stop moving\n    }\n\n    \n    // missiles can hit other things\n    if (tmthing->flags & MF_MISSILE)\n    {\n\t// see if it went over / under\n\tif (tmthing->z > thing->z + thing->height)\n\t    return true;\t\t// overhead\n\tif (tmthing->z+tmthing->height < thing->z)\n\t    return true;\t\t// underneath\n\t\t\n\tif (tmthing->target \n         && (tmthing->target->type == thing->type || \n\t    (tmthing->target->type == MT_KNIGHT && thing->type == MT_BRUISER)||\n\t    (tmthing->target->type == MT_BRUISER && thing->type == MT_KNIGHT) ) )\n\t{\n\t    // Don't hit same species as originator.\n\t    if (thing == tmthing->target)\n\t\treturn true;\n\n            // sdh: Add deh_species_infighting here.  We can override the\n            // \"monsters of the same species cant hurt each other\" behavior\n            // through dehacked patches\n\n\t    if (thing->type != MT_PLAYER && !deh_species_infighting)\n\t    {\n\t\t// Explode, but do no damage.\n\t\t// Let players missile other players.\n\t\treturn false;\n\t    }\n\t}\n\t\n\tif (! (thing->flags & MF_SHOOTABLE) )\n\t{\n\t    // didn't do any damage\n\t    return !(thing->flags & MF_SOLID);\t\n\t}\n\t\n\t// damage / explode\n\tdamage = ((P_Random()%8)+1)*tmthing->info->damage;\n\tP_DamageMobj (thing, tmthing, tmthing->target, damage);\n\n\t// don't traverse any more\n\treturn false;\t\t\t\t\n    }\n    \n    // check for special pickup\n    if (thing->flags & MF_SPECIAL)\n    {\n\tsolid = (thing->flags & MF_SOLID) != 0;\n\tif (tmflags&MF_PICKUP)\n\t{\n\t    // can remove thing\n\t    P_TouchSpecialThing (thing, tmthing);\n\t}\n\treturn !solid;\n    }\n\t\n    return !(thing->flags & MF_SOLID);\n}\n\n\n//\n// MOVEMENT CLIPPING\n//\n\n//\n// P_CheckPosition\n// This is purely informative, nothing is modified\n// (except things picked up).\n// \n// in:\n//  a mobj_t (can be valid or invalid)\n//  a position to be checked\n//   (doesn't need to be related to the mobj_t->x,y)\n//\n// during:\n//  special things are touched if MF_PICKUP\n//  early out on solid lines?\n//\n// out:\n//  newsubsec\n//  floorz\n//  ceilingz\n//  tmdropoffz\n//   the lowest point contacted\n//   (monsters won't move to a dropoff)\n//  speciallines[]\n//  numspeciallines\n//\nboolean\nP_CheckPosition\n( mobj_t*\tthing,\n  fixed_t\tx,\n  fixed_t\ty )\n{\n    int\t\t\txl;\n    int\t\t\txh;\n    int\t\t\tyl;\n    int\t\t\tyh;\n    int\t\t\tbx;\n    int\t\t\tby;\n    subsector_t*\tnewsubsec;\n\n    tmthing = thing;\n    tmflags = thing->flags;\n\t\n    tmx = x;\n    tmy = y;\n\t\n    tmbbox[BOXTOP] = y + tmthing->radius;\n    tmbbox[BOXBOTTOM] = y - tmthing->radius;\n    tmbbox[BOXRIGHT] = x + tmthing->radius;\n    tmbbox[BOXLEFT] = x - tmthing->radius;\n\n    newsubsec = R_PointInSubsector (x,y);\n    ceilingline = NULL;\n    \n    // The base floor / ceiling is from the subsector\n    // that contains the point.\n    // Any contacted lines the step closer together\n    // will adjust them.\n    tmfloorz = tmdropoffz = newsubsec->sector->floorheight;\n    tmceilingz = newsubsec->sector->ceilingheight;\n\t\t\t\n    validcount++;\n    numspechit = 0;\n\n    if ( tmflags & MF_NOCLIP )\n\treturn true;\n    \n    // Check things first, possibly picking things up.\n    // The bounding box is extended by MAXRADIUS\n    // because mobj_ts are grouped into mapblocks\n    // based on their origin point, and can overlap\n    // into adjacent blocks by up to MAXRADIUS units.\n    xl = (tmbbox[BOXLEFT] - bmaporgx - MAXRADIUS)>>MAPBLOCKSHIFT;\n    xh = (tmbbox[BOXRIGHT] - bmaporgx + MAXRADIUS)>>MAPBLOCKSHIFT;\n    yl = (tmbbox[BOXBOTTOM] - bmaporgy - MAXRADIUS)>>MAPBLOCKSHIFT;\n    yh = (tmbbox[BOXTOP] - bmaporgy + MAXRADIUS)>>MAPBLOCKSHIFT;\n\n    for (bx=xl ; bx<=xh ; bx++)\n\tfor (by=yl ; by<=yh ; by++)\n\t    if (!P_BlockThingsIterator(bx,by,PIT_CheckThing))\n\t\treturn false;\n    \n    // check lines\n    xl = (tmbbox[BOXLEFT] - bmaporgx)>>MAPBLOCKSHIFT;\n    xh = (tmbbox[BOXRIGHT] - bmaporgx)>>MAPBLOCKSHIFT;\n    yl = (tmbbox[BOXBOTTOM] - bmaporgy)>>MAPBLOCKSHIFT;\n    yh = (tmbbox[BOXTOP] - bmaporgy)>>MAPBLOCKSHIFT;\n\n    for (bx=xl ; bx<=xh ; bx++)\n\tfor (by=yl ; by<=yh ; by++)\n\t    if (!P_BlockLinesIterator (bx,by,PIT_CheckLine))\n\t\treturn false;\n\n    return true;\n}\n\n\n//\n// P_TryMove\n// Attempt to move to a new position,\n// crossing special lines unless MF_TELEPORT is set.\n//\nboolean\nP_TryMove\n( mobj_t*\tthing,\n  fixed_t\tx,\n  fixed_t\ty )\n{\n    fixed_t\toldx;\n    fixed_t\toldy;\n    int\t\tside;\n    int\t\toldside;\n    line_t*\tld;\n\n    floatok = false;\n    if (!P_CheckPosition (thing, x, y))\n\treturn false;\t\t// solid wall or thing\n    \n    if ( !(thing->flags & MF_NOCLIP) )\n    {\n\tif (tmceilingz - tmfloorz < thing->height)\n\t    return false;\t// doesn't fit\n\n\tfloatok = true;\n\t\n\tif ( !(thing->flags&MF_TELEPORT) \n\t     &&tmceilingz - thing->z < thing->height)\n\t    return false;\t// mobj must lower itself to fit\n\n\tif ( !(thing->flags&MF_TELEPORT)\n\t     && tmfloorz - thing->z > 24*FRACUNIT )\n\t    return false;\t// too big a step up\n\n\tif ( !(thing->flags&(MF_DROPOFF|MF_FLOAT))\n\t     && tmfloorz - tmdropoffz > 24*FRACUNIT )\n\t    return false;\t// don't stand over a dropoff\n    }\n    \n    // the move is ok,\n    // so link the thing into its new position\n    P_UnsetThingPosition (thing);\n\n    oldx = thing->x;\n    oldy = thing->y;\n    thing->floorz = tmfloorz;\n    thing->ceilingz = tmceilingz;\t\n    thing->x = x;\n    thing->y = y;\n\n    P_SetThingPosition (thing);\n    \n    // if any special lines were hit, do the effect\n    if (! (thing->flags&(MF_TELEPORT|MF_NOCLIP)) )\n    {\n\twhile (numspechit--)\n\t{\n\t    // see if the line was crossed\n\t    ld = spechit[numspechit];\n\t    side = P_PointOnLineSide (thing->x, thing->y, ld);\n\t    oldside = P_PointOnLineSide (oldx, oldy, ld);\n\t    if (side != oldside)\n\t    {\n\t\tif (ld->special)\n\t\t    P_CrossSpecialLine (ld-lines, oldside, thing);\n\t    }\n\t}\n    }\n\n    return true;\n}\n\n\n//\n// P_ThingHeightClip\n// Takes a valid thing and adjusts the thing->floorz,\n// thing->ceilingz, and possibly thing->z.\n// This is called for all nearby monsters\n// whenever a sector changes height.\n// If the thing doesn't fit,\n// the z will be set to the lowest value\n// and false will be returned.\n//\nboolean P_ThingHeightClip (mobj_t* thing)\n{\n    boolean\t\tonfloor;\n\t\n    onfloor = (thing->z == thing->floorz);\n\t\n    P_CheckPosition (thing, thing->x, thing->y);\t\n    // what about stranding a monster partially off an edge?\n\t\n    thing->floorz = tmfloorz;\n    thing->ceilingz = tmceilingz;\n\t\n    if (onfloor)\n    {\n\t// walking monsters rise and fall with the floor\n\tthing->z = thing->floorz;\n    }\n    else\n    {\n\t// don't adjust a floating monster unless forced to\n\tif (thing->z+thing->height > thing->ceilingz)\n\t    thing->z = thing->ceilingz - thing->height;\n    }\n\t\n    if (thing->ceilingz - thing->floorz < thing->height)\n\treturn false;\n\t\t\n    return true;\n}\n\n\n\n//\n// SLIDE MOVE\n// Allows the player to slide along any angled walls.\n//\nfixed_t\t\tbestslidefrac;\nfixed_t\t\tsecondslidefrac;\n\nline_t*\t\tbestslideline;\nline_t*\t\tsecondslideline;\n\nmobj_t*\t\tslidemo;\n\nfixed_t\t\ttmxmove;\nfixed_t\t\ttmymove;\n\n\n\n//\n// P_HitSlideLine\n// Adjusts the xmove / ymove\n// so that the next move will slide along the wall.\n//\nvoid P_HitSlideLine (line_t* ld)\n{\n    int\t\t\tside;\n\n    angle_t\t\tlineangle;\n    angle_t\t\tmoveangle;\n    angle_t\t\tdeltaangle;\n    \n    fixed_t\t\tmovelen;\n    fixed_t\t\tnewlen;\n\t\n\t\n    if (ld->slopetype == ST_HORIZONTAL)\n    {\n\ttmymove = 0;\n\treturn;\n    }\n    \n    if (ld->slopetype == ST_VERTICAL)\n    {\n\ttmxmove = 0;\n\treturn;\n    }\n\t\n    side = P_PointOnLineSide (slidemo->x, slidemo->y, ld);\n\t\n    lineangle = R_PointToAngle2 (0,0, ld->dx, ld->dy);\n\n    if (side == 1)\n\tlineangle += ANG180;\n\n    moveangle = R_PointToAngle2 (0,0, tmxmove, tmymove);\n    deltaangle = moveangle-lineangle;\n\n    if (deltaangle > ANG180)\n\tdeltaangle += ANG180;\n    //\tI_Error (\"SlideLine: ang>ANG180\");\n\n    lineangle >>= ANGLETOFINESHIFT;\n    deltaangle >>= ANGLETOFINESHIFT;\n\t\n    movelen = P_AproxDistance (tmxmove, tmymove);\n    newlen = FixedMul (movelen, finecosine[deltaangle]);\n\n    tmxmove = FixedMul (newlen, finecosine[lineangle]);\t\n    tmymove = FixedMul (newlen, finesine[lineangle]);\t\n}\n\n\n//\n// PTR_SlideTraverse\n//\nboolean PTR_SlideTraverse (intercept_t* in)\n{\n    line_t*\tli;\n\t\n    if (!in->isaline)\n\tI_Error (\"PTR_SlideTraverse: not a line?\");\n\t\t\n    li = in->d.line;\n    \n    if ( ! (li->flags & ML_TWOSIDED) )\n    {\n\tif (P_PointOnLineSide (slidemo->x, slidemo->y, li))\n\t{\n\t    // don't hit the back side\n\t    return true;\t\t\n\t}\n\tgoto isblocking;\n    }\n\n    // set openrange, opentop, openbottom\n    P_LineOpening (li);\n    \n    if (openrange < slidemo->height)\n\tgoto isblocking;\t\t// doesn't fit\n\t\t\n    if (opentop - slidemo->z < slidemo->height)\n\tgoto isblocking;\t\t// mobj is too high\n\n    if (openbottom - slidemo->z > 24*FRACUNIT )\n\tgoto isblocking;\t\t// too big a step up\n\n    // this line doesn't block movement\n    return true;\t\t\n\t\n    // the line does block movement,\n    // see if it is closer than best so far\n  isblocking:\t\t\n    if (in->frac < bestslidefrac)\n    {\n\tsecondslidefrac = bestslidefrac;\n\tsecondslideline = bestslideline;\n\tbestslidefrac = in->frac;\n\tbestslideline = li;\n    }\n\t\n    return false;\t// stop\n}\n\n\n\n//\n// P_SlideMove\n// The momx / momy move is bad, so try to slide\n// along a wall.\n// Find the first line hit, move flush to it,\n// and slide along it\n//\n// This is a kludgy mess.\n//\nvoid P_SlideMove (mobj_t* mo)\n{\n    fixed_t\t\tleadx;\n    fixed_t\t\tleady;\n    fixed_t\t\ttrailx;\n    fixed_t\t\ttraily;\n    fixed_t\t\tnewx;\n    fixed_t\t\tnewy;\n    int\t\t\thitcount;\n\t\t\n    slidemo = mo;\n    hitcount = 0;\n    \n  retry:\n    if (++hitcount == 3)\n\tgoto stairstep;\t\t// don't loop forever\n\n    \n    // trace along the three leading corners\n    if (mo->momx > 0)\n    {\n\tleadx = mo->x + mo->radius;\n\ttrailx = mo->x - mo->radius;\n    }\n    else\n    {\n\tleadx = mo->x - mo->radius;\n\ttrailx = mo->x + mo->radius;\n    }\n\t\n    if (mo->momy > 0)\n    {\n\tleady = mo->y + mo->radius;\n\ttraily = mo->y - mo->radius;\n    }\n    else\n    {\n\tleady = mo->y - mo->radius;\n\ttraily = mo->y + mo->radius;\n    }\n\t\t\n    bestslidefrac = FRACUNIT+1;\n\t\n    P_PathTraverse ( leadx, leady, leadx+mo->momx, leady+mo->momy,\n\t\t     PT_ADDLINES, PTR_SlideTraverse );\n    P_PathTraverse ( trailx, leady, trailx+mo->momx, leady+mo->momy,\n\t\t     PT_ADDLINES, PTR_SlideTraverse );\n    P_PathTraverse ( leadx, traily, leadx+mo->momx, traily+mo->momy,\n\t\t     PT_ADDLINES, PTR_SlideTraverse );\n    \n    // move up to the wall\n    if (bestslidefrac == FRACUNIT+1)\n    {\n\t// the move most have hit the middle, so stairstep\n      stairstep:\n\tif (!P_TryMove (mo, mo->x, mo->y + mo->momy))\n\t    P_TryMove (mo, mo->x + mo->momx, mo->y);\n\treturn;\n    }\n\n    // fudge a bit to make sure it doesn't hit\n    bestslidefrac -= 0x800;\t\n    if (bestslidefrac > 0)\n    {\n\tnewx = FixedMul (mo->momx, bestslidefrac);\n\tnewy = FixedMul (mo->momy, bestslidefrac);\n\t\n\tif (!P_TryMove (mo, mo->x+newx, mo->y+newy))\n\t    goto stairstep;\n    }\n    \n    // Now continue along the wall.\n    // First calculate remainder.\n    bestslidefrac = FRACUNIT-(bestslidefrac+0x800);\n    \n    if (bestslidefrac > FRACUNIT)\n\tbestslidefrac = FRACUNIT;\n    \n    if (bestslidefrac <= 0)\n\treturn;\n    \n    tmxmove = FixedMul (mo->momx, bestslidefrac);\n    tmymove = FixedMul (mo->momy, bestslidefrac);\n\n    P_HitSlideLine (bestslideline);\t// clip the moves\n\n    mo->momx = tmxmove;\n    mo->momy = tmymove;\n\t\t\n    if (!P_TryMove (mo, mo->x+tmxmove, mo->y+tmymove))\n    {\n\tgoto retry;\n    }\n}\n\n\n//\n// P_LineAttack\n//\nmobj_t*\t\tlinetarget;\t// who got hit (or NULL)\nmobj_t*\t\tshootthing;\n\n// Height if not aiming up or down\n// ???: use slope for monsters?\nfixed_t\t\tshootz;\t\n\nint\t\tla_damage;\nfixed_t\t\tattackrange;\n\nfixed_t\t\taimslope;\n\n// slopes to top and bottom of target\nextern fixed_t\ttopslope;\nextern fixed_t\tbottomslope;\t\n\n\n//\n// PTR_AimTraverse\n// Sets linetaget and aimslope when a target is aimed at.\n//\nboolean\nPTR_AimTraverse (intercept_t* in)\n{\n    line_t*\t\tli;\n    mobj_t*\t\tth;\n    fixed_t\t\tslope;\n    fixed_t\t\tthingtopslope;\n    fixed_t\t\tthingbottomslope;\n    fixed_t\t\tdist;\n\t\t\n    if (in->isaline)\n    {\n\tli = in->d.line;\n\t\n\tif ( !(li->flags & ML_TWOSIDED) )\n\t    return false;\t\t// stop\n\t\n\t// Crosses a two sided line.\n\t// A two sided line will restrict\n\t// the possible target ranges.\n\tP_LineOpening (li);\n\t\n\tif (openbottom >= opentop)\n\t    return false;\t\t// stop\n\t\n\tdist = FixedMul (attackrange, in->frac);\n\n        if (li->backsector == NULL\n         || li->frontsector->floorheight != li->backsector->floorheight)\n\t{\n\t    slope = FixedDiv (openbottom - shootz , dist);\n\t    if (slope > bottomslope)\n\t\tbottomslope = slope;\n\t}\n\t\t\n\tif (li->backsector == NULL\n         || li->frontsector->ceilingheight != li->backsector->ceilingheight)\n\t{\n\t    slope = FixedDiv (opentop - shootz , dist);\n\t    if (slope < topslope)\n\t\ttopslope = slope;\n\t}\n\t\t\n\tif (topslope <= bottomslope)\n\t    return false;\t\t// stop\n\t\t\t\n\treturn true;\t\t\t// shot continues\n    }\n    \n    // shoot a thing\n    th = in->d.thing;\n    if (th == shootthing)\n\treturn true;\t\t\t// can't shoot self\n    \n    if (!(th->flags&MF_SHOOTABLE))\n\treturn true;\t\t\t// corpse or something\n\n    // check angles to see if the thing can be aimed at\n    dist = FixedMul (attackrange, in->frac);\n    thingtopslope = FixedDiv (th->z+th->height - shootz , dist);\n\n    if (thingtopslope < bottomslope)\n\treturn true;\t\t\t// shot over the thing\n\n    thingbottomslope = FixedDiv (th->z - shootz, dist);\n\n    if (thingbottomslope > topslope)\n\treturn true;\t\t\t// shot under the thing\n    \n    // this thing can be hit!\n    if (thingtopslope > topslope)\n\tthingtopslope = topslope;\n    \n    if (thingbottomslope < bottomslope)\n\tthingbottomslope = bottomslope;\n\n    aimslope = (thingtopslope+thingbottomslope)/2;\n    linetarget = th;\n\n    return false;\t\t\t// don't go any farther\n}\n\n\n//\n// PTR_ShootTraverse\n//\nboolean PTR_ShootTraverse (intercept_t* in)\n{\n    fixed_t\t\tx;\n    fixed_t\t\ty;\n    fixed_t\t\tz;\n    fixed_t\t\tfrac;\n    \n    line_t*\t\tli;\n    \n    mobj_t*\t\tth;\n\n    fixed_t\t\tslope;\n    fixed_t\t\tdist;\n    fixed_t\t\tthingtopslope;\n    fixed_t\t\tthingbottomslope;\n\t\t\n    if (in->isaline)\n    {\n\tli = in->d.line;\n\t\n\tif (li->special)\n\t    P_ShootSpecialLine (shootthing, li);\n\n\tif ( !(li->flags & ML_TWOSIDED) )\n\t    goto hitline;\n\t\n\t// crosses a two sided line\n\tP_LineOpening (li);\n\t\t\n\tdist = FixedMul (attackrange, in->frac);\n\n        // e6y: emulation of missed back side on two-sided lines.\n        // backsector can be NULL when emulating missing back side.\n\n        if (li->backsector == NULL)\n        {\n            slope = FixedDiv (openbottom - shootz , dist);\n            if (slope > aimslope)\n                goto hitline;\n\n            slope = FixedDiv (opentop - shootz , dist);\n            if (slope < aimslope)\n                goto hitline;\n        }\n        else\n        {\n            if (li->frontsector->floorheight != li->backsector->floorheight)\n            {\n                slope = FixedDiv (openbottom - shootz , dist);\n                if (slope > aimslope)\n                    goto hitline;\n            }\n\n            if (li->frontsector->ceilingheight != li->backsector->ceilingheight)\n            {\n                slope = FixedDiv (opentop - shootz , dist);\n                if (slope < aimslope)\n                    goto hitline;\n            }\n        }\n\n\t// shot continues\n\treturn true;\n\t\n\t\n\t// hit line\n      hitline:\n\t// position a bit closer\n\tfrac = in->frac - FixedDiv (4*FRACUNIT,attackrange);\n\tx = trace.x + FixedMul (trace.dx, frac);\n\ty = trace.y + FixedMul (trace.dy, frac);\n\tz = shootz + FixedMul (aimslope, FixedMul(frac, attackrange));\n\n\tif (li->frontsector->ceilingpic == skyflatnum)\n\t{\n\t    // don't shoot the sky!\n\t    if (z > li->frontsector->ceilingheight)\n\t\treturn false;\n\t    \n\t    // it's a sky hack wall\n\t    if\t(li->backsector && li->backsector->ceilingpic == skyflatnum)\n\t\treturn false;\t\t\n\t}\n\n\t// Spawn bullet puffs.\n\tP_SpawnPuff (x,y,z);\n\t\n\t// don't go any farther\n\treturn false;\t\n    }\n    \n    // shoot a thing\n    th = in->d.thing;\n    if (th == shootthing)\n\treturn true;\t\t// can't shoot self\n    \n    if (!(th->flags&MF_SHOOTABLE))\n\treturn true;\t\t// corpse or something\n\t\t\n    // check angles to see if the thing can be aimed at\n    dist = FixedMul (attackrange, in->frac);\n    thingtopslope = FixedDiv (th->z+th->height - shootz , dist);\n\n    if (thingtopslope < aimslope)\n\treturn true;\t\t// shot over the thing\n\n    thingbottomslope = FixedDiv (th->z - shootz, dist);\n\n    if (thingbottomslope > aimslope)\n\treturn true;\t\t// shot under the thing\n\n    \n    // hit thing\n    // position a bit closer\n    frac = in->frac - FixedDiv (10*FRACUNIT,attackrange);\n\n    x = trace.x + FixedMul (trace.dx, frac);\n    y = trace.y + FixedMul (trace.dy, frac);\n    z = shootz + FixedMul (aimslope, FixedMul(frac, attackrange));\n\n    // Spawn bullet puffs or blod spots,\n    // depending on target type.\n    if (in->d.thing->flags & MF_NOBLOOD)\n\tP_SpawnPuff (x,y,z);\n    else\n\tP_SpawnBlood (x,y,z, la_damage);\n\n    if (la_damage)\n\tP_DamageMobj (th, shootthing, shootthing, la_damage);\n\n    // don't go any farther\n    return false;\n\t\n}\n\n\n//\n// P_AimLineAttack\n//\nfixed_t\nP_AimLineAttack\n( mobj_t*\tt1,\n  angle_t\tangle,\n  fixed_t\tdistance )\n{\n    fixed_t\tx2;\n    fixed_t\ty2;\n\n    t1 = P_SubstNullMobj(t1);\n\t\n    angle >>= ANGLETOFINESHIFT;\n    shootthing = t1;\n    \n    x2 = t1->x + (distance>>FRACBITS)*finecosine[angle];\n    y2 = t1->y + (distance>>FRACBITS)*finesine[angle];\n    shootz = t1->z + (t1->height>>1) + 8*FRACUNIT;\n\n    // can't shoot outside view angles\n    topslope = (SCREENHEIGHT/2)*FRACUNIT/(SCREENWIDTH/2);\t\n    bottomslope = -(SCREENHEIGHT/2)*FRACUNIT/(SCREENWIDTH/2);\n    \n    attackrange = distance;\n    linetarget = NULL;\n\t\n    P_PathTraverse ( t1->x, t1->y,\n\t\t     x2, y2,\n\t\t     PT_ADDLINES|PT_ADDTHINGS,\n\t\t     PTR_AimTraverse );\n\t\t\n    if (linetarget)\n\treturn aimslope;\n\n    return 0;\n}\n \n\n//\n// P_LineAttack\n// If damage == 0, it is just a test trace\n// that will leave linetarget set.\n//\nvoid\nP_LineAttack\n( mobj_t*\tt1,\n  angle_t\tangle,\n  fixed_t\tdistance,\n  fixed_t\tslope,\n  int\t\tdamage )\n{\n    fixed_t\tx2;\n    fixed_t\ty2;\n\t\n    angle >>= ANGLETOFINESHIFT;\n    shootthing = t1;\n    la_damage = damage;\n    x2 = t1->x + (distance>>FRACBITS)*finecosine[angle];\n    y2 = t1->y + (distance>>FRACBITS)*finesine[angle];\n    shootz = t1->z + (t1->height>>1) + 8*FRACUNIT;\n    attackrange = distance;\n    aimslope = slope;\n\t\t\n    P_PathTraverse ( t1->x, t1->y,\n\t\t     x2, y2,\n\t\t     PT_ADDLINES|PT_ADDTHINGS,\n\t\t     PTR_ShootTraverse );\n}\n \n\n\n//\n// USE LINES\n//\nmobj_t*\t\tusething;\n\nboolean\tPTR_UseTraverse (intercept_t* in)\n{\n    int\t\tside;\n\t\n    if (!in->d.line->special)\n    {\n\tP_LineOpening (in->d.line);\n\tif (openrange <= 0)\n\t{\n\t    S_StartSound (usething, sfx_noway);\n\t    \n\t    // can't use through a wall\n\t    return false;\t\n\t}\n\t// not a special line, but keep checking\n\treturn true ;\t\t\n    }\n\t\n    side = 0;\n    if (P_PointOnLineSide (usething->x, usething->y, in->d.line) == 1)\n\tside = 1;\n    \n    //\treturn false;\t\t// don't use back side\n\t\n    P_UseSpecialLine (usething, in->d.line, side);\n\n    // can't use for than one special line in a row\n    return in->d.line->flags&ML_PASSUSE ? true : false;\n}\n\n\n//\n// P_UseLines\n// Looks for special lines in front of the player to activate.\n//\nvoid P_UseLines (player_t*\tplayer) \n{\n    int\t\tangle;\n    fixed_t\tx1;\n    fixed_t\ty1;\n    fixed_t\tx2;\n    fixed_t\ty2;\n\t\n    usething = player->mo;\n\t\t\n    angle = player->mo->angle >> ANGLETOFINESHIFT;\n\n    x1 = player->mo->x;\n    y1 = player->mo->y;\n    x2 = x1 + (USERANGE>>FRACBITS)*finecosine[angle];\n    y2 = y1 + (USERANGE>>FRACBITS)*finesine[angle];\n\t\n    P_PathTraverse ( x1, y1, x2, y2, PT_ADDLINES, PTR_UseTraverse );\n}\n\n\n//\n// RADIUS ATTACK\n//\nmobj_t*\t\tbombsource;\nmobj_t*\t\tbombspot;\nint\t\tbombdamage;\n\n\n//\n// PIT_RadiusAttack\n// \"bombsource\" is the creature\n// that caused the explosion at \"bombspot\".\n//\nboolean PIT_RadiusAttack (mobj_t* thing)\n{\n    fixed_t\tdx;\n    fixed_t\tdy;\n    fixed_t\tdist;\n\t\n    if (!(thing->flags & MF_SHOOTABLE) )\n\treturn true;\n\n    // Boss spider and cyborg\n    // take no damage from concussion.\n    if (thing->type == MT_CYBORG\n\t|| thing->type == MT_SPIDER)\n\treturn true;\t\n\t\t\n    dx = abs(thing->x - bombspot->x);\n    dy = abs(thing->y - bombspot->y);\n    \n    dist = dx>dy ? dx : dy;\n    dist = (dist - thing->radius) >> FRACBITS;\n\n    if (dist < 0)\n\tdist = 0;\n\n    if (dist >= bombdamage)\n\treturn true;\t// out of range\n\n    if ( P_CheckSight (thing, bombspot) )\n    {\n\t// must be in direct path\n\tP_DamageMobj (thing, bombspot, bombsource, bombdamage - dist);\n    }\n    \n    return true;\n}\n\n\n//\n// P_RadiusAttack\n// Source is the creature that caused the explosion at spot.\n//\nvoid\nP_RadiusAttack\n( mobj_t*\tspot,\n  mobj_t*\tsource,\n  int\t\tdamage )\n{\n    int\t\tx;\n    int\t\ty;\n    \n    int\t\txl;\n    int\t\txh;\n    int\t\tyl;\n    int\t\tyh;\n    \n    fixed_t\tdist;\n\t\n    dist = (damage+MAXRADIUS)<<FRACBITS;\n    yh = (spot->y + dist - bmaporgy)>>MAPBLOCKSHIFT;\n    yl = (spot->y - dist - bmaporgy)>>MAPBLOCKSHIFT;\n    xh = (spot->x + dist - bmaporgx)>>MAPBLOCKSHIFT;\n    xl = (spot->x - dist - bmaporgx)>>MAPBLOCKSHIFT;\n    bombspot = spot;\n    bombsource = source;\n    bombdamage = damage;\n\t\n    for (y=yl ; y<=yh ; y++)\n\tfor (x=xl ; x<=xh ; x++)\n\t    P_BlockThingsIterator (x, y, PIT_RadiusAttack );\n}\n\n\n\n//\n// SECTOR HEIGHT CHANGING\n// After modifying a sectors floor or ceiling height,\n// call this routine to adjust the positions\n// of all things that touch the sector.\n//\n// If anything doesn't fit anymore, true will be returned.\n// If crunch is true, they will take damage\n//  as they are being crushed.\n// If Crunch is false, you should set the sector height back\n//  the way it was and call P_ChangeSector again\n//  to undo the changes.\n//\nboolean\t\tcrushchange;\nboolean\t\tnofit;\n\n\n//\n// PIT_ChangeSector\n//\nboolean PIT_ChangeSector (mobj_t*\tthing)\n{\n    mobj_t*\tmo;\n\t\n    if (P_ThingHeightClip (thing))\n    {\n\t// keep checking\n\treturn true;\n    }\n    \n\n    // crunch bodies to giblets\n    if (thing->health <= 0)\n    {\n\tP_SetMobjState (thing, S_GIBS);\n\n\tthing->flags &= ~MF_SOLID;\n\tthing->height = 0;\n\tthing->radius = 0;\n\n\t// keep checking\n\treturn true;\t\t\n    }\n\n    // crunch dropped items\n    if (thing->flags & MF_DROPPED)\n    {\n\tP_RemoveMobj (thing);\n\t\n\t// keep checking\n\treturn true;\t\t\n    }\n\n    if (! (thing->flags & MF_SHOOTABLE) )\n    {\n\t// assume it is bloody gibs or something\n\treturn true;\t\t\t\n    }\n    \n    nofit = true;\n\n    if (crushchange && !(leveltime&3) )\n    {\n\tP_DamageMobj(thing,NULL,NULL,10);\n\n\t// spray blood in a random direction\n\tmo = P_SpawnMobj (thing->x,\n\t\t\t  thing->y,\n\t\t\t  thing->z + thing->height/2, MT_BLOOD);\n\t\n\tmo->momx = P_SubRandom() << 12;\n\tmo->momy = P_SubRandom() << 12;\n    }\n\n    // keep checking (crush other things)\t\n    return true;\t\n}\n\n\n\n//\n// P_ChangeSector\n//\nboolean\nP_ChangeSector\n( sector_t*\tsector,\n  boolean\tcrunch )\n{\n    int\t\tx;\n    int\t\ty;\n\t\n    nofit = false;\n    crushchange = crunch;\n\t\n    // re-check heights for all things near the moving sector\n    for (x=sector->blockbox[BOXLEFT] ; x<= sector->blockbox[BOXRIGHT] ; x++)\n\tfor (y=sector->blockbox[BOXBOTTOM];y<= sector->blockbox[BOXTOP] ; y++)\n\t    P_BlockThingsIterator (x, y, PIT_ChangeSector);\n\t\n\t\n    return nofit;\n}\n\n// Code to emulate the behavior of Vanilla Doom when encountering an overrun\n// of the spechit array.  This is by Andrey Budko (e6y) and comes from his\n// PrBoom plus port.  A big thanks to Andrey for this.\n\nstatic void SpechitOverrun(line_t *ld)\n{\n    static unsigned int baseaddr = 0;\n    unsigned int addr;\n   \n    if (baseaddr == 0)\n    {\n        int p;\n\n        // This is the first time we have had an overrun.  Work out\n        // what base address we are going to use.\n        // Allow a spechit value to be specified on the command line.\n\n        //!\n        // @category compat\n        // @arg <n>\n        //\n        // Use the specified magic value when emulating spechit overruns.\n        //\n\n        p = M_CheckParmWithArgs(\"-spechit\", 1);\n        \n        if (p > 0)\n        {\n            M_StrToInt(myargv[p+1], (int *) &baseaddr);\n        }\n        else\n        {\n            baseaddr = DEFAULT_SPECHIT_MAGIC;\n        }\n    }\n    \n    // Calculate address used in doom2.exe\n\n    addr = baseaddr + (ld - lines) * 0x3E;\n\n    switch(numspechit)\n    {\n        case 9: \n        case 10:\n        case 11:\n        case 12:\n            tmbbox[numspechit-9] = addr;\n            break;\n        case 13: \n            crushchange = addr; \n            break;\n        case 14: \n            nofit = addr; \n            break;\n        default:\n            fprintf(stderr, \"SpechitOverrun: Warning: unable to emulate\"\n                            \"an overrun where numspechit=%i\\n\",\n                            numspechit);\n            break;\n    }\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n// Copyright(C) 2005, 2006 Andrey Budko\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tMovement/collision utility functions,\n//\tas used by function in p_map.c. \n//\tBLOCKMAP Iterator functions,\n//\tand some PIT_* functions to use for iteration.\n//\n\n\n\n#include <stdlib.h>\n\n\n#include \"i_system.h\" // [crispy] I_Realloc()\n#include \"m_bbox.h\"\n\n#include \"doomdef.h\"\n#include \"doomstat.h\"\n#include \"p_local.h\"\n\n\n// State.\n#include \"r_state.h\"\n\n//\n// P_AproxDistance\n// Gives an estimation of distance (not exact)\n//\n\nfixed_t\nP_AproxDistance\n( fixed_t\tdx,\n  fixed_t\tdy )\n{\n    dx = abs(dx);\n    dy = abs(dy);\n    if (dx < dy)\n\treturn dx+dy-(dx>>1);\n    return dx+dy-(dy>>1);\n}\n\n\n//\n// P_PointOnLineSide\n// Returns 0 or 1\n//\nint\nP_PointOnLineSide\n( fixed_t\tx,\n  fixed_t\ty,\n  line_t*\tline )\n{\n    fixed_t\tdx;\n    fixed_t\tdy;\n    fixed_t\tleft;\n    fixed_t\tright;\n\t\n    if (!line->dx)\n    {\n\tif (x <= line->v1->x)\n\t    return line->dy > 0;\n\t\n\treturn line->dy < 0;\n    }\n    if (!line->dy)\n    {\n\tif (y <= line->v1->y)\n\t    return line->dx < 0;\n\t\n\treturn line->dx > 0;\n    }\n\t\n    dx = (x - line->v1->x);\n    dy = (y - line->v1->y);\n\t\n    left = FixedMul ( line->dy>>FRACBITS , dx );\n    right = FixedMul ( dy , line->dx>>FRACBITS );\n\t\n    if (right < left)\n\treturn 0;\t\t// front side\n    return 1;\t\t\t// back side\n}\n\n\n\n//\n// P_BoxOnLineSide\n// Considers the line to be infinite\n// Returns side 0 or 1, -1 if box crosses the line.\n//\nint\nP_BoxOnLineSide\n( fixed_t*\ttmbox,\n  line_t*\tld )\n{\n    int\t\tp1 = 0;\n    int\t\tp2 = 0;\n\t\n    switch (ld->slopetype)\n    {\n      case ST_HORIZONTAL:\n\tp1 = tmbox[BOXTOP] > ld->v1->y;\n\tp2 = tmbox[BOXBOTTOM] > ld->v1->y;\n\tif (ld->dx < 0)\n\t{\n\t    p1 ^= 1;\n\t    p2 ^= 1;\n\t}\n\tbreak;\n\t\n      case ST_VERTICAL:\n\tp1 = tmbox[BOXRIGHT] < ld->v1->x;\n\tp2 = tmbox[BOXLEFT] < ld->v1->x;\n\tif (ld->dy < 0)\n\t{\n\t    p1 ^= 1;\n\t    p2 ^= 1;\n\t}\n\tbreak;\n\t\n      case ST_POSITIVE:\n\tp1 = P_PointOnLineSide (tmbox[BOXLEFT], tmbox[BOXTOP], ld);\n\tp2 = P_PointOnLineSide (tmbox[BOXRIGHT], tmbox[BOXBOTTOM], ld);\n\tbreak;\n\t\n      case ST_NEGATIVE:\n\tp1 = P_PointOnLineSide (tmbox[BOXRIGHT], tmbox[BOXTOP], ld);\n\tp2 = P_PointOnLineSide (tmbox[BOXLEFT], tmbox[BOXBOTTOM], ld);\n\tbreak;\n    }\n\n    if (p1 == p2)\n\treturn p1;\n    return -1;\n}\n\n\n//\n// P_PointOnDivlineSide\n// Returns 0 or 1.\n//\nint\nP_PointOnDivlineSide\n( fixed_t\tx,\n  fixed_t\ty,\n  divline_t*\tline )\n{\n    fixed_t\tdx;\n    fixed_t\tdy;\n    fixed_t\tleft;\n    fixed_t\tright;\n\t\n    if (!line->dx)\n    {\n\tif (x <= line->x)\n\t    return line->dy > 0;\n\t\n\treturn line->dy < 0;\n    }\n    if (!line->dy)\n    {\n\tif (y <= line->y)\n\t    return line->dx < 0;\n\n\treturn line->dx > 0;\n    }\n\t\n    dx = (x - line->x);\n    dy = (y - line->y);\n\t\n    // try to quickly decide by looking at sign bits\n    if ( (line->dy ^ line->dx ^ dx ^ dy)&0x80000000 )\n    {\n\tif ( (line->dy ^ dx) & 0x80000000 )\n\t    return 1;\t\t// (left is negative)\n\treturn 0;\n    }\n\t\n    left = FixedMul ( line->dy>>8, dx>>8 );\n    right = FixedMul ( dy>>8 , line->dx>>8 );\n\t\n    if (right < left)\n\treturn 0;\t\t// front side\n    return 1;\t\t\t// back side\n}\n\n\n\n//\n// P_MakeDivline\n//\nvoid\nP_MakeDivline\n( line_t*\tli,\n  divline_t*\tdl )\n{\n    dl->x = li->v1->x;\n    dl->y = li->v1->y;\n    dl->dx = li->dx;\n    dl->dy = li->dy;\n}\n\n\n\n//\n// P_InterceptVector\n// Returns the fractional intercept point\n// along the first divline.\n// This is only called by the addthings\n// and addlines traversers.\n//\nfixed_t\nP_InterceptVector\n( divline_t*\tv2,\n  divline_t*\tv1 )\n{\n    fixed_t\tfrac;\n    fixed_t\tnum;\n    fixed_t\tden;\n\t\n    den = FixedMul (v1->dy>>8,v2->dx) - FixedMul(v1->dx>>8,v2->dy);\n\n    if (den == 0)\n\treturn 0;\n    \n    num =\n\tFixedMul ( (v1->x - v2->x)>>8 ,v1->dy )\n\t+FixedMul ( (v2->y - v1->y)>>8, v1->dx );\n\n    frac = FixedDiv (num , den);\n\n    return frac;\n}\n\n\n//\n// P_LineOpening\n// Sets opentop and openbottom to the window\n// through a two sided line.\n// OPTIMIZE: keep this precalculated\n//\nfixed_t opentop;\nfixed_t openbottom;\nfixed_t openrange;\nfixed_t\tlowfloor;\n\n\nvoid P_LineOpening (line_t* linedef)\n{\n    sector_t*\tfront;\n    sector_t*\tback;\n\t\n    if (linedef->sidenum[1] == NO_INDEX) // [crispy] extended nodes\n    {\n\t// single sided line\n\topenrange = 0;\n\treturn;\n    }\n\t \n    front = linedef->frontsector;\n    back = linedef->backsector;\n\t\n    if (front->ceilingheight < back->ceilingheight)\n\topentop = front->ceilingheight;\n    else\n\topentop = back->ceilingheight;\n\n    if (front->floorheight > back->floorheight)\n    {\n\topenbottom = front->floorheight;\n\tlowfloor = back->floorheight;\n    }\n    else\n    {\n\topenbottom = back->floorheight;\n\tlowfloor = front->floorheight;\n    }\n\t\n    openrange = opentop - openbottom;\n}\n\n\n//\n// THING POSITION SETTING\n//\n\n\n//\n// P_UnsetThingPosition\n// Unlinks a thing from block map and sectors.\n// On each position change, BLOCKMAP and other\n// lookups maintaining lists ot things inside\n// these structures need to be updated.\n//\nvoid P_UnsetThingPosition (mobj_t* thing)\n{\n    int\t\tblockx;\n    int\t\tblocky;\n\n    if ( ! (thing->flags & MF_NOSECTOR) )\n    {\n\t// inert things don't need to be in blockmap?\n\t// unlink from subsector\n\tif (thing->snext)\n\t    thing->snext->sprev = thing->sprev;\n\n\tif (thing->sprev)\n\t    thing->sprev->snext = thing->snext;\n\telse\n\t    thing->subsector->sector->thinglist = thing->snext;\n    }\n\t\n    if ( ! (thing->flags & MF_NOBLOCKMAP) )\n    {\n\t// inert things don't need to be in blockmap\n\t// unlink from block map\n\tif (thing->bnext)\n\t    thing->bnext->bprev = thing->bprev;\n\t\n\tif (thing->bprev)\n\t    thing->bprev->bnext = thing->bnext;\n\telse\n\t{\n\t    blockx = (thing->x - bmaporgx)>>MAPBLOCKSHIFT;\n\t    blocky = (thing->y - bmaporgy)>>MAPBLOCKSHIFT;\n\n\t    if (blockx>=0 && blockx < bmapwidth\n\t\t&& blocky>=0 && blocky <bmapheight)\n\t    {\n\t\tblocklinks[blocky*bmapwidth+blockx] = thing->bnext;\n\t    }\n\t}\n    }\n}\n\n\n//\n// P_SetThingPosition\n// Links a thing into both a block and a subsector\n// based on it's x y.\n// Sets thing->subsector properly\n//\nvoid\nP_SetThingPosition (mobj_t* thing)\n{\n    subsector_t*\tss;\n    sector_t*\t\tsec;\n    int\t\t\tblockx;\n    int\t\t\tblocky;\n    mobj_t**\t\tlink;\n\n    \n    // link into subsector\n    ss = R_PointInSubsector (thing->x,thing->y);\n    thing->subsector = ss;\n    \n    if ( ! (thing->flags & MF_NOSECTOR) )\n    {\n\t// invisible things don't go into the sector links\n\tsec = ss->sector;\n\t\n\tthing->sprev = NULL;\n\tthing->snext = sec->thinglist;\n\n\tif (sec->thinglist)\n\t    sec->thinglist->sprev = thing;\n\n\tsec->thinglist = thing;\n    }\n\n    \n    // link into blockmap\n    if ( ! (thing->flags & MF_NOBLOCKMAP) )\n    {\n\t// inert things don't need to be in blockmap\t\t\n\tblockx = (thing->x - bmaporgx)>>MAPBLOCKSHIFT;\n\tblocky = (thing->y - bmaporgy)>>MAPBLOCKSHIFT;\n\n\tif (blockx>=0\n\t    && blockx < bmapwidth\n\t    && blocky>=0\n\t    && blocky < bmapheight)\n\t{\n\t    link = &blocklinks[blocky*bmapwidth+blockx];\n\t    thing->bprev = NULL;\n\t    thing->bnext = *link;\n\t    if (*link)\n\t\t(*link)->bprev = thing;\n\n\t    *link = thing;\n\t}\n\telse\n\t{\n\t    // thing is off the map\n\t    thing->bnext = thing->bprev = NULL;\n\t}\n    }\n}\n\n\n\n//\n// BLOCK MAP ITERATORS\n// For each line/thing in the given mapblock,\n// call the passed PIT_* function.\n// If the function returns false,\n// exit with false without checking anything else.\n//\n\n\n//\n// P_BlockLinesIterator\n// The validcount flags are used to avoid checking lines\n// that are marked in multiple mapblocks,\n// so increment validcount before the first call\n// to P_BlockLinesIterator, then make one or more calls\n// to it.\n//\nboolean\nP_BlockLinesIterator\n( int\t\t\tx,\n  int\t\t\ty,\n  boolean(*func)(line_t*) )\n{\n    int\t\t\toffset;\n    int32_t*\t\tlist; // [crispy] BLOCKMAP limit\n    line_t*\t\tld;\n\t\n    if (x<0\n\t|| y<0\n\t|| x>=bmapwidth\n\t|| y>=bmapheight)\n    {\n\treturn true;\n    }\n    \n    offset = y*bmapwidth+x;\n\t\n    offset = *(blockmap+offset);\n\n    for ( list = blockmaplump+offset ; *list != -1 ; list++)\n    {\n\tld = &lines[*list];\n\n\tif (ld->validcount == validcount)\n\t    continue; \t// line has already been checked\n\n\tld->validcount = validcount;\n\t\t\n\tif ( !func(ld) )\n\t    return false;\n    }\n    return true;\t// everything was checked\n}\n\n\n//\n// P_BlockThingsIterator\n//\nboolean\nP_BlockThingsIterator\n( int\t\t\tx,\n  int\t\t\ty,\n  boolean(*func)(mobj_t*) )\n{\n    mobj_t*\t\tmobj;\n\t\n    if ( x<0\n\t || y<0\n\t || x>=bmapwidth\n\t || y>=bmapheight)\n    {\n\treturn true;\n    }\n    \n\n    for (mobj = blocklinks[y*bmapwidth+x] ;\n\t mobj ;\n\t mobj = mobj->bnext)\n    {\n\tif (!func( mobj ) )\n\t    return false;\n    }\n    return true;\n}\n\n\n\n//\n// INTERCEPT ROUTINES\n//\nstatic intercept_t*\tintercepts; // [crispy] remove INTERCEPTS limit\nintercept_t*\tintercept_p;\n\n// [crispy] remove INTERCEPTS limit\n// taken from PrBoom+/src/p_maputl.c:422-433\nstatic void check_intercept(void)\n{\n\tstatic size_t num_intercepts;\n\tconst size_t offset = intercept_p - intercepts;\n\n\tif (offset >= num_intercepts)\n\t{\n\t\tnum_intercepts = num_intercepts ? num_intercepts * 2 : MAXINTERCEPTS_ORIGINAL;\n\t\tintercepts = I_Realloc(intercepts, sizeof(*intercepts) * num_intercepts);\n\t\tintercept_p = intercepts + offset;\n\t}\n}\n\ndivline_t \ttrace;\nboolean \tearlyout;\nint\t\tptflags;\n\nstatic void InterceptsOverrun(int num_intercepts, intercept_t *intercept);\n\n// [crispy] show mapthing number in INTERCEPTS overflow warnings\nextern mobj_t* shootthing;\n\n//\n// PIT_AddLineIntercepts.\n// Looks for lines in the given block\n// that intercept the given trace\n// to add to the intercepts list.\n//\n// A line is crossed if its endpoints\n// are on opposite sides of the trace.\n// Returns true if earlyout and a solid line hit.\n//\nboolean\nPIT_AddLineIntercepts (line_t* ld)\n{\n    int\t\t\ts1;\n    int\t\t\ts2;\n    fixed_t\t\tfrac;\n    divline_t\t\tdl;\n\t\n    // avoid precision problems with two routines\n    if ( trace.dx > FRACUNIT*16\n\t || trace.dy > FRACUNIT*16\n\t || trace.dx < -FRACUNIT*16\n\t || trace.dy < -FRACUNIT*16)\n    {\n\ts1 = P_PointOnDivlineSide (ld->v1->x, ld->v1->y, &trace);\n\ts2 = P_PointOnDivlineSide (ld->v2->x, ld->v2->y, &trace);\n    }\n    else\n    {\n\ts1 = P_PointOnLineSide (trace.x, trace.y, ld);\n\ts2 = P_PointOnLineSide (trace.x+trace.dx, trace.y+trace.dy, ld);\n    }\n    \n    if (s1 == s2)\n\treturn true;\t// line isn't crossed\n    \n    // hit the line\n    P_MakeDivline (ld, &dl);\n    frac = P_InterceptVector (&trace, &dl);\n\n    if (frac < 0)\n\treturn true;\t// behind source\n\t\n    // try to early out the check\n    if (earlyout\n\t&& frac < FRACUNIT\n\t&& !ld->backsector)\n    {\n\treturn false;\t// stop checking\n    }\n    \n\t\n    check_intercept(); // [crispy] remove INTERCEPTS limit\n    intercept_p->frac = frac;\n    intercept_p->isaline = true;\n    intercept_p->d.line = ld;\n    InterceptsOverrun(intercept_p - intercepts, intercept_p);\n    intercept_p++;\n\n    return true;\t// continue\n}\n\n\n\n//\n// PIT_AddThingIntercepts\n//\nboolean PIT_AddThingIntercepts (mobj_t* thing)\n{\n    fixed_t\t\tx1;\n    fixed_t\t\ty1;\n    fixed_t\t\tx2;\n    fixed_t\t\ty2;\n    \n    int\t\t\ts1;\n    int\t\t\ts2;\n    \n    boolean\t\ttracepositive;\n\n    divline_t\t\tdl;\n    \n    fixed_t\t\tfrac;\n\t\n    tracepositive = (trace.dx ^ trace.dy)>0;\n\t\t\n    // check a corner to corner crossection for hit\n    if (tracepositive)\n    {\n\tx1 = thing->x - thing->radius;\n\ty1 = thing->y + thing->radius;\n\t\t\n\tx2 = thing->x + thing->radius;\n\ty2 = thing->y - thing->radius;\t\t\t\n    }\n    else\n    {\n\tx1 = thing->x - thing->radius;\n\ty1 = thing->y - thing->radius;\n\t\t\n\tx2 = thing->x + thing->radius;\n\ty2 = thing->y + thing->radius;\t\t\t\n    }\n    \n    s1 = P_PointOnDivlineSide (x1, y1, &trace);\n    s2 = P_PointOnDivlineSide (x2, y2, &trace);\n\n    if (s1 == s2)\n\treturn true;\t\t// line isn't crossed\n\t\n    dl.x = x1;\n    dl.y = y1;\n    dl.dx = x2-x1;\n    dl.dy = y2-y1;\n    \n    frac = P_InterceptVector (&trace, &dl);\n\n    if (frac < 0)\n\treturn true;\t\t// behind source\n\n    check_intercept(); // [crispy] remove INTERCEPTS limit\n    intercept_p->frac = frac;\n    intercept_p->isaline = false;\n    intercept_p->d.thing = thing;\n    InterceptsOverrun(intercept_p - intercepts, intercept_p);\n    intercept_p++;\n\n    return true;\t\t// keep going\n}\n\n\n//\n// P_TraverseIntercepts\n// Returns true if the traverser function returns true\n// for all lines.\n// \nboolean\nP_TraverseIntercepts\n( traverser_t\tfunc,\n  fixed_t\tmaxfrac )\n{\n    int\t\t\tcount;\n    fixed_t\t\tdist;\n    intercept_t*\tscan;\n    intercept_t*\tin;\n\t\n    count = intercept_p - intercepts;\n    \n    in = 0;\t\t\t// shut up compiler warning\n\t\n    while (count--)\n    {\n\tdist = INT_MAX;\n\tfor (scan = intercepts ; scan<intercept_p ; scan++)\n\t{\n\t    if (scan->frac < dist)\n\t    {\n\t\tdist = scan->frac;\n\t\tin = scan;\n\t    }\n\t}\n\t\n\tif (dist > maxfrac)\n\t    return true;\t// checked everything in range\t\t\n\n        if ( !func (in) )\n\t    return false;\t// don't bother going farther\n\n\tin->frac = INT_MAX;\n    }\n\t\n    return true;\t\t// everything was traversed\n}\n\nextern fixed_t bulletslope;\n\n// Intercepts Overrun emulation, from PrBoom-plus.\n// Thanks to Andrey Budko (entryway) for researching this and his \n// implementation of Intercepts Overrun emulation in PrBoom-plus\n// which this is based on.\n\ntypedef struct\n{\n    int len;\n    void *addr;\n    boolean int16_array;\n} intercepts_overrun_t;\n\n// Intercepts memory table.  This is where various variables are located\n// in memory in Vanilla Doom.  When the intercepts table overflows, we\n// need to write to them.\n//\n// Almost all of the values to overwrite are 32-bit integers, except for\n// playerstarts, which is effectively an array of 16-bit integers and\n// must be treated differently.\n\nstatic intercepts_overrun_t intercepts_overrun[] =\n{\n    {4,   NULL,                          false},\n    {4,   NULL, /* &earlyout, */         false},\n    {4,   NULL, /* &intercept_p, */      false},\n    {4,   &lowfloor,                     false},\n    {4,   &openbottom,                   false},\n    {4,   &opentop,                      false},\n    {4,   &openrange,                    false},\n    {4,   NULL,                          false},\n    {120, NULL, /* &activeplats, */      false},\n    {8,   NULL,                          false},\n    {4,   &bulletslope,                  false},\n    {4,   NULL, /* &swingx, */           false},\n    {4,   NULL, /* &swingy, */           false},\n    {4,   NULL,                          false},\n    {40,  &playerstarts,                 true},\n    {4,   NULL, /* &blocklinks, */       false},\n    {4,   &bmapwidth,                    false},\n    {4,   NULL, /* &blockmap, */         false},\n    {4,   &bmaporgx,                     false},\n    {4,   &bmaporgy,                     false},\n    {4,   NULL, /* &blockmaplump, */     false},\n    {4,   &bmapheight,                   false},\n    {0,   NULL,                          false},\n};\n\n// Overwrite a specific memory location with a value.\n\nstatic void InterceptsMemoryOverrun(int location, int value)\n{\n    int i, offset;\n    int index;\n    void *addr;\n\n    i = 0;\n    offset = 0;\n\n    // Search down the array until we find the right entry\n\n    while (intercepts_overrun[i].len != 0)\n    {\n        if (offset + intercepts_overrun[i].len > location)\n        {\n            addr = intercepts_overrun[i].addr;\n\n            // Write the value to the memory location.\n            // 16-bit and 32-bit values are written differently.\n\n            if (addr != NULL)\n            {\n                if (intercepts_overrun[i].int16_array)\n                {\n                    index = (location - offset) / 2;\n                    ((short *) addr)[index] = value & 0xffff;\n                    ((short *) addr)[index + 1] = (value >> 16) & 0xffff;\n                }\n                else\n                {\n                    index = (location - offset) / 4;\n                    ((int *) addr)[index] = value;\n                }\n            }\n\n            break;\n        }\n\n        offset += intercepts_overrun[i].len;\n        ++i;\n    }\n}\n\n// Emulate overruns of the intercepts[] array.\n\nstatic void InterceptsOverrun(int num_intercepts, intercept_t *intercept)\n{\n    int location;\n\n    if (num_intercepts <= MAXINTERCEPTS_ORIGINAL)\n    {\n        // No overrun\n\n        return;\n    }\n\n    location = (num_intercepts - MAXINTERCEPTS_ORIGINAL - 1) * 12;\n\n    // Overwrite memory that is overwritten in Vanilla Doom, using\n    // the values from the intercept structure.\n    //\n    // Note: the ->d.{thing,line} member should really have its\n    // address translated into the correct address value for \n    // Vanilla Doom.\n\n    InterceptsMemoryOverrun(location, intercept->frac);\n    InterceptsMemoryOverrun(location + 4, intercept->isaline);\n    InterceptsMemoryOverrun(location + 8, (intptr_t) intercept->d.thing);\n}\n\n\n//\n// P_PathTraverse\n// Traces a line from x1,y1 to x2,y2,\n// calling the traverser function for each.\n// Returns true if the traverser function returns true\n// for all lines.\n//\nboolean\nP_PathTraverse\n( fixed_t\t\tx1,\n  fixed_t\t\ty1,\n  fixed_t\t\tx2,\n  fixed_t\t\ty2,\n  int\t\t\tflags,\n  boolean (*trav) (intercept_t *))\n{\n    fixed_t\txt1;\n    fixed_t\tyt1;\n    fixed_t\txt2;\n    fixed_t\tyt2;\n    \n    fixed_t\txstep;\n    fixed_t\tystep;\n    \n    fixed_t\tpartial;\n    \n    fixed_t\txintercept;\n    fixed_t\tyintercept;\n    \n    int\t\tmapx;\n    int\t\tmapy;\n    \n    int\t\tmapxstep;\n    int\t\tmapystep;\n\n    int\t\tcount;\n\t\t\n    earlyout = (flags & PT_EARLYOUT) != 0;\n\t\t\n    validcount++;\n    intercept_p = intercepts;\n\t\n    if ( ((x1-bmaporgx)&(MAPBLOCKSIZE-1)) == 0)\n\tx1 += FRACUNIT;\t// don't side exactly on a line\n    \n    if ( ((y1-bmaporgy)&(MAPBLOCKSIZE-1)) == 0)\n\ty1 += FRACUNIT;\t// don't side exactly on a line\n\n    trace.x = x1;\n    trace.y = y1;\n    trace.dx = x2 - x1;\n    trace.dy = y2 - y1;\n\n    x1 -= bmaporgx;\n    y1 -= bmaporgy;\n    xt1 = x1>>MAPBLOCKSHIFT;\n    yt1 = y1>>MAPBLOCKSHIFT;\n\n    x2 -= bmaporgx;\n    y2 -= bmaporgy;\n    xt2 = x2>>MAPBLOCKSHIFT;\n    yt2 = y2>>MAPBLOCKSHIFT;\n\n    if (xt2 > xt1)\n    {\n\tmapxstep = 1;\n\tpartial = FRACUNIT - ((x1>>MAPBTOFRAC)&(FRACUNIT-1));\n\tystep = FixedDiv (y2-y1,abs(x2-x1));\n    }\n    else if (xt2 < xt1)\n    {\n\tmapxstep = -1;\n\tpartial = (x1>>MAPBTOFRAC)&(FRACUNIT-1);\n\tystep = FixedDiv (y2-y1,abs(x2-x1));\n    }\n    else\n    {\n\tmapxstep = 0;\n\tpartial = FRACUNIT;\n\tystep = 256*FRACUNIT;\n    }\t\n\n    yintercept = (y1>>MAPBTOFRAC) + FixedMul (partial, ystep);\n\n\t\n    if (yt2 > yt1)\n    {\n\tmapystep = 1;\n\tpartial = FRACUNIT - ((y1>>MAPBTOFRAC)&(FRACUNIT-1));\n\txstep = FixedDiv (x2-x1,abs(y2-y1));\n    }\n    else if (yt2 < yt1)\n    {\n\tmapystep = -1;\n\tpartial = (y1>>MAPBTOFRAC)&(FRACUNIT-1);\n\txstep = FixedDiv (x2-x1,abs(y2-y1));\n    }\n    else\n    {\n\tmapystep = 0;\n\tpartial = FRACUNIT;\n\txstep = 256*FRACUNIT;\n    }\t\n    xintercept = (x1>>MAPBTOFRAC) + FixedMul (partial, xstep);\n    \n    // Step through map blocks.\n    // Count is present to prevent a round off error\n    // from skipping the break.\n    mapx = xt1;\n    mapy = yt1;\n\t\n    for (count = 0 ; count < 64 ; count++)\n    {\n\tif (flags & PT_ADDLINES)\n\t{\n\t    if (!P_BlockLinesIterator (mapx, mapy,PIT_AddLineIntercepts))\n\t\treturn false;\t// early out\n\t}\n\t\n\tif (flags & PT_ADDTHINGS)\n\t{\n\t    if (!P_BlockThingsIterator (mapx, mapy,PIT_AddThingIntercepts))\n\t\treturn false;\t// early out\n\t}\n\t\t\n\tif (mapx == xt2\n\t    && mapy == yt2)\n\t{\n\t    break;\n\t}\n\t\n\tif ( (yintercept >> FRACBITS) == mapy)\n\t{\n\t    yintercept += ystep;\n\t    mapx += mapxstep;\n\t}\n\telse if ( (xintercept >> FRACBITS) == mapx)\n\t{\n\t    xintercept += xstep;\n\t    mapy += mapystep;\n\t}\n\t\t\n    }\n    // go through the sorted list\n    return P_TraverseIntercepts ( trav, FRACUNIT );\n}\n\n\n\n","//\n// Copyright (C) 2013-2018 Alexey Khokholov (Nuke.YKT)\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n//  Nuked OPL3 emulator.\n//  Thanks:\n//      MAME Development Team(Jarek Burczynski, Tatsuyuki Satoh):\n//          Feedback and Rhythm part calculation information.\n//      forums.submarine.org.uk(carbon14, opl3):\n//          Tremolo and phase generator calculation information.\n//      OPLx decapsulated(Matthew Gambrell, Olli Niemitalo):\n//          OPL2 ROMs.\n//      siliconpr0n.org(John McMaster, digshadow):\n//          YMF262 and VRC VII decaps and die shots.\n//\n// version: 1.8\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"opl3.h\"\n\n#define RSM_FRAC    10\n\n// Channel types\n\nenum {\n    ch_2op = 0,\n    ch_4op = 1,\n    ch_4op2 = 2,\n    ch_drum = 3\n};\n\n// Envelope key types\n\nenum {\n    egk_norm = 0x01,\n    egk_drum = 0x02\n};\n\n\n//\n// logsin table\n//\n\nstatic const Bit16u logsinrom[256] = {\n    0x859, 0x6c3, 0x607, 0x58b, 0x52e, 0x4e4, 0x4a6, 0x471,\n    0x443, 0x41a, 0x3f5, 0x3d3, 0x3b5, 0x398, 0x37e, 0x365,\n    0x34e, 0x339, 0x324, 0x311, 0x2ff, 0x2ed, 0x2dc, 0x2cd,\n    0x2bd, 0x2af, 0x2a0, 0x293, 0x286, 0x279, 0x26d, 0x261,\n    0x256, 0x24b, 0x240, 0x236, 0x22c, 0x222, 0x218, 0x20f,\n    0x206, 0x1fd, 0x1f5, 0x1ec, 0x1e4, 0x1dc, 0x1d4, 0x1cd,\n    0x1c5, 0x1be, 0x1b7, 0x1b0, 0x1a9, 0x1a2, 0x19b, 0x195,\n    0x18f, 0x188, 0x182, 0x17c, 0x177, 0x171, 0x16b, 0x166,\n    0x160, 0x15b, 0x155, 0x150, 0x14b, 0x146, 0x141, 0x13c,\n    0x137, 0x133, 0x12e, 0x129, 0x125, 0x121, 0x11c, 0x118,\n    0x114, 0x10f, 0x10b, 0x107, 0x103, 0x0ff, 0x0fb, 0x0f8,\n    0x0f4, 0x0f0, 0x0ec, 0x0e9, 0x0e5, 0x0e2, 0x0de, 0x0db,\n    0x0d7, 0x0d4, 0x0d1, 0x0cd, 0x0ca, 0x0c7, 0x0c4, 0x0c1,\n    0x0be, 0x0bb, 0x0b8, 0x0b5, 0x0b2, 0x0af, 0x0ac, 0x0a9,\n    0x0a7, 0x0a4, 0x0a1, 0x09f, 0x09c, 0x099, 0x097, 0x094,\n    0x092, 0x08f, 0x08d, 0x08a, 0x088, 0x086, 0x083, 0x081,\n    0x07f, 0x07d, 0x07a, 0x078, 0x076, 0x074, 0x072, 0x070,\n    0x06e, 0x06c, 0x06a, 0x068, 0x066, 0x064, 0x062, 0x060,\n    0x05e, 0x05c, 0x05b, 0x059, 0x057, 0x055, 0x053, 0x052,\n    0x050, 0x04e, 0x04d, 0x04b, 0x04a, 0x048, 0x046, 0x045,\n    0x043, 0x042, 0x040, 0x03f, 0x03e, 0x03c, 0x03b, 0x039,\n    0x038, 0x037, 0x035, 0x034, 0x033, 0x031, 0x030, 0x02f,\n    0x02e, 0x02d, 0x02b, 0x02a, 0x029, 0x028, 0x027, 0x026,\n    0x025, 0x024, 0x023, 0x022, 0x021, 0x020, 0x01f, 0x01e,\n    0x01d, 0x01c, 0x01b, 0x01a, 0x019, 0x018, 0x017, 0x017,\n    0x016, 0x015, 0x014, 0x014, 0x013, 0x012, 0x011, 0x011,\n    0x010, 0x00f, 0x00f, 0x00e, 0x00d, 0x00d, 0x00c, 0x00c,\n    0x00b, 0x00a, 0x00a, 0x009, 0x009, 0x008, 0x008, 0x007,\n    0x007, 0x007, 0x006, 0x006, 0x005, 0x005, 0x005, 0x004,\n    0x004, 0x004, 0x003, 0x003, 0x003, 0x002, 0x002, 0x002,\n    0x002, 0x001, 0x001, 0x001, 0x001, 0x001, 0x001, 0x001,\n    0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000\n};\n\n//\n// exp table\n//\n\nstatic const Bit16u exprom[256] = {\n    0x7fa, 0x7f5, 0x7ef, 0x7ea, 0x7e4, 0x7df, 0x7da, 0x7d4,\n    0x7cf, 0x7c9, 0x7c4, 0x7bf, 0x7b9, 0x7b4, 0x7ae, 0x7a9,\n    0x7a4, 0x79f, 0x799, 0x794, 0x78f, 0x78a, 0x784, 0x77f,\n    0x77a, 0x775, 0x770, 0x76a, 0x765, 0x760, 0x75b, 0x756,\n    0x751, 0x74c, 0x747, 0x742, 0x73d, 0x738, 0x733, 0x72e,\n    0x729, 0x724, 0x71f, 0x71a, 0x715, 0x710, 0x70b, 0x706,\n    0x702, 0x6fd, 0x6f8, 0x6f3, 0x6ee, 0x6e9, 0x6e5, 0x6e0,\n    0x6db, 0x6d6, 0x6d2, 0x6cd, 0x6c8, 0x6c4, 0x6bf, 0x6ba,\n    0x6b5, 0x6b1, 0x6ac, 0x6a8, 0x6a3, 0x69e, 0x69a, 0x695,\n    0x691, 0x68c, 0x688, 0x683, 0x67f, 0x67a, 0x676, 0x671,\n    0x66d, 0x668, 0x664, 0x65f, 0x65b, 0x657, 0x652, 0x64e,\n    0x649, 0x645, 0x641, 0x63c, 0x638, 0x634, 0x630, 0x62b,\n    0x627, 0x623, 0x61e, 0x61a, 0x616, 0x612, 0x60e, 0x609,\n    0x605, 0x601, 0x5fd, 0x5f9, 0x5f5, 0x5f0, 0x5ec, 0x5e8,\n    0x5e4, 0x5e0, 0x5dc, 0x5d8, 0x5d4, 0x5d0, 0x5cc, 0x5c8,\n    0x5c4, 0x5c0, 0x5bc, 0x5b8, 0x5b4, 0x5b0, 0x5ac, 0x5a8,\n    0x5a4, 0x5a0, 0x59c, 0x599, 0x595, 0x591, 0x58d, 0x589,\n    0x585, 0x581, 0x57e, 0x57a, 0x576, 0x572, 0x56f, 0x56b,\n    0x567, 0x563, 0x560, 0x55c, 0x558, 0x554, 0x551, 0x54d,\n    0x549, 0x546, 0x542, 0x53e, 0x53b, 0x537, 0x534, 0x530,\n    0x52c, 0x529, 0x525, 0x522, 0x51e, 0x51b, 0x517, 0x514,\n    0x510, 0x50c, 0x509, 0x506, 0x502, 0x4ff, 0x4fb, 0x4f8,\n    0x4f4, 0x4f1, 0x4ed, 0x4ea, 0x4e7, 0x4e3, 0x4e0, 0x4dc,\n    0x4d9, 0x4d6, 0x4d2, 0x4cf, 0x4cc, 0x4c8, 0x4c5, 0x4c2,\n    0x4be, 0x4bb, 0x4b8, 0x4b5, 0x4b1, 0x4ae, 0x4ab, 0x4a8,\n    0x4a4, 0x4a1, 0x49e, 0x49b, 0x498, 0x494, 0x491, 0x48e,\n    0x48b, 0x488, 0x485, 0x482, 0x47e, 0x47b, 0x478, 0x475,\n    0x472, 0x46f, 0x46c, 0x469, 0x466, 0x463, 0x460, 0x45d,\n    0x45a, 0x457, 0x454, 0x451, 0x44e, 0x44b, 0x448, 0x445,\n    0x442, 0x43f, 0x43c, 0x439, 0x436, 0x433, 0x430, 0x42d,\n    0x42a, 0x428, 0x425, 0x422, 0x41f, 0x41c, 0x419, 0x416,\n    0x414, 0x411, 0x40e, 0x40b, 0x408, 0x406, 0x403, 0x400\n};\n\n//\n// freq mult table multiplied by 2\n//\n// 1/2, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 12, 12, 15, 15\n//\n\nstatic const Bit8u mt[16] = {\n    1, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 20, 24, 24, 30, 30\n};\n\n//\n// ksl table\n//\n\nstatic const Bit8u kslrom[16] = {\n    0, 32, 40, 45, 48, 51, 53, 55, 56, 58, 59, 60, 61, 62, 63, 64\n};\n\nstatic const Bit8u kslshift[4] = {\n    8, 1, 2, 0\n};\n\n//\n// envelope generator constants\n//\n\nstatic const Bit8u eg_incstep[4][4] = {\n    { 0, 0, 0, 0 },\n    { 1, 0, 0, 0 },\n    { 1, 0, 1, 0 },\n    { 1, 1, 1, 0 }\n};\n\n//\n// address decoding\n//\n\nstatic const Bit8s ad_slot[0x20] = {\n    0, 1, 2, 3, 4, 5, -1, -1, 6, 7, 8, 9, 10, 11, -1, -1,\n    12, 13, 14, 15, 16, 17, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1\n};\n\nstatic const Bit8u ch_slot[18] = {\n    0, 1, 2, 6, 7, 8, 12, 13, 14, 18, 19, 20, 24, 25, 26, 30, 31, 32\n};\n\n//\n// Envelope generator\n//\n\ntypedef Bit16s(*envelope_sinfunc)(Bit16u phase, Bit16u envelope);\ntypedef void(*envelope_genfunc)(opl3_slot *slott);\n\nstatic Bit16s OPL3_EnvelopeCalcExp(Bit32u level)\n{\n    if (level > 0x1fff)\n    {\n        level = 0x1fff;\n    }\n    return (exprom[level & 0xff] << 1) >> (level >> 8);\n}\n\nstatic Bit16s OPL3_EnvelopeCalcSin0(Bit16u phase, Bit16u envelope)\n{\n    Bit16u out = 0;\n    Bit16u neg = 0;\n    phase &= 0x3ff;\n    if (phase & 0x200)\n    {\n        neg = 0xffff;\n    }\n    if (phase & 0x100)\n    {\n        out = logsinrom[(phase & 0xff) ^ 0xff];\n    }\n    else\n    {\n        out = logsinrom[phase & 0xff];\n    }\n    return OPL3_EnvelopeCalcExp(out + (envelope << 3)) ^ neg;\n}\n\nstatic Bit16s OPL3_EnvelopeCalcSin1(Bit16u phase, Bit16u envelope)\n{\n    Bit16u out = 0;\n    phase &= 0x3ff;\n    if (phase & 0x200)\n    {\n        out = 0x1000;\n    }\n    else if (phase & 0x100)\n    {\n        out = logsinrom[(phase & 0xff) ^ 0xff];\n    }\n    else\n    {\n        out = logsinrom[phase & 0xff];\n    }\n    return OPL3_EnvelopeCalcExp(out + (envelope << 3));\n}\n\nstatic Bit16s OPL3_EnvelopeCalcSin2(Bit16u phase, Bit16u envelope)\n{\n    Bit16u out = 0;\n    phase &= 0x3ff;\n    if (phase & 0x100)\n    {\n        out = logsinrom[(phase & 0xff) ^ 0xff];\n    }\n    else\n    {\n        out = logsinrom[phase & 0xff];\n    }\n    return OPL3_EnvelopeCalcExp(out + (envelope << 3));\n}\n\nstatic Bit16s OPL3_EnvelopeCalcSin3(Bit16u phase, Bit16u envelope)\n{\n    Bit16u out = 0;\n    phase &= 0x3ff;\n    if (phase & 0x100)\n    {\n        out = 0x1000;\n    }\n    else\n    {\n        out = logsinrom[phase & 0xff];\n    }\n    return OPL3_EnvelopeCalcExp(out + (envelope << 3));\n}\n\nstatic Bit16s OPL3_EnvelopeCalcSin4(Bit16u phase, Bit16u envelope)\n{\n    Bit16u out = 0;\n    Bit16u neg = 0;\n    phase &= 0x3ff;\n    if ((phase & 0x300) == 0x100)\n    {\n        neg = 0xffff;\n    }\n    if (phase & 0x200)\n    {\n        out = 0x1000;\n    }\n    else if (phase & 0x80)\n    {\n        out = logsinrom[((phase ^ 0xff) << 1) & 0xff];\n    }\n    else\n    {\n        out = logsinrom[(phase << 1) & 0xff];\n    }\n    return OPL3_EnvelopeCalcExp(out + (envelope << 3)) ^ neg;\n}\n\nstatic Bit16s OPL3_EnvelopeCalcSin5(Bit16u phase, Bit16u envelope)\n{\n    Bit16u out = 0;\n    phase &= 0x3ff;\n    if (phase & 0x200)\n    {\n        out = 0x1000;\n    }\n    else if (phase & 0x80)\n    {\n        out = logsinrom[((phase ^ 0xff) << 1) & 0xff];\n    }\n    else\n    {\n        out = logsinrom[(phase << 1) & 0xff];\n    }\n    return OPL3_EnvelopeCalcExp(out + (envelope << 3));\n}\n\nstatic Bit16s OPL3_EnvelopeCalcSin6(Bit16u phase, Bit16u envelope)\n{\n    Bit16u neg = 0;\n    phase &= 0x3ff;\n    if (phase & 0x200)\n    {\n        neg = 0xffff;\n    }\n    return OPL3_EnvelopeCalcExp(envelope << 3) ^ neg;\n}\n\nstatic Bit16s OPL3_EnvelopeCalcSin7(Bit16u phase, Bit16u envelope)\n{\n    Bit16u out = 0;\n    Bit16u neg = 0;\n    phase &= 0x3ff;\n    if (phase & 0x200)\n    {\n        neg = 0xffff;\n        phase = (phase & 0x1ff) ^ 0x1ff;\n    }\n    out = phase << 3;\n    return OPL3_EnvelopeCalcExp(out + (envelope << 3)) ^ neg;\n}\n\nstatic const envelope_sinfunc envelope_sin[8] = {\n    OPL3_EnvelopeCalcSin0,\n    OPL3_EnvelopeCalcSin1,\n    OPL3_EnvelopeCalcSin2,\n    OPL3_EnvelopeCalcSin3,\n    OPL3_EnvelopeCalcSin4,\n    OPL3_EnvelopeCalcSin5,\n    OPL3_EnvelopeCalcSin6,\n    OPL3_EnvelopeCalcSin7\n};\n\nenum envelope_gen_num\n{\n    envelope_gen_num_attack = 0,\n    envelope_gen_num_decay = 1,\n    envelope_gen_num_sustain = 2,\n    envelope_gen_num_release = 3\n};\n\nstatic void OPL3_EnvelopeUpdateKSL(opl3_slot *slot)\n{\n    Bit16s ksl = (kslrom[slot->channel->f_num >> 6] << 2)\n               - ((0x08 - slot->channel->block) << 5);\n    if (ksl < 0)\n    {\n        ksl = 0;\n    }\n    slot->eg_ksl = (Bit8u)ksl;\n}\n\nstatic void OPL3_EnvelopeCalc(opl3_slot *slot)\n{\n    Bit8u nonzero;\n    Bit8u rate;\n    Bit8u rate_hi;\n    Bit8u rate_lo;\n    Bit8u reg_rate = 0;\n    Bit8u ks;\n    Bit8u eg_shift, shift;\n    Bit16u eg_rout;\n    Bit16s eg_inc;\n    Bit8u eg_off;\n    Bit8u reset = 0;\n    slot->eg_out = slot->eg_rout + (slot->reg_tl << 2)\n                 + (slot->eg_ksl >> kslshift[slot->reg_ksl]) + *slot->trem;\n    if (slot->key && slot->eg_gen == envelope_gen_num_release)\n    {\n        reset = 1;\n        reg_rate = slot->reg_ar;\n    }\n    else\n    {\n        switch (slot->eg_gen)\n        {\n        case envelope_gen_num_attack:\n            reg_rate = slot->reg_ar;\n            break;\n        case envelope_gen_num_decay:\n            reg_rate = slot->reg_dr;\n            break;\n        case envelope_gen_num_sustain:\n            if (!slot->reg_type)\n            {\n                reg_rate = slot->reg_rr;\n            }\n            break;\n        case envelope_gen_num_release:\n            reg_rate = slot->reg_rr;\n            break;\n        }\n    }\n    slot->pg_reset = reset;\n    ks = slot->channel->ksv >> ((slot->reg_ksr ^ 1) << 1);\n    nonzero = (reg_rate != 0);\n    rate = ks + (reg_rate << 2);\n    rate_hi = rate >> 2;\n    rate_lo = rate & 0x03;\n    if (rate_hi & 0x10)\n    {\n        rate_hi = 0x0f;\n    }\n    eg_shift = rate_hi + slot->chip->eg_add;\n    shift = 0;\n    if (nonzero)\n    {\n        if (rate_hi < 12)\n        {\n            if (slot->chip->eg_state)\n            {\n                switch (eg_shift)\n                {\n                case 12:\n                    shift = 1;\n                    break;\n                case 13:\n                    shift = (rate_lo >> 1) & 0x01;\n                    break;\n                case 14:\n                    shift = rate_lo & 0x01;\n                    break;\n                default:\n                    break;\n                }\n            }\n        }\n        else\n        {\n            shift = (rate_hi & 0x03) + eg_incstep[rate_lo][slot->chip->timer & 0x03];\n            if (shift & 0x04)\n            {\n                shift = 0x03;\n            }\n            if (!shift)\n            {\n                shift = slot->chip->eg_state;\n            }\n        }\n    }\n    eg_rout = slot->eg_rout;\n    eg_inc = 0;\n    eg_off = 0;\n    // Instant attack\n    if (reset && rate_hi == 0x0f)\n    {\n        eg_rout = 0x00;\n    }\n    // Envelope off\n    if ((slot->eg_rout & 0x1f8) == 0x1f8)\n    {\n        eg_off = 1;\n    }\n    if (slot->eg_gen != envelope_gen_num_attack && !reset && eg_off)\n    {\n        eg_rout = 0x1ff;\n    }\n    switch (slot->eg_gen)\n    {\n    case envelope_gen_num_attack:\n        if (!slot->eg_rout)\n        {\n            slot->eg_gen = envelope_gen_num_decay;\n        }\n        else if (slot->key && shift > 0 && rate_hi != 0x0f)\n        {\n            eg_inc = ((~slot->eg_rout) << shift) >> 4;\n        }\n        break;\n    case envelope_gen_num_decay:\n        if ((slot->eg_rout >> 4) == slot->reg_sl)\n        {\n            slot->eg_gen = envelope_gen_num_sustain;\n        }\n        else if (!eg_off && !reset && shift > 0)\n        {\n            eg_inc = 1 << (shift - 1);\n        }\n        break;\n    case envelope_gen_num_sustain:\n    case envelope_gen_num_release:\n        if (!eg_off && !reset && shift > 0)\n        {\n            eg_inc = 1 << (shift - 1);\n        }\n        break;\n    }\n    slot->eg_rout = (eg_rout + eg_inc) & 0x1ff;\n    // Key off\n    if (reset)\n    {\n        slot->eg_gen = envelope_gen_num_attack;\n    }\n    if (!slot->key)\n    {\n        slot->eg_gen = envelope_gen_num_release;\n    }\n}\n\nstatic void OPL3_EnvelopeKeyOn(opl3_slot *slot, Bit8u type)\n{\n    slot->key |= type;\n}\n\nstatic void OPL3_EnvelopeKeyOff(opl3_slot *slot, Bit8u type)\n{\n    slot->key &= ~type;\n}\n\n//\n// Phase Generator\n//\n\nstatic void OPL3_PhaseGenerate(opl3_slot *slot)\n{\n    opl3_chip *chip;\n    Bit16u f_num;\n    Bit32u basefreq;\n    Bit8u rm_xor, n_bit;\n    Bit32u noise;\n    Bit16u phase;\n\n    chip = slot->chip;\n    f_num = slot->channel->f_num;\n    if (slot->reg_vib)\n    {\n        Bit8s range;\n        Bit8u vibpos;\n\n        range = (f_num >> 7) & 7;\n        vibpos = slot->chip->vibpos;\n\n        if (!(vibpos & 3))\n        {\n            range = 0;\n        }\n        else if (vibpos & 1)\n        {\n            range >>= 1;\n        }\n        range >>= slot->chip->vibshift;\n\n        if (vibpos & 4)\n        {\n            range = -range;\n        }\n        f_num += range;\n    }\n    basefreq = (f_num << slot->channel->block) >> 1;\n    phase = (Bit16u)(slot->pg_phase >> 9);\n    if (slot->pg_reset)\n    {\n        slot->pg_phase = 0;\n    }\n    slot->pg_phase += (basefreq * mt[slot->reg_mult]) >> 1;\n    // Rhythm mode\n    noise = chip->noise;\n    slot->pg_phase_out = phase;\n    if (slot->slot_num == 13) // hh\n    {\n        chip->rm_hh_bit2 = (phase >> 2) & 1;\n        chip->rm_hh_bit3 = (phase >> 3) & 1;\n        chip->rm_hh_bit7 = (phase >> 7) & 1;\n        chip->rm_hh_bit8 = (phase >> 8) & 1;\n    }\n    if (slot->slot_num == 17 && (chip->rhy & 0x20)) // tc\n    {\n        chip->rm_tc_bit3 = (phase >> 3) & 1;\n        chip->rm_tc_bit5 = (phase >> 5) & 1;\n    }\n    if (chip->rhy & 0x20)\n    {\n        rm_xor = (chip->rm_hh_bit2 ^ chip->rm_hh_bit7)\n               | (chip->rm_hh_bit3 ^ chip->rm_tc_bit5)\n               | (chip->rm_tc_bit3 ^ chip->rm_tc_bit5);\n        switch (slot->slot_num)\n        {\n        case 13: // hh\n            slot->pg_phase_out = rm_xor << 9;\n            if (rm_xor ^ (noise & 1))\n            {\n                slot->pg_phase_out |= 0xd0;\n            }\n            else\n            {\n                slot->pg_phase_out |= 0x34;\n            }\n            break;\n        case 16: // sd\n            slot->pg_phase_out = (chip->rm_hh_bit8 << 9)\n                               | ((chip->rm_hh_bit8 ^ (noise & 1)) << 8);\n            break;\n        case 17: // tc\n            slot->pg_phase_out = (rm_xor << 9) | 0x80;\n            break;\n        default:\n            break;\n        }\n    }\n    n_bit = ((noise >> 14) ^ noise) & 0x01;\n    chip->noise = (noise >> 1) | (n_bit << 22);\n}\n\n//\n// Slot\n//\n\nstatic void OPL3_SlotWrite20(opl3_slot *slot, Bit8u data)\n{\n    if ((data >> 7) & 0x01)\n    {\n        slot->trem = &slot->chip->tremolo;\n    }\n    else\n    {\n        slot->trem = (Bit8u*)&slot->chip->zeromod;\n    }\n    slot->reg_vib = (data >> 6) & 0x01;\n    slot->reg_type = (data >> 5) & 0x01;\n    slot->reg_ksr = (data >> 4) & 0x01;\n    slot->reg_mult = data & 0x0f;\n}\n\nstatic void OPL3_SlotWrite40(opl3_slot *slot, Bit8u data)\n{\n    slot->reg_ksl = (data >> 6) & 0x03;\n    slot->reg_tl = data & 0x3f;\n    OPL3_EnvelopeUpdateKSL(slot);\n}\n\nstatic void OPL3_SlotWrite60(opl3_slot *slot, Bit8u data)\n{\n    slot->reg_ar = (data >> 4) & 0x0f;\n    slot->reg_dr = data & 0x0f;\n}\n\nstatic void OPL3_SlotWrite80(opl3_slot *slot, Bit8u data)\n{\n    slot->reg_sl = (data >> 4) & 0x0f;\n    if (slot->reg_sl == 0x0f)\n    {\n        slot->reg_sl = 0x1f;\n    }\n    slot->reg_rr = data & 0x0f;\n}\n\nstatic void OPL3_SlotWriteE0(opl3_slot *slot, Bit8u data)\n{\n    slot->reg_wf = data & 0x07;\n    if (slot->chip->newm == 0x00)\n    {\n        slot->reg_wf &= 0x03;\n    }\n}\n\nstatic void OPL3_SlotGenerate(opl3_slot *slot)\n{\n    slot->out = envelope_sin[slot->reg_wf](slot->pg_phase_out + *slot->mod, slot->eg_out);\n}\n\nstatic void OPL3_SlotCalcFB(opl3_slot *slot)\n{\n    if (slot->channel->fb != 0x00)\n    {\n        slot->fbmod = (slot->prout + slot->out) >> (0x09 - slot->channel->fb);\n    }\n    else\n    {\n        slot->fbmod = 0;\n    }\n    slot->prout = slot->out;\n}\n\n//\n// Channel\n//\n\nstatic void OPL3_ChannelSetupAlg(opl3_channel *channel);\n\nstatic void OPL3_ChannelUpdateRhythm(opl3_chip *chip, Bit8u data)\n{\n    opl3_channel *channel6;\n    opl3_channel *channel7;\n    opl3_channel *channel8;\n    Bit8u chnum;\n\n    chip->rhy = data & 0x3f;\n    if (chip->rhy & 0x20)\n    {\n        channel6 = &chip->channel[6];\n        channel7 = &chip->channel[7];\n        channel8 = &chip->channel[8];\n        channel6->out[0] = &channel6->slots[1]->out;\n        channel6->out[1] = &channel6->slots[1]->out;\n        channel6->out[2] = &chip->zeromod;\n        channel6->out[3] = &chip->zeromod;\n        channel7->out[0] = &channel7->slots[0]->out;\n        channel7->out[1] = &channel7->slots[0]->out;\n        channel7->out[2] = &channel7->slots[1]->out;\n        channel7->out[3] = &channel7->slots[1]->out;\n        channel8->out[0] = &channel8->slots[0]->out;\n        channel8->out[1] = &channel8->slots[0]->out;\n        channel8->out[2] = &channel8->slots[1]->out;\n        channel8->out[3] = &channel8->slots[1]->out;\n        for (chnum = 6; chnum < 9; chnum++)\n        {\n            chip->channel[chnum].chtype = ch_drum;\n        }\n        OPL3_ChannelSetupAlg(channel6);\n        OPL3_ChannelSetupAlg(channel7);\n        OPL3_ChannelSetupAlg(channel8);\n        //hh\n        if (chip->rhy & 0x01)\n        {\n            OPL3_EnvelopeKeyOn(channel7->slots[0], egk_drum);\n        }\n        else\n        {\n            OPL3_EnvelopeKeyOff(channel7->slots[0], egk_drum);\n        }\n        //tc\n        if (chip->rhy & 0x02)\n        {\n            OPL3_EnvelopeKeyOn(channel8->slots[1], egk_drum);\n        }\n        else\n        {\n            OPL3_EnvelopeKeyOff(channel8->slots[1], egk_drum);\n        }\n        //tom\n        if (chip->rhy & 0x04)\n        {\n            OPL3_EnvelopeKeyOn(channel8->slots[0], egk_drum);\n        }\n        else\n        {\n            OPL3_EnvelopeKeyOff(channel8->slots[0], egk_drum);\n        }\n        //sd\n        if (chip->rhy & 0x08)\n        {\n            OPL3_EnvelopeKeyOn(channel7->slots[1], egk_drum);\n        }\n        else\n        {\n            OPL3_EnvelopeKeyOff(channel7->slots[1], egk_drum);\n        }\n        //bd\n        if (chip->rhy & 0x10)\n        {\n            OPL3_EnvelopeKeyOn(channel6->slots[0], egk_drum);\n            OPL3_EnvelopeKeyOn(channel6->slots[1], egk_drum);\n        }\n        else\n        {\n            OPL3_EnvelopeKeyOff(channel6->slots[0], egk_drum);\n            OPL3_EnvelopeKeyOff(channel6->slots[1], egk_drum);\n        }\n    }\n    else\n    {\n        for (chnum = 6; chnum < 9; chnum++)\n        {\n            chip->channel[chnum].chtype = ch_2op;\n            OPL3_ChannelSetupAlg(&chip->channel[chnum]);\n            OPL3_EnvelopeKeyOff(chip->channel[chnum].slots[0], egk_drum);\n            OPL3_EnvelopeKeyOff(chip->channel[chnum].slots[1], egk_drum);\n        }\n    }\n}\n\nstatic void OPL3_ChannelWriteA0(opl3_channel *channel, Bit8u data)\n{\n    if (channel->chip->newm && channel->chtype == ch_4op2)\n    {\n        return;\n    }\n    channel->f_num = (channel->f_num & 0x300) | data;\n    channel->ksv = (channel->block << 1)\n                 | ((channel->f_num >> (0x09 - channel->chip->nts)) & 0x01);\n    OPL3_EnvelopeUpdateKSL(channel->slots[0]);\n    OPL3_EnvelopeUpdateKSL(channel->slots[1]);\n    if (channel->chip->newm && channel->chtype == ch_4op)\n    {\n        channel->pair->f_num = channel->f_num;\n        channel->pair->ksv = channel->ksv;\n        OPL3_EnvelopeUpdateKSL(channel->pair->slots[0]);\n        OPL3_EnvelopeUpdateKSL(channel->pair->slots[1]);\n    }\n}\n\nstatic void OPL3_ChannelWriteB0(opl3_channel *channel, Bit8u data)\n{\n    if (channel->chip->newm && channel->chtype == ch_4op2)\n    {\n        return;\n    }\n    channel->f_num = (channel->f_num & 0xff) | ((data & 0x03) << 8);\n    channel->block = (data >> 2) & 0x07;\n    channel->ksv = (channel->block << 1)\n                 | ((channel->f_num >> (0x09 - channel->chip->nts)) & 0x01);\n    OPL3_EnvelopeUpdateKSL(channel->slots[0]);\n    OPL3_EnvelopeUpdateKSL(channel->slots[1]);\n    if (channel->chip->newm && channel->chtype == ch_4op)\n    {\n        channel->pair->f_num = channel->f_num;\n        channel->pair->block = channel->block;\n        channel->pair->ksv = channel->ksv;\n        OPL3_EnvelopeUpdateKSL(channel->pair->slots[0]);\n        OPL3_EnvelopeUpdateKSL(channel->pair->slots[1]);\n    }\n}\n\nstatic void OPL3_ChannelSetupAlg(opl3_channel *channel)\n{\n    if (channel->chtype == ch_drum)\n    {\n        if (channel->ch_num == 7 || channel->ch_num == 8)\n        {\n            channel->slots[0]->mod = &channel->chip->zeromod;\n            channel->slots[1]->mod = &channel->chip->zeromod;\n            return;\n        }\n        switch (channel->alg & 0x01)\n        {\n        case 0x00:\n            channel->slots[0]->mod = &channel->slots[0]->fbmod;\n            channel->slots[1]->mod = &channel->slots[0]->out;\n            break;\n        case 0x01:\n            channel->slots[0]->mod = &channel->slots[0]->fbmod;\n            channel->slots[1]->mod = &channel->chip->zeromod;\n            break;\n        }\n        return;\n    }\n    if (channel->alg & 0x08)\n    {\n        return;\n    }\n    if (channel->alg & 0x04)\n    {\n        channel->pair->out[0] = &channel->chip->zeromod;\n        channel->pair->out[1] = &channel->chip->zeromod;\n        channel->pair->out[2] = &channel->chip->zeromod;\n        channel->pair->out[3] = &channel->chip->zeromod;\n        switch (channel->alg & 0x03)\n        {\n        case 0x00:\n            channel->pair->slots[0]->mod = &channel->pair->slots[0]->fbmod;\n            channel->pair->slots[1]->mod = &channel->pair->slots[0]->out;\n            channel->slots[0]->mod = &channel->pair->slots[1]->out;\n            channel->slots[1]->mod = &channel->slots[0]->out;\n            channel->out[0] = &channel->slots[1]->out;\n            channel->out[1] = &channel->chip->zeromod;\n            channel->out[2] = &channel->chip->zeromod;\n            channel->out[3] = &channel->chip->zeromod;\n            break;\n        case 0x01:\n            channel->pair->slots[0]->mod = &channel->pair->slots[0]->fbmod;\n            channel->pair->slots[1]->mod = &channel->pair->slots[0]->out;\n            channel->slots[0]->mod = &channel->chip->zeromod;\n            channel->slots[1]->mod = &channel->slots[0]->out;\n            channel->out[0] = &channel->pair->slots[1]->out;\n            channel->out[1] = &channel->slots[1]->out;\n            channel->out[2] = &channel->chip->zeromod;\n            channel->out[3] = &channel->chip->zeromod;\n            break;\n        case 0x02:\n            channel->pair->slots[0]->mod = &channel->pair->slots[0]->fbmod;\n            channel->pair->slots[1]->mod = &channel->chip->zeromod;\n            channel->slots[0]->mod = &channel->pair->slots[1]->out;\n            channel->slots[1]->mod = &channel->slots[0]->out;\n            channel->out[0] = &channel->pair->slots[0]->out;\n            channel->out[1] = &channel->slots[1]->out;\n            channel->out[2] = &channel->chip->zeromod;\n            channel->out[3] = &channel->chip->zeromod;\n            break;\n        case 0x03:\n            channel->pair->slots[0]->mod = &channel->pair->slots[0]->fbmod;\n            channel->pair->slots[1]->mod = &channel->chip->zeromod;\n            channel->slots[0]->mod = &channel->pair->slots[1]->out;\n            channel->slots[1]->mod = &channel->chip->zeromod;\n            channel->out[0] = &channel->pair->slots[0]->out;\n            channel->out[1] = &channel->slots[0]->out;\n            channel->out[2] = &channel->slots[1]->out;\n            channel->out[3] = &channel->chip->zeromod;\n            break;\n        }\n    }\n    else\n    {\n        switch (channel->alg & 0x01)\n        {\n        case 0x00:\n            channel->slots[0]->mod = &channel->slots[0]->fbmod;\n            channel->slots[1]->mod = &channel->slots[0]->out;\n            channel->out[0] = &channel->slots[1]->out;\n            channel->out[1] = &channel->chip->zeromod;\n            channel->out[2] = &channel->chip->zeromod;\n            channel->out[3] = &channel->chip->zeromod;\n            break;\n        case 0x01:\n            channel->slots[0]->mod = &channel->slots[0]->fbmod;\n            channel->slots[1]->mod = &channel->chip->zeromod;\n            channel->out[0] = &channel->slots[0]->out;\n            channel->out[1] = &channel->slots[1]->out;\n            channel->out[2] = &channel->chip->zeromod;\n            channel->out[3] = &channel->chip->zeromod;\n            break;\n        }\n    }\n}\n\nstatic void OPL3_ChannelWriteC0(opl3_channel *channel, Bit8u data)\n{\n    channel->fb = (data & 0x0e) >> 1;\n    channel->con = data & 0x01;\n    channel->alg = channel->con;\n    if (channel->chip->newm)\n    {\n        if (channel->chtype == ch_4op)\n        {\n            channel->pair->alg = 0x04 | (channel->con << 1) | (channel->pair->con);\n            channel->alg = 0x08;\n            OPL3_ChannelSetupAlg(channel->pair);\n        }\n        else if (channel->chtype == ch_4op2)\n        {\n            channel->alg = 0x04 | (channel->pair->con << 1) | (channel->con);\n            channel->pair->alg = 0x08;\n            OPL3_ChannelSetupAlg(channel);\n        }\n        else\n        {\n            OPL3_ChannelSetupAlg(channel);\n        }\n    }\n    else\n    {\n        OPL3_ChannelSetupAlg(channel);\n    }\n    if (channel->chip->newm)\n    {\n        channel->cha = ((data >> 4) & 0x01) ? ~0 : 0;\n        channel->chb = ((data >> 5) & 0x01) ? ~0 : 0;\n    }\n    else\n    {\n        channel->cha = channel->chb = (Bit16u)~0;\n    }\n}\n\nstatic void OPL3_ChannelKeyOn(opl3_channel *channel)\n{\n    if (channel->chip->newm)\n    {\n        if (channel->chtype == ch_4op)\n        {\n            OPL3_EnvelopeKeyOn(channel->slots[0], egk_norm);\n            OPL3_EnvelopeKeyOn(channel->slots[1], egk_norm);\n            OPL3_EnvelopeKeyOn(channel->pair->slots[0], egk_norm);\n            OPL3_EnvelopeKeyOn(channel->pair->slots[1], egk_norm);\n        }\n        else if (channel->chtype == ch_2op || channel->chtype == ch_drum)\n        {\n            OPL3_EnvelopeKeyOn(channel->slots[0], egk_norm);\n            OPL3_EnvelopeKeyOn(channel->slots[1], egk_norm);\n        }\n    }\n    else\n    {\n        OPL3_EnvelopeKeyOn(channel->slots[0], egk_norm);\n        OPL3_EnvelopeKeyOn(channel->slots[1], egk_norm);\n    }\n}\n\nstatic void OPL3_ChannelKeyOff(opl3_channel *channel)\n{\n    if (channel->chip->newm)\n    {\n        if (channel->chtype == ch_4op)\n        {\n            OPL3_EnvelopeKeyOff(channel->slots[0], egk_norm);\n            OPL3_EnvelopeKeyOff(channel->slots[1], egk_norm);\n            OPL3_EnvelopeKeyOff(channel->pair->slots[0], egk_norm);\n            OPL3_EnvelopeKeyOff(channel->pair->slots[1], egk_norm);\n        }\n        else if (channel->chtype == ch_2op || channel->chtype == ch_drum)\n        {\n            OPL3_EnvelopeKeyOff(channel->slots[0], egk_norm);\n            OPL3_EnvelopeKeyOff(channel->slots[1], egk_norm);\n        }\n    }\n    else\n    {\n        OPL3_EnvelopeKeyOff(channel->slots[0], egk_norm);\n        OPL3_EnvelopeKeyOff(channel->slots[1], egk_norm);\n    }\n}\n\nstatic void OPL3_ChannelSet4Op(opl3_chip *chip, Bit8u data)\n{\n    Bit8u bit;\n    Bit8u chnum;\n    for (bit = 0; bit < 6; bit++)\n    {\n        chnum = bit;\n        if (bit >= 3)\n        {\n            chnum += 9 - 3;\n        }\n        if ((data >> bit) & 0x01)\n        {\n            chip->channel[chnum].chtype = ch_4op;\n            chip->channel[chnum + 3].chtype = ch_4op2;\n        }\n        else\n        {\n            chip->channel[chnum].chtype = ch_2op;\n            chip->channel[chnum + 3].chtype = ch_2op;\n        }\n    }\n}\n\nstatic Bit16s OPL3_ClipSample(Bit32s sample)\n{\n    if (sample > 32767)\n    {\n        sample = 32767;\n    }\n    else if (sample < -32768)\n    {\n        sample = -32768;\n    }\n    return (Bit16s)sample;\n}\n\nvoid OPL3_Generate(opl3_chip *chip, Bit16s *buf)\n{\n    Bit8u ii;\n    Bit8u jj;\n    Bit16s accm;\n    Bit8u shift = 0;\n\n    buf[1] = OPL3_ClipSample(chip->mixbuff[1]);\n\n    for (ii = 0; ii < 15; ii++)\n    {\n        OPL3_SlotCalcFB(&chip->slot[ii]);\n        OPL3_EnvelopeCalc(&chip->slot[ii]);\n        OPL3_PhaseGenerate(&chip->slot[ii]);\n        OPL3_SlotGenerate(&chip->slot[ii]);\n    }\n\n    chip->mixbuff[0] = 0;\n    for (ii = 0; ii < 18; ii++)\n    {\n        accm = 0;\n        for (jj = 0; jj < 4; jj++)\n        {\n            accm += *chip->channel[ii].out[jj];\n        }\n        chip->mixbuff[0] += (Bit16s)(accm & chip->channel[ii].cha);\n    }\n\n    for (ii = 15; ii < 18; ii++)\n    {\n        OPL3_SlotCalcFB(&chip->slot[ii]);\n        OPL3_EnvelopeCalc(&chip->slot[ii]);\n        OPL3_PhaseGenerate(&chip->slot[ii]);\n        OPL3_SlotGenerate(&chip->slot[ii]);\n    }\n\n    buf[0] = OPL3_ClipSample(chip->mixbuff[0]);\n\n    for (ii = 18; ii < 33; ii++)\n    {\n        OPL3_SlotCalcFB(&chip->slot[ii]);\n        OPL3_EnvelopeCalc(&chip->slot[ii]);\n        OPL3_PhaseGenerate(&chip->slot[ii]);\n        OPL3_SlotGenerate(&chip->slot[ii]);\n    }\n\n    chip->mixbuff[1] = 0;\n    for (ii = 0; ii < 18; ii++)\n    {\n        accm = 0;\n        for (jj = 0; jj < 4; jj++)\n        {\n            accm += *chip->channel[ii].out[jj];\n        }\n        chip->mixbuff[1] += (Bit16s)(accm & chip->channel[ii].chb);\n    }\n\n    for (ii = 33; ii < 36; ii++)\n    {\n        OPL3_SlotCalcFB(&chip->slot[ii]);\n        OPL3_EnvelopeCalc(&chip->slot[ii]);\n        OPL3_PhaseGenerate(&chip->slot[ii]);\n        OPL3_SlotGenerate(&chip->slot[ii]);\n    }\n\n    if ((chip->timer & 0x3f) == 0x3f)\n    {\n        chip->tremolopos = (chip->tremolopos + 1) % 210;\n    }\n    if (chip->tremolopos < 105)\n    {\n        chip->tremolo = chip->tremolopos >> chip->tremoloshift;\n    }\n    else\n    {\n        chip->tremolo = (210 - chip->tremolopos) >> chip->tremoloshift;\n    }\n\n    if ((chip->timer & 0x3ff) == 0x3ff)\n    {\n        chip->vibpos = (chip->vibpos + 1) & 7;\n    }\n\n    chip->timer++;\n\n    chip->eg_add = 0;\n    if (chip->eg_timer)\n    {\n        while (shift < 36 && ((chip->eg_timer >> shift) & 1) == 0)\n        {\n            shift++;\n        }\n        if (shift > 12)\n        {\n            chip->eg_add = 0;\n        }\n        else\n        {\n            chip->eg_add = shift + 1;\n        }\n    }\n\n    if (chip->eg_timerrem || chip->eg_state)\n    {\n        if (chip->eg_timer == 0xfffffffff)\n        {\n            chip->eg_timer = 0;\n            chip->eg_timerrem = 1;\n        }\n        else\n        {\n            chip->eg_timer++;\n            chip->eg_timerrem = 0;\n        }\n    }\n\n    chip->eg_state ^= 1;\n\n    while (chip->writebuf[chip->writebuf_cur].time <= chip->writebuf_samplecnt)\n    {\n        if (!(chip->writebuf[chip->writebuf_cur].reg & 0x200))\n        {\n            break;\n        }\n        chip->writebuf[chip->writebuf_cur].reg &= 0x1ff;\n        OPL3_WriteReg(chip, chip->writebuf[chip->writebuf_cur].reg,\n                      chip->writebuf[chip->writebuf_cur].data);\n        chip->writebuf_cur = (chip->writebuf_cur + 1) % OPL_WRITEBUF_SIZE;\n    }\n    chip->writebuf_samplecnt++;\n}\n\nvoid OPL3_GenerateResampled(opl3_chip *chip, Bit16s *buf)\n{\n    while (chip->samplecnt >= chip->rateratio)\n    {\n        chip->oldsamples[0] = chip->samples[0];\n        chip->oldsamples[1] = chip->samples[1];\n        OPL3_Generate(chip, chip->samples);\n        chip->samplecnt -= chip->rateratio;\n    }\n    buf[0] = (Bit16s)((chip->oldsamples[0] * (chip->rateratio - chip->samplecnt)\n                     + chip->samples[0] * chip->samplecnt) / chip->rateratio);\n    buf[1] = (Bit16s)((chip->oldsamples[1] * (chip->rateratio - chip->samplecnt)\n                     + chip->samples[1] * chip->samplecnt) / chip->rateratio);\n    chip->samplecnt += 1 << RSM_FRAC;\n}\n\nvoid OPL3_Reset(opl3_chip *chip, Bit32u samplerate)\n{\n    Bit8u slotnum;\n    Bit8u channum;\n\n    memset(chip, 0, sizeof(opl3_chip));\n    for (slotnum = 0; slotnum < 36; slotnum++)\n    {\n        chip->slot[slotnum].chip = chip;\n        chip->slot[slotnum].mod = &chip->zeromod;\n        chip->slot[slotnum].eg_rout = 0x1ff;\n        chip->slot[slotnum].eg_out = 0x1ff;\n        chip->slot[slotnum].eg_gen = envelope_gen_num_release;\n        chip->slot[slotnum].trem = (Bit8u*)&chip->zeromod;\n        chip->slot[slotnum].slot_num = slotnum;\n    }\n    for (channum = 0; channum < 18; channum++)\n    {\n        chip->channel[channum].slots[0] = &chip->slot[ch_slot[channum]];\n        chip->channel[channum].slots[1] = &chip->slot[ch_slot[channum] + 3];\n        chip->slot[ch_slot[channum]].channel = &chip->channel[channum];\n        chip->slot[ch_slot[channum] + 3].channel = &chip->channel[channum];\n        if ((channum % 9) < 3)\n        {\n            chip->channel[channum].pair = &chip->channel[channum + 3];\n        }\n        else if ((channum % 9) < 6)\n        {\n            chip->channel[channum].pair = &chip->channel[channum - 3];\n        }\n        chip->channel[channum].chip = chip;\n        chip->channel[channum].out[0] = &chip->zeromod;\n        chip->channel[channum].out[1] = &chip->zeromod;\n        chip->channel[channum].out[2] = &chip->zeromod;\n        chip->channel[channum].out[3] = &chip->zeromod;\n        chip->channel[channum].chtype = ch_2op;\n        chip->channel[channum].cha = 0xffff;\n        chip->channel[channum].chb = 0xffff;\n        chip->channel[channum].ch_num = channum;\n        OPL3_ChannelSetupAlg(&chip->channel[channum]);\n    }\n    chip->noise = 1;\n    chip->rateratio = (samplerate << RSM_FRAC) / 49716;\n    chip->tremoloshift = 4;\n    chip->vibshift = 1;\n}\n\nvoid OPL3_WriteReg(opl3_chip *chip, Bit16u reg, Bit8u v)\n{\n    Bit8u high = (reg >> 8) & 0x01;\n    Bit8u regm = reg & 0xff;\n    switch (regm & 0xf0)\n    {\n    case 0x00:\n        if (high)\n        {\n            switch (regm & 0x0f)\n            {\n            case 0x04:\n                OPL3_ChannelSet4Op(chip, v);\n                break;\n            case 0x05:\n                chip->newm = v & 0x01;\n                break;\n            }\n        }\n        else\n        {\n            switch (regm & 0x0f)\n            {\n            case 0x08:\n                chip->nts = (v >> 6) & 0x01;\n                break;\n            }\n        }\n        break;\n    case 0x20:\n    case 0x30:\n        if (ad_slot[regm & 0x1f] >= 0)\n        {\n            OPL3_SlotWrite20(&chip->slot[18 * high + ad_slot[regm & 0x1f]], v);\n        }\n        break;\n    case 0x40:\n    case 0x50:\n        if (ad_slot[regm & 0x1f] >= 0)\n        {\n            OPL3_SlotWrite40(&chip->slot[18 * high + ad_slot[regm & 0x1f]], v);\n        }\n        break;\n    case 0x60:\n    case 0x70:\n        if (ad_slot[regm & 0x1f] >= 0)\n        {\n            OPL3_SlotWrite60(&chip->slot[18 * high + ad_slot[regm & 0x1f]], v);\n        }\n        break;\n    case 0x80:\n    case 0x90:\n        if (ad_slot[regm & 0x1f] >= 0)\n        {\n            OPL3_SlotWrite80(&chip->slot[18 * high + ad_slot[regm & 0x1f]], v);\n        }\n        break;\n    case 0xe0:\n    case 0xf0:\n        if (ad_slot[regm & 0x1f] >= 0)\n        {\n            OPL3_SlotWriteE0(&chip->slot[18 * high + ad_slot[regm & 0x1f]], v);\n        }\n        break;\n    case 0xa0:\n        if ((regm & 0x0f) < 9)\n        {\n            OPL3_ChannelWriteA0(&chip->channel[9 * high + (regm & 0x0f)], v);\n        }\n        break;\n    case 0xb0:\n        if (regm == 0xbd && !high)\n        {\n            chip->tremoloshift = (((v >> 7) ^ 1) << 1) + 2;\n            chip->vibshift = ((v >> 6) & 0x01) ^ 1;\n            OPL3_ChannelUpdateRhythm(chip, v);\n        }\n        else if ((regm & 0x0f) < 9)\n        {\n            OPL3_ChannelWriteB0(&chip->channel[9 * high + (regm & 0x0f)], v);\n            if (v & 0x20)\n            {\n                OPL3_ChannelKeyOn(&chip->channel[9 * high + (regm & 0x0f)]);\n            }\n            else\n            {\n                OPL3_ChannelKeyOff(&chip->channel[9 * high + (regm & 0x0f)]);\n            }\n        }\n        break;\n    case 0xc0:\n        if ((regm & 0x0f) < 9)\n        {\n            OPL3_ChannelWriteC0(&chip->channel[9 * high + (regm & 0x0f)], v);\n        }\n        break;\n    }\n}\n\nvoid OPL3_WriteRegBuffered(opl3_chip *chip, Bit16u reg, Bit8u v)\n{\n    Bit64u time1, time2;\n\n    if (chip->writebuf[chip->writebuf_last].reg & 0x200)\n    {\n        OPL3_WriteReg(chip, chip->writebuf[chip->writebuf_last].reg & 0x1ff,\n                      chip->writebuf[chip->writebuf_last].data);\n\n        chip->writebuf_cur = (chip->writebuf_last + 1) % OPL_WRITEBUF_SIZE;\n        chip->writebuf_samplecnt = chip->writebuf[chip->writebuf_last].time;\n    }\n\n    chip->writebuf[chip->writebuf_last].reg = reg | 0x200;\n    chip->writebuf[chip->writebuf_last].data = v;\n    time1 = chip->writebuf_lasttime + OPL_WRITEBUF_DELAY;\n    time2 = chip->writebuf_samplecnt;\n\n    if (time1 < time2)\n    {\n        time1 = time2;\n    }\n\n    chip->writebuf[chip->writebuf_last].time = time1;\n    chip->writebuf_lasttime = time1;\n    chip->writebuf_last = (chip->writebuf_last + 1) % OPL_WRITEBUF_SIZE;\n}\n\nvoid OPL3_GenerateStream(opl3_chip *chip, Bit16s *sndptr, Bit32u numsamples)\n{\n    Bit32u i;\n\n    for(i = 0; i < numsamples; i++)\n    {\n        OPL3_GenerateResampled(chip, sndptr);\n        sndptr += 2;\n    }\n}\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//     Queue of waiting callbacks, stored in a binary min heap, so that we\n//     can always get the first callback.\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"opl_queue.h\"\n\n#define MAX_OPL_QUEUE 512\n\ntypedef struct\n{\n    opl_callback_t callback;\n    void *data;\n    uint64_t time;\n} opl_queue_entry_t;\n\nstruct opl_callback_queue_s\n{\n    opl_queue_entry_t entries[MAX_OPL_QUEUE];\n    unsigned int num_entries;\n};\n\nopl_callback_queue_t *OPL_Queue_Create(void)\n{\n    opl_callback_queue_t *queue;\n\n    queue = malloc(sizeof(opl_callback_queue_t));\n    queue->num_entries = 0;\n\n    return queue;\n}\n\nvoid OPL_Queue_Destroy(opl_callback_queue_t *queue)\n{\n    free(queue);\n}\n\nint OPL_Queue_IsEmpty(opl_callback_queue_t *queue)\n{\n    return queue->num_entries == 0;\n}\n\nvoid OPL_Queue_Clear(opl_callback_queue_t *queue)\n{\n    queue->num_entries = 0;\n}\n\nvoid OPL_Queue_Push(opl_callback_queue_t *queue,\n                    opl_callback_t callback, void *data,\n                    uint64_t time)\n{\n    int entry_id;\n    int parent_id;\n\n    if (queue->num_entries >= MAX_OPL_QUEUE)\n    {\n        fprintf(stderr, \"OPL_Queue_Push: Exceeded maximum callbacks\\n\");\n        return;\n    }\n\n    // Add to last queue entry.\n\n    entry_id = queue->num_entries;\n    ++queue->num_entries;\n\n    // Shift existing entries down in the heap.\n\n    while (entry_id > 0)\n    {\n        parent_id = (entry_id - 1) / 2;\n\n        // Is the heap condition satisfied?\n\n        if (time >= queue->entries[parent_id].time)\n        {\n            break;\n        }\n\n        // Move the existing entry down in the heap.\n\n        memcpy(&queue->entries[entry_id],\n               &queue->entries[parent_id],\n               sizeof(opl_queue_entry_t));\n\n        // Advance to the parent.\n\n        entry_id = parent_id;\n    }\n\n    // Insert new callback data.\n\n    queue->entries[entry_id].callback = callback;\n    queue->entries[entry_id].data = data;\n    queue->entries[entry_id].time = time;\n}\n\nint OPL_Queue_Pop(opl_callback_queue_t *queue,\n                  opl_callback_t *callback, void **data)\n{\n    opl_queue_entry_t *entry;\n    int child1, child2;\n    int i, next_i;\n\n    // Empty?\n\n    if (queue->num_entries <= 0)\n    {\n        return 0;\n    }\n\n    // Store the result:\n\n    *callback = queue->entries[0].callback;\n    *data = queue->entries[0].data;\n\n    // Decrease the heap size, and keep pointer to the last entry in\n    // the heap, which must now be percolated down from the top.\n\n    --queue->num_entries;\n    entry = &queue->entries[queue->num_entries];\n\n    // Percolate down.\n\n    i = 0;\n\n    for (;;)\n    {\n        child1 = i * 2 + 1;\n        child2 = i * 2 + 2;\n\n        if (child1 < queue->num_entries\n         && queue->entries[child1].time < entry->time)\n        {\n            // Left child is less than entry.\n            // Use the minimum of left and right children.\n\n            if (child2 < queue->num_entries\n             && queue->entries[child2].time < queue->entries[child1].time)\n            {\n                next_i = child2;\n            }\n            else\n            {\n                next_i = child1;\n            }\n        }\n        else if (child2 < queue->num_entries\n              && queue->entries[child2].time < entry->time)\n        {\n            // Right child is less than entry.  Go down the right side.\n\n            next_i = child2;\n        }\n        else\n        {\n            // Finished percolating.\n            break;\n        }\n\n        // Percolate the next value up and advance.\n\n        memcpy(&queue->entries[i],\n               &queue->entries[next_i],\n               sizeof(opl_queue_entry_t));\n        i = next_i;\n    }\n\n    // Store the old last-entry at its new position.\n\n    memcpy(&queue->entries[i], entry, sizeof(opl_queue_entry_t));\n\n    return 1;\n}\n\nuint64_t OPL_Queue_Peek(opl_callback_queue_t *queue)\n{\n    if (queue->num_entries > 0)\n    {\n        return queue->entries[0].time;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nvoid OPL_Queue_AdjustCallbacks(opl_callback_queue_t *queue,\n                               uint64_t time, float factor)\n{\n    int64_t offset;\n    int i;\n\n    for (i = 0; i < queue->num_entries; ++i)\n    {\n        offset = queue->entries[i].time - time;\n        queue->entries[i].time = time + (uint64_t) (offset / factor);\n    }\n}\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//     OPL SDL interface.\n//\n\n#include \"config.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <errno.h>\n#include <assert.h>\n\n#include \"SDL.h\"\n#include \"SDL_mixer.h\"\n\n#include \"opl3.h\"\n\n#include \"opl.h\"\n#include \"opl_internal.h\"\n\n#include \"opl_queue.h\"\n\n#define MAX_SOUND_SLICE_TIME 100 /* ms */\n\ntypedef struct\n{\n    unsigned int rate;        // Number of times the timer is advanced per sec.\n    unsigned int enabled;     // Non-zero if timer is enabled.\n    unsigned int value;       // Last value that was set.\n    uint64_t expire_time;     // Calculated time that timer will expire.\n} opl_timer_t;\n\n// When the callback mutex is locked using OPL_Lock, callback functions\n// are not invoked.\n\nstatic SDL_mutex *callback_mutex = NULL;\n\n// Queue of callbacks waiting to be invoked.\n\nstatic opl_callback_queue_t *callback_queue;\n\n// Mutex used to control access to the callback queue.\n\nstatic SDL_mutex *callback_queue_mutex = NULL;\n\n// Current time, in us since startup:\n\nstatic uint64_t current_time;\n\n// If non-zero, playback is currently paused.\n\nstatic int opl_sdl_paused;\n\n// Time offset (in us) due to the fact that callbacks\n// were previously paused.\n\nstatic uint64_t pause_offset;\n\n// OPL software emulator structure.\n\nstatic opl3_chip opl_chip;\nstatic int opl_opl3mode;\n\n// Temporary mixing buffer used by the mixing callback.\n\nstatic int32_t *mix_buffer = NULL;\n\n// Register number that was written.\n\nstatic int register_num = 0;\n\n// Timers; DBOPL does not do timer stuff itself.\n\nstatic opl_timer_t timer1 = { 12500, 0, 0, 0 };\nstatic opl_timer_t timer2 = { 3125, 0, 0, 0 };\n\n// SDL parameters.\n\nstatic int sdl_was_initialized = 0;\nstatic int mixing_freq, mixing_channels;\nstatic Uint16 mixing_format;\n\nstatic int SDLIsInitialized(void)\n{\n    int freq, channels;\n    Uint16 format;\n\n    return Mix_QuerySpec(&freq, &format, &channels);\n}\n\n// Advance time by the specified number of samples, invoking any\n// callback functions as appropriate.\n\nstatic void AdvanceTime(unsigned int nsamples)\n{\n    opl_callback_t callback;\n    void *callback_data;\n    uint64_t us;\n\n    // SDL_LockMutex(callback_queue_mutex);\n\n    // Advance time.\n\n    us = ((uint64_t) nsamples * OPL_SECOND) / mixing_freq;\n    current_time += us;\n\n    if (opl_sdl_paused)\n    {\n        pause_offset += us;\n    }\n\n    // Are there callbacks to invoke now?  Keep invoking them\n    // until there are no more left.\n\n    while (!OPL_Queue_IsEmpty(callback_queue)\n        && current_time >= OPL_Queue_Peek(callback_queue) + pause_offset)\n    {\n        // Pop the callback from the queue to invoke it.\n\n        if (!OPL_Queue_Pop(callback_queue, &callback, &callback_data))\n        {\n            break;\n        }\n\n        callback(callback_data);\n    }\n}\n\n// Call the OPL emulator code to fill the specified buffer.\n\nstatic void FillBuffer(int16_t *buffer, unsigned int nsamples)\n{\n    // This seems like a reasonable assumption.  mix_buffer is\n    // 1 second long, which should always be much longer than the\n    // SDL mix buffer.\n\n    assert(nsamples < mixing_freq);\n\n    OPL3_GenerateStream(&opl_chip, buffer, nsamples);\n}\n\n// Callback function to fill a new sound buffer:\n\nstatic void OPL_Mix_Callback(void *udata,\n                             Uint8 *byte_buffer,\n                             int buffer_bytes)\n{\n    int16_t *buffer;\n    unsigned int buffer_len;\n    unsigned int filled = 0;\n\n    // Buffer length in samples (quadrupled, because of 16-bit and stereo)\n\n    buffer = (int16_t *) byte_buffer;\n    buffer_len = buffer_bytes / 4;\n\n    // Repeatedly call the OPL emulator update function until the buffer is\n    // full.\n\n    while (filled < buffer_len)\n    {\n        uint64_t next_callback_time;\n        uint64_t nsamples;\n\n        // Work out the time until the next callback waiting in\n        // the callback queue must be invoked.  We can then fill the\n        // buffer with this many samples.\n\n        if (opl_sdl_paused || OPL_Queue_IsEmpty(callback_queue))\n        {\n            nsamples = buffer_len - filled;\n        }\n        else\n        {\n            next_callback_time = OPL_Queue_Peek(callback_queue) + pause_offset;\n\n            nsamples = (next_callback_time - current_time) * mixing_freq;\n            nsamples = (nsamples + OPL_SECOND - 1) / OPL_SECOND;\n\n            if (nsamples > buffer_len - filled)\n            {\n                nsamples = buffer_len - filled;\n            }\n        }\n\n        // Add emulator output to buffer.\n\n        FillBuffer(buffer + filled * 2, nsamples);\n        filled += nsamples;\n\n        // Invoke callbacks for this point in time.\n\n        AdvanceTime(nsamples);\n    }\n}\n\nstatic void OPL_SDL_Shutdown(void)\n{\n    Mix_HookMusic(NULL, NULL);\n\n    if (sdl_was_initialized)\n    {\n        Mix_CloseAudio();\n        SDL_QuitSubSystem(SDL_INIT_AUDIO);\n        OPL_Queue_Destroy(callback_queue);\n        free(mix_buffer);\n        sdl_was_initialized = 0;\n    }\n\n    if (callback_mutex != NULL)\n    {\n        SDL_DestroyMutex(callback_mutex);\n        callback_mutex = NULL;\n    }\n\n    if (callback_queue_mutex != NULL)\n    {\n        SDL_DestroyMutex(callback_queue_mutex);\n        callback_queue_mutex = NULL;\n    }\n}\n\nstatic unsigned int GetSliceSize(void)\n{\n    int limit;\n    int n;\n\n    limit = (opl_sample_rate * MAX_SOUND_SLICE_TIME) / 1000;\n\n    // Try all powers of two, not exceeding the limit.\n\n    for (n=0;; ++n)\n    {\n        // 2^n <= limit < 2^n+1 ?\n\n        if ((1 << (n + 1)) > limit)\n        {\n            return (1 << n);\n        }\n    }\n\n    // Should never happen?\n\n    return 1024;\n}\n\nstatic int OPL_SDL_Init(unsigned int port_base)\n{\n    // Check if SDL_mixer has been opened already\n    // If not, we must initialize it now\n\n    if (!SDLIsInitialized())\n    {\n        if (SDL_Init(SDL_INIT_AUDIO) < 0)\n        {\n            fprintf(stderr, \"Unable to set up sound.\\n\");\n            return 0;\n        }\n\n        if (Mix_OpenAudio(opl_sample_rate, AUDIO_S16SYS, 2, GetSliceSize()) < 0)\n        {\n            fprintf(stderr, \"Error initialising SDL_mixer: %s\\n\", Mix_GetError());\n\n            SDL_QuitSubSystem(SDL_INIT_AUDIO);\n            return 0;\n        }\n\n        SDL_PauseAudio(0);\n\n        // When this module shuts down, it has the responsibility to \n        // shut down SDL.\n\n        sdl_was_initialized = 1;\n    }\n    else\n    {\n        sdl_was_initialized = 0;\n    }\n\n    opl_sdl_paused = 0;\n    pause_offset = 0;\n\n    // Queue structure of callbacks to invoke.\n\n    callback_queue = OPL_Queue_Create();\n    current_time = 0;\n\n    // Get the mixer frequency, format and number of channels.\n\n    Mix_QuerySpec(&mixing_freq, &mixing_format, &mixing_channels);\n\n    // Only supports AUDIO_S16SYS\n\n    if (mixing_format != AUDIO_S16SYS || mixing_channels != 2)\n    {\n        fprintf(stderr, \n                \"OPL_SDL only supports native signed 16-bit LSB, \"\n                \"stereo format!\\n\");\n\n        OPL_SDL_Shutdown();\n        return 0;\n    }\n\n    // Mix buffer:\n\n    mix_buffer = malloc(mixing_freq * sizeof(uint32_t) * 2);\n\n    // Create the emulator structure:\n\n    OPL3_Reset(&opl_chip, mixing_freq);\n    opl_opl3mode = 0;\n\n    callback_mutex = SDL_CreateMutex();\n    callback_queue_mutex = SDL_CreateMutex();\n\n    // TODO: This should be music callback? or-?\n    Mix_HookMusic(OPL_Mix_Callback, NULL);\n\n    return 1;\n}\n\nstatic unsigned int OPL_SDL_PortRead(opl_port_t port)\n{\n    unsigned int result = 0;\n\n    if (port == OPL_REGISTER_PORT_OPL3)\n    {\n        return 0xff;\n    }\n\n    if (timer1.enabled && current_time > timer1.expire_time)\n    {\n        result |= 0x80;   // Either have expired\n        result |= 0x40;   // Timer 1 has expired\n    }\n\n    if (timer2.enabled && current_time > timer2.expire_time)\n    {\n        result |= 0x80;   // Either have expired\n        result |= 0x20;   // Timer 2 has expired\n    }\n\n    return result;\n}\n\nstatic void OPLTimer_CalculateEndTime(opl_timer_t *timer)\n{\n    int tics;\n\n    // If the timer is enabled, calculate the time when the timer\n    // will expire.\n\n    if (timer->enabled)\n    {\n        tics = 0x100 - timer->value;\n        timer->expire_time = current_time\n                           + ((uint64_t) tics * OPL_SECOND) / timer->rate;\n    }\n}\n\nstatic void WriteRegister(unsigned int reg_num, unsigned int value)\n{\n    switch (reg_num)\n    {\n        case OPL_REG_TIMER1:\n            timer1.value = value;\n            OPLTimer_CalculateEndTime(&timer1);\n            break;\n\n        case OPL_REG_TIMER2:\n            timer2.value = value;\n            OPLTimer_CalculateEndTime(&timer2);\n            break;\n\n        case OPL_REG_TIMER_CTRL:\n            if (value & 0x80)\n            {\n                timer1.enabled = 0;\n                timer2.enabled = 0;\n            }\n            else\n            {\n                if ((value & 0x40) == 0)\n                {\n                    timer1.enabled = (value & 0x01) != 0;\n                    OPLTimer_CalculateEndTime(&timer1);\n                }\n\n                if ((value & 0x20) == 0)\n                {\n                    timer1.enabled = (value & 0x02) != 0;\n                    OPLTimer_CalculateEndTime(&timer2);\n                }\n            }\n\n            break;\n\n        case OPL_REG_NEW:\n            opl_opl3mode = value & 0x01;\n\n        default:\n            OPL3_WriteRegBuffered(&opl_chip, reg_num, value);\n            break;\n    }\n}\n\nstatic void OPL_SDL_PortWrite(opl_port_t port, unsigned int value)\n{\n    if (port == OPL_REGISTER_PORT)\n    {\n        register_num = value;\n    }\n    else if (port == OPL_REGISTER_PORT_OPL3)\n    {\n        register_num = value | 0x100;\n    }\n    else if (port == OPL_DATA_PORT)\n    {\n        WriteRegister(register_num, value);\n    }\n}\n\nstatic void OPL_SDL_SetCallback(uint64_t us, opl_callback_t callback,\n                                void *data)\n{\n    OPL_Queue_Push(callback_queue, callback, data,\n                   current_time - pause_offset + us);\n}\n\nstatic void OPL_SDL_ClearCallbacks(void)\n{\n    OPL_Queue_Clear(callback_queue);\n}\n\nstatic void OPL_SDL_Lock(void)\n{\n}\n\nstatic void OPL_SDL_Unlock(void)\n{\n}\n\nstatic void OPL_SDL_SetPaused(int paused)\n{\n    opl_sdl_paused = paused;\n}\n\nstatic void OPL_SDL_AdjustCallbacks(float factor)\n{\n    OPL_Queue_AdjustCallbacks(callback_queue, current_time, factor);\n}\n\nopl_driver_t opl_sdl_driver =\n{\n    \"SDL\",\n    OPL_SDL_Init,\n    OPL_SDL_Shutdown,\n    OPL_SDL_PortRead,\n    OPL_SDL_PortWrite,\n    OPL_SDL_SetCallback,\n    OPL_SDL_ClearCallbacks,\n    OPL_SDL_Lock,\n    OPL_SDL_Unlock,\n    OPL_SDL_SetPaused,\n    OPL_SDL_AdjustCallbacks,\n};\n\n","/*\n  SDL_mixer:  An audio mixer library based on the SDL library\n  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  This file by Ryan C. Gordon (icculus@icculus.org)\n\n  These are some internally supported special effects that use SDL_mixer's\n  effect callback API. They are meant for speed over quality.  :)\n*/\n\n/* $Id$ */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"SDL.h\"\n#include \"SDL_endian.h\"\n#include \"SDL_mixer.h\"\n#include \"mixer.h\"\n\n#define __MIX_INTERNAL_EFFECT__\n#include \"effects_internal.h\"\n\n/* profile code:\n    #include <sys/time.h>\n    #include <unistd.h>\n    struct timeval tv1;\n    struct timeval tv2;\n\n    gettimeofday(&tv1, NULL);\n\n        ... do your thing here ...\n\n    gettimeofday(&tv2, NULL);\n    printf(\"%ld\\n\", tv2.tv_usec - tv1.tv_usec);\n*/\n\n\n/*\n * Positional effects...panning, distance attenuation, etc.\n */\n\ntypedef struct _Eff_positionargs\n{\n    volatile float left_f;\n    volatile float right_f;\n    volatile Uint8 left_u8;\n    volatile Uint8 right_u8;\n    volatile float left_rear_f;\n    volatile float right_rear_f;\n    volatile float center_f;\n    volatile float lfe_f;\n    volatile Uint8 left_rear_u8;\n    volatile Uint8 right_rear_u8;\n    volatile Uint8 center_u8;\n    volatile Uint8 lfe_u8;\n    volatile float distance_f;\n    volatile Uint8 distance_u8;\n    volatile Sint16 room_angle;\n    volatile int in_use;\n    volatile int channels;\n} position_args;\n\nstatic position_args **pos_args_array = NULL;\nstatic position_args *pos_args_global = NULL;\nstatic int position_channels = 0;\n\nvoid _Eff_PositionDeinit(void)\n{\n    int i;\n    for (i = 0; i < position_channels; i++) {\n        SDL_free(pos_args_array[i]);\n    }\n\n    position_channels = 0;\n\n    SDL_free(pos_args_global);\n    pos_args_global = NULL;\n    SDL_free(pos_args_array);\n    pos_args_array = NULL;\n}\n\n\n/* This just frees up the callback-specific data. */\nstatic void SDLCALL _Eff_PositionDone(int channel, void *udata)\n{\n    if (channel < 0) {\n        if (pos_args_global != NULL) {\n            SDL_free(pos_args_global);\n            pos_args_global = NULL;\n        }\n    }\n\n    else if (pos_args_array[channel] != NULL) {\n        SDL_free(pos_args_array[channel]);\n        pos_args_array[channel] = NULL;\n    }\n}\n\n\nstatic void SDLCALL _Eff_position_u8(int chan, void *stream, int len, void *udata)\n{\n    volatile position_args *args = (volatile position_args *) udata;\n    Uint8 *ptr = (Uint8 *) stream;\n    int i;\n\n        /*\n         * if there's only a mono channnel (the only way we wouldn't have\n         *  a len divisible by 2 here), then left_f and right_f are always\n         *  1.0, and are therefore throwaways.\n         */\n    if (len % sizeof (Uint16) != 0) {\n        *ptr = (Uint8) (((float) *ptr) * args->distance_f);\n        ptr++;\n        len--;\n    }\n\n    if (args->room_angle == 180)\n    for (i = 0; i < len; i += sizeof (Uint8) * 2) {\n        /* must adjust the sample so that 0 is the center */\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_f) * args->distance_f) + 128);\n        ptr++;\n    }\n    else for (i = 0; i < len; i += sizeof (Uint8) * 2) {\n        /* must adjust the sample so that 0 is the center */\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_f) * args->distance_f) + 128);\n        ptr++;\n    }\n}\nstatic void SDLCALL _Eff_position_u8_c4(int chan, void *stream, int len, void *udata)\n{\n    volatile position_args *args = (volatile position_args *) udata;\n    Uint8 *ptr = (Uint8 *) stream;\n    int i;\n\n        /*\n         * if there's only a mono channnel (the only way we wouldn't have\n         *  a len divisible by 2 here), then left_f and right_f are always\n         *  1.0, and are therefore throwaways.\n         */\n    if (len % sizeof (Uint16) != 0) {\n        *ptr = (Uint8) (((float) *ptr) * args->distance_f);\n        ptr++;\n        len--;\n    }\n\n    if (args->room_angle == 0)\n    for (i = 0; i < len; i += sizeof (Uint8) * 6) {\n        /* must adjust the sample so that 0 is the center */\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_rear_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_rear_f) * args->distance_f) + 128);\n        ptr++;\n    }\n    else if (args->room_angle == 90)\n    for (i = 0; i < len; i += sizeof (Uint8) * 6) {\n        /* must adjust the sample so that 0 is the center */\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_rear_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_rear_f) * args->distance_f) + 128);\n        ptr++;\n    }\n    else if (args->room_angle == 180)\n    for (i = 0; i < len; i += sizeof (Uint8) * 6) {\n        /* must adjust the sample so that 0 is the center */\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_rear_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_rear_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_f) * args->distance_f) + 128);\n        ptr++;\n    }\n    else if (args->room_angle == 270)\n    for (i = 0; i < len; i += sizeof (Uint8) * 6) {\n        /* must adjust the sample so that 0 is the center */\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_rear_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_rear_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_f) * args->distance_f) + 128);\n        ptr++;\n    }\n}\n\n\nstatic void SDLCALL _Eff_position_u8_c6(int chan, void *stream, int len, void *udata)\n{\n    volatile position_args *args = (volatile position_args *) udata;\n    Uint8 *ptr = (Uint8 *) stream;\n    int i;\n\n        /*\n         * if there's only a mono channnel (the only way we wouldn't have\n         *  a len divisible by 2 here), then left_f and right_f are always\n         *  1.0, and are therefore throwaways.\n         */\n    if (len % sizeof (Uint16) != 0) {\n        *ptr = (Uint8) (((float) *ptr) * args->distance_f);\n        ptr++;\n        len--;\n    }\n\n    if (args->room_angle == 0)\n    for (i = 0; i < len; i += sizeof (Uint8) * 6) {\n        /* must adjust the sample so that 0 is the center */\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_rear_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_rear_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->center_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->lfe_f) * args->distance_f) + 128);\n        ptr++;\n    }\n    else if (args->room_angle == 90)\n    for (i = 0; i < len; i += sizeof (Uint8) * 6) {\n        /* must adjust the sample so that 0 is the center */\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_rear_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_rear_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_rear_f) * args->distance_f/2) + 128)\n            + (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_f) * args->distance_f/2) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->lfe_f) * args->distance_f) + 128);\n        ptr++;\n    }\n    else if (args->room_angle == 180)\n    for (i = 0; i < len; i += sizeof (Uint8) * 6) {\n        /* must adjust the sample so that 0 is the center */\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_rear_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_rear_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_rear_f) * args->distance_f/2) + 128)\n            + (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_rear_f) * args->distance_f/2) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->lfe_f) * args->distance_f) + 128);\n        ptr++;\n    }\n    else if (args->room_angle == 270)\n    for (i = 0; i < len; i += sizeof (Uint8) * 6) {\n        /* must adjust the sample so that 0 is the center */\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_rear_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_rear_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->right_f) * args->distance_f) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_f) * args->distance_f/2) + 128)\n            + (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->left_rear_f) * args->distance_f/2) + 128);\n        ptr++;\n        *ptr = (Uint8) ((Sint8) ((((float) (Sint8) (*ptr - 128))\n            * args->lfe_f) * args->distance_f) + 128);\n        ptr++;\n    }\n}\n\n\n/*\n * This one runs about 10.1 times faster than the non-table version, with\n *  no loss in quality. It does, however, require 64k of memory for the\n *  lookup table. Also, this will only update position information once per\n *  call; the non-table version always checks the arguments for each sample,\n *  in case the user has called Mix_SetPanning() or whatnot again while this\n *  callback is running.\n */\nstatic void SDLCALL _Eff_position_table_u8(int chan, void *stream, int len, void *udata)\n{\n    volatile position_args *args = (volatile position_args *) udata;\n    Uint8 *ptr = (Uint8 *) stream;\n    Uint32 *p;\n    int i;\n    Uint8 *l = ((Uint8 *) _Eff_volume_table) + (256 * args->left_u8);\n    Uint8 *r = ((Uint8 *) _Eff_volume_table) + (256 * args->right_u8);\n    Uint8 *d = ((Uint8 *) _Eff_volume_table) + (256 * args->distance_u8);\n\n    if (args->room_angle == 180) {\n        Uint8 *temp = l;\n        l = r;\n        r = temp;\n    }\n        /*\n         * if there's only a mono channnel, then l[] and r[] are always\n         *  volume 255, and are therefore throwaways. Still, we have to\n         *  be sure not to overrun the audio buffer...\n         */\n    while (len % sizeof (Uint32) != 0) {\n        *ptr = d[l[*ptr]];\n        ptr++;\n        if (args->channels > 1) {\n            *ptr = d[r[*ptr]];\n            ptr++;\n        }\n        len -= args->channels;\n    }\n\n    p = (Uint32 *) ptr;\n\n    for (i = 0; i < len; i += sizeof (Uint32)) {\n#if (SDL_BYTEORDER == SDL_BIG_ENDIAN)\n        *p = (d[l[(*p & 0xFF000000) >> 24]] << 24) |\n             (d[r[(*p & 0x00FF0000) >> 16]] << 16) |\n             (d[l[(*p & 0x0000FF00) >>  8]] <<  8) |\n             (d[r[(*p & 0x000000FF)      ]]     ) ;\n#else\n        *p = (d[r[(*p & 0xFF000000) >> 24]] << 24) |\n             (d[l[(*p & 0x00FF0000) >> 16]] << 16) |\n             (d[r[(*p & 0x0000FF00) >>  8]] <<  8) |\n             (d[l[(*p & 0x000000FF)      ]]     ) ;\n#endif\n        ++p;\n    }\n}\n\n\nstatic void SDLCALL _Eff_position_s8(int chan, void *stream, int len, void *udata)\n{\n    volatile position_args *args = (volatile position_args *) udata;\n    Sint8 *ptr = (Sint8 *) stream;\n    int i;\n\n        /*\n         * if there's only a mono channnel (the only way we wouldn't have\n         *  a len divisible by 2 here), then left_f and right_f are always\n         *  1.0, and are therefore throwaways.\n         */\n    if (len % sizeof (Sint16) != 0) {\n        *ptr = (Sint8) (((float) *ptr) * args->distance_f);\n        ptr++;\n        len--;\n    }\n\n    if (args->room_angle == 180)\n    for (i = 0; i < len; i += sizeof (Sint8) * 2) {\n        *ptr = (Sint8)((((float) *ptr) * args->right_f) * args->distance_f);\n        ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->left_f) * args->distance_f);\n        ptr++;\n    }\n    else\n    for (i = 0; i < len; i += sizeof (Sint8) * 2) {\n        *ptr = (Sint8)((((float) *ptr) * args->left_f) * args->distance_f);\n        ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->right_f) * args->distance_f);\n        ptr++;\n    }\n}\nstatic void SDLCALL _Eff_position_s8_c4(int chan, void *stream, int len, void *udata)\n{\n    volatile position_args *args = (volatile position_args *) udata;\n    Sint8 *ptr = (Sint8 *) stream;\n    int i;\n\n        /*\n         * if there's only a mono channnel (the only way we wouldn't have\n         *  a len divisible by 2 here), then left_f and right_f are always\n         *  1.0, and are therefore throwaways.\n         */\n    if (len % sizeof (Sint16) != 0) {\n        *ptr = (Sint8) (((float) *ptr) * args->distance_f);\n        ptr++;\n        len--;\n    }\n\n    for (i = 0; i < len; i += sizeof (Sint8) * 4) {\n      switch (args->room_angle) {\n       case 0:\n        *ptr = (Sint8)((((float) *ptr) * args->left_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->right_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->left_rear_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->right_rear_f) * args->distance_f); ptr++;\n    break;\n       case 90:\n        *ptr = (Sint8)((((float) *ptr) * args->right_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->right_rear_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->left_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->left_rear_f) * args->distance_f); ptr++;\n    break;\n       case 180:\n        *ptr = (Sint8)((((float) *ptr) * args->right_rear_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->left_rear_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->right_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->left_f) * args->distance_f); ptr++;\n    break;\n       case 270:\n        *ptr = (Sint8)((((float) *ptr) * args->left_rear_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->left_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->right_rear_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->right_f) * args->distance_f); ptr++;\n    break;\n      }\n    }\n}\nstatic void SDLCALL _Eff_position_s8_c6(int chan, void *stream, int len, void *udata)\n{\n    volatile position_args *args = (volatile position_args *) udata;\n    Sint8 *ptr = (Sint8 *) stream;\n    int i;\n\n        /*\n         * if there's only a mono channnel (the only way we wouldn't have\n         *  a len divisible by 2 here), then left_f and right_f are always\n         *  1.0, and are therefore throwaways.\n         */\n    if (len % sizeof (Sint16) != 0) {\n        *ptr = (Sint8) (((float) *ptr) * args->distance_f);\n        ptr++;\n        len--;\n    }\n\n    for (i = 0; i < len; i += sizeof (Sint8) * 6) {\n      switch (args->room_angle) {\n       case 0:\n        *ptr = (Sint8)((((float) *ptr) * args->left_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->right_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->left_rear_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->right_rear_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->center_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->lfe_f) * args->distance_f); ptr++;\n    break;\n       case 90:\n        *ptr = (Sint8)((((float) *ptr) * args->right_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->right_rear_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->left_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->left_rear_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->right_rear_f) * args->distance_f / 2)\n           + (Sint8)((((float) *ptr) * args->right_f) * args->distance_f / 2); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->lfe_f) * args->distance_f); ptr++;\n    break;\n       case 180:\n        *ptr = (Sint8)((((float) *ptr) * args->right_rear_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->left_rear_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->right_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->left_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->right_rear_f) * args->distance_f / 2)\n           + (Sint8)((((float) *ptr) * args->left_rear_f) * args->distance_f / 2); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->lfe_f) * args->distance_f); ptr++;\n    break;\n       case 270:\n        *ptr = (Sint8)((((float) *ptr) * args->left_rear_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->left_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->right_rear_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->right_f) * args->distance_f); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->left_f) * args->distance_f / 2)\n           + (Sint8)((((float) *ptr) * args->left_rear_f) * args->distance_f / 2); ptr++;\n        *ptr = (Sint8)((((float) *ptr) * args->lfe_f) * args->distance_f); ptr++;\n    break;\n      }\n    }\n}\n\n\n/*\n * This one runs about 10.1 times faster than the non-table version, with\n *  no loss in quality. It does, however, require 64k of memory for the\n *  lookup table. Also, this will only update position information once per\n *  call; the non-table version always checks the arguments for each sample,\n *  in case the user has called Mix_SetPanning() or whatnot again while this\n *  callback is running.\n */\nstatic void SDLCALL _Eff_position_table_s8(int chan, void *stream, int len, void *udata)\n{\n    volatile position_args *args = (volatile position_args *) udata;\n    Sint8 *ptr = (Sint8 *) stream;\n    Uint32 *p;\n    int i;\n    Sint8 *l = ((Sint8 *) _Eff_volume_table) + (256 * args->left_u8);\n    Sint8 *r = ((Sint8 *) _Eff_volume_table) + (256 * args->right_u8);\n    Sint8 *d = ((Sint8 *) _Eff_volume_table) + (256 * args->distance_u8);\n\n    if (args->room_angle == 180) {\n        Sint8 *temp = l;\n        l = r;\n        r = temp;\n    }\n\n\n    while (len % sizeof (Uint32) != 0) {\n        *ptr = d[l[*ptr]];\n        ptr++;\n        if (args->channels > 1) {\n            *ptr = d[r[*ptr]];\n            ptr++;\n        }\n        len -= args->channels;\n    }\n\n    p = (Uint32 *) ptr;\n\n    for (i = 0; i < len; i += sizeof (Uint32)) {\n#if (SDL_BYTEORDER == SDL_BIG_ENDIAN)\n        *p = (d[l[((Sint16)(Sint8)((*p & 0xFF000000) >> 24))+128]] << 24) |\n             (d[r[((Sint16)(Sint8)((*p & 0x00FF0000) >> 16))+128]] << 16) |\n             (d[l[((Sint16)(Sint8)((*p & 0x0000FF00) >>  8))+128]] <<  8) |\n             (d[r[((Sint16)(Sint8)((*p & 0x000000FF)     ))+128]]     ) ;\n#else\n        *p = (d[r[((Sint16)(Sint8)((*p & 0xFF000000) >> 24))+128]] << 24) |\n             (d[l[((Sint16)(Sint8)((*p & 0x00FF0000) >> 16))+128]] << 16) |\n             (d[r[((Sint16)(Sint8)((*p & 0x0000FF00) >>  8))+128]] <<  8) |\n             (d[l[((Sint16)(Sint8)((*p & 0x000000FF)     ))+128]]     ) ;\n#endif\n        ++p;\n    }\n\n\n}\n\n\n/* !!! FIXME : Optimize the code for 16-bit samples? */\n\nstatic void SDLCALL _Eff_position_u16lsb(int chan, void *stream, int len, void *udata)\n{\n    volatile position_args *args = (volatile position_args *) udata;\n    Uint16 *ptr = (Uint16 *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (Uint16) * 2) {\n        Sint16 sampl = (Sint16) (SDL_SwapLE16(*(ptr+0)) - 32768);\n        Sint16 sampr = (Sint16) (SDL_SwapLE16(*(ptr+1)) - 32768);\n\n        Uint16 swapl = (Uint16) ((Sint16) (((float) sampl * args->left_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swapr = (Uint16) ((Sint16) (((float) sampr * args->right_f)\n                                    * args->distance_f) + 32768);\n\n    if (args->room_angle == 180) {\n            *(ptr++) = (Uint16) SDL_SwapLE16(swapr);\n            *(ptr++) = (Uint16) SDL_SwapLE16(swapl);\n    }\n    else {\n            *(ptr++) = (Uint16) SDL_SwapLE16(swapl);\n            *(ptr++) = (Uint16) SDL_SwapLE16(swapr);\n    }\n    }\n}\nstatic void SDLCALL _Eff_position_u16lsb_c4(int chan, void *stream, int len, void *udata)\n{\n    volatile position_args *args = (volatile position_args *) udata;\n    Uint16 *ptr = (Uint16 *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (Uint16) * 4) {\n        Sint16 sampl = (Sint16) (SDL_SwapLE16(*(ptr+0)) - 32768);\n        Sint16 sampr = (Sint16) (SDL_SwapLE16(*(ptr+1)) - 32768);\n        Sint16 samplr = (Sint16) (SDL_SwapLE16(*(ptr+2)) - 32768);\n        Sint16 samprr = (Sint16) (SDL_SwapLE16(*(ptr+3)) - 32768);\n\n        Uint16 swapl = (Uint16) ((Sint16) (((float) sampl * args->left_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swapr = (Uint16) ((Sint16) (((float) sampr * args->right_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swaplr = (Uint16) ((Sint16) (((float) samplr * args->left_rear_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swaprr = (Uint16) ((Sint16) (((float) samprr * args->right_rear_f)\n                                    * args->distance_f) + 32768);\n\n    switch (args->room_angle) {\n        case 0:\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapl);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaplr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaprr);\n            break;\n        case 90:\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaprr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapl);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaplr);\n            break;\n        case 180:\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaprr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaplr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapl);\n            break;\n        case 270:\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaplr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapl);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaprr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapr);\n            break;\n    }\n    }\n}\nstatic void SDLCALL _Eff_position_u16lsb_c6(int chan, void *stream, int len, void *udata)\n{\n    volatile position_args *args = (volatile position_args *) udata;\n    Uint16 *ptr = (Uint16 *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (Uint16) * 6) {\n        Sint16 sampl = (Sint16) (SDL_SwapLE16(*(ptr+0)) - 32768);\n        Sint16 sampr = (Sint16) (SDL_SwapLE16(*(ptr+1)) - 32768);\n        Sint16 samplr = (Sint16) (SDL_SwapLE16(*(ptr+2)) - 32768);\n        Sint16 samprr = (Sint16) (SDL_SwapLE16(*(ptr+3)) - 32768);\n        Sint16 sampce = (Sint16) (SDL_SwapLE16(*(ptr+4)) - 32768);\n        Sint16 sampwf = (Sint16) (SDL_SwapLE16(*(ptr+5)) - 32768);\n\n        Uint16 swapl = (Uint16) ((Sint16) (((float) sampl * args->left_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swapr = (Uint16) ((Sint16) (((float) sampr * args->right_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swaplr = (Uint16) ((Sint16) (((float) samplr * args->left_rear_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swaprr = (Uint16) ((Sint16) (((float) samprr * args->right_rear_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swapce = (Uint16) ((Sint16) (((float) sampce * args->center_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swapwf = (Uint16) ((Sint16) (((float) sampwf * args->lfe_f)\n                                    * args->distance_f) + 32768);\n\n    switch (args->room_angle) {\n        case 0:\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapl);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaplr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaprr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapce);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapwf);\n            break;\n        case 90:\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaprr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapl);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaplr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapr)/2 + (Uint16) SDL_SwapLE16(swaprr)/2;\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapwf);\n            break;\n        case 180:\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaprr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaplr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapl);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaprr)/2 + (Uint16) SDL_SwapLE16(swaplr)/2;\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapwf);\n            break;\n        case 270:\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaplr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapl);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swaprr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapr);\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapl)/2 + (Uint16) SDL_SwapLE16(swaplr)/2;\n                *(ptr++) = (Uint16) SDL_SwapLE16(swapwf);\n            break;\n    }\n    }\n}\n\nstatic void SDLCALL _Eff_position_s16lsb(int chan, void *stream, int len, void *udata)\n{\n    /* 16 signed bits (lsb) * 2 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    Sint16 *ptr = (Sint16 *) stream;\n    int i;\n\n#if 0\n    if (len % (sizeof(Sint16) * 2)) {\n        fprintf(stderr,\"Not an even number of frames! len=%d\\n\", len);\n        return;\n    }\n#endif\n\n    for (i = 0; i < len; i += sizeof (Sint16) * 2) {\n        Sint16 swapl = (Sint16) ((((float) (Sint16) SDL_SwapLE16(*(ptr+0))) *\n                                    args->left_f) * args->distance_f);\n        Sint16 swapr = (Sint16) ((((float) (Sint16) SDL_SwapLE16(*(ptr+1))) *\n                                    args->right_f) * args->distance_f);\n    if (args->room_angle == 180) {\n            *(ptr++) = (Sint16) SDL_SwapLE16(swapr);\n            *(ptr++) = (Sint16) SDL_SwapLE16(swapl);\n    }\n    else {\n            *(ptr++) = (Sint16) SDL_SwapLE16(swapl);\n            *(ptr++) = (Sint16) SDL_SwapLE16(swapr);\n    }\n    }\n}\nstatic void SDLCALL _Eff_position_s16lsb_c4(int chan, void *stream, int len, void *udata)\n{\n    /* 16 signed bits (lsb) * 4 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    Sint16 *ptr = (Sint16 *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (Sint16) * 4) {\n        Sint16 swapl = (Sint16) ((((float) (Sint16) SDL_SwapLE16(*(ptr+0))) *\n                                    args->left_f) * args->distance_f);\n        Sint16 swapr = (Sint16) ((((float) (Sint16) SDL_SwapLE16(*(ptr+1))) *\n                                    args->right_f) * args->distance_f);\n        Sint16 swaplr = (Sint16) ((((float) (Sint16) SDL_SwapLE16(*(ptr+1))) *\n                                    args->left_rear_f) * args->distance_f);\n        Sint16 swaprr = (Sint16) ((((float) (Sint16) SDL_SwapLE16(*(ptr+2))) *\n                                    args->right_rear_f) * args->distance_f);\n    switch (args->room_angle) {\n        case 0:\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapl);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaplr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaprr);\n            break;\n        case 90:\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaprr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapl);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaplr);\n            break;\n        case 180:\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaprr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaplr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapl);\n            break;\n        case 270:\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaplr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapl);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaprr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapr);\n            break;\n    }\n    }\n}\n\nstatic void SDLCALL _Eff_position_s16lsb_c6(int chan, void *stream, int len, void *udata)\n{\n    /* 16 signed bits (lsb) * 6 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    Sint16 *ptr = (Sint16 *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (Sint16) * 6) {\n        Sint16 swapl = (Sint16) ((((float) (Sint16) SDL_SwapLE16(*(ptr+0))) *\n                                    args->left_f) * args->distance_f);\n        Sint16 swapr = (Sint16) ((((float) (Sint16) SDL_SwapLE16(*(ptr+1))) *\n                                    args->right_f) * args->distance_f);\n        Sint16 swaplr = (Sint16) ((((float) (Sint16) SDL_SwapLE16(*(ptr+2))) *\n                                    args->left_rear_f) * args->distance_f);\n        Sint16 swaprr = (Sint16) ((((float) (Sint16) SDL_SwapLE16(*(ptr+3))) *\n                                    args->right_rear_f) * args->distance_f);\n        Sint16 swapce = (Sint16) ((((float) (Sint16) SDL_SwapLE16(*(ptr+4))) *\n                                    args->center_f) * args->distance_f);\n        Sint16 swapwf = (Sint16) ((((float) (Sint16) SDL_SwapLE16(*(ptr+5))) *\n                                    args->lfe_f) * args->distance_f);\n    switch (args->room_angle) {\n        case 0:\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapl);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaplr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaprr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapce);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapwf);\n            break;\n        case 90:\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaprr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapl);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaplr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapr)/2 + (Sint16) SDL_SwapLE16(swaprr)/2;\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapwf);\n            break;\n        case 180:\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaprr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaplr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapl);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaprr)/2 + (Sint16) SDL_SwapLE16(swaplr)/2;\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapwf);\n            break;\n        case 270:\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaplr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapl);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swaprr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapr);\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapl)/2 + (Sint16) SDL_SwapLE16(swaplr)/2;\n                *(ptr++) = (Sint16) SDL_SwapLE16(swapwf);\n            break;\n    }\n    }\n}\n\nstatic void SDLCALL _Eff_position_u16msb(int chan, void *stream, int len, void *udata)\n{\n    /* 16 signed bits (lsb) * 2 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    Uint16 *ptr = (Uint16 *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (Sint16) * 2) {\n        Sint16 sampl = (Sint16) (SDL_SwapBE16(*(ptr+0)) - 32768);\n        Sint16 sampr = (Sint16) (SDL_SwapBE16(*(ptr+1)) - 32768);\n\n        Uint16 swapl = (Uint16) ((Sint16) (((float) sampl * args->left_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swapr = (Uint16) ((Sint16) (((float) sampr * args->right_f)\n                                    * args->distance_f) + 32768);\n\n    if (args->room_angle == 180) {\n            *(ptr++) = (Uint16) SDL_SwapBE16(swapr);\n            *(ptr++) = (Uint16) SDL_SwapBE16(swapl);\n    }\n    else {\n            *(ptr++) = (Uint16) SDL_SwapBE16(swapl);\n            *(ptr++) = (Uint16) SDL_SwapBE16(swapr);\n    }\n    }\n}\nstatic void SDLCALL _Eff_position_u16msb_c4(int chan, void *stream, int len, void *udata)\n{\n    /* 16 signed bits (lsb) * 4 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    Uint16 *ptr = (Uint16 *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (Sint16) * 4) {\n        Sint16 sampl = (Sint16) (SDL_SwapBE16(*(ptr+0)) - 32768);\n        Sint16 sampr = (Sint16) (SDL_SwapBE16(*(ptr+1)) - 32768);\n        Sint16 samplr = (Sint16) (SDL_SwapBE16(*(ptr+2)) - 32768);\n        Sint16 samprr = (Sint16) (SDL_SwapBE16(*(ptr+3)) - 32768);\n\n        Uint16 swapl = (Uint16) ((Sint16) (((float) sampl * args->left_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swapr = (Uint16) ((Sint16) (((float) sampr * args->right_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swaplr = (Uint16) ((Sint16) (((float) samplr * args->left_rear_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swaprr = (Uint16) ((Sint16) (((float) samprr * args->right_rear_f)\n                                    * args->distance_f) + 32768);\n\n    switch (args->room_angle) {\n        case 0:\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapl);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaplr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaprr);\n            break;\n        case 90:\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaprr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapl);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaplr);\n            break;\n        case 180:\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaprr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaplr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapl);\n            break;\n        case 270:\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaplr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapl);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaprr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapr);\n            break;\n    }\n    }\n}\nstatic void SDLCALL _Eff_position_u16msb_c6(int chan, void *stream, int len, void *udata)\n{\n    /* 16 signed bits (lsb) * 6 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    Uint16 *ptr = (Uint16 *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (Sint16) * 6) {\n        Sint16 sampl = (Sint16) (SDL_SwapBE16(*(ptr+0)) - 32768);\n        Sint16 sampr = (Sint16) (SDL_SwapBE16(*(ptr+1)) - 32768);\n        Sint16 samplr = (Sint16) (SDL_SwapBE16(*(ptr+2)) - 32768);\n        Sint16 samprr = (Sint16) (SDL_SwapBE16(*(ptr+3)) - 32768);\n        Sint16 sampce = (Sint16) (SDL_SwapBE16(*(ptr+4)) - 32768);\n        Sint16 sampwf = (Sint16) (SDL_SwapBE16(*(ptr+5)) - 32768);\n\n        Uint16 swapl = (Uint16) ((Sint16) (((float) sampl * args->left_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swapr = (Uint16) ((Sint16) (((float) sampr * args->right_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swaplr = (Uint16) ((Sint16) (((float) samplr * args->left_rear_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swaprr = (Uint16) ((Sint16) (((float) samprr * args->right_rear_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swapce = (Uint16) ((Sint16) (((float) sampce * args->center_f)\n                                    * args->distance_f) + 32768);\n        Uint16 swapwf = (Uint16) ((Sint16) (((float) sampwf * args->lfe_f)\n                                    * args->distance_f) + 32768);\n\n    switch (args->room_angle) {\n        case 0:\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapl);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaplr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaprr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapce);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapwf);\n            break;\n        case 90:\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaprr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapl);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaplr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapr)/2 + (Uint16) SDL_SwapBE16(swaprr)/2;\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapwf);\n            break;\n        case 180:\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaprr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaplr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapl);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaprr)/2 + (Uint16) SDL_SwapBE16(swaplr)/2;\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapwf);\n            break;\n        case 270:\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaplr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapl);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swaprr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapr);\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapl)/2 + (Uint16) SDL_SwapBE16(swaplr)/2;\n                *(ptr++) = (Uint16) SDL_SwapBE16(swapwf);\n            break;\n    }\n    }\n}\n\nstatic void SDLCALL _Eff_position_s16msb(int chan, void *stream, int len, void *udata)\n{\n    /* 16 signed bits (lsb) * 2 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    Sint16 *ptr = (Sint16 *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (Sint16) * 2) {\n        Sint16 swapl = (Sint16) ((((float) (Sint16) SDL_SwapBE16(*(ptr+0))) *\n                                    args->left_f) * args->distance_f);\n        Sint16 swapr = (Sint16) ((((float) (Sint16) SDL_SwapBE16(*(ptr+1))) *\n                                    args->right_f) * args->distance_f);\n        *(ptr++) = (Sint16) SDL_SwapBE16(swapl);\n        *(ptr++) = (Sint16) SDL_SwapBE16(swapr);\n    }\n}\nstatic void SDLCALL _Eff_position_s16msb_c4(int chan, void *stream, int len, void *udata)\n{\n    /* 16 signed bits (lsb) * 4 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    Sint16 *ptr = (Sint16 *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (Sint16) * 4) {\n        Sint16 swapl = (Sint16) ((((float) (Sint16) SDL_SwapBE16(*(ptr+0))) *\n                                    args->left_f) * args->distance_f);\n        Sint16 swapr = (Sint16) ((((float) (Sint16) SDL_SwapBE16(*(ptr+1))) *\n                                    args->right_f) * args->distance_f);\n        Sint16 swaplr = (Sint16) ((((float) (Sint16) SDL_SwapBE16(*(ptr+2))) *\n                                    args->left_rear_f) * args->distance_f);\n        Sint16 swaprr = (Sint16) ((((float) (Sint16) SDL_SwapBE16(*(ptr+3))) *\n                                    args->right_rear_f) * args->distance_f);\n    switch (args->room_angle) {\n        case 0:\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapl);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaplr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaprr);\n            break;\n        case 90:\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaprr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapl);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaplr);\n            break;\n        case 180:\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaprr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaplr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapl);\n            break;\n        case 270:\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaplr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapl);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaprr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapr);\n            break;\n    }\n    }\n}\nstatic void SDLCALL _Eff_position_s16msb_c6(int chan, void *stream, int len, void *udata)\n{\n    /* 16 signed bits (lsb) * 6 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    Sint16 *ptr = (Sint16 *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (Sint16) * 6) {\n        Sint16 swapl = (Sint16) ((((float) (Sint16) SDL_SwapBE16(*(ptr+0))) *\n                                    args->left_f) * args->distance_f);\n        Sint16 swapr = (Sint16) ((((float) (Sint16) SDL_SwapBE16(*(ptr+1))) *\n                                    args->right_f) * args->distance_f);\n        Sint16 swaplr = (Sint16) ((((float) (Sint16) SDL_SwapBE16(*(ptr+2))) *\n                                    args->left_rear_f) * args->distance_f);\n        Sint16 swaprr = (Sint16) ((((float) (Sint16) SDL_SwapBE16(*(ptr+3))) *\n                                    args->right_rear_f) * args->distance_f);\n        Sint16 swapce = (Sint16) ((((float) (Sint16) SDL_SwapBE16(*(ptr+4))) *\n                                    args->center_f) * args->distance_f);\n        Sint16 swapwf = (Sint16) ((((float) (Sint16) SDL_SwapBE16(*(ptr+5))) *\n                                    args->lfe_f) * args->distance_f);\n\n    switch (args->room_angle) {\n        case 0:\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapl);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaplr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaprr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapce);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapwf);\n            break;\n        case 90:\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaprr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapl);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaplr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapr)/2 + (Sint16) SDL_SwapBE16(swaprr)/2;\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapwf);\n            break;\n        case 180:\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaprr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaplr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapl);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaprr)/2 + (Sint16) SDL_SwapBE16(swaplr)/2;\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapwf);\n            break;\n        case 270:\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaplr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapl);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swaprr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapr);\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapl)/2 + (Sint16) SDL_SwapBE16(swaplr)/2;\n                *(ptr++) = (Sint16) SDL_SwapBE16(swapwf);\n            break;\n    }\n    }\n}\n\nstatic void SDLCALL _Eff_position_s32lsb(int chan, void *stream, int len, void *udata)\n{\n    /* 32 signed bits (lsb) * 2 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    Sint32 *ptr = (Sint32 *) stream;\n    int i;\n\n#if 0\n    if (len % (sizeof(Sint32) * 2)) {\n        fprintf(stderr,\"Not an even number of frames! len=%d\\n\", len);\n        return;\n    }\n#endif\n\n    for (i = 0; i < len; i += sizeof (Sint32) * 2) {\n        Sint32 swapl = (Sint32) ((((float) (Sint32) SDL_SwapLE32(*(ptr+0))) *\n                                    args->left_f) * args->distance_f);\n        Sint32 swapr = (Sint32) ((((float) (Sint32) SDL_SwapLE32(*(ptr+1))) *\n                                    args->right_f) * args->distance_f);\n    if (args->room_angle == 180) {\n            *(ptr++) = (Sint32) SDL_SwapLE32(swapr);\n            *(ptr++) = (Sint32) SDL_SwapLE32(swapl);\n    }\n    else {\n            *(ptr++) = (Sint32) SDL_SwapLE32(swapl);\n            *(ptr++) = (Sint32) SDL_SwapLE32(swapr);\n    }\n    }\n}\nstatic void SDLCALL _Eff_position_s32lsb_c4(int chan, void *stream, int len, void *udata)\n{\n    /* 32 signed bits (lsb) * 4 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    Sint32 *ptr = (Sint32 *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (Sint32) * 4) {\n        Sint32 swapl = (Sint32) ((((float) (Sint32) SDL_SwapLE32(*(ptr+0))) *\n                                    args->left_f) * args->distance_f);\n        Sint32 swapr = (Sint32) ((((float) (Sint32) SDL_SwapLE32(*(ptr+1))) *\n                                    args->right_f) * args->distance_f);\n        Sint32 swaplr = (Sint32) ((((float) (Sint32) SDL_SwapLE32(*(ptr+1))) *\n                                    args->left_rear_f) * args->distance_f);\n        Sint32 swaprr = (Sint32) ((((float) (Sint32) SDL_SwapLE32(*(ptr+2))) *\n                                    args->right_rear_f) * args->distance_f);\n    switch (args->room_angle) {\n        case 0:\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapl);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaplr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaprr);\n            break;\n        case 90:\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaprr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapl);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaplr);\n            break;\n        case 180:\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaprr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaplr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapl);\n            break;\n        case 270:\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaplr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapl);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaprr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapr);\n            break;\n    }\n    }\n}\n\nstatic void SDLCALL _Eff_position_s32lsb_c6(int chan, void *stream, int len, void *udata)\n{\n    /* 32 signed bits (lsb) * 6 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    Sint32 *ptr = (Sint32 *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (Sint32) * 6) {\n        Sint32 swapl = (Sint32) ((((float) (Sint32) SDL_SwapLE32(*(ptr+0))) *\n                                    args->left_f) * args->distance_f);\n        Sint32 swapr = (Sint32) ((((float) (Sint32) SDL_SwapLE32(*(ptr+1))) *\n                                    args->right_f) * args->distance_f);\n        Sint32 swaplr = (Sint32) ((((float) (Sint32) SDL_SwapLE32(*(ptr+2))) *\n                                    args->left_rear_f) * args->distance_f);\n        Sint32 swaprr = (Sint32) ((((float) (Sint32) SDL_SwapLE32(*(ptr+3))) *\n                                    args->right_rear_f) * args->distance_f);\n        Sint32 swapce = (Sint32) ((((float) (Sint32) SDL_SwapLE32(*(ptr+4))) *\n                                    args->center_f) * args->distance_f);\n        Sint32 swapwf = (Sint32) ((((float) (Sint32) SDL_SwapLE32(*(ptr+5))) *\n                                    args->lfe_f) * args->distance_f);\n    switch (args->room_angle) {\n        case 0:\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapl);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaplr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaprr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapce);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapwf);\n            break;\n        case 90:\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaprr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapl);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaplr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapr)/2 + (Sint32) SDL_SwapLE32(swaprr)/2;\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapwf);\n            break;\n        case 180:\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaprr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaplr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapl);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaprr)/2 + (Sint32) SDL_SwapLE32(swaplr)/2;\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapwf);\n            break;\n        case 270:\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaplr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapl);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swaprr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapr);\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapl)/2 + (Sint32) SDL_SwapLE32(swaplr)/2;\n                *(ptr++) = (Sint32) SDL_SwapLE32(swapwf);\n            break;\n    }\n    }\n}\n\nstatic void SDLCALL _Eff_position_s32msb(int chan, void *stream, int len, void *udata)\n{\n    /* 32 signed bits (lsb) * 2 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    Sint32 *ptr = (Sint32 *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (Sint32) * 2) {\n        Sint32 swapl = (Sint32) ((((float) (Sint32) SDL_SwapBE32(*(ptr+0))) *\n                                    args->left_f) * args->distance_f);\n        Sint32 swapr = (Sint32) ((((float) (Sint32) SDL_SwapBE32(*(ptr+1))) *\n                                    args->right_f) * args->distance_f);\n        *(ptr++) = (Sint32) SDL_SwapBE32(swapl);\n        *(ptr++) = (Sint32) SDL_SwapBE32(swapr);\n    }\n}\nstatic void SDLCALL _Eff_position_s32msb_c4(int chan, void *stream, int len, void *udata)\n{\n    /* 32 signed bits (lsb) * 4 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    Sint32 *ptr = (Sint32 *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (Sint32) * 4) {\n        Sint32 swapl = (Sint32) ((((float) (Sint32) SDL_SwapBE32(*(ptr+0))) *\n                                    args->left_f) * args->distance_f);\n        Sint32 swapr = (Sint32) ((((float) (Sint32) SDL_SwapBE32(*(ptr+1))) *\n                                    args->right_f) * args->distance_f);\n        Sint32 swaplr = (Sint32) ((((float) (Sint32) SDL_SwapBE32(*(ptr+2))) *\n                                    args->left_rear_f) * args->distance_f);\n        Sint32 swaprr = (Sint32) ((((float) (Sint32) SDL_SwapBE32(*(ptr+3))) *\n                                    args->right_rear_f) * args->distance_f);\n    switch (args->room_angle) {\n        case 0:\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapl);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaplr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaprr);\n            break;\n        case 90:\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaprr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapl);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaplr);\n            break;\n        case 180:\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaprr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaplr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapl);\n            break;\n        case 270:\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaplr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapl);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaprr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapr);\n            break;\n    }\n    }\n}\nstatic void SDLCALL _Eff_position_s32msb_c6(int chan, void *stream, int len, void *udata)\n{\n    /* 32 signed bits (lsb) * 6 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    Sint32 *ptr = (Sint32 *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (Sint32) * 6) {\n        Sint32 swapl = (Sint32) ((((float) (Sint32) SDL_SwapBE32(*(ptr+0))) *\n                                    args->left_f) * args->distance_f);\n        Sint32 swapr = (Sint32) ((((float) (Sint32) SDL_SwapBE32(*(ptr+1))) *\n                                    args->right_f) * args->distance_f);\n        Sint32 swaplr = (Sint32) ((((float) (Sint32) SDL_SwapBE32(*(ptr+2))) *\n                                    args->left_rear_f) * args->distance_f);\n        Sint32 swaprr = (Sint32) ((((float) (Sint32) SDL_SwapBE32(*(ptr+3))) *\n                                    args->right_rear_f) * args->distance_f);\n        Sint32 swapce = (Sint32) ((((float) (Sint32) SDL_SwapBE32(*(ptr+4))) *\n                                    args->center_f) * args->distance_f);\n        Sint32 swapwf = (Sint32) ((((float) (Sint32) SDL_SwapBE32(*(ptr+5))) *\n                                    args->lfe_f) * args->distance_f);\n\n    switch (args->room_angle) {\n        case 0:\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapl);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaplr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaprr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapce);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapwf);\n            break;\n        case 90:\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaprr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapl);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaplr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapr)/2 + (Sint32) SDL_SwapBE32(swaprr)/2;\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapwf);\n            break;\n        case 180:\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaprr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaplr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapl);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaprr)/2 + (Sint32) SDL_SwapBE32(swaplr)/2;\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapwf);\n            break;\n        case 270:\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaplr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapl);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swaprr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapr);\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapl)/2 + (Sint32) SDL_SwapBE32(swaplr)/2;\n                *(ptr++) = (Sint32) SDL_SwapBE32(swapwf);\n            break;\n    }\n    }\n}\n\nstatic void SDLCALL _Eff_position_f32sys(int chan, void *stream, int len, void *udata)\n{\n    /* float * 2 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    float *ptr = (float *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (float) * 2) {\n        float swapl = ((*(ptr+0) * args->left_f) * args->distance_f);\n        float swapr = ((*(ptr+1) * args->right_f) * args->distance_f);\n        *(ptr++) = swapl;\n        *(ptr++) = swapr;\n    }\n}\nstatic void SDLCALL _Eff_position_f32sys_c4(int chan, void *stream, int len, void *udata)\n{\n    /* float * 4 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    float *ptr = (float *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (float) * 4) {\n        float swapl = ((*(ptr+0) * args->left_f) * args->distance_f);\n        float swapr = ((*(ptr+1) * args->right_f) * args->distance_f);\n        float swaplr = ((*(ptr+2) * args->left_rear_f) * args->distance_f);\n        float swaprr = ((*(ptr+3) * args->right_rear_f) * args->distance_f);\n        switch (args->room_angle) {\n        case 0:\n                *(ptr++) = swapl;\n                *(ptr++) = swapr;\n                *(ptr++) = swaplr;\n                *(ptr++) = swaprr;\n            break;\n        case 90:\n                *(ptr++) = swapr;\n                *(ptr++) = swaprr;\n                *(ptr++) = swapl;\n                *(ptr++) = swaplr;\n            break;\n        case 180:\n                *(ptr++) = swaprr;\n                *(ptr++) = swaplr;\n                *(ptr++) = swapr;\n                *(ptr++) = swapl;\n            break;\n        case 270:\n                *(ptr++) = swaplr;\n                *(ptr++) = swapl;\n                *(ptr++) = swaprr;\n                *(ptr++) = swapr;\n            break;\n        }\n    }\n}\nstatic void SDLCALL _Eff_position_f32sys_c6(int chan, void *stream, int len, void *udata)\n{\n    /* float * 6 channels. */\n    volatile position_args *args = (volatile position_args *) udata;\n    float *ptr = (float *) stream;\n    int i;\n\n    for (i = 0; i < len; i += sizeof (float) * 6) {\n        float swapl = ((*(ptr+0) * args->left_f) * args->distance_f);\n        float swapr = ((*(ptr+1) * args->right_f) * args->distance_f);\n        float swaplr = ((*(ptr+2) * args->left_rear_f) * args->distance_f);\n        float swaprr = ((*(ptr+3) * args->right_rear_f) * args->distance_f);\n        float swapce = ((*(ptr+4) * args->center_f) * args->distance_f);\n        float swapwf = ((*(ptr+5) * args->lfe_f) * args->distance_f);\n\n    switch (args->room_angle) {\n        case 0:\n                *(ptr++) = swapl;\n                *(ptr++) = swapr;\n                *(ptr++) = swaplr;\n                *(ptr++) = swaprr;\n                *(ptr++) = swapce;\n                *(ptr++) = swapwf;\n            break;\n        case 90:\n                *(ptr++) = swapr;\n                *(ptr++) = swaprr;\n                *(ptr++) = swapl;\n                *(ptr++) = swaplr;\n                *(ptr++) = swapr/2.0f + swaprr/2.0f;\n                *(ptr++) = swapwf;\n            break;\n        case 180:\n                *(ptr++) = swaprr;\n                *(ptr++) = swaplr;\n                *(ptr++) = swapr;\n                *(ptr++) = swapl;\n                *(ptr++) = swaprr/2.0f + swaplr/2.0f;\n                *(ptr++) = swapwf;\n            break;\n        case 270:\n                *(ptr++) = swaplr;\n                *(ptr++) = swapl;\n                *(ptr++) = swaprr;\n                *(ptr++) = swapr;\n                *(ptr++) = swapl/2.0f + swaplr/2.0f;\n                *(ptr++) = swapwf;\n            break;\n    }\n    }\n}\n\nstatic void init_position_args(position_args *args)\n{\n    SDL_memset(args, '\\0', sizeof (position_args));\n    args->in_use = 0;\n    args->room_angle = 0;\n    args->left_u8 = args->right_u8 = args->distance_u8 = 255;\n    args->left_f  = args->right_f  = args->distance_f  = 1.0f;\n    args->left_rear_u8 = args->right_rear_u8 = args->center_u8 = args->lfe_u8 = 255;\n    args->left_rear_f = args->right_rear_f = args->center_f = args->lfe_f = 1.0f;\n    Mix_QuerySpec(NULL, NULL, (int *) &args->channels);\n}\n\n\nstatic position_args *get_position_arg(int channel)\n{\n    void *rc;\n    int i;\n\n    if (channel < 0) {\n        if (pos_args_global == NULL) {\n            pos_args_global = SDL_malloc(sizeof (position_args));\n            if (pos_args_global == NULL) {\n                Mix_SetError(\"Out of memory\");\n                return(NULL);\n            }\n            init_position_args(pos_args_global);\n        }\n\n        return(pos_args_global);\n    }\n\n    if (channel >= position_channels) {\n        rc = SDL_realloc(pos_args_array, (channel + 1) * sizeof (position_args *));\n        if (rc == NULL) {\n            Mix_SetError(\"Out of memory\");\n            return(NULL);\n        }\n        pos_args_array = (position_args **) rc;\n        for (i = position_channels; i <= channel; i++) {\n            pos_args_array[i] = NULL;\n        }\n        position_channels = channel + 1;\n    }\n\n    if (pos_args_array[channel] == NULL) {\n        pos_args_array[channel] = (position_args *)SDL_malloc(sizeof(position_args));\n        if (pos_args_array[channel] == NULL) {\n            Mix_SetError(\"Out of memory\");\n            return(NULL);\n        }\n        init_position_args(pos_args_array[channel]);\n    }\n\n    return(pos_args_array[channel]);\n}\n\n\nstatic Mix_EffectFunc_t get_position_effect_func(Uint16 format, int channels)\n{\n    Mix_EffectFunc_t f = NULL;\n\n    switch (format) {\n        case AUDIO_U8:\n        switch (channels) {\n            case 1:\n            case 2:\n                f = (_Eff_build_volume_table_u8()) ? _Eff_position_table_u8 :\n                                                        _Eff_position_u8;\n                break;\n            case 4:\n                f = _Eff_position_u8_c4;\n                break;\n            case 6:\n                f = _Eff_position_u8_c6;\n                break;\n            default:\n                Mix_SetError(\"Unsupported audio channels\");\n                break;\n        }\n        break;\n\n        case AUDIO_S8:\n        switch (channels) {\n            case 1:\n            case 2:\n                f = (_Eff_build_volume_table_s8()) ? _Eff_position_table_s8 :\n                                                        _Eff_position_s8;\n                break;\n            case 4:\n                f = _Eff_position_s8_c4;\n                break;\n            case 6:\n                f = _Eff_position_s8_c6;\n                break;\n            default:\n                Mix_SetError(\"Unsupported audio channels\");\n                break;\n        }\n        break;\n\n        case AUDIO_U16LSB:\n        switch (channels) {\n            case 1:\n            case 2:\n                f = _Eff_position_u16lsb;\n                break;\n            case 4:\n                f = _Eff_position_u16lsb_c4;\n                break;\n            case 6:\n                f = _Eff_position_u16lsb_c6;\n                break;\n            default:\n                Mix_SetError(\"Unsupported audio channels\");\n                break;\n        }\n        break;\n\n        case AUDIO_S16LSB:\n        switch (channels) {\n            case 1:\n            case 2:\n                f = _Eff_position_s16lsb;\n                break;\n            case 4:\n                f = _Eff_position_s16lsb_c4;\n                break;\n            case 6:\n                f = _Eff_position_s16lsb_c6;\n                break;\n            default:\n                Mix_SetError(\"Unsupported audio channels\");\n                break;\n        }\n        break;\n\n        case AUDIO_U16MSB:\n        switch (channels) {\n            case 1:\n            case 2:\n                f = _Eff_position_u16msb;\n                break;\n            case 4:\n                f = _Eff_position_u16msb_c4;\n                break;\n            case 6:\n                f = _Eff_position_u16msb_c6;\n                break;\n            default:\n                Mix_SetError(\"Unsupported audio channels\");\n                break;\n        }\n        break;\n\n        case AUDIO_S16MSB:\n        switch (channels) {\n            case 1:\n            case 2:\n                f = _Eff_position_s16msb;\n                break;\n            case 4:\n                f = _Eff_position_s16msb_c4;\n                break;\n            case 6:\n                f = _Eff_position_s16msb_c6;\n                break;\n            default:\n                Mix_SetError(\"Unsupported audio channels\");\n                break;\n        }\n        break;\n\n        case AUDIO_S32MSB:\n        switch (channels) {\n            case 1:\n            case 2:\n                f = _Eff_position_s32msb;\n                break;\n            case 4:\n                f = _Eff_position_s32msb_c4;\n                break;\n            case 6:\n                f = _Eff_position_s32msb_c6;\n                break;\n            default:\n                Mix_SetError(\"Unsupported audio channels\");\n                break;\n        }\n        break;\n\n        case AUDIO_S32LSB:\n        switch (channels) {\n            case 1:\n            case 2:\n                f = _Eff_position_s32lsb;\n                break;\n            case 4:\n                f = _Eff_position_s32lsb_c4;\n                break;\n            case 6:\n                f = _Eff_position_s32lsb_c6;\n                break;\n            default:\n                Mix_SetError(\"Unsupported audio channels\");\n                break;\n        }\n        break;\n\n        case AUDIO_F32SYS:\n        switch (channels) {\n            case 1:\n            case 2:\n                f = _Eff_position_f32sys;\n                break;\n            case 4:\n                f = _Eff_position_f32sys_c4;\n                break;\n            case 6:\n                f = _Eff_position_f32sys_c6;\n                break;\n            default:\n                Mix_SetError(\"Unsupported audio channels\");\n                break;\n        }\n        break;\n\n        default:\n            Mix_SetError(\"Unsupported audio format\");\n            break;\n    }\n\n    return(f);\n}\n\nstatic Uint8 speaker_amplitude[6];\n\nstatic void set_amplitudes(int channels, int angle, int room_angle)\n{\n    int left = 255, right = 255;\n    int left_rear = 255, right_rear = 255, center = 255;\n\n    angle = SDL_abs(angle) % 360;  /* make angle between 0 and 359. */\n\n    if (channels == 2)\n    {\n        /*\n         * We only attenuate by position if the angle falls on the far side\n         *  of center; That is, an angle that's due north would not attenuate\n         *  either channel. Due west attenuates the right channel to 0.0, and\n         *  due east attenuates the left channel to 0.0. Slightly east of\n         *  center attenuates the left channel a little, and the right channel\n         *  not at all. I think of this as occlusion by one's own head.  :)\n         *\n         *   ...so, we split our angle circle into four quadrants...\n         */\n        if (angle < 90) {\n            left = 255 - ((int) (255.0f * (((float) angle) / 89.0f)));\n        } else if (angle < 180) {\n            left = (int) (255.0f * (((float) (angle - 90)) / 89.0f));\n        } else if (angle < 270) {\n            right = 255 - ((int) (255.0f * (((float) (angle - 180)) / 89.0f)));\n        } else {\n            right = (int) (255.0f * (((float) (angle - 270)) / 89.0f));\n        }\n    }\n\n    if (channels == 4 || channels == 6)\n    {\n        /*\n         *  An angle that's due north does not attenuate the center channel.\n         *  An angle in the first quadrant, 0-90, does not attenuate the RF.\n         *\n         *   ...so, we split our angle circle into 8 ...\n         *\n         *             CE\n         *             0\n         *     LF      |         RF\n         *             |\n         *  270<-------|----------->90\n         *             |\n         *     LR      |         RR\n         *            180\n         *\n         */\n        if (angle < 45) {\n            left = ((int) (255.0f * (((float) (180 - angle)) / 179.0f)));\n            left_rear = 255 - ((int) (255.0f * (((float) (angle + 45)) / 89.0f)));\n            right_rear = 255 - ((int) (255.0f * (((float) (90 - angle)) / 179.0f)));\n        } else if (angle < 90) {\n            center = ((int) (255.0f * (((float) (225 - angle)) / 179.0f)));\n            left = ((int) (255.0f * (((float) (180 - angle)) / 179.0f)));\n            left_rear = 255 - ((int) (255.0f * (((float) (135 - angle)) / 89.0f)));\n            right_rear = ((int) (255.0f * (((float) (90 + angle)) / 179.0f)));\n        } else if (angle < 135) {\n            center = ((int) (255.0f * (((float) (225 - angle)) / 179.0f)));\n            left = 255 - ((int) (255.0f * (((float) (angle - 45)) / 89.0f)));\n            right = ((int) (255.0f * (((float) (270 - angle)) / 179.0f)));\n            left_rear = ((int) (255.0f * (((float) (angle)) / 179.0f)));\n        } else if (angle < 180) {\n            center = 255 - ((int) (255.0f * (((float) (angle - 90)) / 89.0f)));\n            left = 255 - ((int) (255.0f * (((float) (225 - angle)) / 89.0f)));\n            right = ((int) (255.0f * (((float) (270 - angle)) / 179.0f)));\n            left_rear = ((int) (255.0f * (((float) (angle)) / 179.0f)));\n        } else if (angle < 225) {\n            center = 255 - ((int) (255.0f * (((float) (270 - angle)) / 89.0f)));\n            left = ((int) (255.0f * (((float) (angle - 90)) / 179.0f)));\n            right = 255 - ((int) (255.0f * (((float) (angle - 135)) / 89.0f)));\n            right_rear = ((int) (255.0f * (((float) (360 - angle)) / 179.0f)));\n        } else if (angle < 270) {\n            center = ((int) (255.0f * (((float) (angle - 135)) / 179.0f)));\n            left = ((int) (255.0f * (((float) (angle - 90)) / 179.0f)));\n            right = 255 - ((int) (255.0f * (((float) (315 - angle)) / 89.0f)));\n            right_rear = ((int) (255.0f * (((float) (360 - angle)) / 179.0f)));\n        } else if (angle < 315) {\n            center = ((int) (255.0f * (((float) (angle - 135)) / 179.0f)));\n            right = ((int) (255.0f * (((float) (angle - 180)) / 179.0f)));\n            left_rear = ((int) (255.0f * (((float) (450 - angle)) / 179.0f)));\n            right_rear = 255 - ((int) (255.0f * (((float) (angle - 225)) / 89.0f)));\n        } else {\n            right = ((int) (255.0f * (((float) (angle - 180)) / 179.0f)));\n            left_rear = ((int) (255.0f * (((float) (450 - angle)) / 179.0f)));\n            right_rear = 255 - ((int) (255.0f * (((float) (405 - angle)) / 89.0f)));\n        }\n    }\n\n    if (left < 0) left = 0; if (left > 255) left = 255;\n    if (right < 0) right = 0; if (right > 255) right = 255;\n    if (left_rear < 0) left_rear = 0; if (left_rear > 255) left_rear = 255;\n    if (right_rear < 0) right_rear = 0; if (right_rear > 255) right_rear = 255;\n    if (center < 0) center = 0; if (center > 255) center = 255;\n\n    if (room_angle == 90) {\n        speaker_amplitude[0] = (Uint8)left_rear;\n        speaker_amplitude[1] = (Uint8)left;\n        speaker_amplitude[2] = (Uint8)right_rear;\n        speaker_amplitude[3] = (Uint8)right;\n    }\n    else if (room_angle == 180) {\n    if (channels == 2) {\n            speaker_amplitude[0] = (Uint8)right;\n            speaker_amplitude[1] = (Uint8)left;\n    }\n    else {\n            speaker_amplitude[0] = (Uint8)right_rear;\n            speaker_amplitude[1] = (Uint8)left_rear;\n            speaker_amplitude[2] = (Uint8)right;\n            speaker_amplitude[3] = (Uint8)left;\n    }\n    }\n    else if (room_angle == 270) {\n        speaker_amplitude[0] = (Uint8)right;\n        speaker_amplitude[1] = (Uint8)right_rear;\n        speaker_amplitude[2] = (Uint8)left;\n        speaker_amplitude[3] = (Uint8)left_rear;\n    }\n    else {\n        speaker_amplitude[0] = (Uint8)left;\n        speaker_amplitude[1] = (Uint8)right;\n        speaker_amplitude[2] = (Uint8)left_rear;\n        speaker_amplitude[3] = (Uint8)right_rear;\n    }\n    speaker_amplitude[4] = (Uint8)center;\n    speaker_amplitude[5] = 255;\n}\n\nint Mix_SetPosition(int channel, Sint16 angle, Uint8 distance);\n\nint Mix_SetPanning(int channel, Uint8 left, Uint8 right)\n{\n    Mix_EffectFunc_t f = NULL;\n    int channels;\n    Uint16 format;\n    position_args *args = NULL;\n    int retval = 1;\n\n    Mix_QuerySpec(NULL, &format, &channels);\n\n    if (channels != 2 && channels != 4 && channels != 6)    /* it's a no-op; we call that successful. */\n        return(1);\n\n    if (channels > 2) {\n        /* left = right = 255 => angle = 0, to unregister effect as when channels = 2 */\n        /* left = 255 =>  angle = -90;  left = 0 => angle = +89 */\n        int angle = 0;\n        if ((left != 255) || (right != 255)) {\n        angle = (int)left;\n            angle = 127 - angle;\n        angle = -angle;\n            angle = angle * 90 / 128; /* Make it larger for more effect? */\n        }\n        return(Mix_SetPosition(channel, angle, 0));\n    }\n\n    f = get_position_effect_func(format, channels);\n    if (f == NULL)\n        return(0);\n\n    Mix_LockAudio();\n    args = get_position_arg(channel);\n    if (!args) {\n        Mix_UnlockAudio();\n        return(0);\n    }\n\n        /* it's a no-op; unregister the effect, if it's registered. */\n    if ((args->distance_u8 == 255) && (left == 255) && (right == 255)) {\n        if (args->in_use) {\n            retval = _Mix_UnregisterEffect_locked(channel, f);\n            Mix_UnlockAudio();\n            return(retval);\n        } else {\n            Mix_UnlockAudio();\n            return(1);\n        }\n    }\n\n    args->left_u8 = left;\n    args->left_f = ((float) left) / 255.0f;\n    args->right_u8 = right;\n    args->right_f = ((float) right) / 255.0f;\n    args->room_angle = 0;\n\n    if (!args->in_use) {\n        args->in_use = 1;\n        retval=_Mix_RegisterEffect_locked(channel, f, _Eff_PositionDone, (void*)args);\n    }\n\n    Mix_UnlockAudio();\n    return(retval);\n}\n\n\nint Mix_SetDistance(int channel, Uint8 distance)\n{\n    Mix_EffectFunc_t f = NULL;\n    Uint16 format;\n    position_args *args = NULL;\n    int channels;\n    int retval = 1;\n\n    Mix_QuerySpec(NULL, &format, &channels);\n    f = get_position_effect_func(format, channels);\n    if (f == NULL)\n        return(0);\n\n    Mix_LockAudio();\n    args = get_position_arg(channel);\n    if (!args) {\n        Mix_UnlockAudio();\n        return(0);\n    }\n\n    distance = 255 - distance;  /* flip it to our scale. */\n\n        /* it's a no-op; unregister the effect, if it's registered. */\n    if ((distance == 255) && (args->left_u8 == 255) && (args->right_u8 == 255)) {\n        if (args->in_use) {\n            retval = _Mix_UnregisterEffect_locked(channel, f);\n            Mix_UnlockAudio();\n            return(retval);\n        } else {\n            Mix_UnlockAudio();\n            return(1);\n        }\n    }\n\n    args->distance_u8 = distance;\n    args->distance_f = ((float) distance) / 255.0f;\n    if (!args->in_use) {\n        args->in_use = 1;\n        retval = _Mix_RegisterEffect_locked(channel, f, _Eff_PositionDone, (void *) args);\n    }\n\n    Mix_UnlockAudio();\n    return(retval);\n}\n\n\nint Mix_SetPosition(int channel, Sint16 angle, Uint8 distance)\n{\n    Mix_EffectFunc_t f = NULL;\n    Uint16 format;\n    int channels;\n    position_args *args = NULL;\n    Sint16 room_angle = 0;\n    int retval = 1;\n\n    Mix_QuerySpec(NULL, &format, &channels);\n    f = get_position_effect_func(format, channels);\n    if (f == NULL)\n        return(0);\n\n    angle = SDL_abs(angle) % 360;  /* make angle between 0 and 359. */\n\n    Mix_LockAudio();\n    args = get_position_arg(channel);\n    if (!args) {\n        Mix_UnlockAudio();\n        return(0);\n    }\n\n        /* it's a no-op; unregister the effect, if it's registered. */\n    if ((!distance) && (!angle)) {\n        if (args->in_use) {\n            retval = _Mix_UnregisterEffect_locked(channel, f);\n            Mix_UnlockAudio();\n            return(retval);\n        } else {\n            Mix_UnlockAudio();\n            return(1);\n        }\n    }\n\n    if (channels == 2)\n    {\n    if (angle > 180)\n        room_angle = 180; /* exchange left and right channels */\n    else room_angle = 0;\n    }\n\n    if (channels == 4 || channels == 6)\n    {\n    if (angle > 315) room_angle = 0;\n    else if (angle > 225) room_angle = 270;\n    else if (angle > 135) room_angle = 180;\n    else if (angle > 45) room_angle = 90;\n    else room_angle = 0;\n    }\n\n\n    distance = 255 - distance;  /* flip it to scale Mix_SetDistance() uses. */\n\n    set_amplitudes(channels, angle, room_angle);\n\n    args->left_u8 = speaker_amplitude[0];\n    args->left_f = ((float) speaker_amplitude[0]) / 255.0f;\n    args->right_u8 = speaker_amplitude[1];\n    args->right_f = ((float) speaker_amplitude[1]) / 255.0f;\n    args->left_rear_u8 = speaker_amplitude[2];\n    args->left_rear_f = ((float) speaker_amplitude[2]) / 255.0f;\n    args->right_rear_u8 = speaker_amplitude[3];\n    args->right_rear_f = ((float) speaker_amplitude[3]) / 255.0f;\n    args->center_u8 = speaker_amplitude[4];\n    args->center_f = ((float) speaker_amplitude[4]) / 255.0f;\n    args->lfe_u8 = speaker_amplitude[5];\n    args->lfe_f = ((float) speaker_amplitude[5]) / 255.0f;\n    args->distance_u8 = distance;\n    args->distance_f = ((float) distance) / 255.0f;\n    args->room_angle = room_angle;\n    if (!args->in_use) {\n        args->in_use = 1;\n        retval = _Mix_RegisterEffect_locked(channel, f, _Eff_PositionDone, (void *) args);\n    }\n\n    Mix_UnlockAudio();\n    return(retval);\n}\n\n\n/* end of effects_position.c ... */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:  Heads-up displays\n//\n\n\n#include <ctype.h>\n\n#include \"doomdef.h\"\n#include \"doomkeys.h\"\n\n#include \"z_zone.h\"\n\n#include \"deh_main.h\"\n#include \"i_input.h\"\n#include \"i_swap.h\"\n#include \"i_video.h\"\n\n#include \"hu_stuff.h\"\n#include \"hu_lib.h\"\n#include \"m_controls.h\"\n#include \"m_misc.h\"\n#include \"w_wad.h\"\n#include \"m_argv.h\" // [crispy] M_ParmExists()\n#include \"st_stuff.h\" // [crispy] ST_HEIGHT\n#include \"p_setup.h\" // maplumpinfo\n\n#include \"s_sound.h\"\n\n#include \"doomstat.h\"\n\n// Data.\n#include \"dstrings.h\"\n#include \"sounds.h\"\n\n#include \"v_video.h\" // [crispy] V_DrawPatch() et al.\n\n#include <emscripten.h>\n\n//\n// Locally used constants, shortcuts.\n//\n#define HU_TITLE\t(mapnames[(gameepisode-1)*9+gamemap-1])\n#define HU_TITLE2\t(mapnames_commercial[gamemap-1])\n#define HU_TITLEP\t(mapnames_commercial[gamemap-1 + 32])\n#define HU_TITLET\t(mapnames_commercial[gamemap-1 + 64])\n#define HU_TITLEN\t(mapnames_commercial[gamemap-1 + 96 + 3])\n#define HU_TITLEM\t(mapnames_commercial[gamemap-1 + 105 + 3])\n#define HU_TITLE_CHEX   (mapnames_chex[(gameepisode-1)*9+gamemap-1])\n#define HU_TITLEHEIGHT\t1\n#define HU_TITLEX\t0\n#define HU_TITLEY\t(167 - SHORT(hu_font[0]->height))\n\n#define HU_INPUTTOGGLE\t't'\n#define HU_INPUTX\tHU_MSGX\n#define HU_INPUTY\t(HU_MSGY + HU_MSGHEIGHT*(SHORT(hu_font[0]->height) +1))\n#define HU_INPUTWIDTH\t64\n#define HU_INPUTHEIGHT\t1\n\n#define HU_COORDX\t(ORIGWIDTH - 7 * hu_font['A'-HU_FONTSTART]->width)\n\nchar *chat_macros[10] =\n{\n    HUSTR_CHATMACRO0,\n    HUSTR_CHATMACRO1,\n    HUSTR_CHATMACRO2,\n    HUSTR_CHATMACRO3,\n    HUSTR_CHATMACRO4,\n    HUSTR_CHATMACRO5,\n    HUSTR_CHATMACRO6,\n    HUSTR_CHATMACRO7,\n    HUSTR_CHATMACRO8,\n    HUSTR_CHATMACRO9\n};\n\nchar*\tplayer_names[] =\n{\n    HUSTR_PLRGREEN,\n    HUSTR_PLRINDIGO,\n    HUSTR_PLRBROWN,\n    HUSTR_PLRRED\n};\n\nchar\t\t\tchat_char; // remove later.\nstatic player_t*\tplr;\npatch_t*\t\thu_font[HU_FONTSIZE];\nstatic hu_textline_t\tw_title;\nboolean\t\t\tchat_on;\nstatic hu_itext_t\tw_chat;\nstatic boolean\t\talways_off = false;\nstatic char\t\tchat_dest[MAXPLAYERS];\nstatic hu_itext_t w_inputbuffer[MAXPLAYERS];\n\nstatic boolean\t\tmessage_on;\nboolean\t\t\tmessage_dontfuckwithme;\nstatic boolean\t\tmessage_nottobefuckedwith;\n\nstatic hu_stext_t\tw_message;\nstatic int\t\tmessage_counter;\n\nextern int\t\tshowMessages;\n\nstatic boolean\t\theadsupactive = false;\n\n//\n// Builtin map names.\n// The actual names can be found in DStrings.h.\n//\n\nchar*\tmapnames[] =\t// DOOM shareware/registered/retail (Ultimate) names.\n{\n\n    HUSTR_E1M1,\n    HUSTR_E1M2,\n    HUSTR_E1M3,\n    HUSTR_E1M4,\n    HUSTR_E1M5,\n    HUSTR_E1M6,\n    HUSTR_E1M7,\n    HUSTR_E1M8,\n    HUSTR_E1M9,\n\n    HUSTR_E2M1,\n    HUSTR_E2M2,\n    HUSTR_E2M3,\n    HUSTR_E2M4,\n    HUSTR_E2M5,\n    HUSTR_E2M6,\n    HUSTR_E2M7,\n    HUSTR_E2M8,\n    HUSTR_E2M9,\n\n    HUSTR_E3M1,\n    HUSTR_E3M2,\n    HUSTR_E3M3,\n    HUSTR_E3M4,\n    HUSTR_E3M5,\n    HUSTR_E3M6,\n    HUSTR_E3M7,\n    HUSTR_E3M8,\n    HUSTR_E3M9,\n\n    HUSTR_E4M1,\n    HUSTR_E4M2,\n    HUSTR_E4M3,\n    HUSTR_E4M4,\n    HUSTR_E4M5,\n    HUSTR_E4M6,\n    HUSTR_E4M7,\n    HUSTR_E4M8,\n    HUSTR_E4M9,\n\n    \"NEWLEVEL\",\n    \"NEWLEVEL\",\n    \"NEWLEVEL\",\n    \"NEWLEVEL\",\n    \"NEWLEVEL\",\n    \"NEWLEVEL\",\n    \"NEWLEVEL\",\n    \"NEWLEVEL\",\n    \"NEWLEVEL\"\n};\n\nchar*   mapnames_chex[] =   // Chex Quest names.\n{\n\n    HUSTR_E1M1,\n    HUSTR_E1M2,\n    HUSTR_E1M3,\n    HUSTR_E1M4,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n    HUSTR_E1M5,\n\n    \"NEWLEVEL\",\n    \"NEWLEVEL\",\n    \"NEWLEVEL\",\n    \"NEWLEVEL\",\n    \"NEWLEVEL\",\n    \"NEWLEVEL\",\n    \"NEWLEVEL\",\n    \"NEWLEVEL\",\n    \"NEWLEVEL\"\n};\n\n// List of names for levels in commercial IWADs\n// (doom2.wad, plutonia.wad, tnt.wad).  These are stored in a\n// single large array; WADs like pl2.wad have a MAP33, and rely on\n// the layout in the Vanilla executable, where it is possible to\n// overflow the end of one array into the next.\n\nchar *mapnames_commercial[] =\n{\n    // DOOM 2 map names.\n\n    HUSTR_1,\n    HUSTR_2,\n    HUSTR_3,\n    HUSTR_4,\n    HUSTR_5,\n    HUSTR_6,\n    HUSTR_7,\n    HUSTR_8,\n    HUSTR_9,\n    HUSTR_10,\n    HUSTR_11,\n\t\n    HUSTR_12,\n    HUSTR_13,\n    HUSTR_14,\n    HUSTR_15,\n    HUSTR_16,\n    HUSTR_17,\n    HUSTR_18,\n    HUSTR_19,\n    HUSTR_20,\n\t\n    HUSTR_21,\n    HUSTR_22,\n    HUSTR_23,\n    HUSTR_24,\n    HUSTR_25,\n    HUSTR_26,\n    HUSTR_27,\n    HUSTR_28,\n    HUSTR_29,\n    HUSTR_30,\n    HUSTR_31,\n    HUSTR_32,\n\n    // Plutonia WAD map names.\n\n    PHUSTR_1,\n    PHUSTR_2,\n    PHUSTR_3,\n    PHUSTR_4,\n    PHUSTR_5,\n    PHUSTR_6,\n    PHUSTR_7,\n    PHUSTR_8,\n    PHUSTR_9,\n    PHUSTR_10,\n    PHUSTR_11,\n\t\n    PHUSTR_12,\n    PHUSTR_13,\n    PHUSTR_14,\n    PHUSTR_15,\n    PHUSTR_16,\n    PHUSTR_17,\n    PHUSTR_18,\n    PHUSTR_19,\n    PHUSTR_20,\n\t\n    PHUSTR_21,\n    PHUSTR_22,\n    PHUSTR_23,\n    PHUSTR_24,\n    PHUSTR_25,\n    PHUSTR_26,\n    PHUSTR_27,\n    PHUSTR_28,\n    PHUSTR_29,\n    PHUSTR_30,\n    PHUSTR_31,\n    PHUSTR_32,\n    \n    // TNT WAD map names.\n\n    THUSTR_1,\n    THUSTR_2,\n    THUSTR_3,\n    THUSTR_4,\n    THUSTR_5,\n    THUSTR_6,\n    THUSTR_7,\n    THUSTR_8,\n    THUSTR_9,\n    THUSTR_10,\n    THUSTR_11,\n\t\n    THUSTR_12,\n    THUSTR_13,\n    THUSTR_14,\n    THUSTR_15,\n    THUSTR_16,\n    THUSTR_17,\n    THUSTR_18,\n    THUSTR_19,\n    THUSTR_20,\n\t\n    THUSTR_21,\n    THUSTR_22,\n    THUSTR_23,\n    THUSTR_24,\n    THUSTR_25,\n    THUSTR_26,\n    THUSTR_27,\n    THUSTR_28,\n    THUSTR_29,\n    THUSTR_30,\n    THUSTR_31,\n    THUSTR_32,\n\n    // Emulation: TNT maps 33-35 can be warped to and played if they exist\n    // so include blank names instead of spilling over\n    \"\",\n    \"\",\n    \"\"\n    ,\n    NHUSTR_1,\n    NHUSTR_2,\n    NHUSTR_3,\n    NHUSTR_4,\n    NHUSTR_5,\n    NHUSTR_6,\n    NHUSTR_7,\n    NHUSTR_8,\n    NHUSTR_9,\n\n    MHUSTR_1,\n    MHUSTR_2,\n    MHUSTR_3,\n    MHUSTR_4,\n    MHUSTR_5,\n    MHUSTR_6,\n    MHUSTR_7,\n    MHUSTR_8,\n    MHUSTR_9,\n    MHUSTR_10,\n    MHUSTR_11,\n    MHUSTR_12,\n    MHUSTR_13,\n    MHUSTR_14,\n    MHUSTR_15,\n    MHUSTR_16,\n    MHUSTR_17,\n    MHUSTR_18,\n    MHUSTR_19,\n    MHUSTR_20,\n    MHUSTR_21\n};\n\n// [crispy] display names of single special levels in Automap\n// These are single, non-consecutive, (semi-)official levels\n// without their own music or par times and thus do not need\n// to be handled as distinct pack_* game missions.\ntypedef struct\n{\n    GameMission_t mission;\n    int episode;\n    int map;\n    const char *wad;\n    const char *name;\n} speciallevel_t;\n\nstatic const speciallevel_t speciallevels[] = {\n    // [crispy] ExM0\n    {doom, 1, 0, NULL, NULL},\n    {doom, 2, 0, NULL, NULL},\n    {doom, 3, 0, NULL, NULL},\n    {doom, 4, 0, NULL, NULL},\n    // [crispy] Romero's latest E1 additions\n    {doom, 1, 8, \"e1m8b.wad\", HUSTR_E1M8B},\n    {doom, 1, 4, \"e1m4b.wad\", HUSTR_E1M4B},\n    // [crispy] E1M10 \"Sewers\" (Xbox Doom)\n    {doom, 1, 10, NULL, HUSTR_E1M10},\n    // [crispy] The Master Levels for Doom 2\n    {doom2, 0, 1, \"attack.wad\", MHUSTR_1},\n    {doom2, 0, 1, \"canyon.wad\", MHUSTR_2},\n    {doom2, 0, 1, \"catwalk.wad\", MHUSTR_3},\n    {doom2, 0, 1, \"combine.wad\", MHUSTR_4},\n    {doom2, 0, 1, \"fistula.wad\", MHUSTR_5},\n    {doom2, 0, 1, \"garrison.wad\", MHUSTR_6},\n    {doom2, 0, 1, \"manor.wad\", MHUSTR_7},\n    {doom2, 0, 1, \"paradox.wad\", MHUSTR_8},\n    {doom2, 0, 1, \"subspace.wad\", MHUSTR_9},\n    {doom2, 0, 1, \"subterra.wad\", MHUSTR_10},\n    {doom2, 0, 1, \"ttrap.wad\", MHUSTR_11},\n    {doom2, 0, 3, \"virgil.wad\", MHUSTR_12},\n    {doom2, 0, 5, \"minos.wad\", MHUSTR_13},\n    {doom2, 0, 7, \"bloodsea.wad\", MHUSTR_14},\n    {doom2, 0, 7, \"mephisto.wad\", MHUSTR_15},\n    {doom2, 0, 7, \"nessus.wad\", MHUSTR_16},\n    {doom2, 0, 8, \"geryon.wad\", MHUSTR_17},\n    {doom2, 0, 9, \"vesperas.wad\", MHUSTR_18},\n    {doom2, 0, 25, \"blacktwr.wad\", MHUSTR_19},\n    {doom2, 0, 31, \"teeth.wad\", MHUSTR_20},\n    {doom2, 0, 32, \"teeth.wad\", MHUSTR_21},\n};\n\nstatic void HU_SetSpecialLevelName (const char *wad, const char **name)\n{\n    int i;\n\n    for (i = 0; i < arrlen(speciallevels); i++)\n    {\n\tconst speciallevel_t speciallevel = speciallevels[i];\n\n\tif (logical_gamemission == speciallevel.mission &&\n\t    (!speciallevel.episode || gameepisode == speciallevel.episode) &&\n\t    gamemap == speciallevel.map &&\n\t    (!speciallevel.wad || !strcasecmp(wad, speciallevel.wad)))\n\t{\n\t    *name = speciallevel.name ? speciallevel.name : maplumpinfo->name;\n\t    break;\n\t}\n    }\n}\n\nvoid HU_Init(void)\n{\n\n    int\t\ti;\n    int\t\tj;\n    char\tbuffer[9];\n\n    // load the heads-up font\n    j = HU_FONTSTART;\n    for (i=0;i<HU_FONTSIZE;i++)\n    {\n\tDEH_snprintf(buffer, 9, \"STCFN%.3d\", j++);\n\thu_font[i] = (patch_t *) W_CacheLumpName(buffer, PU_STATIC);\n    }\n\n}\n\nvoid HU_Stop(void)\n{\n    headsupactive = false;\n}\n\nEMSCRIPTEN_KEEPALIVE\nconst char *HU_GetMapName(){\n    const char *s;\n    // [crispy] string buffers for map title and WAD file name\n    char\t*ptr;\n\n    switch ( logical_gamemission )\n    {\n      case doom:\n\ts = HU_TITLE;\n\tbreak;\n      case doom2:\n\t s = HU_TITLE2;\n         // Pre-Final Doom compatibility: map33-map35 names don't spill over\n         if (gameversion <= exe_doom_1_9 && gamemap >= 33)\n         {\n             s = \"\";\n         }\n\t break;\n      case pack_plut:\n\ts = HU_TITLEP;\n\tbreak;\n      case pack_tnt:\n\ts = HU_TITLET;\n\tbreak;\n      default:\n         s = \"Unknown level\";\n         break;\n    }\n\n    if (logical_gamemission == doom && gameversion == exe_chex)\n    {\n        s = HU_TITLE_CHEX;\n    }\n\n    // [crispy] display names of single special levels in Automap\n    HU_SetSpecialLevelName(W_WadNameForLump(maplumpinfo), &s);\n\n    // [crispy] explicitely display (episode and) map if the\n    // map is from a PWAD or if the map title string has been dehacked\n    if (strcmp(s, DEH_String(s)) || (!W_IsIWADLump(maplumpinfo) && (!nervewadfile || gamemission != pack_nerve)))\n    {\n\tchar *m;\n\n\tptr = M_StringJoin(W_WadNameForLump(maplumpinfo), \": \", maplumpinfo->name, NULL);\n\tm = ptr;\n\n\tfree(ptr);\n    }\n\n    // dehacked substitution to get modified level name\n\n    s = DEH_String(s);\n\n    return s;\n}\n\nvoid HU_Start(void)\n{\n\n    int\t\ti;\n    const char *s;\n    // [crispy] string buffers for map title and WAD file name\n    char\tbuf[8], *ptr;\n\n    if (headsupactive)\n\tHU_Stop();\n\n    plr = &players[consoleplayer];\n    message_on = false;\n    message_dontfuckwithme = false;\n    message_nottobefuckedwith = false;\n    chat_on = false;\n\n    // create the message widget\n    HUlib_initSText(&w_message,\n\t\t    HU_MSGX, HU_MSGY, HU_MSGHEIGHT,\n\t\t    hu_font,\n\t\t    HU_FONTSTART, &message_on);\n\n    // create the map title widget\n    HUlib_initTextLine(&w_title,\n\t\t       HU_TITLEX, HU_TITLEY,\n\t\t       hu_font,\n\t\t       HU_FONTSTART);\n    \n    switch ( logical_gamemission )\n    {\n      case doom:\n\ts = HU_TITLE;\n\tbreak;\n      case doom2:\n\t s = HU_TITLE2;\n         // Pre-Final Doom compatibility: map33-map35 names don't spill over\n         if (gameversion <= exe_doom_1_9 && gamemap >= 33)\n         {\n             s = \"\";\n         }\n\t break;\n      case pack_plut:\n\ts = HU_TITLEP;\n\tbreak;\n      case pack_tnt:\n\ts = HU_TITLET;\n\tbreak;\n      case pack_nerve:\n\tif (gamemap <= 9)\n\t  s = HU_TITLEN;\n\telse\n\t  s = HU_TITLE2;\n\tbreak;\n      case pack_master:\n\tif (gamemap <= 21)\n\t  s = HU_TITLEM;\n\telse\n\t  s = HU_TITLE2;\n\tbreak;\n      default:\n         s = \"Unknown level\";\n         break;\n    }\n\n    if (logical_gamemission == doom && gameversion == exe_chex)\n    {\n        s = HU_TITLE_CHEX;\n    }\n\n    // [crispy] display names of single special levels in Automap\n    HU_SetSpecialLevelName(W_WadNameForLump(maplumpinfo), &s);\n\n    // [crispy] explicitely display (episode and) map if the\n    // map is from a PWAD or if the map title string has been dehacked\n    if (strcmp(s, DEH_String(s)) || (!W_IsIWADLump(maplumpinfo) && (!nervewadfile || gamemission != pack_nerve)))\n    {\n\tchar *m;\n\n\tptr = M_StringJoin(W_WadNameForLump(maplumpinfo), \": \", maplumpinfo->name, NULL);\n\tm = ptr;\n\n\tfree(ptr);\n    }\n\n    // dehacked substitution to get modified level name\n\n    s = DEH_String(s);\n    // [crispy] print the map title in white from the first colon onward\n    M_snprintf(buf, sizeof(buf), \"%s\", \":\");\n    ptr = M_StringReplace(s, \":\", buf);\n    s = ptr;\n    \n    while (*s)\n\tHUlib_addCharToTextLine(&w_title, *(s++));\n\n    // create the chat widget\n    HUlib_initIText(&w_chat,\n\t\t    HU_INPUTX, HU_INPUTY,\n\t\t    hu_font,\n\t\t    HU_FONTSTART, &chat_on);\n\n    // create the inputbuffer widgets\n    for (i=0 ; i<MAXPLAYERS ; i++)\n\tHUlib_initIText(&w_inputbuffer[i], 0, 0, 0, 0, &always_off);\n\n    headsupactive = true;\n\n}\n\nvoid HU_Drawer(void)\n{\n\n    HUlib_drawSText(&w_message);\n    HUlib_drawIText(&w_chat);\n    if (automapactive)\n\tHUlib_drawTextLine(&w_title, false);\n\n}\n\nvoid HU_Erase(void)\n{\n\n    HUlib_eraseSText(&w_message);\n    HUlib_eraseIText(&w_chat);\n    HUlib_eraseTextLine(&w_title);\n\n}\n\nvoid HU_Ticker(void)\n{\n\n    int i, rc;\n    char c;\n\n    // tick down message counter if message is up\n    if (message_counter && !--message_counter)\n    {\n\tmessage_on = false;\n\tmessage_nottobefuckedwith = false;\n    }\n\n    if (showMessages || message_dontfuckwithme)\n    {\n\n\t// display message if necessary\n\tif ((plr->message && !message_nottobefuckedwith)\n\t    || (plr->message && message_dontfuckwithme))\n\t{\n\t    HUlib_addMessageToSText(&w_message, 0, plr->message);\n\t    plr->message = 0;\n\t    message_on = true;\n\t    message_counter = HU_MSGTIMEOUT;\n\t    message_nottobefuckedwith = message_dontfuckwithme;\n\t    message_dontfuckwithme = 0;\n\t}\n\n    }\n\n    // check for incoming chat characters\n    if (netgame)\n    {\n\tfor (i=0 ; i<MAXPLAYERS; i++)\n\t{\n\t    if (!playeringame[i])\n\t\tcontinue;\n\t    if (i != consoleplayer\n\t\t&& (c = players[i].cmd.chatchar))\n\t    {\n\t\tif (c <= HU_BROADCAST)\n\t\t    chat_dest[i] = c;\n\t\telse\n\t\t{\n\t\t    rc = HUlib_keyInIText(&w_inputbuffer[i], c);\n\t\t    if (rc && c == KEY_ENTER)\n\t\t    {\n\t\t\tif (w_inputbuffer[i].l.len\n\t\t\t    && (chat_dest[i] == consoleplayer+1\n\t\t\t\t|| chat_dest[i] == HU_BROADCAST))\n\t\t\t{\n\t\t\t    HUlib_addMessageToSText(&w_message,\n\t\t\t\t\t\t    DEH_String(player_names[i]),\n\t\t\t\t\t\t    w_inputbuffer[i].l.l);\n\t\t\t    \n\t\t\t    message_nottobefuckedwith = true;\n\t\t\t    message_on = true;\n\t\t\t    message_counter = HU_MSGTIMEOUT;\n\t\t\t    if ( gamemode == commercial )\n\t\t\t      S_StartSound(0, sfx_radio);\n\t\t\t    else\n\t\t\t      S_StartSound(0, sfx_tink);\n\t\t\t}\n\t\t\tHUlib_resetIText(&w_inputbuffer[i]);\n\t\t    }\n\t\t}\n\t\tplayers[i].cmd.chatchar = 0;\n\t    }\n\t}\n    }\n\n}\n\n#define QUEUESIZE\t\t128\n\nstatic char\tchatchars[QUEUESIZE];\nstatic int\thead = 0;\nstatic int\ttail = 0;\n\n\nvoid HU_queueChatChar(char c)\n{\n    if (((head + 1) & (QUEUESIZE-1)) == tail)\n    {\n\tplr->message = DEH_String(HUSTR_MSGU);\n    }\n    else\n    {\n\tchatchars[head] = c;\n\thead = (head + 1) & (QUEUESIZE-1);\n    }\n}\n\nchar HU_dequeueChatChar(void)\n{\n    char c;\n\n    if (head != tail)\n    {\n\tc = chatchars[tail];\n\ttail = (tail + 1) & (QUEUESIZE-1);\n    }\n    else\n    {\n\tc = 0;\n    }\n\n    return c;\n}\n\nstatic void StartChatInput(int dest)\n{\n    chat_on = true;\n    HUlib_resetIText(&w_chat);\n    HU_queueChatChar(HU_BROADCAST);\n\n    I_StartTextInput(0, 8, SCREENWIDTH, 16);\n}\n\nstatic void StopChatInput(void)\n{\n    chat_on = false;\n    I_StopTextInput();\n}\n\nboolean HU_Responder(event_t *ev)\n{\n\n    static char\t\tlastmessage[HU_MAXLINELENGTH+1];\n    char*\t\tmacromessage;\n    boolean\t\teatkey = false;\n    static boolean\taltdown = false;\n    unsigned char \tc;\n    int\t\t\ti;\n    int\t\t\tnumplayers;\n    \n    static int\t\tnum_nobrainers = 0;\n\n    numplayers = 0;\n    for (i=0 ; i<MAXPLAYERS ; i++)\n\tnumplayers += playeringame[i];\n\n    if (ev->data1 == KEY_RSHIFT)\n    {\n\treturn false;\n    }\n    else if (ev->data1 == KEY_RALT || ev->data1 == KEY_LALT)\n    {\n\taltdown = ev->type == ev_keydown;\n\treturn false;\n    }\n\n    if (ev->type != ev_keydown)\n\treturn false;\n\n    if (!chat_on)\n    {\n\tif (ev->data1 == key_message_refresh)\n\t{\n\t    message_on = true;\n\t    message_counter = HU_MSGTIMEOUT;\n\t    eatkey = true;\n\t}\n\telse if (netgame && ev->data2 == key_multi_msg)\n\t{\n\t    eatkey = true;\n            StartChatInput(HU_BROADCAST);\n\t}\n\telse if (netgame && numplayers > 2)\n\t{\n\t    for (i=0; i<MAXPLAYERS ; i++)\n\t    {\n\t\tif (ev->data2 == key_multi_msgplayer[i])\n\t\t{\n\t\t    if (playeringame[i] && i!=consoleplayer)\n\t\t    {\n\t\t\teatkey = true;\n                        StartChatInput(i + 1);\n\t\t\tbreak;\n\t\t    }\n\t\t    else if (i == consoleplayer)\n\t\t    {\n\t\t\tnum_nobrainers++;\n\t\t\tif (num_nobrainers < 3)\n\t\t\t    plr->message = DEH_String(HUSTR_TALKTOSELF1);\n\t\t\telse if (num_nobrainers < 6)\n\t\t\t    plr->message = DEH_String(HUSTR_TALKTOSELF2);\n\t\t\telse if (num_nobrainers < 9)\n\t\t\t    plr->message = DEH_String(HUSTR_TALKTOSELF3);\n\t\t\telse if (num_nobrainers < 32)\n\t\t\t    plr->message = DEH_String(HUSTR_TALKTOSELF4);\n\t\t\telse\n\t\t\t    plr->message = DEH_String(HUSTR_TALKTOSELF5);\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n    else\n    {\n\t// send a macro\n\tif (altdown)\n\t{\n\t    c = ev->data1 - '0';\n\t    if (c > 9)\n\t\treturn false;\n\t    // fprintf(stderr, \"got here\\n\");\n\t    macromessage = chat_macros[c];\n\n\t    // kill last message with a '\\n'\n\t    HU_queueChatChar(KEY_ENTER); // DEBUG!!!\n\n\t    // send the macro message\n\t    while (*macromessage)\n\t\tHU_queueChatChar(*macromessage++);\n\t    HU_queueChatChar(KEY_ENTER);\n\n            // leave chat mode and notify that it was sent\n            StopChatInput();\n            M_StringCopy(lastmessage, chat_macros[c], sizeof(lastmessage));\n            plr->message = lastmessage;\n            eatkey = true;\n\t}\n\telse\n\t{\n            c = ev->data3;\n\n\t    eatkey = HUlib_keyInIText(&w_chat, c);\n\t    if (eatkey)\n\t    {\n\t\tHU_queueChatChar(c);\n\t    }\n\t    if (c == KEY_ENTER)\n\t    {\n\t\tStopChatInput();\n                if (w_chat.l.len)\n                {\n                    M_StringCopy(lastmessage, w_chat.l.l, sizeof(lastmessage));\n                    plr->message = lastmessage;\n                }\n\t    }\n\t    else if (c == KEY_ESCAPE)\n\t    {\n                StopChatInput();\n            }\n\t}\n    }\n\n    return eatkey;\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tIntermission screens.\n//\n\n\n#include <stdio.h>\n\n#include \"z_zone.h\"\n\n#include \"m_misc.h\"\n#include \"m_random.h\"\n\n#include \"deh_main.h\"\n#include \"i_swap.h\"\n#include \"i_system.h\"\n\n#include \"w_wad.h\"\n\n#include \"g_game.h\"\n\n#include \"r_local.h\"\n#include \"s_sound.h\"\n\n#include \"doomstat.h\"\n\n// Data.\n#include \"sounds.h\"\n\n// Needs access to LFB.\n#include \"v_video.h\"\n\n#include \"wi_stuff.h\"\n\n#include \"i_video.h\"\n\n//\n// Data needed to add patches to full screen intermission pics.\n// Patches are statistics messages, and animations.\n// Loads of by-pixel layout and placement, offsets etc.\n//\n\n\n//\n// Different vetween registered DOOM (1994) and\n//  Ultimate DOOM - Final edition (retail, 1995?).\n// This is supposedly ignored for commercial\n//  release (aka DOOM II), which had 34 maps\n//  in one episode. So there.\n#define NUMEPISODES\t4\n#define NUMMAPS\t\t9\n\n\n// in tics\n//U #define PAUSELEN\t\t(TICRATE*2) \n//U #define SCORESTEP\t\t100\n//U #define ANIMPERIOD\t\t32\n// pixel distance from \"(YOU)\" to \"PLAYER N\"\n//U #define STARDIST\t\t10 \n//U #define WK 1\n\n\n// GLOBAL LOCATIONS\n#define WI_TITLEY\t\t2\n#define WI_SPACINGY    \t\t33\n\n// SINGPLE-PLAYER STUFF\n#define SP_STATSX\t\t50\n#define SP_STATSY\t\t50\n\n#define SP_TIMEX\t\t16\n#define SP_TIMEY\t\t(SCREENHEIGHT-32)\n\n\n// NET GAME STUFF\n#define NG_STATSY\t\t50\n#define NG_STATSX\t\t(32 + SHORT(star->width)/2 + 32*!dofrags)\n\n#define NG_SPACINGX    \t\t64\n\n\n// DEATHMATCH STUFF\n#define DM_MATRIXX\t\t42\n#define DM_MATRIXY\t\t68\n\n#define DM_SPACINGX\t\t40\n\n#define DM_TOTALSX\t\t269\n\n#define DM_KILLERSX\t\t10\n#define DM_KILLERSY\t\t100\n#define DM_VICTIMSX    \t\t5\n#define DM_VICTIMSY\t\t50\n\n// Crispy\nextern boolean havee1m10;\nextern boolean havemap33;\n\ntypedef enum\n{\n    ANIM_ALWAYS,\n    ANIM_RANDOM,\n    ANIM_LEVEL\n\n} animenum_t;\n\ntypedef struct\n{\n    int\t\tx;\n    int\t\ty;\n    \n} point_t;\n\n\n//\n// Animation.\n// There is another anim_t used in p_spec.\n//\ntypedef struct\n{\n    animenum_t\ttype;\n\n    // period in tics between animations\n    int\t\tperiod;\n\n    // number of animation frames\n    int\t\tnanims;\n\n    // location of animation\n    point_t\tloc;\n\n    // ALWAYS: n/a,\n    // RANDOM: period deviation (<256),\n    // LEVEL: level\n    int\t\tdata1;\n\n    // ALWAYS: n/a,\n    // RANDOM: random base period,\n    // LEVEL: n/a\n    int\t\tdata2; \n\n    // actual graphics for frames of animations\n    patch_t*\tp[3]; \n\n    // following must be initialized to zero before use!\n\n    // next value of bcnt (used in conjunction with period)\n    int\t\tnexttic;\n\n    // last drawn animation frame\n    int\t\tlastdrawn;\n\n    // next frame number to animate\n    int\t\tctr;\n    \n    // used by RANDOM and LEVEL when animating\n    int\t\tstate;  \n\n} anim_t;\n\n\nstatic point_t lnodes[NUMEPISODES][NUMMAPS] =\n{\n    // Episode 0 World Map\n    {\n\t{ 185, 164 },\t// location of level 0 (CJ)\n\t{ 148, 143 },\t// location of level 1 (CJ)\n\t{ 69, 122 },\t// location of level 2 (CJ)\n\t{ 209, 102 },\t// location of level 3 (CJ)\n\t{ 116, 89 },\t// location of level 4 (CJ)\n\t{ 166, 55 },\t// location of level 5 (CJ)\n\t{ 71, 56 },\t// location of level 6 (CJ)\n\t{ 135, 29 },\t// location of level 7 (CJ)\n\t{ 71, 24 }\t// location of level 8 (CJ)\n    },\n\n    // Episode 1 World Map should go here\n    {\n\t{ 254, 25 },\t// location of level 0 (CJ)\n\t{ 97, 50 },\t// location of level 1 (CJ)\n\t{ 188, 64 },\t// location of level 2 (CJ)\n\t{ 128, 78 },\t// location of level 3 (CJ)\n\t{ 214, 92 },\t// location of level 4 (CJ)\n\t{ 133, 130 },\t// location of level 5 (CJ)\n\t{ 208, 136 },\t// location of level 6 (CJ)\n\t{ 148, 140 },\t// location of level 7 (CJ)\n\t{ 235, 158 }\t// location of level 8 (CJ)\n    },\n\n    // Episode 2 World Map should go here\n    {\n\t{ 156, 168 },\t// location of level 0 (CJ)\n\t{ 48, 154 },\t// location of level 1 (CJ)\n\t{ 174, 95 },\t// location of level 2 (CJ)\n\t{ 265, 75 },\t// location of level 3 (CJ)\n\t{ 130, 48 },\t// location of level 4 (CJ)\n\t{ 279, 23 },\t// location of level 5 (CJ)\n\t{ 198, 48 },\t// location of level 6 (CJ)\n\t{ 140, 25 },\t// location of level 7 (CJ)\n\t{ 281, 136 }\t// location of level 8 (CJ)\n    }\n\n};\n\n\n//\n// Animation locations for episode 0 (1).\n// Using patches saves a lot of space,\n//  as they replace 320x200 full screen frames.\n//\n\n#define ANIM(type, period, nanims, x, y, nexttic)            \\\n   { (type), (period), (nanims), { (x), (y) }, (nexttic),    \\\n     0, { NULL, NULL, NULL }, 0, 0, 0, 0 }\n\n\nstatic anim_t epsd0animinfo[] =\n{\n    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 224, 104, 0),\n    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 184, 160, 0),\n    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 112, 136, 0),\n    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 72, 112, 0),\n    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 88, 96, 0),\n    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 64, 48, 0),\n    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 192, 40, 0),\n    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 136, 16, 0),\n    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 80, 16, 0),\n    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 64, 24, 0),\n};\n\nstatic anim_t epsd1animinfo[] =\n{\n    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136, 1),\n    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136, 2),\n    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136, 3),\n    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136, 4),\n    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136, 5),\n    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136, 6),\n    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136, 7),\n    ANIM(ANIM_LEVEL, TICRATE/3, 3, 192, 144, 8),\n    ANIM(ANIM_LEVEL, TICRATE/3, 1, 128, 136, 8),\n};\n\nstatic anim_t epsd2animinfo[] =\n{\n    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 104, 168, 0),\n    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 40, 136, 0),\n    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 160, 96, 0),\n    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 104, 80, 0),\n    ANIM(ANIM_ALWAYS, TICRATE/3, 3, 120, 32, 0),\n    ANIM(ANIM_ALWAYS, TICRATE/4, 3, 40, 0, 0),\n};\n\nstatic int NUMANIMS[NUMEPISODES] =\n{\n    arrlen(epsd0animinfo),\n    arrlen(epsd1animinfo),\n    arrlen(epsd2animinfo),\n};\n\nstatic anim_t *anims[NUMEPISODES] =\n{\n    epsd0animinfo,\n    epsd1animinfo,\n    epsd2animinfo\n};\n\n\n//\n// GENERAL DATA\n//\n\n//\n// Locally used stuff.\n//\n\n// States for single-player\n#define SP_KILLS\t\t0\n#define SP_ITEMS\t\t2\n#define SP_SECRET\t\t4\n#define SP_FRAGS\t\t6 \n#define SP_TIME\t\t\t8 \n#define SP_PAR\t\t\tST_TIME\n\n#define SP_PAUSE\t\t1\n\n// in seconds\n#define SHOWNEXTLOCDELAY\t4\n//#define SHOWLASTLOCDELAY\tSHOWNEXTLOCDELAY\n\n\n// used to accelerate or skip a stage\nstatic int\t\tacceleratestage;\n\n// wbs->pnum\nstatic int\t\tme;\n\n // specifies current state\nstatic stateenum_t\tstate;\n\n// contains information passed into intermission\nstatic wbstartstruct_t*\twbs;\n\nstatic wbplayerstruct_t* plrs;  // wbs->plyr[]\n\n// used for general timing\nstatic int \t\tcnt;  \n\n// used for timing of background animation\nstatic int \t\tbcnt;\n\n// signals to refresh everything for one frame\nstatic int \t\tfirstrefresh; \n\nstatic int\t\tcnt_kills[MAXPLAYERS];\nstatic int\t\tcnt_items[MAXPLAYERS];\nstatic int\t\tcnt_secret[MAXPLAYERS];\nstatic int\t\tcnt_time;\nstatic int\t\tcnt_par;\nstatic int\t\tcnt_pause;\n\n// # of commercial levels\nstatic int\t\tNUMCMAPS; \n\n\n//\n//\tGRAPHICS\n//\n\n// You Are Here graphic\nstatic patch_t*\t\tyah[3] = { NULL, NULL, NULL }; \n\n// splat\nstatic patch_t*\t\tsplat[2] = { NULL, NULL };\n\n// %, : graphics\nstatic patch_t*\t\tpercent;\nstatic patch_t*\t\tcolon;\n\n// 0-9 graphic\nstatic patch_t*\t\tnum[10];\n\n// minus sign\nstatic patch_t*\t\twiminus;\n\n// \"Finished!\" graphics\nstatic patch_t*\t\tfinished;\n\n// \"Entering\" graphic\nstatic patch_t*\t\tentering; \n\n// \"secret\"\nstatic patch_t*\t\tsp_secret;\n\n // \"Kills\", \"Scrt\", \"Items\", \"Frags\"\nstatic patch_t*\t\tkills;\nstatic patch_t*\t\tsecret;\nstatic patch_t*\t\titems;\nstatic patch_t*\t\tfrags;\n\n// Time sucks.\nstatic patch_t*\t\ttimepatch;\nstatic patch_t*\t\tpar;\nstatic patch_t*\t\tsucks;\n\n// \"killers\", \"victims\"\nstatic patch_t*\t\tkillers;\nstatic patch_t*\t\tvictims; \n\n// \"Total\", your face, your dead face\nstatic patch_t*\t\ttotal;\nstatic patch_t*\t\tstar;\nstatic patch_t*\t\tbstar;\n\n// \"red P[1..MAXPLAYERS]\"\nstatic patch_t*\t\tp[MAXPLAYERS];\n\n// \"gray P[1..MAXPLAYERS]\"\nstatic patch_t*\t\tbp[MAXPLAYERS];\n\n // Name graphics of each level (centered)\nstatic patch_t**\tlnames;\n\n// Buffer storing the backdrop\nstatic patch_t *background;\n\n//\n// CODE\n//\n\n// slam background\nvoid WI_slamBackground(void)\n{\n    V_DrawPatch(0, 0, background);\n}\n\n// The ticker is used to detect keys\n//  because of timing issues in netgames.\nboolean WI_Responder(event_t* ev)\n{\n    return false;\n}\n\n// Draws \"<Levelname> Finished!\"\nvoid WI_drawLF(void)\n{\n    int y = WI_TITLEY;\n\n\t// [crispy] prevent crashes with maps without map title graphics lump\n    if ((gamemode == commercial && (unsigned)wbs->last >= NUMCMAPS) ||\n        (gamemode != commercial && (unsigned)wbs->last >= (havee1m10 ? NUMMAPS + 1 : NUMMAPS)))\n    {\n        V_DrawPatch((ORIGWIDTH - SHORT(finished->width)) / 2, y, finished);\n        return;\n    }\n\n    if (gamemode != commercial || wbs->last < NUMCMAPS)\n    {\n        // draw <LevelName> \n        V_DrawPatch((SCREENWIDTH - SHORT(lnames[wbs->last]->width))/2,\n                    y, lnames[wbs->last]);\n\n        // draw \"Finished!\"\n        y += (5*SHORT(lnames[wbs->last]->height))/4;\n\n        V_DrawPatch((SCREENWIDTH - SHORT(finished->width)) / 2, y, finished);\n    }\n    else if (wbs->last == NUMCMAPS)\n    {\n        // MAP33 - draw \"Finished!\" only\n        V_DrawPatch((SCREENWIDTH - SHORT(finished->width)) / 2, y, finished);\n    }\n    else if (wbs->last > NUMCMAPS)\n    {\n        // > MAP33.  Doom bombs out here with a Bad V_DrawPatch error.\n        // I'm pretty sure that doom2.exe is just reading into random\n        // bits of memory at this point, but let's try to be accurate\n        // anyway.  This deliberately triggers a V_DrawPatch error.\n\n        patch_t tmp = { SCREENWIDTH, SCREENHEIGHT, 1, 1, \n                        { 0, 0, 0, 0, 0, 0, 0, 0 } };\n\n        V_DrawPatch(0, y, &tmp);\n    }\n}\n\n\n\n// Draws \"Entering <LevelName>\"\nvoid WI_drawEL(void)\n{\n    int y = WI_TITLEY;\n\n\t// [crispy] prevent crashes with maps without map title graphics lump\n    if ((gamemode == commercial && (unsigned)wbs->next >= NUMCMAPS) ||\n        (gamemode != commercial && (unsigned)wbs->next >= (havee1m10 ? NUMMAPS + 1 : NUMMAPS)))\n    {\n        return;\n    }\n\n    // draw \"Entering\"\n    V_DrawPatch((SCREENWIDTH - SHORT(entering->width))/2,\n\t\ty,\n                entering);\n\n    // draw level\n    y += (5*SHORT(lnames[wbs->next]->height))/4;\n\n    V_DrawPatch((SCREENWIDTH - SHORT(lnames[wbs->next]->width))/2,\n\t\ty, \n                lnames[wbs->next]);\n\n}\n\nvoid\nWI_drawOnLnode\n( int\t\tn,\n  patch_t*\tc[] )\n{\n\n    int\t\ti;\n    int\t\tleft;\n    int\t\ttop;\n    int\t\tright;\n    int\t\tbottom;\n    boolean\tfits = false;\n\n    i = 0;\n    do\n    {\n\tleft = lnodes[wbs->epsd][n].x - SHORT(c[i]->leftoffset);\n\ttop = lnodes[wbs->epsd][n].y - SHORT(c[i]->topoffset);\n\tright = left + SHORT(c[i]->width);\n\tbottom = top + SHORT(c[i]->height);\n\n\tif (left >= 0\n\t    && right < SCREENWIDTH\n\t    && top >= 0\n\t    && bottom < SCREENHEIGHT)\n\t{\n\t    fits = true;\n\t}\n\telse\n\t{\n\t    i++;\n\t}\n    } while (!fits && i!=2 && c[i] != NULL);\n\n    if (fits && i<2)\n    {\n\tV_DrawPatch(lnodes[wbs->epsd][n].x,\n                    lnodes[wbs->epsd][n].y,\n\t\t    c[i]);\n    }\n    else\n    {\n\t// DEBUG\n\tprintf(\"Could not place patch on level %d\", n+1); \n    }\n}\n\n\n\nvoid WI_initAnimatedBack(void)\n{\n    int\t\ti;\n    anim_t*\ta;\n\n    if (gamemode == commercial)\n\treturn;\n\n    if (wbs->epsd > 2)\n\treturn;\n\n    for (i=0;i<NUMANIMS[wbs->epsd];i++)\n    {\n\ta = &anims[wbs->epsd][i];\n\n\t// init variables\n\ta->ctr = -1;\n\n\t// specify the next time to draw it\n\tif (a->type == ANIM_ALWAYS)\n\t    a->nexttic = bcnt + 1 + (M_Random()%a->period);\n\telse if (a->type == ANIM_RANDOM)\n\t    a->nexttic = bcnt + 1 + a->data2+(M_Random()%a->data1);\n\telse if (a->type == ANIM_LEVEL)\n\t    a->nexttic = bcnt + 1;\n    }\n\n}\n\nvoid WI_updateAnimatedBack(void)\n{\n    int\t\ti;\n    anim_t*\ta;\n\n    if (gamemode == commercial)\n\treturn;\n\n    if (wbs->epsd > 2)\n\treturn;\n\n    for (i=0;i<NUMANIMS[wbs->epsd];i++)\n    {\n\ta = &anims[wbs->epsd][i];\n\n\tif (bcnt == a->nexttic)\n\t{\n\t    switch (a->type)\n\t    {\n\t      case ANIM_ALWAYS:\n\t\tif (++a->ctr >= a->nanims) a->ctr = 0;\n\t\ta->nexttic = bcnt + a->period;\n\t\tbreak;\n\n\t      case ANIM_RANDOM:\n\t\ta->ctr++;\n\t\tif (a->ctr == a->nanims)\n\t\t{\n\t\t    a->ctr = -1;\n\t\t    a->nexttic = bcnt+a->data2+(M_Random()%a->data1);\n\t\t}\n\t\telse a->nexttic = bcnt + a->period;\n\t\tbreak;\n\t\t\n\t      case ANIM_LEVEL:\n\t\t// gawd-awful hack for level anims\n\t\tif (!(state == StatCount && i == 7)\n\t\t    && wbs->next == a->data1)\n\t\t{\n\t\t    a->ctr++;\n\t\t    if (a->ctr == a->nanims) a->ctr--;\n\t\t    a->nexttic = bcnt + a->period;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n\n    }\n\n}\n\nvoid WI_drawAnimatedBack(void)\n{\n    int\t\t\ti;\n    anim_t*\t\ta;\n\n    if (gamemode == commercial)\n\treturn;\n\n    if (wbs->epsd > 2)\n\treturn;\n\n    for (i=0 ; i<NUMANIMS[wbs->epsd] ; i++)\n    {\n\ta = &anims[wbs->epsd][i];\n\n\tif (a->ctr >= 0)\n\t    V_DrawPatch(a->loc.x, a->loc.y, a->p[a->ctr]);\n    }\n\n}\n\n//\n// Draws a number.\n// If digits > 0, then use that many digits minimum,\n//  otherwise only use as many as necessary.\n// Returns new x position.\n//\n\nint\nWI_drawNum\n( int\t\tx,\n  int\t\ty,\n  int\t\tn,\n  int\t\tdigits )\n{\n\n    int\t\tfontwidth = SHORT(num[0]->width);\n    int\t\tneg;\n    int\t\ttemp;\n\n    if (digits < 0)\n    {\n\tif (!n)\n\t{\n\t    // make variable-length zeros 1 digit long\n\t    digits = 1;\n\t}\n\telse\n\t{\n\t    // figure out # of digits in #\n\t    digits = 0;\n\t    temp = n;\n\n\t    while (temp)\n\t    {\n\t\ttemp /= 10;\n\t\tdigits++;\n\t    }\n\t}\n    }\n\n    neg = n < 0;\n    if (neg)\n\tn = -n;\n\n    // if non-number, do not draw it\n    if (n == 1994)\n\treturn 0;\n\n    // draw the new number\n    while (digits--)\n    {\n\tx -= fontwidth;\n\tV_DrawPatch(x, y, num[ n % 10 ]);\n\tn /= 10;\n    }\n\n    // draw a minus sign if necessary\n    if (neg)\n\tV_DrawPatch(x-=8, y, wiminus);\n\n    return x;\n\n}\n\nvoid\nWI_drawPercent\n( int\t\tx,\n  int\t\ty,\n  int\t\tp )\n{\n    if (p < 0)\n\treturn;\n\n    V_DrawPatch(x, y, percent);\n    WI_drawNum(x, y, p, -1);\n}\n\n\n\n//\n// Display level completion time and par,\n//  or \"sucks\" message if overflow.\n//\nvoid\nWI_drawTime\n( int\t\tx,\n  int\t\ty,\n  int\t\tt )\n{\n\n    int\t\tdiv;\n    int\t\tn;\n\n    if (t<0)\n\treturn;\n\n    if (t <= 61*59)\n    {\n\tdiv = 1;\n\n\tdo\n\t{\n\t    n = (t / div) % 60;\n\t    x = WI_drawNum(x, y, n, 2) - SHORT(colon->width);\n\t    div *= 60;\n\n\t    // draw\n\t    if (div==60 || t / div)\n\t\tV_DrawPatch(x, y, colon);\n\t    \n\t} while (t / div);\n    }\n    else\n    {\n\t// \"sucks\"\n\tV_DrawPatch(x - SHORT(sucks->width), y, sucks); \n    }\n}\n\n\nvoid WI_End(void)\n{\n    void WI_unloadData(void);\n    WI_unloadData();\n}\n\nvoid WI_initNoState(void)\n{\n    state = NoState;\n    acceleratestage = 0;\n    cnt = 10;\n}\n\nvoid WI_updateNoState(void) {\n\n    WI_updateAnimatedBack();\n\n    if (!--cnt)\n    {\n        // Don't call WI_End yet.  G_WorldDone doesnt immediately \n        // change gamestate, so WI_Drawer is still going to get\n        // run until that happens.  If we do that after WI_End\n        // (which unloads all the graphics), we're in trouble.\n\t//WI_End();\n\tG_WorldDone();\n    }\n\n}\n\nstatic boolean\t\tsnl_pointeron = false;\n\n\nvoid WI_initShowNextLoc(void)\n{\n    state = ShowNextLoc;\n    acceleratestage = 0;\n    cnt = SHOWNEXTLOCDELAY * TICRATE;\n\n    WI_initAnimatedBack();\n}\n\nvoid WI_updateShowNextLoc(void)\n{\n    WI_updateAnimatedBack();\n\n    if (!--cnt || acceleratestage)\n\tWI_initNoState();\n    else\n\tsnl_pointeron = (cnt & 31) < 20;\n}\n\nvoid WI_drawShowNextLoc(void)\n{\n\n    int\t\ti;\n    int\t\tlast;\n\textern boolean secretexit; // [crispy] Master Level support\n\n    WI_slamBackground();\n\n    // draw animated background\n    WI_drawAnimatedBack(); \n\n    if ( gamemode != commercial)\n    {\n  \tif (wbs->epsd > 2)\n\t{\n\t    WI_drawEL();\n\t    return;\n\t}\n\t\n\tlast = (wbs->last == 8) ? wbs->next - 1 : wbs->last;\n\n\t// draw a splat on taken cities.\n\tfor (i=0 ; i<=last ; i++)\n\t    WI_drawOnLnode(i, splat);\n\n\t// splat the secret level?\n\tif (wbs->didsecret)\n\t    WI_drawOnLnode(8, splat);\n\n\t// [crispy] the splat for E1M10 \"Sewers\" is drawn only once,\n\t// i.e. now, when returning from the level\n\t// (and this is not going to change)\n\tif (havee1m10 && wbs->epsd == 0 && wbs->last == 9)\n\t    WI_drawOnLnode(9, splat);\n\n\t// draw flashing ptr\n\tif (snl_pointeron)\n\t    WI_drawOnLnode(wbs->next, yah); \n    }\n\n\tif ((gamemission == pack_nerve && wbs->last == 7) ||\n        (gamemission == pack_master && wbs->last == 19 && !secretexit) ||\n        (gamemission == pack_master && wbs->last == 20))\n        return;\n\n    // draws which level you are entering..\n    if ( (gamemode != commercial)\n\t || wbs->next != 30)\n\tWI_drawEL();  \n\n}\n\nvoid WI_drawNoState(void)\n{\n    snl_pointeron = true;\n    WI_drawShowNextLoc();\n}\n\nint WI_fragSum(int playernum)\n{\n    int\t\ti;\n    int\t\tfrags = 0;\n    \n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (playeringame[i]\n\t    && i!=playernum)\n\t{\n\t    frags += plrs[playernum].frags[i];\n\t}\n    }\n\n\t\n    // JDC hack - negative frags.\n    frags -= plrs[playernum].frags[playernum];\n\n    return frags;\n}\n\n\n\nstatic int\t\tdm_state;\nstatic int\t\tdm_frags[MAXPLAYERS][MAXPLAYERS];\nstatic int\t\tdm_totals[MAXPLAYERS];\n\n\n\nvoid WI_initDeathmatchStats(void)\n{\n\n    int\t\ti;\n    int\t\tj;\n\n    state = StatCount;\n    acceleratestage = 0;\n    dm_state = 1;\n\n    cnt_pause = TICRATE;\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (playeringame[i])\n\t{\n\t    for (j=0 ; j<MAXPLAYERS ; j++)\n\t\tif (playeringame[j])\n\t\t    dm_frags[i][j] = 0;\n\n\t    dm_totals[i] = 0;\n\t}\n    }\n    \n    WI_initAnimatedBack();\n}\n\n\n\nvoid WI_updateDeathmatchStats(void)\n{\n\n    int\t\ti;\n    int\t\tj;\n    \n    boolean\tstillticking;\n\n    WI_updateAnimatedBack();\n\n    if (acceleratestage && dm_state != 4)\n    {\n\tacceleratestage = 0;\n\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (playeringame[i])\n\t    {\n\t\tfor (j=0 ; j<MAXPLAYERS ; j++)\n\t\t    if (playeringame[j])\n\t\t\tdm_frags[i][j] = plrs[i].frags[j];\n\n\t\tdm_totals[i] = WI_fragSum(i);\n\t    }\n\t}\n\t\n\n\tS_StartSound(0, sfx_barexp);\n\tdm_state = 4;\n    }\n\n    \n    if (dm_state == 2)\n    {\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\t\n\tstillticking = false;\n\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (playeringame[i])\n\t    {\n\t\tfor (j=0 ; j<MAXPLAYERS ; j++)\n\t\t{\n\t\t    if (playeringame[j]\n\t\t\t&& dm_frags[i][j] != plrs[i].frags[j])\n\t\t    {\n\t\t\tif (plrs[i].frags[j] < 0)\n\t\t\t    dm_frags[i][j]--;\n\t\t\telse\n\t\t\t    dm_frags[i][j]++;\n\n\t\t\tif (dm_frags[i][j] > 99)\n\t\t\t    dm_frags[i][j] = 99;\n\n\t\t\tif (dm_frags[i][j] < -99)\n\t\t\t    dm_frags[i][j] = -99;\n\t\t\t\n\t\t\tstillticking = true;\n\t\t    }\n\t\t}\n\t\tdm_totals[i] = WI_fragSum(i);\n\n\t\tif (dm_totals[i] > 99)\n\t\t    dm_totals[i] = 99;\n\t\t\n\t\tif (dm_totals[i] < -99)\n\t\t    dm_totals[i] = -99;\n\t    }\n\t    \n\t}\n\tif (!stillticking)\n\t{\n\t    S_StartSound(0, sfx_barexp);\n\t    dm_state++;\n\t}\n\n    }\n    else if (dm_state == 4)\n    {\n\tif (acceleratestage)\n\t{\n\t    S_StartSound(0, sfx_slop);\n\n\t    if ( gamemode == commercial)\n\t\tWI_initNoState();\n\t    else\n\t\tWI_initShowNextLoc();\n\t}\n    }\n    else if (dm_state & 1)\n    {\n\tif (!--cnt_pause)\n\t{\n\t    dm_state++;\n\t    cnt_pause = TICRATE;\n\t}\n    }\n}\n\n\n\nvoid WI_drawDeathmatchStats(void)\n{\n\n    int\t\ti;\n    int\t\tj;\n    int\t\tx;\n    int\t\ty;\n    int\t\tw;\n\n    WI_slamBackground();\n    \n    // draw animated background\n    WI_drawAnimatedBack(); \n    WI_drawLF();\n\n    // draw stat titles (top line)\n    V_DrawPatch(DM_TOTALSX-SHORT(total->width)/2,\n\t\tDM_MATRIXY-WI_SPACINGY+10,\n\t\ttotal);\n    \n    V_DrawPatch(DM_KILLERSX, DM_KILLERSY, killers);\n    V_DrawPatch(DM_VICTIMSX, DM_VICTIMSY, victims);\n\n    // draw P?\n    x = DM_MATRIXX + DM_SPACINGX;\n    y = DM_MATRIXY;\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (playeringame[i])\n\t{\n\t    V_DrawPatch(x-SHORT(p[i]->width)/2,\n\t\t\tDM_MATRIXY - WI_SPACINGY,\n\t\t\tp[i]);\n\t    \n\t    V_DrawPatch(DM_MATRIXX-SHORT(p[i]->width)/2,\n\t\t\ty,\n\t\t\tp[i]);\n\n\t    if (i == me)\n\t    {\n\t\tV_DrawPatch(x-SHORT(p[i]->width)/2,\n\t\t\t    DM_MATRIXY - WI_SPACINGY,\n\t\t\t    bstar);\n\n\t\tV_DrawPatch(DM_MATRIXX-SHORT(p[i]->width)/2,\n\t\t\t    y,\n\t\t\t    star);\n\t    }\n\t}\n\tx += DM_SPACINGX;\n\ty += WI_SPACINGY;\n    }\n\n    // draw stats\n    y = DM_MATRIXY+10;\n    w = SHORT(num[0]->width);\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tx = DM_MATRIXX + DM_SPACINGX;\n\n\tif (playeringame[i])\n\t{\n\t    for (j=0 ; j<MAXPLAYERS ; j++)\n\t    {\n\t\tif (playeringame[j])\n\t\t    WI_drawNum(x+w, y, dm_frags[i][j], 2);\n\n\t\tx += DM_SPACINGX;\n\t    }\n\t    WI_drawNum(DM_TOTALSX+w, y, dm_totals[i], 2);\n\t}\n\ty += WI_SPACINGY;\n    }\n}\n\nstatic int\tcnt_frags[MAXPLAYERS];\nstatic int\tdofrags;\nstatic int\tng_state;\n\nvoid WI_initNetgameStats(void)\n{\n\n    int i;\n\n    state = StatCount;\n    acceleratestage = 0;\n    ng_state = 1;\n\n    cnt_pause = TICRATE;\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (!playeringame[i])\n\t    continue;\n\n\tcnt_kills[i] = cnt_items[i] = cnt_secret[i] = cnt_frags[i] = 0;\n\n\tdofrags += WI_fragSum(i);\n    }\n\n    dofrags = !!dofrags;\n\n    WI_initAnimatedBack();\n}\n\n\n\nvoid WI_updateNetgameStats(void)\n{\n\n    int\t\ti;\n    int\t\tfsum;\n    \n    boolean\tstillticking;\n\n    WI_updateAnimatedBack();\n\n    if (acceleratestage && ng_state != 10)\n    {\n\tacceleratestage = 0;\n\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (!playeringame[i])\n\t\tcontinue;\n\n\t    cnt_kills[i] = (plrs[i].skills * 100) / wbs->maxkills;\n\t    cnt_items[i] = (plrs[i].sitems * 100) / wbs->maxitems;\n\t    cnt_secret[i] = (plrs[i].ssecret * 100) / wbs->maxsecret;\n\n\t    if (dofrags)\n\t\tcnt_frags[i] = WI_fragSum(i);\n\t}\n\tS_StartSound(0, sfx_barexp);\n\tng_state = 10;\n    }\n\n    if (ng_state == 2)\n    {\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\n\tstillticking = false;\n\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (!playeringame[i])\n\t\tcontinue;\n\n\t    cnt_kills[i] += 2;\n\n\t    if (cnt_kills[i] >= (plrs[i].skills * 100) / wbs->maxkills)\n\t\tcnt_kills[i] = (plrs[i].skills * 100) / wbs->maxkills;\n\t    else\n\t\tstillticking = true;\n\t}\n\t\n\tif (!stillticking)\n\t{\n\t    S_StartSound(0, sfx_barexp);\n\t    ng_state++;\n\t}\n    }\n    else if (ng_state == 4)\n    {\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\n\tstillticking = false;\n\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (!playeringame[i])\n\t\tcontinue;\n\n\t    cnt_items[i] += 2;\n\t    if (cnt_items[i] >= (plrs[i].sitems * 100) / wbs->maxitems)\n\t\tcnt_items[i] = (plrs[i].sitems * 100) / wbs->maxitems;\n\t    else\n\t\tstillticking = true;\n\t}\n\tif (!stillticking)\n\t{\n\t    S_StartSound(0, sfx_barexp);\n\t    ng_state++;\n\t}\n    }\n    else if (ng_state == 6)\n    {\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\n\tstillticking = false;\n\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (!playeringame[i])\n\t\tcontinue;\n\n\t    cnt_secret[i] += 2;\n\n\t    if (cnt_secret[i] >= (plrs[i].ssecret * 100) / wbs->maxsecret)\n\t\tcnt_secret[i] = (plrs[i].ssecret * 100) / wbs->maxsecret;\n\t    else\n\t\tstillticking = true;\n\t}\n\t\n\tif (!stillticking)\n\t{\n\t    S_StartSound(0, sfx_barexp);\n\t    ng_state += 1 + 2*!dofrags;\n\t}\n    }\n    else if (ng_state == 8)\n    {\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\n\tstillticking = false;\n\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (!playeringame[i])\n\t\tcontinue;\n\n\t    cnt_frags[i] += 1;\n\n\t    if (cnt_frags[i] >= (fsum = WI_fragSum(i)))\n\t\tcnt_frags[i] = fsum;\n\t    else\n\t\tstillticking = true;\n\t}\n\t\n\tif (!stillticking)\n\t{\n\t    S_StartSound(0, sfx_pldeth);\n\t    ng_state++;\n\t}\n    }\n    else if (ng_state == 10)\n    {\n\tif (acceleratestage)\n\t{\n\t    S_StartSound(0, sfx_sgcock);\n\t    if ( gamemode == commercial )\n\t\tWI_initNoState();\n\t    else\n\t\tWI_initShowNextLoc();\n\t}\n    }\n    else if (ng_state & 1)\n    {\n\tif (!--cnt_pause)\n\t{\n\t    ng_state++;\n\t    cnt_pause = TICRATE;\n\t}\n    }\n}\n\n\n\nvoid WI_drawNetgameStats(void)\n{\n    int\t\ti;\n    int\t\tx;\n    int\t\ty;\n    int\t\tpwidth = SHORT(percent->width);\n\n    WI_slamBackground();\n    \n    // draw animated background\n    WI_drawAnimatedBack(); \n\n    WI_drawLF();\n\n    // draw stat titles (top line)\n    V_DrawPatch(NG_STATSX+NG_SPACINGX-SHORT(kills->width),\n\t\tNG_STATSY, kills);\n\n    V_DrawPatch(NG_STATSX+2*NG_SPACINGX-SHORT(items->width),\n\t\tNG_STATSY, items);\n\n    V_DrawPatch(NG_STATSX+3*NG_SPACINGX-SHORT(secret->width),\n\t\tNG_STATSY, secret);\n    \n    if (dofrags)\n\tV_DrawPatch(NG_STATSX+4*NG_SPACINGX-SHORT(frags->width),\n\t\t    NG_STATSY, frags);\n\n    // draw stats\n    y = NG_STATSY + SHORT(kills->height);\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (!playeringame[i])\n\t    continue;\n\n\tx = NG_STATSX;\n\tV_DrawPatch(x-SHORT(p[i]->width), y, p[i]);\n\n\tif (i == me)\n\t    V_DrawPatch(x-SHORT(p[i]->width), y, star);\n\n\tx += NG_SPACINGX;\n\tWI_drawPercent(x-pwidth, y+10, cnt_kills[i]);\tx += NG_SPACINGX;\n\tWI_drawPercent(x-pwidth, y+10, cnt_items[i]);\tx += NG_SPACINGX;\n\tWI_drawPercent(x-pwidth, y+10, cnt_secret[i]);\tx += NG_SPACINGX;\n\n\tif (dofrags)\n\t    WI_drawNum(x, y+10, cnt_frags[i], -1);\n\n\ty += WI_SPACINGY;\n    }\n\n}\n\nstatic int\tsp_state;\n\nvoid WI_initStats(void)\n{\n    state = StatCount;\n    acceleratestage = 0;\n    sp_state = 1;\n    cnt_kills[0] = cnt_items[0] = cnt_secret[0] = -1;\n    cnt_time = cnt_par = -1;\n    cnt_pause = TICRATE;\n\n    WI_initAnimatedBack();\n}\n\nvoid WI_updateStats(void)\n{\n\n    WI_updateAnimatedBack();\n\n    if (acceleratestage && sp_state != 10)\n    {\n\tacceleratestage = 0;\n\tcnt_kills[0] = (plrs[me].skills * 100) / wbs->maxkills;\n\tcnt_items[0] = (plrs[me].sitems * 100) / wbs->maxitems;\n\tcnt_secret[0] = (plrs[me].ssecret * 100) / wbs->maxsecret;\n\tcnt_time = plrs[me].stime / TICRATE;\n\tcnt_par = wbs->partime / TICRATE;\n\tS_StartSound(0, sfx_barexp);\n\tsp_state = 10;\n    }\n\n    if (sp_state == 2)\n    {\n\tcnt_kills[0] += 2;\n\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\n\tif (cnt_kills[0] >= (plrs[me].skills * 100) / wbs->maxkills)\n\t{\n\t    cnt_kills[0] = (plrs[me].skills * 100) / wbs->maxkills;\n\t    S_StartSound(0, sfx_barexp);\n\t    sp_state++;\n\t}\n    }\n    else if (sp_state == 4)\n    {\n\tcnt_items[0] += 2;\n\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\n\tif (cnt_items[0] >= (plrs[me].sitems * 100) / wbs->maxitems)\n\t{\n\t    cnt_items[0] = (plrs[me].sitems * 100) / wbs->maxitems;\n\t    S_StartSound(0, sfx_barexp);\n\t    sp_state++;\n\t}\n    }\n    else if (sp_state == 6)\n    {\n\tcnt_secret[0] += 2;\n\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\n\tif (cnt_secret[0] >= (plrs[me].ssecret * 100) / wbs->maxsecret)\n\t{\n\t    cnt_secret[0] = (plrs[me].ssecret * 100) / wbs->maxsecret;\n\t    S_StartSound(0, sfx_barexp);\n\t    sp_state++;\n\t}\n    }\n\n    else if (sp_state == 8)\n    {\n\tif (!(bcnt&3))\n\t    S_StartSound(0, sfx_pistol);\n\n\tcnt_time += 3;\n\n\tif (cnt_time >= plrs[me].stime / TICRATE)\n\t    cnt_time = plrs[me].stime / TICRATE;\n\n\tcnt_par += 3;\n\n\tif (cnt_par >= wbs->partime / TICRATE)\n\t{\n\t    cnt_par = wbs->partime / TICRATE;\n\n\t    if (cnt_time >= plrs[me].stime / TICRATE)\n\t    {\n\t\tS_StartSound(0, sfx_barexp);\n\t\tsp_state++;\n\t    }\n\t}\n    }\n    else if (sp_state == 10)\n    {\n\tif (acceleratestage)\n\t{\n\t    S_StartSound(0, sfx_sgcock);\n\n\t    if (gamemode == commercial)\n\t\tWI_initNoState();\n\t    else\n\t\tWI_initShowNextLoc();\n\t}\n    }\n    else if (sp_state & 1)\n    {\n\tif (!--cnt_pause)\n\t{\n\t    sp_state++;\n\t    cnt_pause = TICRATE;\n\t}\n    }\n\n}\n\n// [crispy] conditionally draw par times on intermission screen\nstatic boolean WI_drawParTime (void)\n{\n\textern int bex_pars[4][10], bex_cpars[32];\n\textern lumpinfo_t *maplumpinfo;\n\n\tboolean result = true;\n\n\t// [crispy] PWADs have no par times (including The Master Levels)\n\tif (!W_IsIWADLump(maplumpinfo))\n\t{\n\t\tresult = false;\n\t}\n\n\tif (gamemode == commercial)\n\t{\n\t\t// [crispy] IWAD: Final Doom has no par times\n\t\tif (gamemission == pack_tnt || gamemission == pack_plut)\n\t\t{\n\t\t\tresult = false;\n\t\t}\n\n\t\t// [crispy] PWAD: NRFTL has par times (for singleplayer games)\n\t\tif (gamemission == pack_nerve /*&& crispy->singleplayer*/)\n\t\t{\n\t\t\tresult = true;\n\t\t}\n\n\t\t// [crispy] IWAD/PWAD: BEX patch provided par times\n\t\tif (bex_cpars[wbs->last])\n\t\t{\n\t\t\tresult = true;\n\t\t}\n\t}\n\telse\n\t{\n\t\t// [crispy] IWAD/PWAD: BEX patch provided par times for Episode 4\n\t\t// (disguised as par times for Doom II MAP02 to MAP10)\n\t\tif (wbs->epsd >= 4 && bex_cpars[wbs->last + 1])\n\t\t{\n\t\t\tresult = true;\n\t\t}\n\n\t\t// [crispy] PWAD: BEX patch provided par times for Episodes 1-3\n\t\tif (wbs->epsd < 4 && bex_pars[wbs->epsd + 1][wbs->last + 1])\n\t\t{\n\t\t\tresult = true;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nvoid WI_drawStats(void)\n{\n    // line height\n    int lh;\t\n\n    lh = (3*SHORT(num[0]->height))/2;\n\n    WI_slamBackground();\n\n    // draw animated background\n    WI_drawAnimatedBack();\n    \n    WI_drawLF();\n\n    V_DrawPatch(SP_STATSX, SP_STATSY, kills);\n    WI_drawPercent(SCREENWIDTH - SP_STATSX, SP_STATSY, cnt_kills[0]);\n\n    V_DrawPatch(SP_STATSX, SP_STATSY+lh, items);\n    WI_drawPercent(SCREENWIDTH - SP_STATSX, SP_STATSY+lh, cnt_items[0]);\n\n    V_DrawPatch(SP_STATSX, SP_STATSY+2*lh, sp_secret);\n    WI_drawPercent(SCREENWIDTH - SP_STATSX, SP_STATSY+2*lh, cnt_secret[0]);\n\n    V_DrawPatch(SP_TIMEX, SP_TIMEY, timepatch);\n    WI_drawTime(SCREENWIDTH/2 - SP_TIMEX, SP_TIMEY, cnt_time);\n\n\t// [crispy] conditionally draw par times on intermission screen\n    if (WI_drawParTime())\n    {\n        V_DrawPatch(SCREENWIDTH/2 + SP_TIMEX, SP_TIMEY, par);\n\n        // Emulation: don't draw partime value if map33\n        if (gamemode != commercial || wbs->last != NUMCMAPS)\n        {\n            WI_drawTime(SCREENWIDTH - SP_TIMEX, SP_TIMEY, cnt_par);\n        }\n    }\n\n}\n\nvoid WI_checkForAccelerate(void)\n{\n    int   i;\n    player_t  *player;\n\n    // check for button presses to skip delays\n    for (i=0, player = players ; i<MAXPLAYERS ; i++, player++)\n    {\n\tif (playeringame[i])\n\t{\n\t    if (player->cmd.buttons & BT_ATTACK)\n\t    {\n\t\tif (!player->attackdown)\n\t\t    acceleratestage = 1;\n\t\tplayer->attackdown = true;\n\t    }\n\t    else\n\t\tplayer->attackdown = false;\n\t    if (player->cmd.buttons & BT_USE)\n\t    {\n\t\tif (!player->usedown)\n\t\t    acceleratestage = 1;\n\t\tplayer->usedown = true;\n\t    }\n\t    else\n\t\tplayer->usedown = false;\n\t}\n    }\n}\n\n\n\n// Updates stuff each tick\nvoid WI_Ticker(void)\n{\n    // counter for general background animation\n    bcnt++;  \n\n    if (bcnt == 1)\n    {\n\t// intermission music\n  \tif ( gamemode == commercial )\n\t  S_ChangeMusic(mus_dm2int, true);\n\telse\n\t  S_ChangeMusic(mus_inter, true); \n    }\n\n    WI_checkForAccelerate();\n\n    switch (state)\n    {\n      case StatCount:\n\tif (deathmatch) WI_updateDeathmatchStats();\n\telse if (netgame) WI_updateNetgameStats();\n\telse WI_updateStats();\n\tbreak;\n\t\n      case ShowNextLoc:\n\tWI_updateShowNextLoc();\n\tbreak;\n\t\n      case NoState:\n\tWI_updateNoState();\n\tbreak;\n    }\n\n}\n\ntypedef void (*load_callback_t)(const char *lumpname, patch_t **variable);\n\n// Common load/unload function.  Iterates over all the graphics\n// lumps to be loaded/unloaded into memory.\n\nstatic void WI_loadUnloadData(load_callback_t callback)\n{\n    int i, j;\n    char name[9];\n    anim_t *a;\n\n\tif (nervewadfile && gamemission == pack_nerve)\n    {\n\tfor (i=0 ; i<9 ; i++)\n\t{\n\t    DEH_snprintf(name, 9, \"NWILV%2.2d\", i);\n            callback(name, &lnames[i]);\n\t}\n\tfor ( ; i<NUMCMAPS ; i++)\n\t{\n\t    DEH_snprintf(name, 9, \"CWILV%2.2d\", i);\n            callback(name, &lnames[i]);\n\t}\n    }\n    else\n    if (gamemode == commercial)\n    {\n\tfor (i=0 ; i<NUMCMAPS ; i++)\n\t{\n\t    DEH_snprintf(name, 9, \"CWILV%2.2d\", i);\n            callback(name, &lnames[i]);\n\t}\n    }\n    else\n    {\n\tfor (i=0 ; i<NUMMAPS ; i++)\n\t{\n\t    DEH_snprintf(name, 9, \"WILV%d%d\", wbs->epsd, i);\n            callback(name, &lnames[i]);\n\t}\n\t// [crispy] special-casing for E1M10 \"Sewers\" support\n\tif (havee1m10)\n\t{\n\t    DEH_snprintf(name, 9, \"SEWERS\");\n\t    callback(name, &lnames[i]);\n\t}\n\n\t// you are here\n        callback(DEH_String(\"WIURH0\"), &yah[0]);\n\n\t// you are here (alt.)\n        callback(DEH_String(\"WIURH1\"), &yah[1]);\n\n\t// splat\n        callback(DEH_String(\"WISPLAT\"), &splat[0]);\n\n\tif (wbs->epsd < 3)\n\t{\n\t    for (j=0;j<NUMANIMS[wbs->epsd];j++)\n\t    {\n\t\ta = &anims[wbs->epsd][j];\n\t\tfor (i=0;i<a->nanims;i++)\n\t\t{\n\t\t    // MONDO HACK!\n\t\t    if (wbs->epsd != 1 || j != 8)\n\t\t    {\n\t\t\t// animations\n\t\t\tDEH_snprintf(name, 9, \"WIA%d%.2d%.2d\", wbs->epsd, j, i);\n                        callback(name, &a->p[i]);\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t// HACK ALERT!\n\t\t\ta->p[i] = anims[1][4].p[i];\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    // More hacks on minus sign.\n    callback(DEH_String(\"WIMINUS\"), &wiminus);\n\n    for (i=0;i<10;i++)\n    {\n\t // numbers 0-9\n\tDEH_snprintf(name, 9, \"WINUM%d\", i);\n        callback(name, &num[i]);\n    }\n\n    // percent sign\n    callback(DEH_String(\"WIPCNT\"), &percent);\n\n    // \"finished\"\n    callback(DEH_String(\"WIF\"), &finished);\n\n    // \"entering\"\n    callback(DEH_String(\"WIENTER\"), &entering);\n\n    // \"kills\"\n    callback(DEH_String(\"WIOSTK\"), &kills);\n\n    // \"scrt\"\n    callback(DEH_String(\"WIOSTS\"), &secret);\n\n     // \"secret\"\n    callback(DEH_String(\"WISCRT2\"), &sp_secret);\n\n    // french wad uses WIOBJ (?)\n    if (W_CheckNumForName(DEH_String(\"WIOBJ\")) >= 0)\n    {\n    \t// \"items\"\n    \tif (netgame && !deathmatch)\n            callback(DEH_String(\"WIOBJ\"), &items);\n    \telse\n            callback(DEH_String(\"WIOSTI\"), &items);\n    } else {\n        callback(DEH_String(\"WIOSTI\"), &items);\n    }\n\n    // \"frgs\"\n    callback(DEH_String(\"WIFRGS\"), &frags);\n\n    // \":\"\n    callback(DEH_String(\"WICOLON\"), &colon);\n\n    // \"time\"\n    callback(DEH_String(\"WITIME\"), &timepatch);\n\n    // \"sucks\"\n    callback(DEH_String(\"WISUCKS\"), &sucks);\n\n    // \"par\"\n    callback(DEH_String(\"WIPAR\"), &par);\n\n    // \"killers\" (vertical)\n    callback(DEH_String(\"WIKILRS\"), &killers);\n\n    // \"victims\" (horiz)\n    callback(DEH_String(\"WIVCTMS\"), &victims);\n\n    // \"total\"\n    callback(DEH_String(\"WIMSTT\"), &total);\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\t// \"1,2,3,4\"\n\tDEH_snprintf(name, 9, \"STPB%d\", i);\n        callback(name, &p[i]);\n\n\t// \"1,2,3,4\"\n\tDEH_snprintf(name, 9, \"WIBP%d\", i+1);\n        callback(name, &bp[i]);\n    }\n\n    // Background image\n\n    if (gamemode == commercial)\n    {\n        M_StringCopy(name, DEH_String(\"INTERPIC\"), sizeof(name));\n    }\n    else if (gameversion >= exe_ultimate && wbs->epsd == 3)\n    {\n        M_StringCopy(name, DEH_String(\"INTERPIC\"), sizeof(name));\n    }\n    else\n    {\n\tDEH_snprintf(name, sizeof(name), \"WIMAP%d\", wbs->epsd);\n    }\n\n    // Draw backdrop and save to a temporary buffer\n\n    callback(name, &background);\n}\n\nstatic void WI_loadCallback(const char *name, patch_t **variable)\n{\n    *variable = W_CacheLumpName(name, PU_STATIC);\n}\n\nvoid WI_loadData(void)\n{\n    if (gamemode == commercial)\n    {\n\tNUMCMAPS = (havemap33) ? 33 : 32;\n\tlnames = (patch_t **) Z_Malloc(sizeof(patch_t*) * NUMCMAPS,\n\t\t\t\t       PU_STATIC, NULL);\n    }\n    else\n    {\n\t// [crispy] support E1M10 \"Sewers\"\n\tint nummaps = havee1m10 ? NUMMAPS + 1 : NUMMAPS;\n\tlnames = (patch_t **) Z_Malloc(sizeof(patch_t*) * nummaps,\n\t\t\t\t       PU_STATIC, NULL);\n    }\n\n    WI_loadUnloadData(WI_loadCallback);\n\n    // These two graphics are special cased because we're sharing\n    // them with the status bar code\n\n    // your face\n    star = W_CacheLumpName(DEH_String(\"STFST01\"), PU_STATIC);\n\n    // dead face\n    bstar = W_CacheLumpName(DEH_String(\"STFDEAD0\"), PU_STATIC);\n}\n\nstatic void WI_unloadCallback(const char *name, patch_t **variable)\n{\n    W_ReleaseLumpName(name);\n    *variable = NULL;\n}\n\nvoid WI_unloadData(void)\n{\n    WI_loadUnloadData(WI_unloadCallback);\n}\n\nvoid WI_Drawer (void)\n{\n    switch (state)\n    {\n      case StatCount:\n\tif (deathmatch)\n\t    WI_drawDeathmatchStats();\n\telse if (netgame)\n\t    WI_drawNetgameStats();\n\telse\n\t    WI_drawStats();\n\tbreak;\n\t\n      case ShowNextLoc:\n\tWI_drawShowNextLoc();\n\tbreak;\n\t\n      case NoState:\n\tWI_drawNoState();\n\tbreak;\n    }\n}\n\n\nvoid WI_initVariables(wbstartstruct_t* wbstartstruct)\n{\n\n    wbs = wbstartstruct;\n\n#ifdef RANGECHECKING\n    if (gamemode != commercial)\n    {\n      if (gameversion >= exe_ultimate)\n\tRNGCHECK(wbs->epsd, 0, 3);\n      else\n\tRNGCHECK(wbs->epsd, 0, 2);\n    }\n    else\n    {\n\tRNGCHECK(wbs->last, 0, 8);\n\tRNGCHECK(wbs->next, 0, 8);\n    }\n    RNGCHECK(wbs->pnum, 0, MAXPLAYERS);\n    RNGCHECK(wbs->pnum, 0, MAXPLAYERS);\n#endif\n\n    acceleratestage = 0;\n    cnt = bcnt = 0;\n    firstrefresh = 1;\n    me = wbs->pnum;\n    plrs = wbs->plyr;\n\n    if (!wbs->maxkills)\n\twbs->maxkills = 1;\n\n    if (!wbs->maxitems)\n\twbs->maxitems = 1;\n\n    if (!wbs->maxsecret)\n\twbs->maxsecret = 1;\n\n    if ( gameversion < exe_ultimate )\n      if (wbs->epsd > 2)\n\twbs->epsd -= 3;\n}\n\nvoid WI_Start(wbstartstruct_t* wbstartstruct)\n{\n    WI_initVariables(wbstartstruct);\n    WI_loadData();\n\n    if (deathmatch)\n\tWI_initDeathmatchStats();\n    else if (netgame)\n\tWI_initNetgameStats();\n    else\n\tWI_initStats();\n}\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//    Exit text-mode ENDOOM screen.\n//\n\n#include <stdio.h>\n#include <string.h>\n\n#include <emscripten.h>\n\n#include \"config.h\"\n#include \"doomtype.h\"\n#include \"i_video.h\"\n\n#include \"i_txt.h\"\n\n#define ENDOOM_W 80\n#define ENDOOM_H 25\n\n// \n// Displays the text mode ending screen after the game quits\n//\n\nvoid I_Endoom(byte *endoom_data)\n{\n    unsigned char *screendata;\n    int y;\n    int indent;\n\n    // Set up text mode screen\n\n    TXT_Init();\n\n    // Write the data to the screen memory\n\n    screendata = TXT_GetScreenData();\n\n    indent = (ENDOOM_W - TXT_SCREEN_W) / 2;\n\n    for (y=0; y<TXT_SCREEN_H; ++y)\n    {\n        memcpy(screendata + (y * TXT_SCREEN_W * 2),\n               endoom_data + (y * ENDOOM_W + indent) * 2,\n               TXT_SCREEN_W * 2);\n    }\n\n    TXT_UpdateScreen();\n\n    EM_ASM(\n        if (Module && Module.canvas && typeof Module.canvas.calcRatio == \"function\"){\n            Module.canvas.calcRatio(true);\n        }\n    );\n\n    // Shut down text mode screen\n\n    TXT_Shutdown();\n\n    EM_ASM(\n        document.dispatchEvent(new CustomEvent(\"I_Endoom\", { detail: {} }));\n    );\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//     SDL implementation of system-specific input interface.\n//\n\n\n#include \"SDL.h\"\n#include \"SDL_keycode.h\"\n\n#include \"doomkeys.h\"\n#include \"doomtype.h\"\n#include \"d_event.h\"\n#include \"i_input.h\"\n#include \"m_argv.h\"\n#include \"m_config.h\"\n\n#include <emscripten.h>\n\nstatic const int scancode_translate_table[] = SCANCODE_TO_KEYS_ARRAY;\n\n// Lookup table for mapping ASCII characters to their equivalent when\n// shift is pressed on a US layout keyboard. This is the original table\n// as found in the Doom sources, comments and all.\nstatic const char shiftxform[] =\n{\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n    11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n    21, 22, 23, 24, 25, 26, 27, 28, 29, 30,\n    31, ' ', '!', '\"', '#', '$', '%', '&',\n    '\"', // shift-'\n    '(', ')', '*', '+',\n    '<', // shift-,\n    '_', // shift--\n    '>', // shift-.\n    '?', // shift-/\n    ')', // shift-0\n    '!', // shift-1\n    '@', // shift-2\n    '#', // shift-3\n    '$', // shift-4\n    '%', // shift-5\n    '^', // shift-6\n    '&', // shift-7\n    '*', // shift-8\n    '(', // shift-9\n    ':',\n    ':', // shift-;\n    '<',\n    '+', // shift-=\n    '>', '?', '@',\n    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n    'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    '[', // shift-[\n    '!', // shift-backslash - OH MY GOD DOES WATCOM SUCK\n    ']', // shift-]\n    '\"', '_',\n    '\\'', // shift-`\n    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N',\n    'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n    '{', '|', '}', '~', 127\n};\n\n// If true, I_StartTextInput() has been called, and we are populating\n// the data3 field of ev_keydown events.\nstatic boolean text_input_enabled = true;\n\n// Bit mask of mouse button state.\nstatic unsigned int mouse_button_state = 0;\n\n// Disallow mouse and joystick movement to cause forward/backward\n// motion.  Specified with the '-novert' command line parameter.\n// This is an int to allow saving to config file\nint novert = 0;\n\n// If true, keyboard mapping is ignored, like in Vanilla Doom.\n// The sensible thing to do is to disable this if you have a non-US\n// keyboard.\n\nint vanilla_keyboard_mapping = true;\n\n// Mouse acceleration\n//\n// This emulates some of the behavior of DOS mouse drivers by increasing\n// the speed when the mouse is moved fast.\n//\n// The mouse input values are input directly to the game, but when\n// the values exceed the value of mouse_threshold, they are multiplied\n// by mouse_acceleration to increase the speed.\nfloat mouse_acceleration = 2.0;\nint mouse_threshold = 10;\n\n// Translates the SDL key to a value of the type found in doomkeys.h\nstatic int TranslateKey(SDL_Keysym *sym)\n{\n    int scancode = sym->scancode;\n\n    switch (scancode)\n    {\n        case SDL_SCANCODE_LCTRL:\n        case SDL_SCANCODE_RCTRL:\n            return KEY_RCTRL;\n\n        case SDL_SCANCODE_LSHIFT:\n        case SDL_SCANCODE_RSHIFT:\n            return KEY_RSHIFT;\n\n        case SDL_SCANCODE_LALT:\n            return KEY_LALT;\n\n        case SDL_SCANCODE_RALT:\n            return KEY_RALT;\n\n        default:\n            if (scancode >= 0 && scancode < arrlen(scancode_translate_table))\n            {\n                return scancode_translate_table[scancode];\n            }\n            else\n            {\n                return 0;\n            }\n    }\n}\n\n// Get the localized version of the key press. This takes into account the\n// keyboard layout, but does not apply any changes due to modifiers, (eg.\n// shift-, alt-, etc.)\nstatic int GetLocalizedKey(SDL_Keysym *sym)\n{\n    // When using Vanilla mapping, we just base everything off the scancode\n    // and always pretend the user is using a US layout keyboard.\n    if (vanilla_keyboard_mapping)\n    {\n        return TranslateKey(sym);\n    }\n    else\n    {\n        int result = sym->sym;\n\n        if (result < 0 || result >= 128)\n        {\n            result = 0;\n        }\n\n        return result;\n    }\n}\n\n// Get the equivalent ASCII (Unicode?) character for a keypress.\nstatic int GetTypedChar(SDL_Keysym *sym)\n{\n    // We only return typed characters when entering text, after\n    // I_StartTextInput() has been called. Otherwise we return nothing.\n    if (!text_input_enabled)\n    {\n        return 0;\n    }\n\n    // If we're strictly emulating Vanilla, we should always act like\n    // we're using a US layout keyboard (in ev_keydown, data1=data2).\n    // Otherwise we should use the native key mapping.\n    if (vanilla_keyboard_mapping)\n    {\n        int result = TranslateKey(sym);\n\n        // If shift is held down, apply the original uppercase\n        // translation table used under DOS.\n        if ((SDL_GetModState() & KMOD_SHIFT) != 0\n         && result >= 0 && result < arrlen(shiftxform))\n        {\n            result = shiftxform[result];\n        }\n\n        return result;\n    }\n    else\n    {\n        SDL_Event next_event;\n\n        // Special cases, where we always return a fixed value.\n        switch (sym->sym)\n        {\n            case SDLK_BACKSPACE: return KEY_BACKSPACE;\n            case SDLK_RETURN:    return KEY_ENTER;\n            default:\n                break;\n        }\n\n        // The following is a gross hack, but I don't see an easier way\n        // of doing this within the SDL2 API (in SDL1 it was easier).\n        // We want to get the fully transformed input character associated\n        // with this keypress - correct keyboard layout, appropriately\n        // transformed by any modifier keys, etc. So peek ahead in the SDL\n        // event queue and see if the key press is immediately followed by\n        // an SDL_TEXTINPUT event. If it is, it's reasonable to assume the\n        // key press and the text input are connected. Technically the SDL\n        // API does not guarantee anything of the sort, but in practice this\n        // is what happens and I've verified it through manual inspect of\n        // the SDL source code.\n        //\n        // In an ideal world we'd split out ev_keydown into a separate\n        // ev_textinput event, as SDL2 has done. But this doesn't work\n        // (I experimented with the idea), because lots of Doom's code is\n        // based around different responders \"eating\" events to stop them\n        // being passed on to another responder. If code is listening for\n        // a text input, it cannot block the corresponding keydown events\n        // which can affect other responders.\n        //\n        // So we're stuck with this as a rather fragile alternative.\n\n        if (SDL_PeepEvents(&next_event, 1, SDL_PEEKEVENT,\n                           SDL_FIRSTEVENT, SDL_LASTEVENT) == 1\n         && next_event.type == SDL_TEXTINPUT)\n        {\n            // If an SDL_TEXTINPUT event is found, we always assume it\n            // matches the key press. The input text must be a single\n            // ASCII character - if it isn't, it's possible the input\n            // char is a Unicode value instead; better to send a null\n            // character than the unshifted key.\n            if (strlen(next_event.text.text) == 1\n             && (next_event.text.text[0] & 0x80) == 0)\n            {\n                return next_event.text.text[0];\n            }\n        }\n\n        // Failed to find anything :/\n        return 0;\n    }\n}\n\nvoid I_HandleKeyboardEvent(SDL_Event *sdlevent)\n{\n    // XXX: passing pointers to event for access after this function\n    // has terminated is undefined behaviour\n    event_t event;\n\n    switch (sdlevent->type)\n    {\n        case SDL_KEYDOWN:\n            event.type = ev_keydown;\n            event.data1 = TranslateKey(&sdlevent->key.keysym);\n            event.data2 = GetLocalizedKey(&sdlevent->key.keysym);\n            event.data3 = GetTypedChar(&sdlevent->key.keysym);\n\n            if (event.data1 != 0 && !D_EqualsEventHead(&event))\n            {\n                D_PostEvent(&event);\n            }\n            break;\n\n        case SDL_KEYUP:\n            event.type = ev_keyup;\n            event.data1 = TranslateKey(&sdlevent->key.keysym);\n\n            // data2/data3 are initialized to zero for ev_keyup.\n            // For ev_keydown it's the shifted Unicode character\n            // that was typed, but if something wants to detect\n            // key releases it should do so based on data1\n            // (key ID), not the printable char.\n\n            event.data2 = 0;\n            event.data3 = 0;\n\n            if (event.data1 != 0)\n            {\n                D_PostEvent(&event);\n            }\n            break;\n\n        default:\n            break;\n    }\n}\n\nvoid I_StartTextInput(int x1, int y1, int x2, int y2)\n{\n    text_input_enabled = true;\n\n    if (!vanilla_keyboard_mapping)\n    {\n        // SDL2-TODO: SDL_SetTextInputRect(...);\n        SDL_StartTextInput();\n    }\n}\n\nvoid I_StopTextInput(void)\n{\n    text_input_enabled = false;\n\n    if (!vanilla_keyboard_mapping)\n    {\n        SDL_StopTextInput();\n    }\n}\n\nstatic void UpdateMouseButtonState(unsigned int button, boolean on)\n{\n    static event_t event;\n\n    if (button < SDL_BUTTON_LEFT || button > MAX_MOUSE_BUTTONS)\n    {\n        return;\n    }\n\n    // Note: button \"0\" is left, button \"1\" is right,\n    // button \"2\" is middle for Doom.  This is different\n    // to how SDL sees things.\n\n    switch (button)\n    {\n        case SDL_BUTTON_LEFT:\n            button = 0;\n            break;\n\n        case SDL_BUTTON_RIGHT:\n            button = 1;\n            break;\n\n        case SDL_BUTTON_MIDDLE:\n            button = 2;\n            break;\n\n        default:\n            // SDL buttons are indexed from 1.\n            --button;\n            break;\n    }\n\n    // Turn bit representing this button on or off.\n\n    if (on)\n    {\n        mouse_button_state |= (1 << button);\n    }\n    else\n    {\n        mouse_button_state &= ~(1 << button);\n    }\n\n    // Post an event with the new button state.\n\n    event.type = ev_mouse;\n    event.data1 = mouse_button_state;\n    event.data2 = event.data3 = 0;\n    D_PostEvent(&event);\n}\n\nstatic void MapMouseWheelToButtons(SDL_MouseWheelEvent *wheel)\n{\n    // SDL2 distinguishes button events from mouse wheel events.\n    // We want to treat the mouse wheel as two buttons, as per\n    // SDL1\n    static event_t up, down;\n    int button;\n\n    if (wheel->y <= 0)\n    {   // scroll down\n        button = 4;\n    }\n    else\n    {   // scroll up\n        button = 3;\n    }\n\n    // post a button down event\n    mouse_button_state |= (1 << button);\n    down.type = ev_mouse;\n    down.data1 = mouse_button_state;\n    down.data2 = down.data3 = 0;\n    D_PostEvent(&down);\n\n    // post a button up event\n    mouse_button_state &= ~(1 << button);\n    up.type = ev_mouse;\n    up.data1 = mouse_button_state;\n    up.data2 = up.data3 = 0;\n    D_PostEvent(&up);\n}\n\nvoid I_HandleMouseEvent(SDL_Event *sdlevent)\n{\n    switch (sdlevent->type)\n    {\n        case SDL_MOUSEBUTTONDOWN:\n            UpdateMouseButtonState(sdlevent->button.button, true);\n            break;\n\n        case SDL_MOUSEBUTTONUP:\n            UpdateMouseButtonState(sdlevent->button.button, false);\n            break;\n\n        case SDL_MOUSEWHEEL:\n            MapMouseWheelToButtons(&(sdlevent->wheel));\n            break;\n\n        default:\n            break;\n    }\n}\n\nstatic int AccelerateMouse(int val)\n{\n    if (val < 0)\n        return -AccelerateMouse(-val);\n\n    if (val > mouse_threshold)\n    {\n        return (int)((val - mouse_threshold) * mouse_acceleration + mouse_threshold);\n    }\n    else\n    {\n        return val;\n    }\n}\n\n//\n// Read the change in mouse state to generate mouse motion events\n//\n// This is to combine all mouse movement for a tic into one mouse\n// motion event.\nvoid I_ReadMouse(void)\n{\n    int x, y;\n    event_t ev;\n\n    SDL_GetRelativeMouseState(&x, &y);\n\n    if (x != 0 || y != 0) \n    {\n        ev.type = ev_mouse;\n        ev.data1 = mouse_button_state;\n        ev.data2 = AccelerateMouse(x);\n\n        if (!novert)\n        {\n            ev.data3 = -AccelerateMouse(y);\n        }\n        else\n        {\n            ev.data3 = 0;\n        }\n\n        // XXX: undefined behaviour since event is scoped to\n        // this function\n        D_PostEvent(&ev);\n    }\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid I_TouchMoveEvent(int x, int y)\n{\n    event_t ev;\n\n    if (x != 0 || y != 0) \n    {\n        ev.type = ev_mouse;\n        ev.data1 = mouse_button_state;\n        ev.data2 = AccelerateMouse(x);\n\n        if (!novert)\n        {\n            ev.data3 = -AccelerateMouse(y);\n        }\n        else\n        {\n            ev.data3 = 0;\n        }\n\n        // XXX: undefined behaviour since event is scoped to\n        // this function\n        D_PostEvent(&ev);\n    }\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid I_UpdateMouseButtonState(unsigned int button, boolean on){\n    UpdateMouseButtonState(button, on);\n}\n\n// Bind all variables controlling input options.\nvoid I_BindInputVariables(void)\n{\n    M_BindFloatVariable(\"mouse_acceleration\",      &mouse_acceleration);\n    M_BindIntVariable(\"mouse_threshold\",           &mouse_threshold);\n    M_BindIntVariable(\"vanilla_keyboard_mapping\",  &vanilla_keyboard_mapping);\n    M_BindIntVariable(\"novert\",                    &novert);\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tPreparation of data for rendering,\n//\tgeneration of lookups, caching, retrieval by name.\n//\n\n#include <stdio.h>\n\n#include \"deh_main.h\"\n#include \"i_swap.h\"\n#include \"i_system.h\"\n#include \"z_zone.h\"\n\n\n#include \"w_wad.h\"\n\n#include \"doomdef.h\"\n#include \"m_misc.h\"\n#include \"r_local.h\"\n#include \"p_local.h\"\n\n#include \"doomstat.h\"\n#include \"r_sky.h\"\n\n\n#include \"r_data.h\"\n#include \"v_trans.h\" // [crispy] tranmap, CRMAX\n#include \"r_bmaps.h\" // [crispy] R_BrightmapForTexName()\n\n//\n// Graphics.\n// DOOM graphics for walls and sprites\n// is stored in vertical runs of opaque pixels (posts).\n// A column is composed of zero or more posts,\n// a patch or sprite is composed of zero or more columns.\n// \n\n\n\n//\n// Texture definition.\n// Each texture is composed of one or more patches,\n// with patches being lumps stored in the WAD.\n// The lumps are referenced by number, and patched\n// into the rectangular texture space using origin\n// and possibly other attributes.\n//\ntypedef PACKED_STRUCT (\n{\n    short\toriginx;\n    short\toriginy;\n    short\tpatch;\n    short\tstepdir;\n    short\tcolormap;\n}) mappatch_t;\n\n\n//\n// Texture definition.\n// A DOOM wall texture is a list of patches\n// which are to be combined in a predefined order.\n//\ntypedef PACKED_STRUCT (\n{\n    char\t\tname[8];\n    int\t\t\tmasked;\t\n    short\t\twidth;\n    short\t\theight;\n    int                 obsolete;\n    short\t\tpatchcount;\n    mappatch_t\tpatches[1];\n}) maptexture_t;\n\n\n// A single patch from a texture definition,\n//  basically a rectangular area within\n//  the texture rectangle.\ntypedef struct\n{\n    // Block origin (allways UL),\n    // which has allready accounted\n    // for the internal origin of the patch.\n    short\toriginx;\t\n    short\toriginy;\n    int\t\tpatch;\n} texpatch_t;\n\n\n// A maptexturedef_t describes a rectangular texture,\n//  which is composed of one or more mappatch_t structures\n//  that arrange graphic patches.\n\ntypedef struct texture_s texture_t;\n\nstruct texture_s\n{\n    // Keep name for switch changing, etc.\n    char\tname[8];\t\t\n    short\twidth;\n    short\theight;\n\n    // Index in textures list\n\n    int         index;\n\n    // Next in hash table chain\n\n    texture_t  *next;\n    \n    // All the patches[patchcount]\n    //  are drawn back to front into the cached texture.\n    short\tpatchcount;\n    texpatch_t\tpatches[1];\t\t\n};\n\n// killough 4/17/98: make firstcolormaplump,lastcolormaplump external\nint firstcolormaplump, lastcolormaplump;      // killough 4/17/98\n\nint\t\tfirstflat;\nint\t\tlastflat;\nint\t\tnumflats;\n\nint\t\tfirstpatch;\nint\t\tlastpatch;\nint\t\tnumpatches;\n\nint\t\tfirstspritelump;\nint\t\tlastspritelump;\nint\t\tnumspritelumps;\n\nint\t\tnumtextures;\ntexture_t**\ttextures;\ntexture_t**     textures_hashtable;\n\n\nint*\t\t\ttexturewidthmask;\n// needed for texture pegging\nfixed_t*\t\ttextureheight;\t\t\nint*\t\t\ttexturecompositesize;\nshort**\t\t\ttexturecolumnlump;\nunsigned**\t\ttexturecolumnofs; // killough 4/9/98: make 32-bit\nunsigned**\t\ttexturecolumnofs2; // [crispy] original column offsets for single-patched textures\nbyte**\t\t\ttexturecomposite;\nbyte**\t\t\ttexturebrightmap; // [crispy] brightmaps\n\n// for global animation\nint*\t\tflattranslation;\nint*\t\ttexturetranslation;\n\n// needed for pre rendering\nfixed_t*\tspritewidth;\t\nfixed_t*\tspriteoffset;\nfixed_t*\tspritetopoffset;\n\nlighttable_t\t**colormaps;\n\n\n//\n// MAPTEXTURE_T CACHING\n// When a texture is first needed,\n//  it counts the number of composite columns\n//  required in the texture and allocates space\n//  for a column directory and any new columns.\n// The directory will simply point inside other patches\n//  if there is only one patch in a given column,\n//  but any columns with multiple patches\n//  will have new column_ts generated.\n//\n\n\n\n// [crispy] replace R_DrawColumnInCache(), R_GenerateComposite() and R_GenerateLookup()\n// with Lee Killough's implementations found in MBF to fix Medusa bug\n// taken from mbfsrc/R_DATA.C:136-425\n//\n// R_DrawColumnInCache\n// Clip and draw a column\n//  from a patch into a cached post.\n//\n// Rewritten by Lee Killough for performance and to fix Medusa bug\n//\n\nvoid\nR_DrawColumnInCache\n( column_t*\tpatch,\n  byte*\t\tcache,\n  int\t\toriginy,\n  int\t\tcacheheight,\n  byte*\t\tmarks )\n{\n    int\t\tcount;\n    int\t\tposition;\n    byte*\tsource;\n    int\t\ttop = -1;\n\n    while (patch->topdelta != 0xff)\n    {\n\t// [crispy] support for DeePsea tall patches\n\tif (patch->topdelta <= top)\n\t{\n\t\ttop += patch->topdelta;\n\t}\n\telse\n\t{\n\t\ttop = patch->topdelta;\n\t}\n\tsource = (byte *)patch + 3;\n\tcount = patch->length;\n\tposition = originy + top;\n\n\tif (position < 0)\n\t{\n\t    count += position;\n\t    position = 0;\n\t}\n\n\tif (position + count > cacheheight)\n\t    count = cacheheight - position;\n\n\tif (count > 0)\n\t{\n\t    memcpy (cache + position, source, count);\n\n\t    // killough 4/9/98: remember which cells in column have been drawn,\n\t    // so that column can later be converted into a series of posts, to\n\t    // fix the Medusa bug.\n\n\t    memset (marks + position, 0xff, count);\n\t}\n\t\t\n\tpatch = (column_t *)(  (byte *)patch + patch->length + 4); \n    }\n}\n\n\n\n//\n// R_GenerateComposite\n// Using the texture definition,\n//  the composite texture is created from the patches,\n//  and each column is cached.\n//\n// Rewritten by Lee Killough for performance and to fix Medusa bug\n\nvoid R_GenerateComposite (int texnum)\n{\n    byte*\t\tblock;\n    texture_t*\t\ttexture;\n    texpatch_t*\t\tpatch;\t\n    patch_t*\t\trealpatch;\n    int\t\t\tx;\n    int\t\t\tx1;\n    int\t\t\tx2;\n    int\t\t\ti;\n    column_t*\t\tpatchcol;\n    short*\t\tcollump;\n    unsigned*\t\tcolofs; // killough 4/9/98: make 32-bit\n    byte*\t\tmarks; // killough 4/9/98: transparency marks\n    byte*\t\tsource; // killough 4/9/98: temporary column\n\t\n    texture = textures[texnum];\n\n    block = Z_Malloc (texturecompositesize[texnum],\n\t\t      PU_STATIC, \n\t\t      &texturecomposite[texnum]);\t\n\n    collump = texturecolumnlump[texnum];\n    colofs = texturecolumnofs[texnum];\n    \n    // Composite the columns together.\n    patch = texture->patches;\n\t\t\n    // killough 4/9/98: marks to identify transparent regions in merged textures\n    marks = calloc(texture->width, texture->height);\n\n    // [crispy] initialize composite background to black (index 0)\n    memset(block, 0, texturecompositesize[texnum]);\n\n    for (i=0 , patch = texture->patches;\n\t i<texture->patchcount;\n\t i++, patch++)\n    {\n\trealpatch = W_CacheLumpNum (patch->patch, PU_CACHE);\n\tx1 = patch->originx;\n\tx2 = x1 + SHORT(realpatch->width);\n\n\tif (x1<0)\n\t    x = 0;\n\telse\n\t    x = x1;\n\t\n\tif (x2 > texture->width)\n\t    x2 = texture->width;\n\n\tfor ( ; x<x2 ; x++)\n\t{\n\t    patchcol = (column_t *)((byte *)realpatch\n\t\t\t\t    + LONG(realpatch->columnofs[x-x1]));\n\t    R_DrawColumnInCache (patchcol,\n\t\t\t\t block + colofs[x],\n\t\t\t\t // [crispy] single-patched columns are normally not composited\n\t\t\t\t // but directly read from the patch lump ignoring their originy\n\t\t\t\t collump[x] >= 0 ? 0 : patch->originy,\n\t\t\t\t texture->height,\n\t\t\t\t marks + x * texture->height);\n\t}\n\t\t\t\t\t\t\n    }\n\n    // killough 4/9/98: Next, convert multipatched columns into true columns,\n    // to fix Medusa bug while still allowing for transparent regions.\n\n    source = I_Realloc(NULL, texture->height); // temporary column\n    for (i = 0; i < texture->width; i++)\n    {\n\tif (collump[i] == -1) // process only multipatched columns\n\t{\n\t    column_t *col = (column_t *)(block + colofs[i] - 3); // cached column\n\t    const byte *mark = marks + i * texture->height;\n\t    int j = 0;\n\n\t    // save column in temporary so we can shuffle it around\n\t    memcpy(source, (byte *) col + 3, texture->height);\n\n\t    for ( ; ; ) // reconstruct the column by scanning transparency marks\n\t    {\n\t\tunsigned len; // killough 12/98\n\n\t\twhile (j < texture->height && !mark[j]) // skip transparent cells\n\t\t    j++;\n\n\t\tif (j >= texture->height) // if at end of column\n\t\t{\n\t\t    col->topdelta = -1; // end-of-column marker\n\t\t    break;\n\t\t}\n\n\t\tcol->topdelta = j; // starting offset of post\n\n\t\t// killough 12/98:\n\t\t// Use 32-bit len counter, to support tall 1s multipatched textures\n\n\t\tfor (len = 0; j < texture->height && mark[j]; j++)\n\t\t    len++; // count opaque cells\n\n\t\tcol->length = len; // killough 12/98: intentionally truncate length\n\n\t\t// copy opaque cells from the temporary back into the column\n\t\tmemcpy((byte *) col + 3, source + col->topdelta, len);\n\t\tcol = (column_t *)((byte *) col + len + 4); // next post\n\t    }\n\t}\n    }\n\n    free(source); // free temporary column\n    free(marks); // free transparency marks\n\n    // Now that the texture has been built in column cache,\n    //  it is purgable from zone memory.\n    Z_ChangeTag (block, PU_CACHE);\n}\n\n\n\n//\n// R_GenerateLookup\n//\n// Rewritten by Lee Killough for performance and to fix Medusa bug\n//\n\nvoid R_GenerateLookup (int texnum)\n{\n    texture_t*\t\ttexture;\n    byte*\t\tpatchcount;\t// patchcount[texture->width]\n    byte*\t\tpostcount; // killough 4/9/98: keep count of posts in addition to patches.\n    texpatch_t*\t\tpatch;\t\n    patch_t*\t\trealpatch;\n    int\t\t\tx;\n    int\t\t\tx1;\n    int\t\t\tx2;\n    int\t\t\ti;\n    short*\t\tcollump;\n    unsigned*\t\tcolofs; // killough 4/9/98: make 32-bit\n    unsigned*\t\tcolofs2; // [crispy] original column offsets\n    int\t\t\tcsize = 0; // killough 10/98\n    int\t\t\terr = 0; // killough 10/98\n\t\n    texture = textures[texnum];\n\n    // Composited texture not created yet.\n    texturecomposite[texnum] = 0;\n    \n    texturecompositesize[texnum] = 0;\n    collump = texturecolumnlump[texnum];\n    colofs = texturecolumnofs[texnum];\n    colofs2 = texturecolumnofs2[texnum]; // [crispy] original column offsets\n    \n    // Now count the number of columns\n    //  that are covered by more than one patch.\n    // Fill in the lump / offset, so columns\n    //  with only a single patch are all done.\n    patchcount = (byte *) Z_Malloc(texture->width, PU_STATIC, &patchcount);\n    postcount = (byte *) Z_Malloc(texture->width, PU_STATIC, &postcount);\n    memset (patchcount, 0, texture->width);\n    memset (postcount, 0, texture->width);\n    patch = texture->patches;\n\n    for (i=0 , patch = texture->patches;\n\t i<texture->patchcount;\n\t i++, patch++)\n    {\n\trealpatch = W_CacheLumpNum (patch->patch, PU_CACHE);\n\tx1 = patch->originx;\n\tx2 = x1 + SHORT(realpatch->width);\n\t\n\tif (x1 < 0)\n\t    x = 0;\n\telse\n\t    x = x1;\n\n\tif (x2 > texture->width)\n\t    x2 = texture->width;\n\tfor ( ; x<x2 ; x++)\n\t{\n\t    patchcount[x]++;\n\t    collump[x] = patch->patch;\n\t    colofs[x] = colofs2[x] = LONG(realpatch->columnofs[x-x1])+3; // [crispy] original column offsets\n\t}\n    }\n\t\n    // killough 4/9/98: keep a count of the number of posts in column,\n    // to fix Medusa bug while allowing for transparent multipatches.\n    //\n    // killough 12/98:\n    // Post counts are only necessary if column is multipatched,\n    // so skip counting posts if column comes from a single patch.\n    // This allows arbitrarily tall textures for 1s walls.\n    //\n    // If texture is >= 256 tall, assume it's 1s, and hence it has\n    // only one post per column. This avoids crashes while allowing\n    // for arbitrarily tall multipatched 1s textures.\n\n    if (texture->patchcount > 1 && texture->height < 256)\n    {\n\t// killough 12/98: Warn about a common column construction bug\n\tunsigned limit = texture->height * 3 + 3; // absolute column size limit\n\n\tfor (i = texture->patchcount, patch = texture->patches; --i >= 0; )\n\t{\n\t    int pat = patch->patch;\n\t    const patch_t *realpatch = W_CacheLumpNum(pat, PU_CACHE);\n\t    int x, x1 = patch++->originx, x2 = x1 + SHORT(realpatch->width);\n\t    const int *cofs = realpatch->columnofs - x1;\n\n\t    if (x2 > texture->width)\n\t\tx2 = texture->width;\n\t    if (x1 < 0)\n\t\tx1 = 0;\n\n\t    for (x = x1 ; x < x2 ; x++)\n\t    {\n\t\tif (patchcount[x] > 1) // Only multipatched columns\n\t\t{\n\t\t    const column_t *col = (const column_t*)((const byte*) realpatch + LONG(cofs[x]));\n\t\t    const byte *base = (const byte *) col;\n\n\t\t    // count posts\n\t\t    for ( ; col->topdelta != 0xff; postcount[x]++)\n\t\t    {\n\t\t\tif ((unsigned)((const byte *) col - base) <= limit)\n\t\t\t    col = (const column_t *)((const byte *) col + col->length + 4);\n\t\t\telse\n\t\t\t    break;\n\t\t    }\n\t\t}\n\t    }\n\t}\n    }\n\n    // Now count the number of columns\n    //  that are covered by more than one patch.\n    // Fill in the lump / offset, so columns\n    //  with only a single patch are all done.\n\n    for (x=0 ; x<texture->width ; x++)\n    {\n\tif (!patchcount[x] && !err++) // killough 10/98: non-verbose output\n\t{\n\t    // [crispy] fix absurd texture name in error message\n\t    char namet[9];\n\t    namet[8] = 0;\n\t    memcpy (namet, texture->name, 8);\n\t    printf (\"R_GenerateLookup: column without a patch (%s)\\n\",\n\t\t    namet);\n\t}\n\t\n\t// [crispy] treat patch-less columns the same as multi-patched\n\tif (patchcount[x] > 1 || !patchcount[x])\n\t{\n\t    // Use the cached block.\n\t    // [crispy] moved up here, the rest in this loop\n\t    // applies to single-patched textures as well\n\t    collump[x] = -1;\t\n\t}\n\t    // killough 1/25/98, 4/9/98:\n\t    //\n\t    // Fix Medusa bug, by adding room for column header\n\t    // and trailer bytes for each post in merged column.\n\t    // For now, just allocate conservatively 4 bytes\n\t    // per post per patch per column, since we don't\n\t    // yet know how many posts the merged column will\n\t    // require, and it's bounded above by this limit.\n\n\t    colofs[x] = csize + 3; // three header bytes in a column\n\t    // killough 12/98: add room for one extra post\n\t    csize += 4 * postcount[x] + 5; // 1 stop byte plus 4 bytes per post\n\t\tcsize += texture->height; // height bytes of texture data\n    }\n\n    texturecompositesize[texnum] = csize;\n\n    Z_Free(patchcount);\n    Z_Free(postcount);\n}\n\n\n\n\n//\n// R_GetColumn\n//\nbyte*\nR_GetColumn\n( int\t\ttex,\n  int\t\tcol,\n  boolean\topaque )\n{\n    int\t\tlump;\n    int\t\tofs;\n    int\t\tofs2;\n\t\n    col &= texturewidthmask[tex];\n    lump = texturecolumnlump[tex][col];\n    ofs = texturecolumnofs[tex][col];\n    ofs2 = texturecolumnofs2[tex][col];\n    \n    // [crispy] single-patched mid-textures on two-sided walls\n    if (lump > 0 && !opaque)\n\treturn (byte *)W_CacheLumpNum(lump,PU_CACHE)+ofs2;\n\n    if (!texturecomposite[tex])\n\tR_GenerateComposite (tex);\n\n    return texturecomposite[tex] + ofs;\n}\n\n\nstatic void GenerateTextureHashTable(void)\n{\n    texture_t **rover;\n    int i;\n    int key;\n\n    textures_hashtable \n            = Z_Malloc(sizeof(texture_t *) * numtextures, PU_STATIC, 0);\n\n    memset(textures_hashtable, 0, sizeof(texture_t *) * numtextures);\n\n    // Add all textures to hash table\n\n    for (i=0; i<numtextures; ++i)\n    {\n        // Store index\n\n        textures[i]->index = i;\n\n        // Vanilla Doom does a linear search of the texures array\n        // and stops at the first entry it finds.  If there are two\n        // entries with the same name, the first one in the array\n        // wins. The new entry must therefore be added at the end\n        // of the hash chain, so that earlier entries win.\n\n        key = W_LumpNameHash(textures[i]->name) % numtextures;\n\n        rover = &textures_hashtable[key];\n\n        while (*rover != NULL)\n        {\n            rover = &(*rover)->next;\n        }\n\n        // Hook into hash table\n\n        textures[i]->next = NULL;\n        *rover = textures[i];\n    }\n}\n\n\n//\n// R_InitTextures\n// Initializes the texture list\n//  with the textures from the world map.\n//\n// [crispy] partly rewritten to merge PNAMES and TEXTURE1/2 lumps\nvoid R_InitTextures (void)\n{\n    maptexture_t*\tmtexture;\n    texture_t*\t\ttexture;\n    mappatch_t*\t\tmpatch;\n    texpatch_t*\t\tpatch;\n\n    int\t\t\ti;\n    int\t\t\tj;\n    int\t\t\tk;\n\n    int*\t\tmaptex = NULL;\n    \n    char\t\tname[9];\n    \n    int*\t\tpatchlookup;\n    \n    int\t\t\ttotalwidth;\n    int\t\t\tnummappatches;\n    int\t\t\toffset;\n    int\t\t\tmaxoff = 0;\n\n    int*\t\tdirectory = NULL;\n    \n    int\t\t\ttemp1;\n    int\t\t\ttemp2;\n    int\t\t\ttemp3;\n\n    typedef struct\n    {\n\tint lumpnum;\n\tvoid *names;\n\tshort nummappatches;\n\tshort summappatches;\n\tchar *name_p;\n    } pnameslump_t;\n\n    typedef struct\n    {\n\tint lumpnum;\n\tint *maptex;\n\tint maxoff;\n\tshort numtextures;\n\tshort sumtextures;\n\tshort pnamesoffset;\n    } texturelump_t;\n\n    pnameslump_t\t*pnameslumps = NULL;\n    texturelump_t\t*texturelumps = NULL, *texturelump;\n\n    int\t\t\tmaxpnameslumps = 1; // PNAMES\n    int\t\t\tmaxtexturelumps = 2; // TEXTURE1, TEXTURE2\n\n    int\t\t\tnumpnameslumps = 0;\n    int\t\t\tnumtexturelumps = 0;\n\n    // [crispy] allocate memory for the pnameslumps and texturelumps arrays\n    pnameslumps = I_Realloc(pnameslumps, maxpnameslumps * sizeof(*pnameslumps));\n    texturelumps = I_Realloc(texturelumps, maxtexturelumps * sizeof(*texturelumps));\n\n    // [crispy] make sure the first available TEXTURE1/2 lumps\n    // are always processed first\n    texturelumps[numtexturelumps++].lumpnum = W_GetNumForName(DEH_String(\"TEXTURE1\"));\n    if ((i = W_CheckNumForName(DEH_String(\"TEXTURE2\"))) != -1)\n\ttexturelumps[numtexturelumps++].lumpnum = i;\n    else\n\ttexturelumps[numtexturelumps].lumpnum = -1;\n\n    // [crispy] fill the arrays with all available PNAMES lumps\n    // and the remaining available TEXTURE1/2 lumps\n    nummappatches = 0;\n    for (i = numlumps - 1; i >= 0; i--)\n    {\n\tif (!strncasecmp(lumpinfo[i]->name, DEH_String(\"PNAMES\"), 6))\n\t{\n\t    if (numpnameslumps == maxpnameslumps)\n\t    {\n\t\tmaxpnameslumps++;\n\t\tpnameslumps = I_Realloc(pnameslumps, maxpnameslumps * sizeof(*pnameslumps));\n\t    }\n\n\t    pnameslumps[numpnameslumps].lumpnum = i;\n\t    pnameslumps[numpnameslumps].names = W_CacheLumpNum(pnameslumps[numpnameslumps].lumpnum, PU_STATIC);\n\t    pnameslumps[numpnameslumps].nummappatches = LONG(*((int *) pnameslumps[numpnameslumps].names));\n\n\t    // [crispy] accumulated number of patches in the lookup tables\n\t    // excluding the current one\n\t    pnameslumps[numpnameslumps].summappatches = nummappatches;\n\t    pnameslumps[numpnameslumps].name_p = (char*)pnameslumps[numpnameslumps].names + 4;\n\n\t    // [crispy] calculate total number of patches\n\t    nummappatches += pnameslumps[numpnameslumps].nummappatches;\n\t    numpnameslumps++;\n\t}\n\telse\n\tif (!strncasecmp(lumpinfo[i]->name, DEH_String(\"TEXTURE\"), 7))\n\t{\n\t    // [crispy] support only TEXTURE1/2 lumps, not TEXTURE3 etc.\n\t    if (lumpinfo[i]->name[7] != '1' &&\n\t        lumpinfo[i]->name[7] != '2')\n\t\tcontinue;\n\n\t    // [crispy] make sure the first available TEXTURE1/2 lumps\n\t    // are not processed again\n\t    if (i == texturelumps[0].lumpnum ||\n\t        i == texturelumps[1].lumpnum) // [crispy] may still be -1\n\t\tcontinue;\n\n\t    if (numtexturelumps == maxtexturelumps)\n\t    {\n\t\tmaxtexturelumps++;\n\t\ttexturelumps = I_Realloc(texturelumps, maxtexturelumps * sizeof(*texturelumps));\n\t    }\n\n\t    // [crispy] do not proceed any further, yet\n\t    // we first need a complete pnameslumps[] array and need\n\t    // to process texturelumps[0] (and also texturelumps[1]) as well\n\t    texturelumps[numtexturelumps].lumpnum = i;\n\t    numtexturelumps++;\n\t}\n    }\n\n    // [crispy] fill up the patch lookup table\n    name[8] = 0;\n    patchlookup = Z_Malloc(nummappatches * sizeof(*patchlookup), PU_STATIC, NULL);\n    for (i = 0, k = 0; i < numpnameslumps; i++)\n    {\n\tfor (j = 0; j < pnameslumps[i].nummappatches; j++)\n\t{\n\t    M_StringCopy(name, pnameslumps[i].name_p + j * 8, sizeof(name));\n\t    patchlookup[k++] = W_CheckNumForName(name);\n\t}\n    }\n\n    // [crispy] calculate total number of textures\n    numtextures = 0;\n    for (i = 0; i < numtexturelumps; i++)\n    {\n\ttexturelumps[i].maptex = W_CacheLumpNum(texturelumps[i].lumpnum, PU_STATIC);\n\ttexturelumps[i].maxoff = W_LumpLength(texturelumps[i].lumpnum);\n\ttexturelumps[i].numtextures = LONG(*texturelumps[i].maptex);\n\n\t// [crispy] accumulated number of textures in the texture files\n\t// including the current one\n\tnumtextures += texturelumps[i].numtextures;\n\ttexturelumps[i].sumtextures = numtextures;\n\n\t// [crispy] link textures to their own WAD's patch lookup table (if any)\n\ttexturelumps[i].pnamesoffset = 0;\n\tfor (j = 0; j < numpnameslumps; j++)\n\t{\n\t    // [crispy] both are from the same WAD?\n\t    if (lumpinfo[texturelumps[i].lumpnum]->wad_file ==\n\t        lumpinfo[pnameslumps[j].lumpnum]->wad_file)\n\t    {\n\t\ttexturelumps[i].pnamesoffset = pnameslumps[j].summappatches;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    // [crispy] release memory allocated for patch lookup tables\n    for (i = 0; i < numpnameslumps; i++)\n    {\n\tW_ReleaseLumpNum(pnameslumps[i].lumpnum);\n    }\n    free(pnameslumps);\n\n    // [crispy] pointer to (i.e. actually before) the first texture file\n    texturelump = texturelumps - 1; // [crispy] gets immediately increased below\n\n    textures = Z_Malloc (numtextures * sizeof(*textures), PU_STATIC, 0);\n    texturecolumnlump = Z_Malloc (numtextures * sizeof(*texturecolumnlump), PU_STATIC, 0);\n    texturecolumnofs = Z_Malloc (numtextures * sizeof(*texturecolumnofs), PU_STATIC, 0);\n    texturecolumnofs2 = Z_Malloc (numtextures * sizeof(*texturecolumnofs2), PU_STATIC, 0);\n    texturecomposite = Z_Malloc (numtextures * sizeof(*texturecomposite), PU_STATIC, 0);\n    texturecompositesize = Z_Malloc (numtextures * sizeof(*texturecompositesize), PU_STATIC, 0);\n    texturewidthmask = Z_Malloc (numtextures * sizeof(*texturewidthmask), PU_STATIC, 0);\n    textureheight = Z_Malloc (numtextures * sizeof(*textureheight), PU_STATIC, 0);\n    texturebrightmap = Z_Malloc (numtextures * sizeof(*texturebrightmap), PU_STATIC, 0);\n\n    totalwidth = 0;\n    \n    //\tReally complex printing shit...\n    temp1 = W_GetNumForName (DEH_String(\"S_START\"));  // P_???????\n    temp2 = W_GetNumForName (DEH_String(\"S_END\")) - 1;\n    temp3 = ((temp2-temp1+63)/64) + ((numtextures+63)/64);\n\t\n    for (i=0 ; i<numtextures ; i++, directory++)\n    {\n\t// [crispy] initialize for the first texture file lump,\n\t// skip through empty texture file lumps which do not contain any texture\n\twhile (texturelump == texturelumps - 1 || i == texturelump->sumtextures)\n\t{\n\t    // [crispy] start looking in next texture file\n\t    texturelump++;\n\t    maptex = texturelump->maptex;\n\t    maxoff = texturelump->maxoff;\n\t    directory = maptex+1;\n\t}\n\t\t\n\toffset = LONG(*directory);\n\n\tif (offset > maxoff)\n\t    I_Error (\"R_InitTextures: bad texture directory\");\n\t\n\tmtexture = (maptexture_t *) ( (byte *)maptex + offset);\n\n\ttexture = textures[i] =\n\t    Z_Malloc (sizeof(texture_t)\n\t\t      + sizeof(texpatch_t)*(SHORT(mtexture->patchcount)-1),\n\t\t      PU_STATIC, 0);\n\t\n\ttexture->width = SHORT(mtexture->width);\n\ttexture->height = SHORT(mtexture->height);\n\ttexture->patchcount = SHORT(mtexture->patchcount);\n\t\n\tmemcpy (texture->name, mtexture->name, sizeof(texture->name));\n\tmpatch = &mtexture->patches[0];\n\tpatch = &texture->patches[0];\n\n\t// [crispy] initialize brightmaps\n\ttexturebrightmap[i] = R_BrightmapForTexName(texture->name);\n\n\tfor (j=0 ; j<texture->patchcount ; j++, mpatch++, patch++)\n\t{\n\t    short p;\n\t    patch->originx = SHORT(mpatch->originx);\n\t    patch->originy = SHORT(mpatch->originy);\n\t    // [crispy] apply offset for patches not in the\n\t    // first available patch offset table\n\t    p = SHORT(mpatch->patch) + texturelump->pnamesoffset;\n\t    // [crispy] catch out-of-range patches\n\t    if (p < nummappatches)\n\t\tpatch->patch = patchlookup[p];\n\t    if (patch->patch == -1 || p >= nummappatches)\n\t    {\n\t\tchar\ttexturename[9];\n\t\ttexturename[8] = '\\0';\n\t\tmemcpy (texturename, texture->name, 8);\n\t\t// [crispy] make non-fatal\n\t\tfprintf (stderr, \"R_InitTextures: Missing patch in texture %s\\n\",\n\t\t\t texturename);\n\t\tpatch->patch = 0;\n\t    }\n\t}\t\t\n\ttexturecolumnlump[i] = Z_Malloc (texture->width*sizeof(**texturecolumnlump), PU_STATIC,0);\n\ttexturecolumnofs[i] = Z_Malloc (texture->width*sizeof(**texturecolumnofs), PU_STATIC,0);\n\ttexturecolumnofs2[i] = Z_Malloc (texture->width*sizeof(**texturecolumnofs2), PU_STATIC,0);\n\n\tj = 1;\n\twhile (j*2 <= texture->width)\n\t    j<<=1;\n\n\ttexturewidthmask[i] = j-1;\n\ttextureheight[i] = texture->height<<FRACBITS;\n\t\t\n\ttotalwidth += texture->width;\n    }\n\n    Z_Free(patchlookup);\n\n    // [crispy] release memory allocated for texture files\n    for (i = 0; i < numtexturelumps; i++)\n    {\n\tW_ReleaseLumpNum(texturelumps[i].lumpnum);\n    }\n    free(texturelumps);\n    \n    // Precalculate whatever possible.\t\n\n    for (i=0 ; i<numtextures ; i++)\n\tR_GenerateLookup (i);\n    \n    // Create translation table for global animation.\n    texturetranslation = Z_Malloc ((numtextures+1)*sizeof(*texturetranslation), PU_STATIC, 0);\n    \n    for (i=0 ; i<numtextures ; i++)\n\ttexturetranslation[i] = i;\n\n    GenerateTextureHashTable();\n}\n\n\n\n//\n// R_InitFlats\n//\nvoid R_InitFlats (void)\n{\n    int\t\ti;\n\t\n    firstflat = W_GetNumForName (DEH_String(\"F_START\")) + 1;\n    lastflat = W_GetNumForName (DEH_String(\"F_END\")) - 1;\n    numflats = lastflat - firstflat + 1;\n\t\n    // Create translation table for global animation.\n    flattranslation = Z_Malloc ((numflats+1)*sizeof(*flattranslation), PU_STATIC, 0);\n    \n    for (i=0 ; i<numflats ; i++)\n\tflattranslation[i] = i;\n}\n\n\n//\n// R_InitSpriteLumps\n// Finds the width and hoffset of all sprites in the wad,\n//  so the sprite does not need to be cached completely\n//  just for having the header info ready during rendering.\n//\nvoid R_InitSpriteLumps (void)\n{\n    int\t\ti;\n    patch_t\t*patch;\n\t\n    firstspritelump = W_GetNumForName (DEH_String(\"S_START\")) + 1;\n    lastspritelump = W_GetNumForName (DEH_String(\"S_END\")) - 1;\n    \n    numspritelumps = lastspritelump - firstspritelump + 1;\n    spritewidth = Z_Malloc (numspritelumps*sizeof(*spritewidth), PU_STATIC, 0);\n    spriteoffset = Z_Malloc (numspritelumps*sizeof(*spriteoffset), PU_STATIC, 0);\n    spritetopoffset = Z_Malloc (numspritelumps*sizeof(*spritetopoffset), PU_STATIC, 0);\n\t\n    for (i=0 ; i< numspritelumps ; i++)\n    {\n\tpatch = W_CacheLumpNum (firstspritelump+i, PU_CACHE);\n\tspritewidth[i] = SHORT(patch->width)<<FRACBITS;\n\tspriteoffset[i] = SHORT(patch->leftoffset)<<FRACBITS;\n\tspritetopoffset[i] = SHORT(patch->topoffset)<<FRACBITS;\n    }\n}\n\n// [crispy] initialize translucency filter map\n// based in parts on the implementation from boom202s/R_DATA.C:676-787\n\nenum {\n    r, g, b\n} rgb_t;\n\nint tran_filter_pct = 66;\n\nvoid R_InitTranMap()\n{\n    int lump = W_CheckNumForName(\"TRANMAP\");\n\n    // If a tranlucency filter map lump is present, use it\n    if (lump != -1)\n    {\n\t// Set a pointer to the translucency filter maps.\n\ttranmap = W_CacheLumpNum(lump, PU_STATIC);\n    }\n    else\n    {\n\t// Compose a default transparent filter map based on PLAYPAL.\n\tunsigned char *playpal = W_CacheLumpName(\"PLAYPAL\", PU_STATIC);\n\tFILE *cachefp;\n\tchar *fname = NULL;\n\textern char *configdir;\n\n\tstruct {\n\t    unsigned char pct;\n\t    unsigned char playpal[256*3]; // [crispy] a palette has 768 bytes!\n\t} cache;\n\n\ttranmap = Z_Malloc(256*256, PU_STATIC, 0);\n\tfname = M_StringJoin(configdir, \"tranmap.dat\", NULL);\n\n\t// [crispy] open file readable\n\tif (!((cachefp = fopen(fname, \"rb\")) &&\n\t    // [crispy] could read struct cache from file\n\t    fread(&cache, 1, sizeof(cache), cachefp) == sizeof(cache) &&\n\t    // [crispy] same filter percents\n\t    cache.pct == tran_filter_pct &&\n\t    // [crispy] same base palettes\n\t    memcmp(cache.playpal, playpal, sizeof(cache.playpal)) == 0 &&\n\t    // [crispy] could read entire translucency map\n\t    fread(tranmap, 256, 256, cachefp) == 256 ))\n\t{\n\t    byte *fg, *bg, blend[3], *tp = tranmap;\n\t    int i, j, btmp;\n\n\t    I_SetPalette(playpal);\n\t    // [crispy] background color\n\t    for (i = 0; i < 256; i++)\n\t    {\n\t\t// [crispy] foreground color\n\t\tfor (j = 0; j < 256; j++)\n\t\t{\n\t\t    // [crispy] shortcut: identical foreground and background\n\t\t    if (i == j)\n\t\t    {\n\t\t\t*tp++ = i;\n\t\t\tcontinue;\n\t\t    }\n\n\t\t    bg = playpal + 3*i;\n\t\t    fg = playpal + 3*j;\n\n\t\t    // [crispy] blended color - emphasize blues\n\t\t    // Colour matching in RGB space doesn't work very well with the blues\n\t\t    // in Doom's palette. Rather than do any colour conversions, just\n\t\t    // emphasize the blues when building the translucency table.\n\t\t    btmp = fg[b] * 1.666 < (fg[r] + fg[g]) ? 0 : 50;\n\t\t    blend[r] = (tran_filter_pct * fg[r] + (100 - tran_filter_pct) * bg[r]) / (100 + btmp);\n\t\t    blend[g] = (tran_filter_pct * fg[g] + (100 - tran_filter_pct) * bg[g]) / (100 + btmp);\n\t\t    blend[b] = (tran_filter_pct * fg[b] + (100 - tran_filter_pct) * bg[b]) / 100;\n\n\t\t    *tp++ = I_GetPaletteIndex(blend[r], blend[g], blend[b]);\n\t\t}\n\t    }\n\n\t    // [crispy] file not readable, open writable\n\t    if ((cachefp = fopen(fname, \"wb\")))\n\t    {\n\t\t// [crispy] set filter percents\n\t\tcache.pct = tran_filter_pct;\n\t\t// [crispy] set base palette\n\t\tmemcpy(cache.playpal, playpal, sizeof(cache.playpal));\n\t\t// [crispy] go to start of file\n\t\tfseek(cachefp, 0, SEEK_SET);\n\t\t// [crispy] write struct cache\n\t\tfwrite(&cache, 1, sizeof(cache), cachefp);\n\t\t// [crispy] write translucency map\n\t\tfwrite(tranmap, 256, 256, cachefp);\n\t    }\n\t}\n\n\tif (cachefp)\n\t    fclose(cachefp);\n\n\tfree(fname);\n\n\tZ_ChangeTag(playpal, PU_CACHE);\n    }\n}\n\n//\n// R_InitColormaps\n//\nvoid R_InitColormaps (void)\n{\n    // Load in the light tables, \n    //  256 byte align tables.\n\n\tint i;\n\tif (W_CheckNumForName(\"C_START\") != -1)\n\t{\n\tfirstcolormaplump = W_GetNumForName(\"C_START\");\n\tlastcolormaplump  = W_GetNumForName(\"C_END\");\n\tnumcolormaps = lastcolormaplump - firstcolormaplump;\n\t}\n\telse\n\t{\n\tnumcolormaps = 1;\n\t}\n\t\n\tcolormaps = Z_Malloc(sizeof(*colormaps) * numcolormaps, PU_STATIC, 0);\n\tcolormaps[0] = (lighttable_t *)W_CacheLumpName(\"COLORMAP\", PU_STATIC);\n\tfor (i=1; i<numcolormaps; i++)\n\t\tcolormaps[i] = (lighttable_t *)W_CacheLumpNum(i+firstcolormaplump, PU_STATIC);\n\n    // [crispy] initialize color translation and color strings tables\n    {\n\tbyte *playpal = W_CacheLumpName(\"PLAYPAL\", PU_STATIC);\n\tchar c[3];\n\tint j;\n\tboolean keepgray = false;\n\textern byte V_Colorize (byte *playpal, int cr, byte source, boolean keepgray109);\n\n\tif (!crstr)\n\t    crstr = I_Realloc(NULL, CRMAX * sizeof(*crstr));\n\n\t// [crispy] check for status bar graphics replacements\n\ti = W_CheckNumForName(DEH_String(\"sttnum0\")); // [crispy] Status Bar '0'\n\tkeepgray = (i >= 0 && W_IsIWADLump(lumpinfo[i]));\n\n\t// [crispy] CRMAX - 2: don't override the original GREN and BLUE2 Boom tables\n\tfor (i = 0; i < CRMAX - 2; i++)\n\t{\n\t    for (j = 0; j < 256; j++)\n\t    {\n\t\tcr[i][j] = V_Colorize(playpal, i, j, keepgray);\n\t    }\n\n\t    M_snprintf(c, sizeof(c), \"%c%c\", cr_esc, '0' + i);\n\t    crstr[i] = M_StringDuplicate(c);\n\t}\n\n\tZ_ChangeTag(playpal, PU_CACHE);\n    }\n\n\textern byte *tinttable;\n\ttinttable = cr[CR_DARK];\n}\n\n// killough 4/4/98: get colormap number from name\n// killough 4/11/98: changed to return -1 for illegal names\n// killough 4/17/98: changed to use ns_colormaps tag\n\nint R_ColormapNumForName(const char *name)\n{\n  int i = 0;\n  if (strncasecmp(name,\"COLORMAP\",8))     // COLORMAP predefined to return 0\n    if ((i = W_CheckNumForName(name)) != -1)\n      i -= firstcolormaplump;\n  return i;\n}\n\n//\n// R_InitData\n// Locates all the lumps\n//  that will be used by all views\n// Must be called after W_Init.\n//\nvoid R_InitData (void)\n{\n    R_InitBrightmaps (0);\n    R_InitTextures ();\n    R_InitFlats ();\n    R_InitBrightmaps (1);\n    R_InitSpriteLumps ();\n    R_InitColormaps ();\n    R_InitTranMap(); // [crispy] prints a mark itself\n}\n\n\n\n//\n// R_FlatNumForName\n// Retrieval, get a flat number for a flat name.\n//\nint R_FlatNumForName(const char *name)\n{\n    int\t\ti;\n    char\tnamet[9];\n\n    i = W_CheckNumForNameFromTo (name, lastflat, firstflat);\n\n    if (i == -1)\n    {\n\tnamet[8] = 0;\n\tmemcpy (namet, name,8);\n\t// [crispy] make non-fatal\n\tfprintf (stderr, \"R_FlatNumForName: %s not found\\n\", namet);\n\t// [crispy] since there is no \"No Flat\" marker,\n\t// render missing flats as SKY\n\treturn skyflatnum;\n    }\n    return i - firstflat;\n}\n\n\n\n\n//\n// R_CheckTextureNumForName\n// Check whether texture is available.\n// Filter out NoTexture indicator.\n//\nint R_CheckTextureNumForName(const char *name)\n{\n    texture_t *texture;\n    int key;\n\n    // \"NoTexture\" marker.\n    if (name[0] == '-')\t\t\n\treturn 0;\n\t\t\n    key = W_LumpNameHash(name) % numtextures;\n\n    texture=textures_hashtable[key]; \n    \n    while (texture != NULL)\n    {\n\tif (!strncasecmp (texture->name, name, 8) )\n\t    return texture->index;\n\n        texture = texture->next;\n    }\n    \n    return -1;\n}\n\n\n\n//\n// R_TextureNumForName\n// Calls R_CheckTextureNumForName,\n//  aborts with error message.\n//\nint R_TextureNumForName(const char *name)\n{\n    int\t\ti;\n\t\n    i = R_CheckTextureNumForName (name);\n\n    if (i==-1)\n    {\n\t// [crispy] fix absurd texture name in error message\n\tchar\tnamet[9];\n\tnamet[8] = '\\0';\n\tmemcpy (namet, name, 8);\n\t// [crispy] make non-fatal\n\tfprintf (stderr, \"R_TextureNumForName: %s not found\\n\",\n\t\t namet);\n\treturn 0;\n    }\n    return i;\n}\n\n\n\n\n//\n// R_PrecacheLevel\n// Preloads all relevant graphics for the level.\n//\nint\t\tflatmemory;\nint\t\ttexturememory;\nint\t\tspritememory;\n\nvoid R_PrecacheLevel (void)\n{\n    char*\t\tflatpresent;\n    char*\t\ttexturepresent;\n    char*\t\tspritepresent;\n\n    int\t\t\ti;\n    int\t\t\tj;\n    int\t\t\tk;\n    int\t\t\tlump;\n    \n    texture_t*\t\ttexture;\n    thinker_t*\t\tth;\n    spriteframe_t*\tsf;\n\n    if (demoplayback)\n\treturn;\n    \n    // Precache flats.\n    flatpresent = Z_Malloc(numflats, PU_STATIC, NULL);\n    memset (flatpresent,0,numflats);\t\n\n    for (i=0 ; i<numsectors ; i++)\n    {\n\tflatpresent[sectors[i].floorpic] = 1;\n\tflatpresent[sectors[i].ceilingpic] = 1;\n    }\n\t\n    flatmemory = 0;\n\n    for (i=0 ; i<numflats ; i++)\n    {\n\tif (flatpresent[i])\n\t{\n\t    lump = firstflat + i;\n\t    flatmemory += lumpinfo[lump]->size;\n\t    W_CacheLumpNum(lump, PU_CACHE);\n\t}\n    }\n\n    Z_Free(flatpresent);\n    \n    // Precache textures.\n    texturepresent = Z_Malloc(numtextures, PU_STATIC, NULL);\n    memset (texturepresent,0, numtextures);\n\t\n    for (i=0 ; i<numsides ; i++)\n    {\n\ttexturepresent[sides[i].toptexture] = 1;\n\ttexturepresent[sides[i].midtexture] = 1;\n\ttexturepresent[sides[i].bottomtexture] = 1;\n    }\n\n    // Sky texture is always present.\n    // Note that F_SKY1 is the name used to\n    //  indicate a sky floor/ceiling as a flat,\n    //  while the sky texture is stored like\n    //  a wall texture, with an episode dependend\n    //  name.\n    texturepresent[skytexture] = 1;\n\t\n    texturememory = 0;\n    for (i=0 ; i<numtextures ; i++)\n    {\n\tif (!texturepresent[i])\n\t    continue;\n\n\t// [crispy] precache composite textures\n\tR_GenerateComposite(i);\n\n\ttexture = textures[i];\n\t\n\tfor (j=0 ; j<texture->patchcount ; j++)\n\t{\n\t    lump = texture->patches[j].patch;\n\t    texturememory += lumpinfo[lump]->size;\n\t    W_CacheLumpNum(lump , PU_CACHE);\n\t}\n    }\n\n    Z_Free(texturepresent);\n    \n    // Precache sprites.\n    spritepresent = Z_Malloc(numsprites, PU_STATIC, NULL);\n    memset (spritepresent,0, numsprites);\n\t\n    for (th = thinkercap.next ; th != &thinkercap ; th=th->next)\n    {\n\tif (th->function.acp1 == (actionf_p1)P_MobjThinker)\n\t    spritepresent[((mobj_t *)th)->sprite] = 1;\n    }\n\t\n    spritememory = 0;\n    for (i=0 ; i<numsprites ; i++)\n    {\n\tif (!spritepresent[i])\n\t    continue;\n\n\tfor (j=0 ; j<sprites[i].numframes ; j++)\n\t{\n\t    sf = &sprites[i].spriteframes[j];\n\t    for (k=0 ; k<8 ; k++)\n\t    {\n\t\tlump = firstspritelump + sf->lump[k];\n\t\tspritememory += lumpinfo[lump]->size;\n\t\tW_CacheLumpNum(lump , PU_CACHE);\n\t    }\n\t}\n    }\n\n    Z_Free(spritepresent);\n}\n\n\n\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tThe actual span/column drawing functions.\n//\tHere find the main potential for optimization,\n//\t e.g. inline assembly, different algorithms.\n//\n\n\n\n\n#include \"doomdef.h\"\n#include \"deh_main.h\"\n\n#include \"i_system.h\"\n#include \"z_zone.h\"\n#include \"w_wad.h\"\n\n#include \"r_local.h\"\n\n// Needs access to LFB (guess what).\n#include \"v_video.h\"\n\n// State.\n#include \"doomstat.h\"\n\n\n// ?\n//#define MAXWIDTH\t\t\t1120\n//#define MAXHEIGHT\t\t\t832\n\n// status bar height at bottom of screen\n// #define SBARHEIGHT\t\t(32 << 0) //crispy->hires)\n\n//\n// All drawing to the view buffer is accomplished in this file.\n// The other refresh files only know about ccordinates,\n//  not the architecture of the frame buffer.\n// Conveniently, the frame buffer is a linear one,\n//  and we need only the base address,\n//  and the total size == width*height*depth/8.,\n//\n\n\nbyte*\t\tviewimage; \nint\t\tviewwidth;\nint\t\tscaledviewwidth;\nint\t\tviewheight;\nint\t\tviewwindowx;\nint\t\tviewwindowy; \npixel_t*\t\tylookup[MAXHEIGHT];\nint\t\tcolumnofs[MAXWIDTH]; \n\n// Color tables for different players,\n//  translate a limited part to another\n//  (color ramps used for  suit colors).\n//\nbyte\t\ttranslations[3][256];\t\n \n// Backing buffer containing the bezel drawn around the screen and \n// surrounding background.\n\nstatic pixel_t *background_buffer = NULL;\n\n\n//\n// R_DrawColumn\n// Source is the top of the column to scale.\n//\nlighttable_t*\t\tdc_colormap[2]; // [crispy] brightmaps\nint\t\t\tdc_x; \nint\t\t\tdc_yl; \nint\t\t\tdc_yh; \nfixed_t\t\t\tdc_iscale; \nfixed_t\t\t\tdc_texturemid;\nint\t\t\tdc_texheight; // [crispy] Tutti-Frutti fix\n\n// first pixel in a column (possibly virtual) \nbyte*\t\t\tdc_source;\t\t\n\n// just for profiling \nint\t\t\tdccount;\n\n//\n// A column is a vertical slice/span from a wall texture that,\n//  given the DOOM style restrictions on the view orientation,\n//  will always have constant z depth.\n// Thus a special case loop for very fast rendering can\n//  be used. It has also been used with Wolfenstein 3D.\n// \n// [crispy] replace R_DrawColumn() with Lee Killough's implementation\n// found in MBF to fix Tutti-Frutti, taken from mbfsrc/R_DRAW.C:99-1979\n\nvoid R_DrawColumn (void) \n{ \n    int\t\t\tcount; \n    pixel_t*\t\tdest;\n    fixed_t\t\tfrac;\n    fixed_t\t\tfracstep;\t \n    int\t\t\theightmask = dc_texheight - 1;\n \n    count = dc_yh - dc_yl; \n\n    // Zero length, column does not exceed a pixel.\n    if (count < 0) \n\treturn; \n\t\t\t\t \n#ifdef RANGECHECK \n    if ((unsigned)dc_x >= SCREENWIDTH\n\t|| dc_yl < 0\n\t|| dc_yh >= SCREENHEIGHT) \n\tI_Error (\"R_DrawColumn: %i to %i at %i\", dc_yl, dc_yh, dc_x); \n#endif \n\n    // Framebuffer destination address.\n    // Use ylookup LUT to avoid multiply with ScreenWidth.\n    // Use columnofs LUT for subwindows? \n    dest = ylookup[dc_yl] + columnofs[dc_x];  \n\n    // Determine scaling,\n    //  which is the only mapping to be done.\n    fracstep = dc_iscale; \n    frac = dc_texturemid + (dc_yl-centery)*fracstep; \n\n    // Inner loop that does the actual texture mapping,\n    //  e.g. a DDA-lile scaling.\n    // This is as fast as it gets.\n\n  // heightmask is the Tutti-Frutti fix -- killough\n  if (dc_texheight & heightmask) // not a power of 2 -- killough\n  {\n    heightmask++;\n    heightmask <<= FRACBITS;\n\n    if (frac < 0)\n\twhile ((frac += heightmask) < 0);\n    else\n\twhile (frac >= heightmask)\n\t    frac -= heightmask;\n\n    do\n    {\n\t// [crispy] brightmaps\n\tconst byte source = dc_source[frac>>FRACBITS];\n\t*dest = fullcolormap[dc_colormap[dc_brightmap[source]][source]];\n\n\tdest += SCREENWIDTH;\n\tif ((frac += fracstep) >= heightmask)\n\t    frac -= heightmask;\n    } while (count--);\n  }\n  else // texture height is a power of 2 -- killough\n  {\n    do \n    {\n\t// Re-map color indices from wall texture column\n\t//  using a lighting/special effects LUT.\n\t// [crispy] brightmaps\n\tconst byte source = dc_source[(frac>>FRACBITS)&heightmask];\n\t*dest = fullcolormap[dc_colormap[dc_brightmap[source]][source]];\n\t\n\tdest += SCREENWIDTH; \n\tfrac += fracstep;\n\t\n    } while (count--); \n  }\n} \n\nvoid R_DrawColumnLow (void) \n{ \n    int\t\t\tcount; \n    pixel_t*\t\tdest; \n    pixel_t*\t\tdest2;\n    fixed_t\t\tfrac;\n    fixed_t\t\tfracstep;\t \n    int                 x;\n    int\t\t\theightmask = dc_texheight - 1;\n \n    count = dc_yh - dc_yl; \n\n    // Zero length.\n    if (count < 0) \n\treturn; \n\t\t\t\t \n#ifdef RANGECHECK \n    if ((unsigned)dc_x >= SCREENWIDTH\n\t|| dc_yl < 0\n\t|| dc_yh >= SCREENHEIGHT)\n    {\n\t\n\tI_Error (\"R_DrawColumn: %i to %i at %i\", dc_yl, dc_yh, dc_x);\n    }\n    //\tdccount++; \n#endif \n    // Blocky mode, need to multiply by 2.\n    x = dc_x << 1;\n    \n    dest = ylookup[dc_yl] + columnofs[x];\n    dest2 = ylookup[dc_yl] + columnofs[x+1];\n    \n    fracstep = dc_iscale; \n    frac = dc_texturemid + (dc_yl-centery)*fracstep;\n    \n  // heightmask is the Tutti-Frutti fix -- killough\n  if (dc_texheight & heightmask) // not a power of 2 -- killough\n  {\n    heightmask++;\n    heightmask <<= FRACBITS;\n\n    if (frac < 0)\n\twhile ((frac += heightmask) < 0);\n    else\n\twhile (frac >= heightmask)\n\t    frac -= heightmask;\n\n    do\n    {\n\t// [crispy] brightmaps\n\tconst byte source = dc_source[frac>>FRACBITS];\n\t*dest2 = *dest = dc_colormap[dc_brightmap[source]][source];\n\n\tdest += SCREENWIDTH;\n\tdest2 += SCREENWIDTH;\n\n\tif ((frac += fracstep) >= heightmask)\n\t    frac -= heightmask;\n    } while (count--);\n  }\n  else // texture height is a power of 2 -- killough\n  {\n    do \n    {\n\t// Hack. Does not work corretly.\n\t// [crispy] brightmaps\n\tconst byte source = dc_source[(frac>>FRACBITS)&heightmask];\n\t*dest2 = *dest = dc_colormap[dc_brightmap[source]][source];\n\tdest += SCREENWIDTH;\n\tdest2 += SCREENWIDTH;\n\n\tfrac += fracstep; \n\n    } while (count--);\n  }\n}\n\n\n//\n// Spectre/Invisibility.\n//\n#define FUZZTABLE\t\t50 \n#define FUZZOFF\t(1)\n\n\nint\tfuzzoffset[FUZZTABLE] =\n{\n    FUZZOFF,-FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,\n    FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,\n    FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,\n    FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,\n    FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,\n    FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,\n    FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF,FUZZOFF,-FUZZOFF,FUZZOFF \n}; \n\nint\tfuzzpos = 0; \n\n// [crispy] draw fuzz effect independent of rendering frame rate\nstatic int fuzzpos_tic;\nvoid R_SetFuzzPosTic (void)\n{\n\tfuzzpos_tic = fuzzpos;\n}\nvoid R_SetFuzzPosDraw (void)\n{\n\tfuzzpos = fuzzpos_tic;\n}\n\n//\n// Framebuffer postprocessing.\n// Creates a fuzzy image by copying pixels\n//  from adjacent ones to left and right.\n// Used with an all black colormap, this\n//  could create the SHADOW effect,\n//  i.e. spectres and invisible players.\n//\nvoid R_DrawFuzzColumn (void) \n{ \n    int\t\t\tcount; \n    pixel_t*\t\tdest;\n    fixed_t\t\tfrac;\n    fixed_t\t\tfracstep;\t \n    boolean\t\tcutoff = false;\n\n    // Adjust borders. Low... \n    if (!dc_yl) \n\tdc_yl = 1;\n\n    // .. and high.\n    if (dc_yh == viewheight-1) \n    {\n\tdc_yh = viewheight - 2; \n\tcutoff = true;\n    }\n\t\t \n    count = dc_yh - dc_yl; \n\n    // Zero length.\n    if (count < 0) \n\treturn; \n\n#ifdef RANGECHECK \n    if ((unsigned)dc_x >= SCREENWIDTH\n\t|| dc_yl < 0 || dc_yh >= SCREENHEIGHT)\n    {\n\tI_Error (\"R_DrawFuzzColumn: %i to %i at %i\",\n\t\t dc_yl, dc_yh, dc_x);\n    }\n#endif\n    \n    dest = ylookup[dc_yl] + columnofs[dc_x];\n\n    // Looks familiar.\n    fracstep = dc_iscale; \n    frac = dc_texturemid + (dc_yl-centery)*fracstep; \n\n    // Looks like an attempt at dithering,\n    //  using the colormap #6 (of 0-31, a bit\n    //  brighter than average).\n    do \n    {\n\t// Lookup framebuffer, and retrieve\n\t//  a pixel that is either one column\n\t//  left or right of the current one.\n\t// Add index from colormap to index.\n\t*dest = fullcolormap[6*256+dest[SCREENWIDTH*fuzzoffset[fuzzpos]]]; \n\n\t// Clamp table lookup index.\n\tif (++fuzzpos == FUZZTABLE) \n\t    fuzzpos = 0;\n\t\n\tdest += SCREENWIDTH;\n\n\tfrac += fracstep; \n    } while (count--); \n\n    // [crispy] if the line at the bottom had to be cut off,\n    // draw one extra line using only pixels of that line and the one above\n    if (cutoff)\n    {\n\t*dest = fullcolormap[6*256+dest[SCREENWIDTH*(fuzzoffset[fuzzpos]-FUZZOFF)/2]];\n    }\n} \n\n// low detail mode version\n \nvoid R_DrawFuzzColumnLow (void) \n{ \n    int\t\t\tcount; \n    pixel_t*\t\tdest; \n    pixel_t*\t\tdest2; \n    fixed_t\t\tfrac;\n    fixed_t\t\tfracstep;\t \n    int x;\n    boolean\t\tcutoff = false;\n\n    // Adjust borders. Low... \n    if (!dc_yl) \n\tdc_yl = 1;\n\n    // .. and high.\n    if (dc_yh == viewheight-1) \n    {\n\tdc_yh = viewheight - 2; \n\tcutoff = true;\n    }\n\t\t \n    count = dc_yh - dc_yl; \n\n    // Zero length.\n    if (count < 0) \n\treturn; \n\n    // low detail mode, need to multiply by 2\n    \n    x = dc_x << 1;\n    \n#ifdef RANGECHECK \n    if ((unsigned)x >= SCREENWIDTH\n\t|| dc_yl < 0 || dc_yh >= SCREENHEIGHT)\n    {\n\tI_Error (\"R_DrawFuzzColumn: %i to %i at %i\",\n\t\t dc_yl, dc_yh, dc_x);\n    }\n#endif\n    \n    dest = ylookup[dc_yl] + columnofs[x];\n    dest2 = ylookup[dc_yl] + columnofs[x+1];\n\n    // Looks familiar.\n    fracstep = dc_iscale; \n    frac = dc_texturemid + (dc_yl-centery)*fracstep; \n\n    // Looks like an attempt at dithering,\n    //  using the colormap #6 (of 0-31, a bit\n    //  brighter than average).\n    do \n    {\n\t// Lookup framebuffer, and retrieve\n\t//  a pixel that is either one column\n\t//  left or right of the current one.\n\t// Add index from colormap to index.\n\t*dest = fullcolormap[6*256+dest[SCREENWIDTH*fuzzoffset[fuzzpos]]];\n\t*dest2 = fullcolormap[6*256+dest2[SCREENWIDTH*fuzzoffset[fuzzpos]]];\n\n\t// Clamp table lookup index.\n\tif (++fuzzpos == FUZZTABLE) \n\t    fuzzpos = 0;\n\t\n\tdest += SCREENWIDTH;\n\tdest2 += SCREENWIDTH;\n\n\tfrac += fracstep; \n    } while (count--); \n\n    // [crispy] if the line at the bottom had to be cut off,\n    // draw one extra line using only pixels of that line and the one above\n    if (cutoff)\n    {\n\t*dest = fullcolormap[6*256+dest[SCREENWIDTH*(fuzzoffset[fuzzpos]-FUZZOFF)/2]];\n\t*dest2 = fullcolormap[6*256+dest2[SCREENWIDTH*(fuzzoffset[fuzzpos]-FUZZOFF)/2]];\n    }\n} \n \n  \n  \n \n\n//\n// R_DrawTranslatedColumn\n// Used to draw player sprites\n//  with the green colorramp mapped to others.\n// Could be used with different translation\n//  tables, e.g. the lighter colored version\n//  of the BaronOfHell, the HellKnight, uses\n//  identical sprites, kinda brightened up.\n//\nbyte*\tdc_translation;\nbyte*\ttranslationtables;\n\nvoid R_DrawTranslatedColumn (void) \n{ \n    int\t\t\tcount; \n    pixel_t*\t\tdest;\n    fixed_t\t\tfrac;\n    fixed_t\t\tfracstep;\t \n \n    count = dc_yh - dc_yl; \n    if (count < 0) \n\treturn; \n\t\t\t\t \n#ifdef RANGECHECK \n    if ((unsigned)dc_x >= SCREENWIDTH\n\t|| dc_yl < 0\n\t|| dc_yh >= SCREENHEIGHT)\n    {\n\tI_Error ( \"R_DrawColumn: %i to %i at %i\",\n\t\t  dc_yl, dc_yh, dc_x);\n    }\n    \n#endif \n\n\n    dest = ylookup[dc_yl] + columnofs[dc_x]; \n\n    // Looks familiar.\n    fracstep = dc_iscale; \n    frac = dc_texturemid + (dc_yl-centery)*fracstep; \n\n    // Here we do an additional index re-mapping.\n    do \n    {\n\t// Translation tables are used\n\t//  to map certain colorramps to other ones,\n\t//  used with PLAY sprites.\n\t// Thus the \"green\" ramp of the player 0 sprite\n\t//  is mapped to gray, red, black/indigo. \n\t*dest = fullcolormap[dc_colormap[0][dc_translation[dc_source[frac>>FRACBITS]]]];\n\tdest += SCREENWIDTH;\n\t\n\tfrac += fracstep; \n    } while (count--); \n} \n\nvoid R_DrawTranslatedColumnLow (void) \n{ \n    int\t\t\tcount; \n    pixel_t*\t\tdest; \n    pixel_t*\t\tdest2; \n    fixed_t\t\tfrac;\n    fixed_t\t\tfracstep;\t \n    int                 x;\n \n    count = dc_yh - dc_yl; \n    if (count < 0) \n\treturn; \n\n    // low detail, need to scale by 2\n    x = dc_x << 1;\n\t\t\t\t \n#ifdef RANGECHECK \n    if ((unsigned)x >= SCREENWIDTH\n\t|| dc_yl < 0\n\t|| dc_yh >= SCREENHEIGHT)\n    {\n\tI_Error ( \"R_DrawColumn: %i to %i at %i\",\n\t\t  dc_yl, dc_yh, x);\n    }\n    \n#endif \n\n\n    dest = ylookup[dc_yl] + columnofs[x];\n    dest2 = ylookup[dc_yl] + columnofs[x+1];\n\n    // Looks familiar.\n    fracstep = dc_iscale; \n    frac = dc_texturemid + (dc_yl-centery)*fracstep; \n\n    // Here we do an additional index re-mapping.\n    do \n    {\n\t// Translation tables are used\n\t//  to map certain colorramps to other ones,\n\t//  used with PLAY sprites.\n\t// Thus the \"green\" ramp of the player 0 sprite\n\t//  is mapped to gray, red, black/indigo. \n\t*dest = dc_colormap[0][dc_translation[dc_source[frac>>FRACBITS]]];\n\t*dest2 = dc_colormap[0][dc_translation[dc_source[frac>>FRACBITS]]];\n\tdest += SCREENWIDTH;\n\tdest2 += SCREENWIDTH;\n\t\n\tfrac += fracstep; \n    } while (count--); \n} \n\n// [crispy] draw translucent column\nextern byte *tranmap;\n\nvoid R_DrawTLColumn (void)\n{\n    int\t\t\tcount;\n    byte*\t\tdest;\n    fixed_t\t\tfrac;\n    fixed_t\t\tfracstep;\n\n    count = dc_yh - dc_yl;\n    if (count < 0)\n\treturn;\n\n#ifdef RANGECHECK\n    if ((unsigned)dc_x >= SCREENWIDTH\n\t|| dc_yl < 0\n\t|| dc_yh >= SCREENHEIGHT)\n    {\n\tI_Error ( \"R_DrawColumn: %i to %i at %i\",\n\t\t  dc_yl, dc_yh, dc_x);\n    }\n#endif\n\n    dest = ylookup[dc_yl] + columnofs[dc_x];\n\n    fracstep = dc_iscale;\n    frac = dc_texturemid + (dc_yl-centery)*fracstep;\n\n    do\n    {\n        // actual translucency map lookup taken from boom202s/R_DRAW.C:255\n        *dest = tranmap[(*dest<<8)+dc_colormap[0][dc_source[frac>>FRACBITS]]];\n\tdest += SCREENWIDTH;\n\n\tfrac += fracstep;\n    } while (count--);\n}\n\n// [crispy] draw translucent column, low-resolution version\nvoid R_DrawTLColumnLow (void)\n{\n    int\t\t\tcount;\n    byte*\t\tdest;\n    byte*\t\tdest2;\n    fixed_t\t\tfrac;\n    fixed_t\t\tfracstep;\n    int                 x;\n\n    count = dc_yh - dc_yl;\n    if (count < 0)\n\treturn;\n\n    x = dc_x << 1;\n\n#ifdef RANGECHECK\n    if ((unsigned)x >= SCREENWIDTH\n\t|| dc_yl < 0\n\t|| dc_yh >= SCREENHEIGHT)\n    {\n\tI_Error ( \"R_DrawColumn: %i to %i at %i\",\n\t\t  dc_yl, dc_yh, x);\n    }\n#endif\n\n    dest = ylookup[dc_yl] + columnofs[x];\n    dest2 = ylookup[dc_yl] + columnofs[x+1];\n\n    fracstep = dc_iscale;\n    frac = dc_texturemid + (dc_yl-centery)*fracstep;\n\n    do\n    {\n\t*dest = tranmap[(*dest<<8)+dc_colormap[0][dc_source[frac>>FRACBITS]]];\n\t*dest2 = tranmap[(*dest2<<8)+dc_colormap[0][dc_source[frac>>FRACBITS]]];\n\tdest += SCREENWIDTH;\n\tdest2 += SCREENWIDTH;\n\n\tfrac += fracstep;\n    } while (count--);\n}\n\n//\n// R_InitTranslationTables\n// Creates the translation tables to map\n//  the green color ramp to gray, brown, red.\n// Assumes a given structure of the PLAYPAL.\n// Could be read from a lump instead.\n//\nvoid R_InitTranslationTables (void)\n{\n    int\t\ti;\n\t\n    translationtables = Z_Malloc (256*3, PU_STATIC, 0);\n    \n    // translate just the 16 green colors\n    for (i=0 ; i<256 ; i++)\n    {\n\tif (i >= 0x70 && i<= 0x7f)\n\t{\n\t    // map green ramp to gray, brown, red\n\t    translationtables[i] = 0x60 + (i&0xf);\n\t    translationtables [i+256] = 0x40 + (i&0xf);\n\t    translationtables [i+512] = 0x20 + (i&0xf);\n\t}\n\telse\n\t{\n\t    // Keep all other colors as is.\n\t    translationtables[i] = translationtables[i+256] \n\t\t= translationtables[i+512] = i;\n\t}\n    }\n}\n\n\n\n\n//\n// R_DrawSpan \n// With DOOM style restrictions on view orientation,\n//  the floors and ceilings consist of horizontal slices\n//  or spans with constant z depth.\n// However, rotation around the world z axis is possible,\n//  thus this mapping, while simpler and faster than\n//  perspective correct texture mapping, has to traverse\n//  the texture at an angle in all but a few cases.\n// In consequence, flats are not stored by column (like walls),\n//  and the inner loop has to step in texture space u and v.\n//\nint\t\t\tds_y; \nint\t\t\tds_x1; \nint\t\t\tds_x2;\n\nlighttable_t*\t\tds_colormap[2];\nbyte*\t\t\tds_brightmap;\n\nfixed_t\t\t\tds_xfrac; \nfixed_t\t\t\tds_yfrac; \nfixed_t\t\t\tds_xstep; \nfixed_t\t\t\tds_ystep;\n\n// start of a 64*64 tile image \nbyte*\t\t\tds_source;\t\n\n// just for profiling\nint\t\t\tdscount;\n\n\n//\n// Draws the actual span.\nvoid R_DrawSpan (void) \n{ \n//  unsigned int position, step;\n    pixel_t *dest;\n    int count;\n    int spot;\n    unsigned int xtemp, ytemp;\n\n#ifdef RANGECHECK\n    if (ds_x2 < ds_x1\n\t|| ds_x1<0\n\t|| ds_x2>=SCREENWIDTH\n\t|| (unsigned)ds_y>SCREENHEIGHT)\n    {\n\tI_Error( \"R_DrawSpan: %i to %i at %i\",\n\t\t ds_x1,ds_x2,ds_y);\n    }\n//\tdscount++;\n#endif\n\n    dest = ylookup[ds_y] + columnofs[ds_x1];\n\n    // We do not check for zero spans here?\n    count = ds_x2 - ds_x1;\n\n    do\n    {\n\tbyte source;\n\t// Calculate current texture index in u,v.\n        // [crispy] fix flats getting more distorted the closer they are to the right\n        ytemp = (ds_yfrac >> 10) & 0x0fc0;\n        xtemp = (ds_xfrac >> 16) & 0x3f;\n        spot = xtemp | ytemp;\n\n\t// Lookup pixel from flat texture tile,\n\t//  re-index using light/colormap.\n\tsource = ds_source[spot];\n\t*dest++ = fullcolormap[ds_colormap[ds_brightmap[source]][source]];\n\n        ds_xfrac += ds_xstep;\n        ds_yfrac += ds_ystep;\n\n    } while (count--);\n}\n\n//\n// Again..\n//\nvoid R_DrawSpanLow (void)\n{\n    unsigned int xtemp, ytemp;\n    pixel_t *dest;\n    int count;\n    int spot;\n\n#ifdef RANGECHECK\n    if (ds_x2 < ds_x1\n\t|| ds_x1<0\n\t|| ds_x2>=SCREENWIDTH\n\t|| (unsigned)ds_y>SCREENHEIGHT)\n    {\n\tI_Error( \"R_DrawSpan: %i to %i at %i\",\n\t\t ds_x1,ds_x2,ds_y);\n    }\n#endif\n\n    count = (ds_x2 - ds_x1);\n\n    // Blocky mode, need to multiply by 2.\n    ds_x1 <<= 1;\n    ds_x2 <<= 1;\n\n    dest = ylookup[ds_y] + columnofs[ds_x1];\n\n    do\n    {\n\tbyte source;\n\t// Calculate current texture index in u,v.\n        // [crispy] fix flats getting more distorted the closer they are to the right\n        ytemp = (ds_yfrac >> 10) & 0x0fc0;\n        xtemp = (ds_xfrac >> 16) & 0x3f;\n        spot = xtemp | ytemp;\n\n\t// Lowres/blocky mode does it twice,\n\t//  while scale is adjusted appropriately.\n\tsource = ds_source[spot];\n\t*dest++ = ds_colormap[ds_brightmap[source]][source];\n\t*dest++ = ds_colormap[ds_brightmap[source]][source];\n\n\tds_xfrac += ds_xstep;\n\tds_yfrac += ds_ystep;\n\n\n    } while (count--);\n}\n\n//\n// R_InitBuffer \n// Creats lookup tables that avoid\n//  multiplies and other hazzles\n//  for getting the framebuffer address\n//  of a pixel to draw.\n//\nvoid\nR_InitBuffer\n( int\t\twidth,\n  int\t\theight ) \n{ \n    int\t\ti; \n\n    // Handle resize,\n    //  e.g. smaller view windows\n    //  with border and/or status bar.\n    viewwindowx = (SCREENWIDTH-width) >> 1; \n\n    // Column offset. For windows.\n    for (i=0 ; i<width ; i++) \n\tcolumnofs[i] = viewwindowx + i;\n\n    // Samw with base row offset.\n    if (width == SCREENWIDTH) \n\tviewwindowy = 0; \n    else \n\tviewwindowy = (SCREENHEIGHT-SBARHEIGHT-height) >> 1; \n\n    // Preclaculate all row offsets.\n    for (i=0 ; i<height ; i++) \n\tylookup[i] = I_VideoBuffer + (i+viewwindowy)*SCREENWIDTH; \n} \n \n \n\n\n//\n// R_FillBackScreen\n// Fills the back screen with a pattern\n//  for variable screen sizes\n// Also draws a beveled edge.\n//\nvoid R_FillBackScreen (void) \n{ \n    byte*\tsrc;\n    pixel_t*\tdest;\n    int\t\tx;\n    int\t\ty; \n    patch_t*\tpatch;\n\n    // DOOM border patch.\n    const char *name1 = DEH_String(\"FLOOR7_2\");\n\n    // DOOM II border patch.\n    const char *name2 = DEH_String(\"GRNROCK\");\n\n    const char *name;\n\n    // If we are running full screen, there is no need to do any of this,\n    // and the background buffer can be freed if it was previously in use.\n\n    if (scaledviewwidth == SCREENWIDTH)\n    {\n        if (background_buffer != NULL)\n        {\n            Z_Free(background_buffer);\n            background_buffer = NULL;\n        }\n\n\treturn;\n    }\n\n    // Allocate the background buffer if necessary\n\t\n    if (background_buffer == NULL)\n    {\n        background_buffer = Z_Malloc(SCREENWIDTH * (SCREENHEIGHT - SBARHEIGHT) * sizeof(*background_buffer),\n                                     PU_STATIC, NULL);\n    }\n\n    if (gamemode == commercial)\n\tname = name2;\n    else\n\tname = name1;\n    \n    src = W_CacheLumpName(name, PU_CACHE); \n    dest = background_buffer;\n\t \n    for (y=0 ; y<SCREENHEIGHT-SBARHEIGHT ; y++) \n    { \n\tfor (x=0 ; x<SCREENWIDTH/64 ; x++) \n\t{ \n\t    memcpy (dest, src+((y&63)<<6), 64); \n\t    dest += 64; \n\t} \n\n\tif (SCREENWIDTH&63) \n\t{ \n\t    memcpy (dest, src+((y&63)<<6), SCREENWIDTH&63); \n\t    dest += (SCREENWIDTH&63); \n\t} \n    } \n     \n    // Draw screen and bezel; this is done to a separate screen buffer.\n\n    V_UseBuffer(background_buffer);\n\n    patch = W_CacheLumpName(DEH_String(\"brdr_t\"),PU_CACHE);\n\n    for (x=0 ; x<(scaledviewwidth) ; x+=8)\n\tV_DrawPatch((viewwindowx)+x, (viewwindowy)-8, patch);\n    patch = W_CacheLumpName(DEH_String(\"brdr_b\"),PU_CACHE);\n\n    for (x=0 ; x<(scaledviewwidth) ; x+=8)\n\tV_DrawPatch((viewwindowx)+x, (viewwindowy)+(viewheight), patch);\n    patch = W_CacheLumpName(DEH_String(\"brdr_l\"),PU_CACHE);\n\n    for (y=0 ; y<(viewheight) ; y+=8)\n\tV_DrawPatch((viewwindowx)-8, (viewwindowy)+y, patch);\n    patch = W_CacheLumpName(DEH_String(\"brdr_r\"),PU_CACHE);\n\n    for (y=0 ; y<(viewheight) ; y+=8)\n\tV_DrawPatch((viewwindowx)+(scaledviewwidth), (viewwindowy)+y, patch);\n\n    // Draw beveled edge. \n    V_DrawPatch((viewwindowx)-8,\n                (viewwindowy)-8,\n                W_CacheLumpName(DEH_String(\"brdr_tl\"),PU_CACHE));\n    \n    V_DrawPatch((viewwindowx)+(scaledviewwidth),\n                (viewwindowy)-8,\n                W_CacheLumpName(DEH_String(\"brdr_tr\"),PU_CACHE));\n    \n    V_DrawPatch((viewwindowx)-8,\n                (viewwindowy)+(viewheight),\n                W_CacheLumpName(DEH_String(\"brdr_bl\"),PU_CACHE));\n    \n    V_DrawPatch((viewwindowx)+(scaledviewwidth),\n                (viewwindowy)+(viewheight),\n                W_CacheLumpName(DEH_String(\"brdr_br\"),PU_CACHE));\n\n    V_RestoreBuffer();\n} \n \n\n//\n// Copy a screen buffer.\n//\nvoid\nR_VideoErase\n( unsigned\tofs,\n  int\t\tcount ) \n{ \n  // LFB copy.\n  // This might not be a good idea if memcpy\n  //  is not optiomal, e.g. byte by byte on\n  //  a 32bit CPU, as GNU GCC/Linux libc did\n  //  at one point.\n\n    if (background_buffer != NULL)\n    {\n        memcpy(I_VideoBuffer + ofs, background_buffer + ofs, count * sizeof(*I_VideoBuffer));\n    }\n} \n\n\n//\n// R_DrawViewBorder\n// Draws the border around the view\n//  for different size windows?\n//\nvoid R_DrawViewBorder (void) \n{ \n    int\t\ttop;\n    int\t\tside;\n    int\t\tofs;\n    int\t\ti; \n \n    if (scaledviewwidth == SCREENWIDTH) \n\treturn; \n  \n    top = ((SCREENHEIGHT-SBARHEIGHT)-viewheight)/2;\n    side = (SCREENWIDTH-scaledviewwidth)/2; \n \n    // copy top and one line of left side \n    R_VideoErase (0, top*SCREENWIDTH+side); \n \n    // copy one line of right side and bottom \n    ofs = (viewheight+top)*SCREENWIDTH-side;\n    R_VideoErase (ofs, top*SCREENWIDTH+side); \n \n    // copy sides using wraparound \n    ofs = top*SCREENWIDTH + SCREENWIDTH-side; \n    side <<= 1;\n    \n    for (i=1 ; i<viewheight ; i++)\n    { \n\tR_VideoErase (ofs, side); \n\tofs += SCREENWIDTH; \n    } \n\n    // ? \n    V_MarkRect (0,0,SCREENWIDTH, SCREENHEIGHT-SBARHEIGHT); \n} \n \n \n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tRendering main loop and setup functions,\n//\t utility functions (BSP, geometry, trigonometry).\n//\tSee tables.c, too.\n//\n\n\n\n\n\n#include <stdlib.h>\n#include <math.h>\n\n\n#include \"doomdef.h\"\n#include \"doomstat.h\" // [AM] leveltime, paused, menuactive\n#include \"d_loop.h\"\n\n#include \"m_bbox.h\"\n#include \"m_menu.h\"\n\n#include \"i_system.h\" // [crispy] I_Realloc()\n#include \"p_local.h\" // [crispy] MLOOKUNIT\n#include \"r_local.h\"\n#include \"r_sky.h\"\n\n\n\n\n\n// Fineangles in the SCREENWIDTH wide window.\n#define FIELDOFVIEW\t\t2048\t\n\n\n\nint\t\t\tviewangleoffset;\n\n// increment every time a check is made\nint\t\t\tvalidcount = 1;\t\t\n\n\nlighttable_t*\t\tfixedcolormap;\nextern lighttable_t**\twalllights;\n\nint\t\t\tcenterx;\nint\t\t\tcentery;\n\nfixed_t\t\t\tcenterxfrac;\nfixed_t\t\t\tcenteryfrac;\nfixed_t\t\t\tprojection;\n\n// just for profiling purposes\nint\t\t\tframecount;\t\n\nint\t\t\tsscount;\nint\t\t\tlinecount;\nint\t\t\tloopcount;\n\nfixed_t\t\t\tviewx;\nfixed_t\t\t\tviewy;\nfixed_t\t\t\tviewz;\n\nangle_t\t\t\tviewangle;\n\nfixed_t\t\t\tviewcos;\nfixed_t\t\t\tviewsin;\n\nplayer_t*\t\tviewplayer;\n\n// 0 = high, 1 = low\nint\t\t\tdetailshift;\t\n\n//\n// precalculated math tables\n//\nangle_t\t\t\tclipangle;\n\n// The viewangletox[viewangle + FINEANGLES/4] lookup\n// maps the visible view angles to screen X coordinates,\n// flattening the arc to a flat projection plane.\n// There will be many angles mapped to the same X. \nint\t\t\tviewangletox[FINEANGLES/2];\n\n// The xtoviewangleangle[] table maps a screen pixel\n// to the lowest viewangle that maps back to x ranges\n// from clipangle to -clipangle.\nangle_t\t\t\txtoviewangle[MAXWIDTH+1];\n\n// killough 3/20/98: Support dynamic colormaps, e.g. deep water\n// killough 4/4/98: support dynamic number of them as well\n\nint numcolormaps;\n// [crispy] parameterized for smooth diminishing lighting\nlighttable_t***\t\tscalelight = NULL;\nlighttable_t**\t\tscalelightfixed = NULL;\nlighttable_t****\tzlight = NULL;\nlighttable_t***     cm_zlight = NULL;\nlighttable_t*       fullcolormap = NULL;\n\n// bumped light from gun blasts\nint\t\t\textralight;\t\t\t\n\n// [crispy] parameterized for smooth diminishing lighting\nint LIGHTLEVELS;\nint LIGHTSEGSHIFT;\nint LIGHTBRIGHT;\nint MAXLIGHTSCALE;\nint LIGHTSCALESHIFT;\nint MAXLIGHTZ;\nint LIGHTZSHIFT;\n\n\nvoid (*colfunc) (void);\nvoid (*basecolfunc) (void);\nvoid (*fuzzcolfunc) (void);\nvoid (*transcolfunc) (void);\nvoid (*tlcolfunc) (void);\nvoid (*spanfunc) (void);\n\n\n\n//\n// R_AddPointToBox\n// Expand a given bbox\n// so that it encloses a given point.\n//\nvoid\nR_AddPointToBox\n( int\t\tx,\n  int\t\ty,\n  fixed_t*\tbox )\n{\n    if (x< box[BOXLEFT])\n\tbox[BOXLEFT] = x;\n    if (x> box[BOXRIGHT])\n\tbox[BOXRIGHT] = x;\n    if (y< box[BOXBOTTOM])\n\tbox[BOXBOTTOM] = y;\n    if (y> box[BOXTOP])\n\tbox[BOXTOP] = y;\n}\n\n\n//\n// R_PointOnSide\n// Traverse BSP (sub) tree,\n//  check point against partition plane.\n// Returns side 0 (front) or 1 (back).\n//\nint\nR_PointOnSide\n( fixed_t\tx,\n  fixed_t\ty,\n  node_t*\tnode )\n{\n    fixed_t\tdx;\n    fixed_t\tdy;\n    fixed_t\tleft;\n    fixed_t\tright;\n\t\n    if (!node->dx)\n    {\n\tif (x <= node->x)\n\t    return node->dy > 0;\n\t\n\treturn node->dy < 0;\n    }\n    if (!node->dy)\n    {\n\tif (y <= node->y)\n\t    return node->dx < 0;\n\t\n\treturn node->dx > 0;\n    }\n\t\n    dx = (x - node->x);\n    dy = (y - node->y);\n\t\n    // Try to quickly decide by looking at sign bits.\n    if ( (node->dy ^ node->dx ^ dx ^ dy)&0x80000000 )\n    {\n\tif  ( (node->dy ^ dx) & 0x80000000 )\n\t{\n\t    // (left is negative)\n\t    return 1;\n\t}\n\treturn 0;\n    }\n\n    left = FixedMul ( node->dy>>FRACBITS , dx );\n    right = FixedMul ( dy , node->dx>>FRACBITS );\n\t\n    if (right < left)\n    {\n\t// front side\n\treturn 0;\n    }\n    // back side\n    return 1;\t\t\t\n}\n\n\nint\nR_PointOnSegSide\n( fixed_t\tx,\n  fixed_t\ty,\n  seg_t*\tline )\n{\n    fixed_t\tlx;\n    fixed_t\tly;\n    fixed_t\tldx;\n    fixed_t\tldy;\n    fixed_t\tdx;\n    fixed_t\tdy;\n    fixed_t\tleft;\n    fixed_t\tright;\n\t\n    lx = line->v1->x;\n    ly = line->v1->y;\n\t\n    ldx = line->v2->x - lx;\n    ldy = line->v2->y - ly;\n\t\n    if (!ldx)\n    {\n\tif (x <= lx)\n\t    return ldy > 0;\n\t\n\treturn ldy < 0;\n    }\n    if (!ldy)\n    {\n\tif (y <= ly)\n\t    return ldx < 0;\n\t\n\treturn ldx > 0;\n    }\n\t\n    dx = (x - lx);\n    dy = (y - ly);\n\t\n    // Try to quickly decide by looking at sign bits.\n    if ( (ldy ^ ldx ^ dx ^ dy)&0x80000000 )\n    {\n\tif  ( (ldy ^ dx) & 0x80000000 )\n\t{\n\t    // (left is negative)\n\t    return 1;\n\t}\n\treturn 0;\n    }\n\n    left = FixedMul ( ldy>>FRACBITS , dx );\n    right = FixedMul ( dy , ldx>>FRACBITS );\n\t\n    if (right < left)\n    {\n\t// front side\n\treturn 0;\n    }\n    // back side\n    return 1;\t\t\t\n}\n\n\n//\n// R_PointToAngle\n// To get a global angle from cartesian coordinates,\n//  the coordinates are flipped until they are in\n//  the first octant of the coordinate system, then\n//  the y (<=x) is scaled and divided by x to get a\n//  tangent (slope) value which is looked up in the\n//  tantoangle[] table.\n\n//\n\n\n\n\n// [crispy] turned into a general R_PointToAngle() flavor\n// called with either slope_div = SlopeDivCrispy() from R_PointToAngleCrispy()\n// or slope_div = SlopeDiv() else\nangle_t\nR_PointToAngleSlope\n( fixed_t\tx,\n  fixed_t\ty,\n  int (*slope_div) (unsigned int num, unsigned int den))\n{\t\n    x -= viewx;\n    y -= viewy;\n    \n    if ( (!x) && (!y) )\n\treturn 0;\n\n    if (x>= 0)\n    {\n\t// x >=0\n\tif (y>= 0)\n\t{\n\t    // y>= 0\n\n\t    if (x>y)\n\t    {\n\t\t// octant 0\n\t\treturn tantoangle[slope_div(y,x)];\n\t    }\n\t    else\n\t    {\n\t\t// octant 1\n\t\treturn ANG90-1-tantoangle[slope_div(x,y)];\n\t    }\n\t}\n\telse\n\t{\n\t    // y<0\n\t    y = -y;\n\n\t    if (x>y)\n\t    {\n\t\t// octant 8\n\t\treturn -tantoangle[slope_div(y,x)];\n\t    }\n\t    else\n\t    {\n\t\t// octant 7\n\t\treturn ANG270+tantoangle[slope_div(x,y)];\n\t    }\n\t}\n    }\n    else\n    {\n\t// x<0\n\tx = -x;\n\n\tif (y>= 0)\n\t{\n\t    // y>= 0\n\t    if (x>y)\n\t    {\n\t\t// octant 3\n\t\treturn ANG180-1-tantoangle[slope_div(y,x)];\n\t    }\n\t    else\n\t    {\n\t\t// octant 2\n\t\treturn ANG90+ tantoangle[slope_div(x,y)];\n\t    }\n\t}\n\telse\n\t{\n\t    // y<0\n\t    y = -y;\n\n\t    if (x>y)\n\t    {\n\t\t// octant 4\n\t\treturn ANG180+tantoangle[slope_div(y,x)];\n\t    }\n\t    else\n\t    {\n\t\t // octant 5\n\t\treturn ANG270-1-tantoangle[slope_div(x,y)];\n\t    }\n\t}\n    }\n    return 0;\n}\n\nangle_t\nR_PointToAngle\n( fixed_t\tx,\n  fixed_t\ty )\n{\n    return R_PointToAngleSlope (x, y, SlopeDiv);\n}\n\n// [crispy] overflow-safe R_PointToAngle() flavor\n// called only from R_CheckBBox(), R_AddLine() and P_SegLengths()\nangle_t\nR_PointToAngleCrispy\n( fixed_t\tx,\n  fixed_t\ty )\n{\n    // [crispy] fix overflows for very long distances\n    int64_t y_viewy = (int64_t)y - viewy;\n    int64_t x_viewx = (int64_t)x - viewx;\n\n    // [crispy] the worst that could happen is e.g. INT_MIN-INT_MAX = 2*INT_MIN\n    if (x_viewx < INT_MIN || x_viewx > INT_MAX ||\n        y_viewy < INT_MIN || y_viewy > INT_MAX)\n    {\n\t// [crispy] preserving the angle by halfing the distance in both directions\n\tx = x_viewx / 2 + viewx;\n\ty = y_viewy / 2 + viewy;\n    }\n\n    return R_PointToAngleSlope (x, y, SlopeDivCrispy);\n}\n\nangle_t\nR_PointToAngle2\n( fixed_t\tx1,\n  fixed_t\ty1,\n  fixed_t\tx2,\n  fixed_t\ty2 )\n{\t\n    viewx = x1;\n    viewy = y1;\n    \n    // [crispy] R_PointToAngle2() is never called during rendering\n    return R_PointToAngleSlope (x2, y2, SlopeDiv);\n}\n\n\nfixed_t\nR_PointToDist\n( fixed_t\tx,\n  fixed_t\ty )\n{\n    int\t\tangle;\n    fixed_t\tdx;\n    fixed_t\tdy;\n    fixed_t\ttemp;\n    fixed_t\tdist;\n    fixed_t     frac;\n\t\n    dx = abs(x - viewx);\n    dy = abs(y - viewy);\n\t\n    if (dy>dx)\n    {\n\ttemp = dx;\n\tdx = dy;\n\tdy = temp;\n    }\n\n    // Fix crashes in udm1.wad\n\n    if (dx != 0)\n    {\n        frac = FixedDiv(dy, dx);\n    }\n    else\n    {\n\tfrac = 0;\n    }\n\t\n    angle = (tantoangle[frac>>DBITS]+ANG90) >> ANGLETOFINESHIFT;\n\n    // use as cosine\n    dist = FixedDiv (dx, finesine[angle] );\t\n\t\n    return dist;\n}\n\n\n\n\n//\n// R_InitPointToAngle\n//\nvoid R_InitPointToAngle (void)\n{\n    // UNUSED - now getting from tables.c\n#if 0\n    int\ti;\n    long\tt;\n    float\tf;\n//\n// slope (tangent) to angle lookup\n//\n    for (i=0 ; i<=SLOPERANGE ; i++)\n    {\n\tf = atan( (float)i/SLOPERANGE )/(3.141592657*2);\n\tt = 0xffffffff*f;\n\ttantoangle[i] = t;\n    }\n#endif\n}\n\n\n// [crispy] WiggleFix: move R_ScaleFromGlobalAngle function to r_segs.c,\n// above R_StoreWallRange\n#if 0\n//\n// R_ScaleFromGlobalAngle\n// Returns the texture mapping scale\n//  for the current line (horizontal span)\n//  at the given angle.\n// rw_distance must be calculated first.\n//\nfixed_t R_ScaleFromGlobalAngle (angle_t visangle)\n{\n    fixed_t\t\tscale;\n    angle_t\t\tanglea;\n    angle_t\t\tangleb;\n    int\t\t\tsinea;\n    int\t\t\tsineb;\n    fixed_t\t\tnum;\n    int\t\t\tden;\n\n    // UNUSED\n#if 0\n{\n    fixed_t\t\tdist;\n    fixed_t\t\tz;\n    fixed_t\t\tsinv;\n    fixed_t\t\tcosv;\n\t\n    sinv = finesine[(visangle-rw_normalangle)>>ANGLETOFINESHIFT];\t\n    dist = FixedDiv (rw_distance, sinv);\n    cosv = finecosine[(viewangle-visangle)>>ANGLETOFINESHIFT];\n    z = abs(FixedMul (dist, cosv));\n    scale = FixedDiv(projection, z);\n    return scale;\n}\n#endif\n\n    anglea = ANG90 + (visangle-viewangle);\n    angleb = ANG90 + (visangle-rw_normalangle);\n\n    // both sines are allways positive\n    sinea = finesine[anglea>>ANGLETOFINESHIFT];\t\n    sineb = finesine[angleb>>ANGLETOFINESHIFT];\n    num = FixedMul(projection,sineb)<<detailshift;\n    den = FixedMul(rw_distance,sinea);\n\n    if (den > num>>FRACBITS)\n    {\n\tscale = FixedDiv (num, den);\n\n\tif (scale > 64*FRACUNIT)\n\t    scale = 64*FRACUNIT;\n\telse if (scale < 256)\n\t    scale = 256;\n    }\n    else\n\tscale = 64*FRACUNIT;\n\t\n    return scale;\n}\n#endif\n\n\n// [AM] Interpolate between two angles.\nangle_t R_InterpolateAngle(angle_t oangle, angle_t nangle, fixed_t scale)\n{\n    if (nangle == oangle)\n        return nangle;\n    else if (nangle > oangle)\n    {\n        if (nangle - oangle < ANG270)\n            return oangle + (angle_t)((nangle - oangle) * FIXED2DOUBLE(scale));\n        else // Wrapped around\n            return oangle - (angle_t)((oangle - nangle) * FIXED2DOUBLE(scale));\n    }\n    else // nangle < oangle\n    {\n        if (oangle - nangle < ANG270)\n            return oangle - (angle_t)((oangle - nangle) * FIXED2DOUBLE(scale));\n        else // Wrapped around\n            return oangle + (angle_t)((nangle - oangle) * FIXED2DOUBLE(scale));\n    }\n}\n\n//\n// R_InitTables\n//\nvoid R_InitTables (void)\n{\n    // UNUSED: now getting from tables.c\n#if 0\n    int\t\ti;\n    float\ta;\n    float\tfv;\n    int\t\tt;\n    \n    // viewangle tangent table\n    for (i=0 ; i<FINEANGLES/2 ; i++)\n    {\n\ta = (i-FINEANGLES/4+0.5)*PI*2/FINEANGLES;\n\tfv = FRACUNIT*tan (a);\n\tt = fv;\n\tfinetangent[i] = t;\n    }\n    \n    // finesine table\n    for (i=0 ; i<5*FINEANGLES/4 ; i++)\n    {\n\t// OPTIMIZE: mirror...\n\ta = (i+0.5)*PI*2/FINEANGLES;\n\tt = FRACUNIT*sin (a);\n\tfinesine[i] = t;\n    }\n#endif\n\n}\n\n\n\n//\n// R_InitTextureMapping\n//\nvoid R_InitTextureMapping (void)\n{\n    int\t\t\ti;\n    int\t\t\tx;\n    int\t\t\tt;\n    fixed_t\t\tfocallength;\n    \n    // Use tangent table to generate viewangletox:\n    //  viewangletox will give the next greatest x\n    //  after the view angle.\n    //\n    // Calc focallength\n    //  so FIELDOFVIEW angles covers SCREENWIDTH.\n    focallength = FixedDiv (centerxfrac,\n\t\t\t    finetangent[FINEANGLES/4+FIELDOFVIEW/2] );\n\t\n    for (i=0 ; i<FINEANGLES/2 ; i++)\n    {\n\tif (finetangent[i] > FRACUNIT*2)\n\t    t = -1;\n\telse if (finetangent[i] < -FRACUNIT*2)\n\t    t = viewwidth+1;\n\telse\n\t{\n\t    t = FixedMul (finetangent[i], focallength);\n\t    t = (centerxfrac - t+FRACUNIT-1)>>FRACBITS;\n\n\t    if (t < -1)\n\t\tt = -1;\n\t    else if (t>viewwidth+1)\n\t\tt = viewwidth+1;\n\t}\n\tviewangletox[i] = t;\n    }\n    \n    // Scan viewangletox[] to generate xtoviewangle[]:\n    //  xtoviewangle will give the smallest view angle\n    //  that maps to x.\t\n    for (x=0;x<=viewwidth;x++)\n    {\n\ti = 0;\n\twhile (viewangletox[i]>x)\n\t    i++;\n\txtoviewangle[x] = (i<<ANGLETOFINESHIFT)-ANG90;\n    }\n    \n    // Take out the fencepost cases from viewangletox.\n    for (i=0 ; i<FINEANGLES/2 ; i++)\n    {\n\tt = FixedMul (finetangent[i], focallength);\n\tt = centerx - t;\n\t\n\tif (viewangletox[i] == -1)\n\t    viewangletox[i] = 0;\n\telse if (viewangletox[i] == viewwidth+1)\n\t    viewangletox[i]  = viewwidth;\n    }\n\t\n    clipangle = xtoviewangle[0];\n}\n\n\n\n//\n// R_InitLightTables\n// Only inits the zlight table,\n//  because the scalelight table changes with view size.\n//\n#define DISTMAP\t\t2\n\nvoid R_InitLightTables (void)\n{\n    int     t;\n    int\t\ti;\n    int\t\tj;\n    int\t\tlevel;\n    int\t\tstartmap; \t\n    int\t\tscale;\n    \n    // if (scalelight)\n    // {\n\t// for (i = 0; i < LIGHTLEVELS; i++)\n\t// {\n\t// \tfree(scalelight[i]);\n\t// }\n\t// free(scalelight);\n    // }\n\n    // if (scalelightfixed)\n    // {\n\t// free(scalelightfixed);\n    // }\n\n    // if (zlight)\n    // {\n\t// for (i = 0; i < LIGHTLEVELS; i++)\n\t// {\n\t// \tfree(zlight[i]);\n\t// }\n\t// free(zlight);\n    // }\n\n   // [crispy] smooth diminishing lighting\n    // if (crispy->smoothlight)\n    // {\n\t// LIGHTLEVELS = 32;\n\t// LIGHTSEGSHIFT = 3;\n\t// LIGHTBRIGHT = 2;\n\t// MAXLIGHTSCALE = 48;\n\t// LIGHTSCALESHIFT = 12;\n\t// MAXLIGHTZ = 1024;\n\t// LIGHTZSHIFT = 17;\n    // }\n    // else\n    // {\n\tLIGHTLEVELS = 16;\n\tLIGHTSEGSHIFT = 4;\n\tLIGHTBRIGHT = 1;\n\tMAXLIGHTSCALE = 48;\n\tLIGHTSCALESHIFT = 12;\n\tMAXLIGHTZ = 128;\n\tLIGHTZSHIFT = 20;\n    // }\n\n    scalelight = malloc(LIGHTLEVELS * sizeof(*scalelight));\n    scalelightfixed = malloc(MAXLIGHTSCALE * sizeof(*scalelightfixed));\n    zlight = malloc(numcolormaps * sizeof(*zlight));\n\n    for (t=0 ; t< numcolormaps ; t++)\n    {\n    zlight[t] = malloc(LIGHTLEVELS * sizeof(**zlight));\n    // Calculate the light levels to use\n    //  for each level / distance combination.\n    for (i=0 ; i< LIGHTLEVELS ; i++)\n    {\n\tzlight[t][i] = malloc(MAXLIGHTZ * sizeof(***zlight));\n\n\tstartmap = ((LIGHTLEVELS-LIGHTBRIGHT-i)*2)*NUMCOLORMAPS/LIGHTLEVELS;\n\tfor (j=0 ; j<MAXLIGHTZ ; j++)\n\t{\n\t    scale = FixedDiv ((ORIGWIDTH/2*FRACUNIT), (j+1)<<LIGHTZSHIFT);\n\t    scale >>= LIGHTSCALESHIFT;\n\t    level = startmap - scale/DISTMAP;\n\t    \n\t    if (level < 0)\n\t\tlevel = 0;\n\n\t    if (level >= NUMCOLORMAPS)\n\t\tlevel = NUMCOLORMAPS-1;\n\n\t    zlight[t][i][j] = colormaps[t] + level*256;\n\t}\n    }\n    }\n}\n\n\n\n//\n// R_SetViewSize\n// Do not really change anything here,\n//  because it might be in the middle of a refresh.\n// The change will take effect next refresh.\n//\nboolean\t\tsetsizeneeded;\nint\t\tsetblocks;\nint\t\tsetdetail;\n\n\nvoid\nR_SetViewSize\n( int\t\tblocks,\n  int\t\tdetail )\n{\n    setsizeneeded = true;\n    setblocks = blocks;\n    setdetail = detail;\n}\n\n\n//\n// R_ExecuteSetViewSize\n//\nvoid R_ExecuteSetViewSize (void)\n{\n    fixed_t\tcosadj;\n    fixed_t\tdy;\n    int\t\ti;\n    int\t\tj;\n    int\t\tlevel;\n    int\t\tstartmap; \t\n\n    setsizeneeded = false;\n\n    if (setblocks >= 11) // [crispy] Crispy HUD\n    {\n\tscaledviewwidth = SCREENWIDTH;\n\tviewheight = SCREENHEIGHT;\n    }\n    else\n    {\n\tscaledviewwidth = (setblocks*32);//<<crispy->hires;\n\tviewheight = ((setblocks*168/10)&~7);//<<crispy->hires;\n    }\n    \n    detailshift = setdetail;\n    viewwidth = scaledviewwidth>>detailshift;\n\t\n    centery = viewheight/2;\n    centerx = viewwidth/2;\n    centerxfrac = centerx<<FRACBITS;\n    centeryfrac = centery<<FRACBITS;\n    projection = centerxfrac;\n\n    if (!detailshift)\n    {\n\tcolfunc = basecolfunc = R_DrawColumn;\n\tfuzzcolfunc = R_DrawFuzzColumn;\n\ttranscolfunc = R_DrawTranslatedColumn;\n\ttlcolfunc = R_DrawTLColumn;\n\tspanfunc = R_DrawSpan;\n    }\n    else\n    {\n\tcolfunc = basecolfunc = R_DrawColumnLow;\n\tfuzzcolfunc = R_DrawFuzzColumnLow;\n\ttranscolfunc = R_DrawTranslatedColumnLow;\n\ttlcolfunc = R_DrawTLColumnLow;\n\tspanfunc = R_DrawSpanLow;\n    }\n\n    R_InitBuffer (scaledviewwidth, viewheight);\n\t\n    R_InitTextureMapping ();\n    \n    // psprite scales\n    pspritescale = FRACUNIT*viewwidth/ORIGWIDTH;\n    pspriteiscale = FRACUNIT*ORIGWIDTH/viewwidth;\n    \n    // thing clipping\n    for (i=0 ; i<viewwidth ; i++)\n\tscreenheightarray[i] = viewheight;\n    \n    // planes\n    for (i=0 ; i<viewheight ; i++)\n    {\n\t// [crispy] re-generate lookup-table for yslope[] (free look)\n\t// whenever \"detailshift\" or \"screenblocks\" change\n\tconst fixed_t num = (viewwidth<<detailshift)/2*FRACUNIT;\n\tfor (j = 0; j < LOOKDIRS; j++)\n\t{\n\tdy = ((i-(viewheight/2 + ((j-LOOKDIRMIN) * (1 /*<< crispy->hires*/)) * (screenblocks < 11 ? screenblocks : 11) / 10))<<FRACBITS)+FRACUNIT/2;\n\tdy = abs(dy);\n\tyslopes[j][i] = FixedDiv (num, dy);\n\t}\n    }\n    yslope = yslopes[LOOKDIRMIN];\n\t\n    for (i=0 ; i<viewwidth ; i++)\n    {\n\tcosadj = abs(finecosine[xtoviewangle[i]>>ANGLETOFINESHIFT]);\n\tdistscale[i] = FixedDiv (FRACUNIT,cosadj);\n    }\n    \n    // Calculate the light levels to use\n    //  for each level / scale combination.\n    for (i=0 ; i< LIGHTLEVELS ; i++)\n    {\n\tscalelight[i] = malloc(MAXLIGHTSCALE * sizeof(**scalelight));\n\n\tstartmap = ((LIGHTLEVELS-LIGHTBRIGHT-i)*2)*NUMCOLORMAPS/LIGHTLEVELS;\n\tfor (j=0 ; j<MAXLIGHTSCALE ; j++)\n\t{\n\t    level = startmap - j*SCREENWIDTH/(viewwidth<<detailshift)/DISTMAP;\n\t    \n\t    if (level < 0)\n\t\tlevel = 0;\n\n\t    if (level >= NUMCOLORMAPS)\n\t\tlevel = NUMCOLORMAPS-1;\n\n\t    scalelight[i][j] = colormaps[0] + level*256;\n\t}\n    }\n}\n\n\n\n//\n// R_Init\n//\n\n\n\nvoid R_Init (void)\n{\n    R_InitData ();\n    R_InitPointToAngle ();\n    R_InitTables ();\n    // viewwidth / viewheight / detailLevel are set by the defaults\n\n    R_SetViewSize (screenblocks, detailLevel);\n    R_InitPlanes ();\n    R_InitLightTables ();\n    R_InitSkyMap ();\n    R_InitTranslationTables ();\n\t\n    framecount = 0;\n}\n\n\n//\n// R_PointInSubsector\n//\nsubsector_t*\nR_PointInSubsector\n( fixed_t\tx,\n  fixed_t\ty )\n{\n    node_t*\tnode;\n    int\t\tside;\n    int\t\tnodenum;\n\n    // single subsector is a special case\n    if (!numnodes)\t\t\t\t\n\treturn subsectors;\n\t\t\n    nodenum = numnodes-1;\n\n    while (! (nodenum & NF_SUBSECTOR) )\n    {\n\tnode = &nodes[nodenum];\n\tside = R_PointOnSide (x, y, node);\n\tnodenum = node->children[side];\n    }\n\t\n    return &subsectors[nodenum & ~NF_SUBSECTOR];\n}\n\n\n\n//\n// R_SetupFrame\n//\nvoid R_SetupFrame (player_t* player)\n{\t\t\n    int\t\ti, cm;\n    int\t\ttempCentery;\n    \n    viewplayer = player;\n\n    viewx = player->mo->x;\n    viewy = player->mo->y;\n    viewz = player->viewz;\n    viewangle = player->mo->angle + viewangleoffset;\n\n    extralight = player->extralight;\n\n    // apply new yslope[] whenever \"lookdir\", \"detailshift\" or \"screenblocks\" change\n    tempCentery = viewheight/2 * (screenblocks < 11 ? screenblocks : 11) / 10;\n    if (centery != tempCentery)\n    {\n        centery = tempCentery;\n        centeryfrac = centery << FRACBITS;\n        yslope = yslopes[LOOKDIRMIN];\n    }\n    \n    viewsin = finesine[viewangle>>ANGLETOFINESHIFT];\n    viewcos = finecosine[viewangle>>ANGLETOFINESHIFT];\n\t\n    // killough 3/20/98, 4/4/98: select colormap based on player status\n\n    if (player->mo->subsector->sector->heightsec != -1)\n        {\n        sector_t *s = &sectors[player->mo->subsector->sector->heightsec];\n        cm = viewz < s->floorheight ? s->bottommap : viewz > s->ceilingheight ?\n            s->topmap : s->midmap;\n        if (cm < 0 || cm > numcolormaps)\n            cm = 0;\n        }\n    else\n        cm = 0;\n\n    fullcolormap = colormaps[cm];\n    cm_zlight = zlight[0];\n\n    sscount = 0;\n\t\n    if (player->fixedcolormap)\n    {\n\tfixedcolormap =\n\t    colormaps[0]\n\t    + player->fixedcolormap*256;\n\t\n\twalllights = scalelightfixed;\n\n\tfor (i=0 ; i<MAXLIGHTSCALE ; i++)\n\t    scalelightfixed[i] = fixedcolormap;\n    }\n    else\n\tfixedcolormap = 0;\n\t\t\n    framecount++;\n    validcount++;\n}\n\n\n\n//\n// R_RenderView\n//\nvoid R_RenderPlayerView (player_t* player)\n{\t\n    extern void V_DrawFilledBox (int x, int y, int w, int h, int c);\n    extern void R_InterpolateTextureOffsets (void);\n\n    R_SetupFrame (player);\n\n    // Clear buffers.\n    R_ClearClipSegs ();\n    R_ClearDrawSegs ();\n    R_ClearPlanes ();\n    R_ClearSprites ();\n    if (automapactive)\n    {\n        R_RenderBSPNode (numnodes-1);\n        return;\n    }\n    \n    // [crispy] flashing HOM indicator\n    V_DrawFilledBox(viewwindowx, viewwindowy,\n        scaledviewwidth, viewheight, 0);\n\n    // check for new console commands.\n    NetUpdate ();\n\n    // [crispy] smooth texture scrolling\n    R_InterpolateTextureOffsets();\n    // The head node is the last node output.\n    R_RenderBSPNode (numnodes-1);\n    \n    // Check for new console commands.\n    NetUpdate ();\n    \n    R_DrawPlanes ();\n    \n    // Check for new console commands.\n    NetUpdate ();\n    \n    // [crispy] draw fuzz effect independent of rendering frame rate\n    R_SetFuzzPosDraw();\n    R_DrawMasked ();\n\n    // Check for new console commands.\n    NetUpdate ();\t\t\t\t\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 1993-2008 Raven Software\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tGamma correction LUT stuff.\n//\tFunctions to draw patches (by post) directly to screen.\n//\tFunctions to blit a block to the screen.\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#include \"i_system.h\"\n\n#include \"doomtype.h\"\n\n#include \"deh_str.h\"\n#include \"i_input.h\"\n#include \"i_swap.h\"\n#include \"i_video.h\"\n#include \"m_bbox.h\"\n#include \"m_misc.h\"\n#include \"v_video.h\"\n#include \"w_wad.h\"\n#include \"z_zone.h\"\n\n#include \"config.h\"\n#ifdef HAVE_LIBPNG\n#include <emscripten.h>\n#include <png.h>\n#endif\n\n// TODO: There are separate RANGECHECK defines for different games, but this\n// is common code. Fix this.\n#define RANGECHECK\n\n// Blending table used for fuzzpatch, etc.\n// Only used in Heretic/Hexen\n\nbyte *tinttable = NULL;\nbyte *tranmap = NULL;\nbyte *dp_translation = NULL;\nboolean dp_translucent = false;\n\n// villsa [STRIFE] Blending table used for Strife\nbyte *xlatab = NULL;\n\n// The screen buffer that the v_video.c code draws to.\n\nstatic pixel_t *dest_screen = NULL;\n\nint dirtybox[4];\n\n// haleyjd 08/28/10: clipping callback function for patches.\n// This is needed for Chocolate Strife, which clips patches to the screen.\nstatic vpatchclipfunc_t patchclip_callback = NULL;\n\n//\n// V_MarkRect\n//\nvoid V_MarkRect(int x, int y, int width, int height)\n{\n    // If we are temporarily using an alternate screen, do not\n    // affect the update box.\n\n    if (dest_screen == I_VideoBuffer)\n    {\n        M_AddToBox (dirtybox, x, y);\n        M_AddToBox (dirtybox, x + width-1, y + height-1);\n    }\n}\n\n\n//\n// V_CopyRect\n//\nvoid V_CopyRect(int srcx, int srcy, pixel_t *source,\n                int width, int height,\n                int destx, int desty)\n{\n    pixel_t *src;\n    pixel_t *dest;\n\n#ifdef RANGECHECK\n    if (srcx < 0\n     || srcx + width > SCREENWIDTH\n     || srcy < 0\n     || srcy + height > SCREENHEIGHT\n     || destx < 0\n     || destx /* + width */ > SCREENWIDTH\n     || desty < 0\n     || desty /* + height */ > SCREENHEIGHT)\n    {\n        I_Error (\"Bad V_CopyRect\");\n    }\n#endif\n\n    // [crispy] prevent framebuffer overflow\n    if (destx + width > SCREENWIDTH)\n\twidth = SCREENWIDTH - destx;\n    if (desty + height > SCREENHEIGHT)\n\theight = SCREENHEIGHT - desty;\n\n    V_MarkRect(destx, desty, width, height);\n\n    src = source + SCREENWIDTH * srcy + srcx;\n    dest = dest_screen + SCREENWIDTH * desty + destx;\n\n    for ( ; height>0 ; height--)\n    {\n        memcpy(dest, src, width * sizeof(*dest));\n        src += SCREENWIDTH;\n        dest += SCREENWIDTH;\n    }\n}\n\n//\n// V_SetPatchClipCallback\n//\n// haleyjd 08/28/10: Added for Strife support.\n// By calling this function, you can setup runtime error checking for patch\n// clipping. Strife never caused errors by drawing patches partway off-screen.\n// Some versions of vanilla DOOM also behaved differently than the default\n// implementation, so this could possibly be extended to those as well for\n// accurate emulation.\n//\nvoid V_SetPatchClipCallback(vpatchclipfunc_t func)\n{\n    patchclip_callback = func;\n}\n\n//\n// V_DrawPatch\n// Masks a column based masked pic to the screen.\n//\n\n// [crispy] four different rendering functions\n// for each possible combination of dp_translation and dp_translucent:\n// (1) normal, opaque patch\nstatic const inline byte drawpatchpx00 (const byte dest, const byte source)\n{return source;}\n// (2) color-translated, opaque patch\nstatic const inline byte drawpatchpx01 (const byte dest, const byte source)\n{return dp_translation[source];}\n// (3) normal, translucent patch\nstatic const inline byte drawpatchpx10 (const byte dest, const byte source)\n{return tranmap[(dest<<8)+source];}\n// (4) color-translated, translucent patch\nstatic const inline byte drawpatchpx11 (const byte dest, const byte source)\n{return tranmap[(dest<<8)+dp_translation[source]];}\n\nstatic void V_DrawPatchCrispy(int x, int y, patch_t *patch, int r)\n{\n    int count;\n    int col;\n    column_t *column;\n    pixel_t *desttop;\n    pixel_t *dest;\n    byte *source;\n    byte *desttop2, *dest2;\n    int w;\n\n    // [crispy] four different rendering functions\n    const byte (* drawpatchpx) (const byte dest, const byte source) =\n        (!dp_translucent ?\n        (!dp_translation ? drawpatchpx00 : drawpatchpx01) :\n        (!dp_translation ? drawpatchpx10 : drawpatchpx11));\n\n    y -= SHORT(patch->topoffset);\n    x -= SHORT(patch->leftoffset);\n\n    // haleyjd 08/28/10: Strife needs silent error checking here.\n    if(patchclip_callback)\n    {\n        if(!patchclip_callback(patch, x, y))\n            return;\n    }\n\n// #ifdef RANGECHECK_NOTHANKS\n//     if (x < 0\n//      || x + SHORT(patch->width) > SCREENWIDTH\n//      || y < 0\n//      || y + SHORT(patch->height) > SCREENHEIGHT)\n//     {\n//         I_Error(\"Bad V_DrawPatch\");\n//     }\n// #endif\n\n    V_MarkRect(x, y, SHORT(patch->width), SHORT(patch->height));\n\n    col = 0;\n    desttop = dest_screen + y * SCREENWIDTH + x;\n    desttop2 = dest_screen + (y + r) * SCREENWIDTH + (x + r);\n\n    w = SHORT(patch->width);\n\n    for ( ; col<w ; x++, col++, desttop++, desttop2++)\n    {\n        int topdelta = -1;\n\n        // [crispy] too far left\n        if (x < 0)\n        {\n            continue;\n        }\n\n        // [crispy] too far right / width\n        if (x >= SCREENWIDTH)\n        {\n            break;\n        }\n\n        column = (column_t *)((byte *)patch + LONG(patch->columnofs[col]));\n\n        // step through the posts in a column\n        while (column->topdelta != 0xff)\n        {\n            int top, srccol = 0;\n            // [crispy] support for DeePsea tall patches\n            if (column->topdelta <= topdelta)\n            {\n                topdelta += column->topdelta;\n            }\n            else\n            {\n                topdelta = column->topdelta;\n            }\n            top = y + topdelta;\n            source = (byte *)column + 3;\n            dest = desttop + topdelta * SCREENWIDTH;\n            dest2 = desttop2 + topdelta * SCREENWIDTH;\n            count = column->length;\n\n            // [crispy] too low / height\n            if (top + count > SCREENHEIGHT)\n            {\n                count = SCREENHEIGHT - top;\n            }\n\n            // [crispy] nothing left to draw?\n            if (count < 1)\n            {\n                break;\n            }\n\n            while (count--)\n            {\n                if (r)\n                {\n                    *dest2 = tinttable[*dest2];\n                    dest2 += SCREENWIDTH;\n                }\n\n                // [crispy] too high\n                if (top++ >= 0)\n                {\n                    *dest = drawpatchpx(*dest, source[srccol]);\n                }\n                srccol++;\n                dest += SCREENWIDTH;\n            }\n            column = (column_t *)((byte *)column + column->length + 4);\n        }\n    }\n}\n\nvoid V_DrawPatch(int x, int y, patch_t *patch)\n{\n    return V_DrawPatchCrispy(x, y, patch, 0);\n}\n\nvoid V_DrawPatchShadow1(int x, int y, patch_t *patch)\n{\n    return V_DrawPatchCrispy(x, y, patch, 1);\n}\n\nvoid V_DrawPatchShadow2(int x, int y, patch_t *patch)\n{\n    return V_DrawPatchCrispy(x, y, patch, 2);\n}\n\n//\n// V_DrawPatchFlipped\n// Masks a column based masked pic to the screen.\n// Flips horizontally, e.g. to mirror face.\n//\n\nvoid V_DrawPatchFlipped(int x, int y, patch_t *patch)\n{\n    int count;\n    int col;\n    column_t *column;\n    pixel_t *desttop;\n    pixel_t *dest;\n    byte *source;\n    int w;\n\n    y -= SHORT(patch->topoffset);\n    x -= SHORT(patch->leftoffset);\n\n    // haleyjd 08/28/10: Strife needs silent error checking here.\n    if(patchclip_callback)\n    {\n        if(!patchclip_callback(patch, x, y))\n            return;\n    }\n\n#ifdef RANGECHECK_NOTHANKS\n    if (x < 0\n     || x + SHORT(patch->width) > SCREENWIDTH\n     || y < 0\n     || y + SHORT(patch->height) > SCREENHEIGHT)\n    {\n        I_Error(\"Bad V_DrawPatchFlipped\");\n    }\n#endif\n\n    V_MarkRect (x, y, SHORT(patch->width), SHORT(patch->height));\n\n    col = 0;\n    desttop = dest_screen + y * SCREENWIDTH + x;\n\n    w = SHORT(patch->width);\n\n    for ( ; col<w ; x++, col++, desttop++)\n    {\n        int topdelta = -1;\n\n        // [crispy] too far left\n        if (x < 0)\n        {\n            continue;\n        }\n\n        // [crispy] too far right / width\n        if (x >= SCREENWIDTH)\n        {\n            break;\n        }\n\n        column = (column_t *)((byte *)patch + LONG(patch->columnofs[w-1-col]));\n\n        // step through the posts in a column\n        while (column->topdelta != 0xff )\n        {\n            int top, srccol = 0;\n            // [crispy] support for DeePsea tall patches\n            if (column->topdelta <= topdelta)\n            {\n                topdelta += column->topdelta;\n            }\n            else\n            {\n                topdelta = column->topdelta;\n            }\n            top = y + topdelta;\n            source = (byte *)column + 3;\n            dest = desttop + topdelta * SCREENWIDTH;\n            count = column->length;\n\n            // [crispy] too low / height\n            if (top + count > SCREENHEIGHT)\n            {\n                count = SCREENHEIGHT - top;\n            }\n\n            // [crispy] nothing left to draw?\n            if (count < 1)\n            {\n                break;\n            }\n\n            while (count--)\n            {\n                // [crispy] too high\n                if (top++ >= 0)\n                {\n                    *dest = source[srccol];\n                }\n                srccol++;\n                dest += SCREENWIDTH;\n            }\n            column = (column_t *)((byte *)column + column->length + 4);\n        }\n    }\n}\n\n\n\n//\n// V_DrawPatchDirect\n// Draws directly to the screen on the pc.\n//\n\nvoid V_DrawPatchDirect(int x, int y, patch_t *patch)\n{\n    V_DrawPatch(x, y, patch);\n}\n\n//\n// V_DrawTLPatch\n//\n// Masks a column based translucent masked pic to the screen.\n//\n\nvoid V_DrawTLPatch(int x, int y, patch_t * patch)\n{\n    int count, col;\n    column_t *column;\n    pixel_t *desttop, *dest;\n    byte *source;\n    int w;\n\n    y -= SHORT(patch->topoffset);\n    x -= SHORT(patch->leftoffset);\n\n    if (x < 0\n     || x + SHORT(patch->width) > SCREENWIDTH\n     || y < 0\n     || y + SHORT(patch->height) > SCREENHEIGHT)\n    {\n        I_Error(\"Bad V_DrawTLPatch\");\n    }\n\n    col = 0;\n    desttop = dest_screen + y * SCREENWIDTH + x;\n\n    w = SHORT(patch->width);\n    for (; col < w; x++, col++, desttop++)\n    {\n        column = (column_t *) ((byte *) patch + LONG(patch->columnofs[col]));\n\n        // step through the posts in a column\n\n        while (column->topdelta != 0xff)\n        {\n            int srccol = 0;\n            source = (byte *) column + 3;\n            dest = desttop + column->topdelta * SCREENWIDTH;\n            count = column->length;\n\n            while (count--)\n            {\n                *dest = tinttable[((*dest) << 8) + source[srccol]];\n                srccol++;\n                dest += SCREENWIDTH;\n            }\n            column = (column_t *) ((byte *) column + column->length + 4);\n        }\n    }\n}\n\n//\n// V_DrawXlaPatch\n//\n// villsa [STRIFE] Masks a column based translucent masked pic to the screen.\n//\n\nvoid V_DrawXlaPatch(int x, int y, patch_t * patch)\n{\n    int count, col;\n    column_t *column;\n    pixel_t *desttop, *dest;\n    byte *source;\n    int w;\n\n    y -= SHORT(patch->topoffset);\n    x -= SHORT(patch->leftoffset);\n\n    if(patchclip_callback)\n    {\n        if(!patchclip_callback(patch, x, y))\n            return;\n    }\n\n    col = 0;\n    desttop = dest_screen + y * SCREENWIDTH + x;\n\n    w = SHORT(patch->width);\n    for(; col < w; x++, col++, desttop++)\n    {\n        column = (column_t *) ((byte *) patch + LONG(patch->columnofs[col]));\n\n        // step through the posts in a column\n\n        while(column->topdelta != 0xff)\n        {\n            int srccol = 0;\n            source = (byte *) column + 3;\n            dest = desttop + column->topdelta * SCREENWIDTH;\n            count = column->length;\n\n            while(count--)\n            {\n                *dest = xlatab[*dest + (source[srccol] << 8)];\n                srccol++;\n                dest += SCREENWIDTH;\n            }\n            column = (column_t *) ((byte *) column + column->length + 4);\n        }\n    }\n}\n\n//\n// V_DrawAltTLPatch\n//\n// Masks a column based translucent masked pic to the screen.\n//\n\nvoid V_DrawAltTLPatch(int x, int y, patch_t * patch)\n{\n    int count, col;\n    column_t *column;\n    pixel_t *desttop, *dest;\n    byte *source;\n    int w;\n\n    y -= SHORT(patch->topoffset);\n    x -= SHORT(patch->leftoffset);\n\n    if (x < 0\n     || x + SHORT(patch->width) > SCREENWIDTH\n     || y < 0\n     || y + SHORT(patch->height) > SCREENHEIGHT)\n    {\n        I_Error(\"Bad V_DrawAltTLPatch\");\n    }\n\n    col = 0;\n    desttop = dest_screen + y * SCREENWIDTH + x;\n\n    w = SHORT(patch->width);\n    for (; col < w; x++, col++, desttop++)\n    {\n        column = (column_t *) ((byte *) patch + LONG(patch->columnofs[col]));\n\n        // step through the posts in a column\n\n        while (column->topdelta != 0xff)\n        {\n            int srccol = 0;\n            source = (byte *) column + 3;\n            dest = desttop + column->topdelta * SCREENWIDTH;\n            count = column->length;\n\n            while (count--)\n            {\n                *dest = tinttable[((*dest) << 8) + source[srccol]];\n                srccol++;\n                dest += SCREENWIDTH;\n            }\n            column = (column_t *) ((byte *) column + column->length + 4);\n        }\n    }\n}\n\n//\n// V_DrawShadowedPatch\n//\n// Masks a column based masked pic to the screen.\n//\n\nvoid V_DrawShadowedPatch(int x, int y, patch_t *patch)\n{\n    int count, col;\n    column_t *column;\n    pixel_t *desttop, *dest;\n    byte *source;\n    pixel_t *desttop2, *dest2;\n    int w;\n\n    y -= SHORT(patch->topoffset);\n    x -= SHORT(patch->leftoffset);\n\n    if (x < 0\n     || x + SHORT(patch->width) > SCREENWIDTH\n     || y < 0\n     || y + SHORT(patch->height) > SCREENHEIGHT)\n    {\n        I_Error(\"Bad V_DrawShadowedPatch\");\n    }\n\n    col = 0;\n    desttop = dest_screen + y * SCREENWIDTH + x;\n    desttop2 = dest_screen + (y + 2) * SCREENWIDTH + (x + 2);\n\n    w = SHORT(patch->width);\n    for (; col < w; x++, col++, desttop++, desttop2++)\n    {\n        column = (column_t *) ((byte *) patch + LONG(patch->columnofs[col]));\n\n        // step through the posts in a column\n\n        while (column->topdelta != 0xff)\n        {\n            int srccol = 0;\n            source = (byte *) column + 3;\n            dest = desttop + column->topdelta * SCREENWIDTH;\n            dest2 = desttop2 + column->topdelta * SCREENWIDTH;\n            count = column->length;\n\n            while (count--)\n            {\n                *dest2 = tinttable[((*dest2) << 8)];\n                dest2 += SCREENWIDTH;\n                *dest = source[srccol];\n                srccol++;\n                dest += SCREENWIDTH;\n\n            }\n            column = (column_t *) ((byte *) column + column->length + 4);\n        }\n    }\n}\n\n//\n// Load tint table from TINTTAB lump.\n//\n\nvoid V_LoadTintTable(void)\n{\n    tinttable = W_CacheLumpName(\"TINTTAB\", PU_STATIC);\n}\n\n//\n// V_LoadXlaTable\n//\n// villsa [STRIFE] Load xla table from XLATAB lump.\n//\n\nvoid V_LoadXlaTable(void)\n{\n    xlatab = W_CacheLumpName(\"XLATAB\", PU_STATIC);\n}\n\n//\n// V_DrawBlock\n// Draw a linear block of pixels into the view buffer.\n//\n\nvoid V_DrawBlock(int x, int y, int width, int height, pixel_t *src)\n{\n    pixel_t *dest;\n\n#ifdef RANGECHECK\n    if (x < 0\n     || x + width >SCREENWIDTH\n     || y < 0\n     || y + height > SCREENHEIGHT)\n    {\n\tI_Error (\"Bad V_DrawBlock\");\n    }\n#endif\n\n    V_MarkRect (x, y, width, height);\n\n    dest = dest_screen + y * SCREENWIDTH + x;\n\n    while (height--)\n    {\n\tmemcpy (dest, src, width * sizeof(*dest));\n\tsrc += width;\n\tdest += SCREENWIDTH;\n    }\n}\n\nvoid V_DrawScaledBlock(int x, int y, int width, int height, byte *src)\n{\n    byte *dest;\n    int i, j;\n\n#ifdef RANGECHECK\n    if (x < 0\n     || x + width > SCREENWIDTH\n     || y < 0\n     || y + height > SCREENHEIGHT)\n    {\n\tI_Error (\"Bad V_DrawScaledBlock\");\n    }\n#endif\n\n    V_MarkRect (x, y, width, height);\n\n    dest = dest_screen + y * SCREENWIDTH + x;\n\n    for (i = 0; i < height; i++)\n    {\n        for (j = 0; j < width; j++)\n        {\n            *(dest + i * SCREENWIDTH + j) = *(src + i * width + j);\n        }\n    }\n}\n\nvoid V_DrawFilledBox(int x, int y, int w, int h, int c)\n{\n    pixel_t *buf, *buf1;\n    int x1, y1;\n\n    buf = I_VideoBuffer + SCREENWIDTH * y + x;\n\n    for (y1 = 0; y1 < h; ++y1)\n    {\n        buf1 = buf;\n\n        for (x1 = 0; x1 < w; ++x1)\n        {\n            *buf1++ = c;\n        }\n\n        buf += SCREENWIDTH;\n    }\n}\n\nvoid V_DrawHorizLine(int x, int y, int w, int c)\n{\n    pixel_t *buf;\n    int x1;\n\n    // [crispy] prevent framebuffer overflows\n    if (x + w > SCREENWIDTH)\n\tw = SCREENWIDTH - x;\n\n    buf = I_VideoBuffer + SCREENWIDTH * y + x;\n\n    for (x1 = 0; x1 < w; ++x1)\n    {\n        *buf++ = c;\n    }\n}\n\nvoid V_DrawVertLine(int x, int y, int h, int c)\n{\n    pixel_t *buf;\n    int y1;\n\n    buf = I_VideoBuffer + SCREENWIDTH * y + x;\n\n    for (y1 = 0; y1 < h; ++y1)\n    {\n        *buf = c;\n        buf += SCREENWIDTH;\n    }\n}\n\nvoid V_DrawBox(int x, int y, int w, int h, int c)\n{\n    V_DrawHorizLine(x, y, w, c);\n    V_DrawHorizLine(x, y+h-1, w, c);\n    V_DrawVertLine(x, y, h, c);\n    V_DrawVertLine(x+w-1, y, h, c);\n}\n\n//\n// Draw a \"raw\" screen (lump containing raw data to blit directly\n// to the screen)\n//\n\n// void V_CopyScaledBuffer(byte *dest, byte *src, size_t size)\n// {\n// }\n\nvoid V_DrawRawScreen(pixel_t *raw)\n{\n    memcpy(dest_screen, raw, SCREENWIDTH * SCREENHEIGHT * sizeof(*dest_screen));\n}\n\n//\n// V_Init\n//\nvoid V_Init (void)\n{\n    // no-op!\n    // There used to be separate screens that could be drawn to; these are\n    // now handled in the upper layers.\n}\n\n// Set the buffer that the code draws to.\n\nvoid V_UseBuffer(pixel_t *buffer)\n{\n    dest_screen = buffer;\n}\n\n// Restore screen buffer to the i_video screen buffer.\n\nvoid V_RestoreBuffer(void)\n{\n    dest_screen = I_VideoBuffer;\n}\n\n//\n// SCREEN SHOTS\n//\n\ntypedef PACKED_STRUCT (\n{\n    char\t\tmanufacturer;\n    char\t\tversion;\n    char\t\tencoding;\n    char\t\tbits_per_pixel;\n\n    unsigned short\txmin;\n    unsigned short\tymin;\n    unsigned short\txmax;\n    unsigned short\tymax;\n\n    unsigned short\thres;\n    unsigned short\tvres;\n\n    unsigned char\tpalette[48];\n\n    char\t\treserved;\n    char\t\tcolor_planes;\n    unsigned short\tbytes_per_line;\n    unsigned short\tpalette_type;\n\n    char\t\tfiller[58];\n    unsigned char\tdata;\t\t// unbounded\n}) pcx_t;\n\n\n//\n// WritePCXfile\n//\n\nvoid WritePCXfile(char *filename, pixel_t *data,\n                  int width, int height,\n                  byte *palette)\n{\n    int\t\ti;\n    int\t\tlength;\n    pcx_t*\tpcx;\n    byte*\tpack;\n\n    pcx = Z_Malloc (width*height*2+1000, PU_STATIC, NULL);\n\n    pcx->manufacturer = 0x0a;\t\t// PCX id\n    pcx->version = 5;\t\t\t// 256 color\n    pcx->encoding = 1;\t\t\t// uncompressed\n    pcx->bits_per_pixel = 8;\t\t// 256 color\n    pcx->xmin = 0;\n    pcx->ymin = 0;\n    pcx->xmax = SHORT(width-1);\n    pcx->ymax = SHORT(height-1);\n    pcx->hres = SHORT(1);\n    pcx->vres = SHORT(1);\n    memset (pcx->palette,0,sizeof(pcx->palette));\n    pcx->reserved = 0;                  // PCX spec: reserved byte must be zero\n    pcx->color_planes = 1;\t\t// chunky image\n    pcx->bytes_per_line = SHORT(width);\n    pcx->palette_type = SHORT(2);\t// not a grey scale\n    memset (pcx->filler,0,sizeof(pcx->filler));\n\n    // pack the image\n    pack = &pcx->data;\n\n    for (i=0 ; i<width*height ; i++)\n    {\n\tif ( (*data & 0xc0) != 0xc0)\n\t    *pack++ = *data++;\n\telse\n\t{\n\t    *pack++ = 0xc1;\n\t    *pack++ = *data++;\n\t}\n    }\n\n    // write the palette\n    *pack++ = 0x0c;\t// palette ID byte\n    for (i=0 ; i<768 ; i++)\n\t*pack++ = *palette++;\n\n    // write output file\n    length = pack - (byte *)pcx;\n    M_WriteFile (filename, pcx, length);\n\n    Z_Free (pcx);\n}\n\n#ifdef HAVE_LIBPNG\n//\n// WritePNGfile\n//\n\nstatic void error_fn(png_structp p, png_const_charp s)\n{\n    printf(\"libpng error: %s\\n\", s);\n}\n\nstatic void warning_fn(png_structp p, png_const_charp s)\n{\n    printf(\"libpng warning: %s\\n\", s);\n}\n\nvoid WritePNGfile(char *filename, pixel_t *data,\n                  int width, int height,\n                  byte *palette)\n{\n    png_structp ppng;\n    png_infop pinfo;\n    png_colorp pcolor;\n    FILE *handle;\n    int i, j;\n    int w_factor, h_factor;\n    byte *rowbuf;\n\n    if (aspect_ratio_correct)\n    {\n        // scale up to accommodate aspect ratio correction\n        w_factor = 5;\n        h_factor = 6;\n\n        width *= w_factor;\n        height *= h_factor;\n    }\n    else\n    {\n        w_factor = 1;\n        h_factor = 1;\n    }\n\n    handle = fopen(filename, \"wb\");\n    if (!handle)\n    {\n        return;\n    }\n\n    ppng = png_create_write_struct(PNG_LIBPNG_VER_STRING, NULL,\n                                   error_fn, warning_fn);\n    if (!ppng)\n    {\n        fclose(handle);\n        return;\n    }\n\n    pinfo = png_create_info_struct(ppng);\n    if (!pinfo)\n    {\n        fclose(handle);\n        png_destroy_write_struct(&ppng, NULL);\n        return;\n    }\n\n    png_init_io(ppng, handle);\n\n    png_set_IHDR(ppng, pinfo, width, height,\n                 8, PNG_COLOR_TYPE_PALETTE, PNG_INTERLACE_NONE,\n                 PNG_COMPRESSION_TYPE_DEFAULT, PNG_FILTER_TYPE_DEFAULT);\n\n    pcolor = malloc(sizeof(*pcolor) * 256);\n    if (!pcolor)\n    {\n        fclose(handle);\n        png_destroy_write_struct(&ppng, &pinfo);\n        return;\n    }\n\n    for (i = 0; i < 256; i++)\n    {\n        pcolor[i].red   = *(palette + 3 * i);\n        pcolor[i].green = *(palette + 3 * i + 1);\n        pcolor[i].blue  = *(palette + 3 * i + 2);\n    }\n\n    png_set_PLTE(ppng, pinfo, pcolor, 256);\n    free(pcolor);\n\n    png_write_info(ppng, pinfo);\n\n    rowbuf = malloc(width);\n\n    if (rowbuf)\n    {\n        for (i = 0; i < SCREENHEIGHT; i++)\n        {\n            // expand the row 5x\n            for (j = 0; j < SCREENWIDTH; j++)\n            {\n                memset(rowbuf + j * w_factor, *(data + i*SCREENWIDTH + j), w_factor);\n            }\n\n            // write the row 6 times\n            for (j = 0; j < h_factor; j++)\n            {\n                png_write_row(ppng, rowbuf);\n            }\n        }\n\n        free(rowbuf);\n    }\n\n    png_write_end(ppng, pinfo);\n    png_destroy_write_struct(&ppng, &pinfo);\n    fclose(handle);\n\n    EM_ASM({\n        var filename = Module.UTF8ToString($0);\n        var url = URL.createObjectURL(new Blob([Module.FS.readFile(filename)], {type: 'image/png'}));\n        document.dispatchEvent(new CustomEvent(\"V_ScreenShot\", { detail: { url: url } }));\n        Module.FS.unlink(filename);\n    }, filename);\n}\n#endif\n\n//\n// V_ScreenShot\n//\n\nvoid V_ScreenShot(const char *format)\n{\n    int i;\n    char lbmname[16]; // haleyjd 20110213: BUG FIX - 12 is too small!\n    const char *ext;\n\n    // find a file name to save it to\n\n#ifdef HAVE_LIBPNG\n    extern int png_screenshots;\n    if (png_screenshots)\n    {\n        ext = \"png\";\n    }\n    else\n#endif\n    {\n        ext = \"pcx\";\n    }\n\n    for (i=0; i<=9999; i++) // [crispy] increase screenshot filename limit\n    {\n        M_snprintf(lbmname, sizeof(lbmname), format, i, ext);\n\n        if (!M_FileExists(lbmname))\n        {\n            break;      // file doesn't exist\n        }\n    }\n\n    if (i == 10000) // [crispy] increase screenshot filename limit\n    {\n#ifdef HAVE_LIBPNG\n        if (png_screenshots)\n        {\n            I_Error (\"V_ScreenShot: Couldn't create a PNG\");\n        }\n        else\n#endif\n        {\n            I_Error (\"V_ScreenShot: Couldn't create a PCX\");\n        }\n    }\n\n#ifdef HAVE_LIBPNG\n    if (png_screenshots)\n    {\n    WritePNGfile(lbmname, I_VideoBuffer,\n                 SCREENWIDTH, SCREENHEIGHT,\n                 W_CacheLumpName (DEH_String(\"PLAYPAL\"), PU_CACHE));\n    }\n    else\n#endif\n    {\n    // save the pcx file\n    WritePCXfile(lbmname, I_VideoBuffer,\n                 SCREENWIDTH, SCREENHEIGHT,\n                 W_CacheLumpName (DEH_String(\"PLAYPAL\"), PU_CACHE));\n    }\n}\n\n#define MOUSE_SPEED_BOX_WIDTH  120\n#define MOUSE_SPEED_BOX_HEIGHT 9\n\n//\n// V_DrawMouseSpeedBox\n//\n\n// If box is only to calibrate speed, testing relative speed (as a measure\n// of game pixels to movement units) is important whether physical mouse DPI\n// is high or low. Line resolution starts at 1 pixel per 1 move-unit: if\n// line maxes out, resolution becomes 1 pixel per 2 move-units, then per\n// 3 move-units, etc.\n\nstatic int linelen_multiplier = 1;\n\nvoid V_DrawMouseSpeedBox(int speed)\n{\n    extern int usemouse;\n    int bgcolor, bordercolor, red, black, white, yellow;\n    int box_x, box_y;\n    int original_speed;\n    int redline_x;\n    int linelen;\n    int i;\n    boolean draw_acceleration = false;\n\n    // Get palette indices for colors for widget. These depend on the\n    // palette of the game being played.\n\n    bgcolor = I_GetPaletteIndex(0x77, 0x77, 0x77);\n    bordercolor = I_GetPaletteIndex(0x55, 0x55, 0x55);\n    red = I_GetPaletteIndex(0xff, 0x00, 0x00);\n    black = I_GetPaletteIndex(0x00, 0x00, 0x00);\n    yellow = I_GetPaletteIndex(0xff, 0xff, 0x00);\n    white = I_GetPaletteIndex(0xff, 0xff, 0xff);\n\n    // If the mouse is turned off, don't draw the box at all.\n    if (!usemouse)\n    {\n        return;\n    }\n\n    // If acceleration is used, draw a box that helps to calibrate the\n    // threshold point.\n    if (mouse_threshold > 0 && fabs(mouse_acceleration - 1) > 0.01)\n    {\n        draw_acceleration = true;\n    }\n\n    // Calculate box position\n\n    box_x = SCREENWIDTH - MOUSE_SPEED_BOX_WIDTH - 10;\n    box_y = 15;\n\n    V_DrawFilledBox(box_x, box_y,\n                    MOUSE_SPEED_BOX_WIDTH, MOUSE_SPEED_BOX_HEIGHT, bgcolor);\n    V_DrawBox(box_x, box_y,\n              MOUSE_SPEED_BOX_WIDTH, MOUSE_SPEED_BOX_HEIGHT, bordercolor);\n\n    // Calculate the position of the red threshold line when calibrating\n    // acceleration.  This is 1/3 of the way along the box.\n\n    redline_x = MOUSE_SPEED_BOX_WIDTH / 3;\n\n    // Calculate line length\n\n    if (draw_acceleration && speed >= mouse_threshold)\n    {\n        // Undo acceleration and get back the original mouse speed\n        original_speed = speed - mouse_threshold;\n        original_speed = (int) (original_speed / mouse_acceleration);\n        original_speed += mouse_threshold;\n\n        linelen = (original_speed * redline_x) / mouse_threshold;\n    }\n    else\n    {\n        linelen = speed / linelen_multiplier;\n    }\n\n    // Draw horizontal \"thermometer\"\n\n    if (linelen > MOUSE_SPEED_BOX_WIDTH - 1)\n    {\n        linelen = MOUSE_SPEED_BOX_WIDTH - 1;\n        if (!draw_acceleration)\n        {\n            linelen_multiplier++;\n        }\n    }\n\n    V_DrawHorizLine(box_x + 1, box_y + 4, MOUSE_SPEED_BOX_WIDTH - 2, black);\n\n    if (!draw_acceleration || linelen < redline_x)\n    {\n        V_DrawHorizLine(box_x + 1, box_y + MOUSE_SPEED_BOX_HEIGHT / 2,\n                        linelen, white);\n    }\n    else\n    {\n        V_DrawHorizLine(box_x + 1, box_y + MOUSE_SPEED_BOX_HEIGHT / 2,\n                        redline_x, white);\n        V_DrawHorizLine(box_x + redline_x, box_y + MOUSE_SPEED_BOX_HEIGHT / 2,\n                        linelen - redline_x, yellow);\n    }\n\n    if (draw_acceleration)\n    {\n        // Draw acceleration threshold line\n        V_DrawVertLine(box_x + redline_x, box_y + 1,\n                       MOUSE_SPEED_BOX_HEIGHT - 2, red);\n    }\n    else\n    {\n        // Draw multiplier lines to indicate current resolution\n        for (i = 1; i < linelen_multiplier; i++)\n        {\n            V_DrawVertLine(\n                box_x + (i * MOUSE_SPEED_BOX_WIDTH / linelen_multiplier),\n                box_y + 1, MOUSE_SPEED_BOX_HEIGHT - 2, yellow);\n        }\n    }\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tWAD I/O functions.\n//\n\n#include <stdio.h>\n\n#include \"config.h\"\n\n#include \"doomtype.h\"\n#include \"m_argv.h\"\n\n#include \"w_file.h\"\n\nextern wad_file_class_t stdc_wad_file;\n\n#ifdef _WIN32\nextern wad_file_class_t win32_wad_file;\n#endif\n\n#ifdef HAVE_MMAP\nextern wad_file_class_t posix_wad_file;\n#endif \n\nstatic wad_file_class_t *wad_file_classes[] = \n{\n#ifdef _WIN32\n    &win32_wad_file,\n#endif\n#ifdef HAVE_MMAP\n    &posix_wad_file,\n#endif\n    &stdc_wad_file,\n};\n\nwad_file_t *W_OpenFile(char *path)\n{\n    wad_file_t *result;\n    int i;\n\n    //!\n    // @category obscure\n    //\n    // Use the OS's virtual memory subsystem to map WAD files\n    // directly into memory.\n    //\n\n    if (!M_CheckParm(\"-mmap\"))\n    {\n        return stdc_wad_file.OpenFile(path);\n    }\n\n    // Try all classes in order until we find one that works\n\n    result = NULL;\n\n    for (i=0; i<arrlen(wad_file_classes); ++i)\n    {\n        result = wad_file_classes[i]->OpenFile(path);\n\n        if (result != NULL)\n        {\n            break;\n        }\n    }\n\n    return result;\n}\n\nvoid W_CloseFile(wad_file_t *wad)\n{\n    wad->file_class->CloseFile(wad);\n}\n\nsize_t W_Read(wad_file_t *wad, unsigned int offset,\n              void *buffer, size_t buffer_len)\n{\n    return wad->file_class->Read(wad, offset, buffer, buffer_len);\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tWAD I/O functions.\n//\n\n#include <stdio.h>\n\n#include \"m_misc.h\"\n#include \"w_file.h\"\n#include \"z_zone.h\"\n\ntypedef struct\n{\n    wad_file_t wad;\n    FILE *fstream;\n} stdc_wad_file_t;\n\nextern wad_file_class_t stdc_wad_file;\n\nstatic wad_file_t *W_StdC_OpenFile(char *path)\n{\n    stdc_wad_file_t *result;\n    FILE *fstream;\n\n    fstream = fopen(path, \"rb\");\n\n    if (fstream == NULL)\n    {\n        return NULL;\n    }\n\n    // Create a new stdc_wad_file_t to hold the file handle.\n\n    result = Z_Malloc(sizeof(stdc_wad_file_t), PU_STATIC, 0);\n    result->wad.file_class = &stdc_wad_file;\n    result->wad.mapped = NULL;\n    result->wad.length = M_FileLength(fstream);\n    result->wad.path = M_StringDuplicate(path);\n    result->fstream = fstream;\n\n    return &result->wad;\n}\n\nstatic void W_StdC_CloseFile(wad_file_t *wad)\n{\n    stdc_wad_file_t *stdc_wad;\n\n    stdc_wad = (stdc_wad_file_t *) wad;\n\n    fclose(stdc_wad->fstream);\n    Z_Free(stdc_wad);\n}\n\n// Read data from the specified position in the file into the \n// provided buffer.  Returns the number of bytes read.\n\nsize_t W_StdC_Read(wad_file_t *wad, unsigned int offset,\n                   void *buffer, size_t buffer_len)\n{\n    stdc_wad_file_t *stdc_wad;\n    size_t result;\n\n    stdc_wad = (stdc_wad_file_t *) wad;\n\n    // Jump to the specified position in the file.\n\n    fseek(stdc_wad->fstream, offset, SEEK_SET);\n\n    // Read into the buffer.\n\n    result = fread(buffer, 1, buffer_len, stdc_wad->fstream);\n\n    return result;\n}\n\n\nwad_file_class_t stdc_wad_file = \n{\n    W_StdC_OpenFile,\n    W_StdC_CloseFile,\n    W_StdC_Read,\n};\n\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//     Common code to parse command line, identifying WAD files to load.\n//\n\n#include \"config.h\"\n#include \"d_iwad.h\"\n#include \"i_system.h\"\n#include \"m_argv.h\"\n#include \"w_main.h\"\n#include \"w_merge.h\"\n#include \"w_wad.h\"\n#include \"z_zone.h\"\n\n// Parse the command line, merging WAD files that are sppecified.\n// Returns true if at least one file was added.\nboolean W_ParseCommandLine(void)\n{\n    boolean modifiedgame = false;\n    int p;\n\n    // Merged PWADs are loaded first, because they are supposed to be \n    // modified IWADs.\n\n    //!\n    // @arg <files>\n    // @category mod\n    //\n    // Simulates the behavior of deutex's -merge option, merging a PWAD\n    // into the main IWAD.  Multiple files may be specified.\n    //\n\n    p = M_CheckParmWithArgs(\"-merge\", 1);\n\n    if (p > 0)\n    {\n        for (p = p + 1; p<myargc && myargv[p][0] != '-'; ++p)\n        {\n            char *filename;\n\n            modifiedgame = true;\n\n            filename = D_TryFindWADByName(myargv[p]);\n\n            printf(\" merging %s\\n\", filename);\n            W_MergeFile(filename);\n        }\n    }\n\n    // NWT-style merging:\n\n    // NWT's -merge option:\n\n    //!\n    // @arg <files>\n    // @category mod\n    //\n    // Simulates the behavior of NWT's -merge option.  Multiple files\n    // may be specified.\n\n    p = M_CheckParmWithArgs(\"-nwtmerge\", 1);\n\n    if (p > 0)\n    {\n        for (p = p + 1; p<myargc && myargv[p][0] != '-'; ++p)\n        {\n            char *filename;\n\n            modifiedgame = true;\n\n            filename = D_TryFindWADByName(myargv[p]);\n\n            printf(\" performing NWT-style merge of %s\\n\", filename);\n            W_NWTDashMerge(filename);\n        }\n    }\n    \n    // Add flats\n\n    //!\n    // @arg <files>\n    // @category mod\n    //\n    // Simulates the behavior of NWT's -af option, merging flats into\n    // the main IWAD directory.  Multiple files may be specified.\n    //\n\n    p = M_CheckParmWithArgs(\"-af\", 1);\n\n    if (p > 0)\n    {\n        for (p = p + 1; p<myargc && myargv[p][0] != '-'; ++p)\n        {\n            char *filename;\n\n            modifiedgame = true;\n\n            filename = D_TryFindWADByName(myargv[p]);\n\n            printf(\" merging flats from %s\\n\", filename);\n            W_NWTMergeFile(filename, W_NWT_MERGE_FLATS);\n        }\n    }\n\n    //!\n    // @arg <files>\n    // @category mod\n    //\n    // Simulates the behavior of NWT's -as option, merging sprites\n    // into the main IWAD directory.  Multiple files may be specified.\n    //\n\n    p = M_CheckParmWithArgs(\"-as\", 1);\n\n    if (p > 0)\n    {\n        for (p = p + 1; p<myargc && myargv[p][0] != '-'; ++p)\n        {\n            char *filename;\n\n            modifiedgame = true;\n            filename = D_TryFindWADByName(myargv[p]);\n\n            printf(\" merging sprites from %s\\n\", filename);\n            W_NWTMergeFile(filename, W_NWT_MERGE_SPRITES);\n        }\n    }\n\n    //!\n    // @arg <files>\n    // @category mod\n    //\n    // Equivalent to \"-af <files> -as <files>\".\n    //\n\n    p = M_CheckParmWithArgs(\"-aa\", 1);\n\n    if (p > 0)\n    {\n        for (p = p + 1; p<myargc && myargv[p][0] != '-'; ++p)\n        {\n            char *filename;\n\n            modifiedgame = true;\n\n            filename = D_TryFindWADByName(myargv[p]);\n\n            printf(\" merging sprites and flats from %s\\n\", filename);\n            W_NWTMergeFile(filename, W_NWT_MERGE_SPRITES | W_NWT_MERGE_FLATS);\n        }\n    }\n\n    //!\n    // @arg <files>\n    // @vanilla\n    //\n    // Load the specified PWAD files.\n    //\n\n    p = M_CheckParmWithArgs (\"-file\", 1);\n    if (p)\n    {\n\t// the parms after p are wadfile/lump names,\n\t// until end of parms or another - preceded parm\n\tmodifiedgame = true;            // homebrew levels\n\twhile (++p != myargc && myargv[p][0] != '-')\n        {\n            char *filename;\n\n            filename = D_TryFindWADByName(myargv[p]);\n\n            printf(\" adding %s\\n\", filename);\n\t    W_AddFile(filename);\n        }\n    }\n\n//    W_PrintDirectory();\n\n    return modifiedgame;\n}\n\n// Lump names that are unique to particular game types. This lets us check\n// the user is not trying to play with the wrong executable, eg.\n// chocolate-doom -iwad hexen.wad.\nstatic const struct\n{\n    GameMission_t mission;\n    const char *lumpname;\n} unique_lumps[] = {\n    { doom,    \"POSSA1\" },\n    { heretic, \"IMPXA1\" },\n    { hexen,   \"ETTNA1\" },\n    { strife,  \"AGRDA1\" },\n};\n\nvoid W_CheckCorrectIWAD(GameMission_t mission)\n{\n    int i;\n    lumpindex_t lumpnum;\n\n    for (i = 0; i < arrlen(unique_lumps); ++i)\n    {\n        if (mission != unique_lumps[i].mission)\n        {\n            lumpnum = W_CheckNumForName(unique_lumps[i].lumpname);\n\n            if (lumpnum >= 0)\n            {\n                I_Error(\"\\nYou are trying to use a %s IWAD file with \"\n                        \"the %s%s binary.\\nThis isn't going to work.\\n\"\n                        \"You probably want to use the %s%s binary.\",\n                        D_SuggestGameName(unique_lumps[i].mission,\n                                          indetermined),\n                        PROGRAM_PREFIX,\n                        D_GameMissionString(mission),\n                        PROGRAM_PREFIX,\n                        D_GameMissionString(unique_lumps[i].mission));\n            }\n        }\n    }\n}\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n// Handles merging of PWADs, similar to deutex's -merge option\n//\n// Ideally this should work exactly the same as in deutex, but trying to\n// read the deutex source code made my brain hurt.\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"doomtype.h\"\n#include \"i_system.h\"\n#include \"m_misc.h\"\n#include \"w_merge.h\"\n#include \"w_wad.h\"\n#include \"z_zone.h\"\n\ntypedef enum \n{ \n    SECTION_NORMAL, \n    SECTION_FLATS, \n    SECTION_SPRITES,\n} section_t;\n\ntypedef struct\n{\n    lumpinfo_t **lumps;\n    int numlumps;\n} searchlist_t;\n\ntypedef struct\n{\n    char sprname[4];\n    char frame;\n    lumpinfo_t *angle_lumps[8];\n} sprite_frame_t;\n\nstatic searchlist_t iwad;\nstatic searchlist_t iwad_sprites;\nstatic searchlist_t pwad;\n\nstatic searchlist_t iwad_flats;\nstatic searchlist_t pwad_sprites;\nstatic searchlist_t pwad_flats;\n\n// lumps with these sprites must be replaced in the IWAD\nstatic sprite_frame_t *sprite_frames;\nstatic int num_sprite_frames;\nstatic int sprite_frames_alloced;\n\n// Search in a list to find a lump with a particular name\n// Linear search (slow!)\n//\n// Returns -1 if not found\n\nstatic int FindInList(searchlist_t *list, const char *name)\n{\n    int i;\n\n    for (i=0; i<list->numlumps; ++i)\n    {\n        if (!strncasecmp(list->lumps[i]->name, name, 8))\n            return i;\n    }\n\n    return -1;\n}\n\nstatic boolean SetupList(searchlist_t *list, searchlist_t *src_list,\n                         const char *startname, const char *endname,\n                         const char *startname2, const char *endname2)\n{\n    int startlump, endlump;\n\n    list->numlumps = 0;\n    startlump = FindInList(src_list, startname);\n\n    if (startname2 != NULL && startlump < 0)\n    {\n        startlump = FindInList(src_list, startname2);\n    }\n\n    if (startlump >= 0)\n    {\n        endlump = FindInList(src_list, endname);\n\n        if (endname2 != NULL && endlump < 0)\n        {\n            endlump = FindInList(src_list, endname2);\n        }\n\n        if (endlump > startlump)\n        {\n            list->lumps = src_list->lumps + startlump + 1;\n            list->numlumps = endlump - startlump - 1;\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Sets up the sprite/flat search lists\n\nstatic void SetupLists(void)\n{\n    // IWAD\n\n    if (!SetupList(&iwad_flats, &iwad, \"F_START\", \"F_END\", NULL, NULL))\n    {\n        I_Error(\"Flats section not found in IWAD\");\n    }\n\n    if (!SetupList(&iwad_sprites, &iwad, \"S_START\", \"S_END\", NULL, NULL))\n\n    {\n        I_Error(\"Sprites section not found in IWAD\");\n    }\n    \n    // PWAD\n\n    SetupList(&pwad_flats, &pwad, \"F_START\", \"F_END\", \"FF_START\", \"FF_END\");\n    SetupList(&pwad_sprites, &pwad, \"S_START\", \"S_END\", \"SS_START\", \"SS_END\");\n}\n\n// Initialize the replace list\n\nstatic void InitSpriteList(void)\n{\n    if (sprite_frames == NULL)\n    {\n        sprite_frames_alloced = 128;\n        sprite_frames = Z_Malloc(sizeof(*sprite_frames) * sprite_frames_alloced,\n                                 PU_STATIC, NULL);\n    }\n\n    num_sprite_frames = 0;\n}\n\nstatic boolean ValidSpriteLumpName(char *name)\n{\n    if (name[0] == '\\0' || name[1] == '\\0'\n     || name[2] == '\\0' || name[3] == '\\0')\n    {\n        return false;\n    }\n\n    // First frame:\n\n    if (name[4] == '\\0' || !isdigit(name[5]))\n    {\n        return false;\n    }\n\n    // Second frame (optional):\n\n    if (name[6] != '\\0' && !isdigit(name[7]))\n    {\n        return false;\n    }\n\n    return true;\n}\n\n// Find a sprite frame\n\nstatic sprite_frame_t *FindSpriteFrame(char *name, int frame)\n{\n    sprite_frame_t *result;\n    int i;\n\n    // Search the list and try to find the frame\n\n    for (i=0; i<num_sprite_frames; ++i)\n    {\n        sprite_frame_t *cur = &sprite_frames[i];\n\n        if (!strncasecmp(cur->sprname, name, 4) && cur->frame == frame)\n        {\n            return cur;\n        }\n    }\n\n    // Not found in list; Need to add to the list\n\n    // Grow list?\n\n    if (num_sprite_frames >= sprite_frames_alloced)\n    {\n        sprite_frame_t *newframes;\n\n        newframes = Z_Malloc(sprite_frames_alloced * 2 * sizeof(*sprite_frames),\n                             PU_STATIC, NULL);\n        memcpy(newframes, sprite_frames,\n               sprite_frames_alloced * sizeof(*sprite_frames));\n        Z_Free(sprite_frames);\n        sprite_frames_alloced *= 2;\n        sprite_frames = newframes;\n    }\n\n    // Add to end of list\n    \n    result = &sprite_frames[num_sprite_frames];\n    memcpy(result->sprname, name, 4);\n    result->frame = frame;\n\n    for (i=0; i<8; ++i)\n        result->angle_lumps[i] = NULL;\n\n    ++num_sprite_frames;\n\n    return result;\n}\n\n// Check if sprite lump is needed in the new wad\n\nstatic boolean SpriteLumpNeeded(lumpinfo_t *lump)\n{\n    sprite_frame_t *sprite;\n    int angle_num;\n    int i;\n\n    if (!ValidSpriteLumpName(lump->name))\n    {\n        return true;\n    }\n\n    // check the first frame\n\n    sprite = FindSpriteFrame(lump->name, lump->name[4]);\n    angle_num = lump->name[5] - '0';\n\n    if (angle_num == 0)\n    {\n        // must check all frames\n\n        for (i=0; i<8; ++i)\n        {\n            if (sprite->angle_lumps[i] == lump)\n                return true;\n        }\n    }\n    else \n    {\n        // check if this lump is being used for this frame\n\n        if (sprite->angle_lumps[angle_num - 1] == lump)\n            return true;\n    }\n            \n    // second frame if any\n    \n    // no second frame?\n    if (lump->name[6] == '\\0')\n        return false;\n\n    sprite = FindSpriteFrame(lump->name, lump->name[6]);\n    angle_num = lump->name[7] - '0';\n\n    if (angle_num == 0)\n    {\n        // must check all frames\n\n        for (i=0; i<8; ++i)\n        {\n            if (sprite->angle_lumps[i] == lump)\n                return true;\n        }\n    }\n    else \n    {\n        // check if this lump is being used for this frame\n\n        if (sprite->angle_lumps[angle_num - 1] == lump)\n            return true;\n    }\n\n    return false;\n}\n\nstatic void AddSpriteLump(lumpinfo_t *lump)\n{\n    sprite_frame_t *sprite;\n    int angle_num;\n    int i;\n\n    if (!ValidSpriteLumpName(lump->name))\n    {\n        return;\n    }\n    \n    // first angle\n\n    sprite = FindSpriteFrame(lump->name, lump->name[4]);\n    angle_num = lump->name[5] - '0';\n    \n    if (angle_num == 0) \n    {\n        for (i=0; i<8; ++i)\n            sprite->angle_lumps[i] = lump;\n    }\n    else\n    {\n        sprite->angle_lumps[angle_num - 1] = lump;\n    }\n    \n    // second angle\n\n    // no second angle?\n  \n    if (lump->name[6] == '\\0')\n        return;\n    \n    sprite = FindSpriteFrame(lump->name, lump->name[6]);\n    angle_num = lump->name[7] - '0';\n    \n    if (angle_num == 0) \n    {\n        for (i=0; i<8; ++i)\n            sprite->angle_lumps[i] = lump;\n    }\n    else\n    {\n        sprite->angle_lumps[angle_num - 1] = lump;\n    }\n}\n\n// Generate the list.  Run at the start, before merging\n\nstatic void GenerateSpriteList(void)\n{\n    int i;\n\n    InitSpriteList();\n    \n    // Add all sprites from the IWAD\n    \n    for (i=0; i<iwad_sprites.numlumps; ++i)\n    {\n        AddSpriteLump(iwad_sprites.lumps[i]);\n    }\n    \n    // Add all sprites from the PWAD\n    // (replaces IWAD sprites)\n\n    for (i=0; i<pwad_sprites.numlumps; ++i)\n    {\n        AddSpriteLump(pwad_sprites.lumps[i]);\n    }\n}\n\n// Perform the merge.\n//\n// The merge code creates a new lumpinfo list, adding entries from the\n// IWAD first followed by the PWAD.\n//\n// For the IWAD:\n//  * Flats are added.  If a flat with the same name is in the PWAD, \n//    it is ignored(deleted).  At the end of the section, all flats in the \n//    PWAD are inserted.  This is consistent with the behavior of \n//    deutex/deusf.\n//  * Sprites are added.  The \"replace list\" is generated before the merge\n//    from the list of sprites in the PWAD.  Any sprites in the IWAD found\n//    to match the replace list are removed.  At the end of the section,\n//    the sprites from the PWAD are inserted.\n// \n// For the PWAD:\n//  * All Sprites and Flats are ignored, with the assumption they have \n//    already been merged into the IWAD's sections.\n\nstatic void DoMerge(void)\n{\n    section_t current_section;\n    lumpinfo_t **newlumps;\n    int num_newlumps;\n    int lumpindex;\n    int i, n;\n\n    // Can't ever have more lumps than we already have\n    newlumps = calloc(numlumps, sizeof(lumpinfo_t *));\n    num_newlumps = 0;\n\n    // Add IWAD lumps\n    current_section = SECTION_NORMAL;\n\n    for (i=0; i<iwad.numlumps; ++i)\n    {\n        lumpinfo_t *lump = iwad.lumps[i];\n\n        switch (current_section)\n        {\n            case SECTION_NORMAL:\n                if (!strncasecmp(lump->name, \"F_START\", 8))\n                {\n                    current_section = SECTION_FLATS;\n                }\n                else if (!strncasecmp(lump->name, \"S_START\", 8))\n                {\n                    current_section = SECTION_SPRITES;\n                }\n\n                newlumps[num_newlumps++] = lump;\n\n                break;\n\n            case SECTION_FLATS:\n\n                // Have we reached the end of the section?\n\n                if (!strncasecmp(lump->name, \"F_END\", 8))\n                {\n                    // Add all new flats from the PWAD to the end\n                    // of the section\n\n                    for (n=0; n<pwad_flats.numlumps; ++n)\n                    {\n                        newlumps[num_newlumps++] = pwad_flats.lumps[n];\n                    }\n\n                    newlumps[num_newlumps++] = lump;\n\n                    // back to normal reading\n                    current_section = SECTION_NORMAL;\n                }\n                else\n                {\n                    // If there is a flat in the PWAD with the same name,\n                    // do not add it now.  All PWAD flats are added to the\n                    // end of the section. Otherwise, if it is only in the\n                    // IWAD, add it now\n\n                    lumpindex = FindInList(&pwad_flats, lump->name);\n\n                    if (lumpindex < 0)\n                    {\n                        newlumps[num_newlumps++] = lump;\n                    }\n                }\n\n                break;\n\n            case SECTION_SPRITES:\n\n                // Have we reached the end of the section?\n\n                if (!strncasecmp(lump->name, \"S_END\", 8))\n                {\n                    // add all the PWAD sprites\n\n                    for (n=0; n<pwad_sprites.numlumps; ++n)\n                    {\n                        if (SpriteLumpNeeded(pwad_sprites.lumps[n]))\n                        {\n                            newlumps[num_newlumps++] = pwad_sprites.lumps[n];\n                        }\n                    }\n\n                    // copy the ending\n                    newlumps[num_newlumps++] = lump;\n\n                    // back to normal reading\n                    current_section = SECTION_NORMAL;\n                }\n                else\n                {\n                    // Is this lump holding a sprite to be replaced in the\n                    // PWAD? If so, wait until the end to add it.\n\n                    if (SpriteLumpNeeded(lump))\n                    {\n                        newlumps[num_newlumps++] = lump;\n                    }\n                }\n\n                break;\n        }\n    }\n   \n    // Add PWAD lumps\n    current_section = SECTION_NORMAL;\n\n    for (i=0; i<pwad.numlumps; ++i)\n    {\n        lumpinfo_t *lump = pwad.lumps[i];\n\n        switch (current_section)\n        {\n            case SECTION_NORMAL:\n                if (!strncasecmp(lump->name, \"F_START\", 8)\n                 || !strncasecmp(lump->name, \"FF_START\", 8))\n                {\n                    current_section = SECTION_FLATS;\n                }\n                else if (!strncasecmp(lump->name, \"S_START\", 8)\n                      || !strncasecmp(lump->name, \"SS_START\", 8))\n                {\n                    current_section = SECTION_SPRITES;\n                }\n                else\n                {\n                    // Don't include the headers of sections\n       \n                    newlumps[num_newlumps++] = lump;\n                }\n                break;\n\n            case SECTION_FLATS:\n\n                // PWAD flats are ignored (already merged)\n  \n                if (!strncasecmp(lump->name, \"FF_END\", 8)\n                 || !strncasecmp(lump->name, \"F_END\", 8))\n                {\n                    // end of section\n                    current_section = SECTION_NORMAL;\n                }\n                break;\n\n            case SECTION_SPRITES:\n\n                // PWAD sprites are ignored (already merged)\n\n                if (!strncasecmp(lump->name, \"SS_END\", 8)\n                 || !strncasecmp(lump->name, \"S_END\", 8))\n                {\n                    // end of section\n                    current_section = SECTION_NORMAL;\n                }\n                break;\n        }\n    }\n\n    // Switch to the new lumpinfo, and free the old one\n\n    free(lumpinfo);\n    lumpinfo = newlumps;\n    numlumps = num_newlumps;\n}\n\nvoid W_PrintDirectory(void)\n{\n    unsigned int i, n;\n\n    // debug\n    for (i=0; i<numlumps; ++i)\n    {\n        for (n=0; n<8 && lumpinfo[i]->name[n] != '\\0'; ++n)\n            putchar(lumpinfo[i]->name[n]);\n        putchar('\\n');\n    }\n}\n\n// Merge in a file by name\n\nvoid W_MergeFile(char *filename)\n{\n    int old_numlumps;\n\n    old_numlumps = numlumps;\n\n    // Load PWAD\n\n    if (W_AddFile(filename) == NULL)\n        return;\n\n    // IWAD is at the start, PWAD was appended to the end\n\n    iwad.lumps = lumpinfo;\n    iwad.numlumps = old_numlumps;\n\n    pwad.lumps = lumpinfo + old_numlumps;\n    pwad.numlumps = numlumps - old_numlumps;\n    \n    // Setup sprite/flat lists\n\n    SetupLists();\n\n    // Generate list of sprites to be replaced by the PWAD\n\n    GenerateSpriteList();\n\n    // Perform the merge\n\n    DoMerge();\n}\n\n// Replace lumps in the given list with lumps from the PWAD\n\nstatic void W_NWTAddLumps(searchlist_t *list)\n{\n    int i;\n\n    // Go through the IWAD list given, replacing lumps with lumps of\n    // the same name from the PWAD\n    for (i=0; i<list->numlumps; ++i)\n    {\n        int index;\n\n        index = FindInList(&pwad, list->lumps[i]->name);\n\n        if (index > 0)\n        {\n            memcpy(list->lumps[i], pwad.lumps[index],\n                   sizeof(lumpinfo_t));\n        }\n    }\n}\n\n// Merge sprites and flats in the way NWT does with its -af and -as\n// command-line options.\n\nvoid W_NWTMergeFile(char *filename, int flags)\n{\n    int old_numlumps;\n\n    old_numlumps = numlumps;\n\n    // Load PWAD\n\n    if (W_AddFile(filename) == NULL)\n        return;\n\n    // IWAD is at the start, PWAD was appended to the end\n\n    iwad.lumps = lumpinfo;\n    iwad.numlumps = old_numlumps;\n\n    pwad.lumps = lumpinfo + old_numlumps;\n    pwad.numlumps = numlumps - old_numlumps;\n\n    // Setup sprite/flat lists\n\n    SetupLists();\n\n    // Merge in flats?\n\n    if (flags & W_NWT_MERGE_FLATS)\n    {\n        W_NWTAddLumps(&iwad_flats);\n    }\n\n    // Sprites?\n\n    if (flags & W_NWT_MERGE_SPRITES)\n    {\n        W_NWTAddLumps(&iwad_sprites);\n    }\n    \n    // Discard the PWAD\n\n    numlumps = old_numlumps;\n}\n\n// Simulates the NWT -merge command line parameter.  What this does is load\n// a PWAD, then search the IWAD sprites, removing any sprite lumps that also\n// exist in the PWAD.\n\nvoid W_NWTDashMerge(char *filename)\n{\n    wad_file_t *wad_file;\n    int old_numlumps;\n    int i;\n\n    old_numlumps = numlumps;\n\n    // Load PWAD\n\n    wad_file = W_AddFile(filename);\n\n    if (wad_file == NULL)\n    {\n        return;\n    }\n\n    // IWAD is at the start, PWAD was appended to the end\n\n    iwad.lumps = lumpinfo;\n    iwad.numlumps = old_numlumps;\n\n    pwad.lumps = lumpinfo + old_numlumps;\n    pwad.numlumps = numlumps - old_numlumps;\n\n    // Setup sprite/flat lists\n\n    SetupLists();\n\n    // Search through the IWAD sprites list.\n\n    for (i=0; i<iwad_sprites.numlumps; ++i)\n    {\n        if (FindInList(&pwad, iwad_sprites.lumps[i]->name) >= 0)\n        {\n            // Replace this entry with an empty string.  This is what\n            // nwt -merge does.\n\n            M_StringCopy(iwad_sprites.lumps[i]->name, \"\", 8);\n        }\n    }\n\n    // Discard PWAD\n    // The PWAD must now be added in again with -file.\n\n    numlumps = old_numlumps;\n\n    W_CloseFile(wad_file);\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tHandles WAD file header, directory, lump I/O.\n//\n\n\n\n\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"doomtype.h\"\n\n#include \"i_swap.h\"\n#include \"i_system.h\"\n#include \"i_video.h\"\n#include \"m_misc.h\"\n#include \"v_diskicon.h\"\n#include \"z_zone.h\"\n\n#include \"w_wad.h\"\n\ntypedef PACKED_STRUCT (\n{\n    // Should be \"IWAD\" or \"PWAD\".\n    char\t\tidentification[4];\n    int\t\t\tnumlumps;\n    int\t\t\tinfotableofs;\n}) wadinfo_t;\n\n\ntypedef PACKED_STRUCT (\n{\n    int\t\t\tfilepos;\n    int\t\t\tsize;\n    char\t\tname[8];\n}) filelump_t;\n\n//\n// GLOBALS\n//\n\n// Location of each lump on disk.\nlumpinfo_t **lumpinfo;\nunsigned int numlumps = 0;\n\n// Hash table for fast lookups\nstatic lumpindex_t *lumphash;\n\n// Variables for the reload hack: filename of the PWAD to reload, and the\n// lumps from WADs before the reload file, so we can resent numlumps and\n// load the file again.\nstatic wad_file_t *reloadhandle = NULL;\nstatic lumpinfo_t *reloadlumps = NULL;\nstatic char *reloadname = NULL;\nstatic int reloadlump = -1;\n\n// Hash function used for lump names.\nunsigned int W_LumpNameHash(const char *s)\n{\n    // This is the djb2 string hash function, modded to work on strings\n    // that have a maximum length of 8.\n\n    unsigned int result = 5381;\n    unsigned int i;\n\n    for (i=0; i < 8 && s[i] != '\\0'; ++i)\n    {\n        result = ((result << 5) ^ result ) ^ toupper(s[i]);\n    }\n\n    return result;\n}\n\n//\n// LUMP BASED ROUTINES.\n//\n\n//\n// W_AddFile\n// All files are optional, but at least one file must be\n//  found (PWAD, if all required lumps are present).\n// Files with a .wad extension are wadlink files\n//  with multiple lumps.\n// Other files are single lumps with the base filename\n//  for the lump name.\n\nwad_file_t *W_AddFile (char *filename)\n{\n    wadinfo_t header;\n    lumpindex_t i;\n    wad_file_t *wad_file;\n    int length;\n    int startlump;\n    filelump_t *fileinfo;\n    filelump_t *filerover;\n    lumpinfo_t *filelumps;\n    int numfilelumps;\n\n    // If the filename begins with a ~, it indicates that we should use the\n    // reload hack.\n    if (filename[0] == '~')\n    {\n        if (reloadname != NULL)\n        {\n            I_Error(\"Prefixing a WAD filename with '~' indicates that the \"\n                    \"WAD should be reloaded\\n\"\n                    \"on each level restart, for use by level authors for \"\n                    \"rapid development. You\\n\"\n                    \"can only reload one WAD file, and it must be the last \"\n                    \"file in the -file list.\");\n        }\n\n        reloadname = strdup(filename);\n        reloadlump = numlumps;\n        ++filename;\n    }\n\n    // Open the file and add to directory\n    wad_file = W_OpenFile(filename);\n\n    if (wad_file == NULL)\n    {\n\tprintf (\" couldn't open %s\\n\", filename);\n\treturn NULL;\n    }\n\n    if (strcasecmp(filename+strlen(filename)-3 , \"wad\" ) )\n    {\n\t// single lump file\n\n        // fraggle: Swap the filepos and size here.  The WAD directory\n        // parsing code expects a little-endian directory, so will swap\n        // them back.  Effectively we're constructing a \"fake WAD directory\"\n        // here, as it would appear on disk.\n\n\tfileinfo = Z_Malloc(sizeof(filelump_t), PU_STATIC, 0);\n\tfileinfo->filepos = LONG(0);\n\tfileinfo->size = LONG(wad_file->length);\n\n        // Name the lump after the base of the filename (without the\n        // extension).\n\n\tM_ExtractFileBase (filename, fileinfo->name);\n\tnumfilelumps = 1;\n    }\n    else\n    {\n\t// WAD file\n        W_Read(wad_file, 0, &header, sizeof(header));\n\n\tif (strncmp(header.identification,\"IWAD\",4))\n\t{\n\t    // Homebrew levels?\n\t    if (strncmp(header.identification,\"PWAD\",4))\n\t    {\n\t\tW_CloseFile(wad_file);\n\t\tI_Error (\"Wad file %s doesn't have IWAD \"\n\t\t\t \"or PWAD id\\n\", filename);\n\t    }\n\n\t    // ???modifiedgame = true;\n\t}\n\n\theader.numlumps = LONG(header.numlumps);\n\n         // Vanilla Doom doesn't like WADs with more than 4046 lumps\n         // https://www.doomworld.com/vb/post/1010985\n        //  if (!strncmp(header.identification,\"PWAD\",4) && header.numlumps > 4046)\n        //  {\n        //          W_CloseFile(wad_file);\n        //          I_Error (\"Error: Vanilla limit for lumps in a WAD is 4046, \"\n        //                   \"PWAD %s has %d\", filename, header.numlumps);\n        //  }\n\n\theader.infotableofs = LONG(header.infotableofs);\n\tlength = header.numlumps*sizeof(filelump_t);\n\tfileinfo = Z_Malloc(length, PU_STATIC, 0);\n\n        W_Read(wad_file, header.infotableofs, fileinfo, length);\n\tnumfilelumps = header.numlumps;\n    }\n\n    // Increase size of numlumps array to accomodate the new file.\n    filelumps = calloc(numfilelumps, sizeof(lumpinfo_t));\n    if (filelumps == NULL)\n    {\n        W_CloseFile(wad_file);\n        I_Error(\"Failed to allocate array for lumps from new file.\");\n    }\n\n    startlump = numlumps;\n    numlumps += numfilelumps;\n    lumpinfo = I_Realloc(lumpinfo, numlumps * sizeof(lumpinfo_t *));\n    filerover = fileinfo;\n\n    for (i = startlump; i < numlumps; ++i)\n    {\n        lumpinfo_t *lump_p = &filelumps[i - startlump];\n        lump_p->wad_file = wad_file;\n        lump_p->position = LONG(filerover->filepos);\n        lump_p->size = LONG(filerover->size);\n        lump_p->cache = NULL;\n        strncpy(lump_p->name, filerover->name, 8);\n        lumpinfo[i] = lump_p;\n\n        ++filerover;\n    }\n\n    Z_Free(fileinfo);\n\n    if (lumphash != NULL)\n    {\n        Z_Free(lumphash);\n        lumphash = NULL;\n    }\n\n    // If this is the reload file, we need to save some details about the\n    // file so that we can close it later on when we do a reload.\n    if (reloadname)\n    {\n        reloadhandle = wad_file;\n        reloadlumps = filelumps;\n    }\n\n    return wad_file;\n}\n\n\n\n//\n// W_NumLumps\n//\nint W_NumLumps (void)\n{\n    return numlumps;\n}\n\n\n\n//\n// W_CheckNumForName\n// Returns -1 if name not found.\n//\n\nlumpindex_t W_CheckNumForName(const char *name)\n{\n    lumpindex_t i;\n\n    // Do we have a hash table yet?\n\n    if (lumphash != NULL)\n    {\n        int hash;\n\n        // We do! Excellent.\n\n        hash = W_LumpNameHash(name) % numlumps;\n\n        for (i = lumphash[hash]; i != -1; i = lumpinfo[i]->next)\n        {\n            if (!strncasecmp(lumpinfo[i]->name, name, 8))\n            {\n                return i;\n            }\n        }\n    }\n    else\n    {\n        // We don't have a hash table generate yet. Linear search :-(\n        //\n        // scan backwards so patch lump files take precedence\n\n        for (i = numlumps - 1; i >= 0; --i)\n        {\n            if (!strncasecmp(lumpinfo[i]->name, name, 8))\n            {\n                return i;\n            }\n        }\n    }\n\n    // TFB. Not found.\n\n    return -1;\n}\n\n\n\n\n//\n// W_GetNumForName\n// Calls W_CheckNumForName, but bombs out if not found.\n//\nlumpindex_t W_GetNumForName(const char *name)\n{\n    lumpindex_t i;\n\n    i = W_CheckNumForName (name);\n\n    if (i < 0)\n    {\n        I_Error (\"W_GetNumForName: %s not found!\", name);\n    }\n \n    return i;\n}\n\nlumpindex_t W_CheckNumForNameFromTo(const char *name, int from, int to)\n{\n    lumpindex_t i;\n\n    for (i = from; i >= to; i--)\n    {\n        if (!strncasecmp(lumpinfo[i]->name, name, 8))\n        {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\n//\n// W_LumpLength\n// Returns the buffer size needed to load the given lump.\n//\nint W_LumpLength(lumpindex_t lump)\n{\n    if (lump >= numlumps)\n    {\n\tI_Error (\"W_LumpLength: %i >= numlumps\", lump);\n    }\n\n    return lumpinfo[lump]->size;\n}\n\n\n\n//\n// W_ReadLump\n// Loads the lump into the given buffer,\n//  which must be >= W_LumpLength().\n//\nvoid W_ReadLump(lumpindex_t lump, void *dest)\n{\n    int c;\n    lumpinfo_t *l;\n\n    if (lump >= numlumps)\n    {\n        I_Error (\"W_ReadLump: %i >= numlumps\", lump);\n    }\n\n    l = lumpinfo[lump];\n\n    V_BeginRead(l->size);\n\n    c = W_Read(l->wad_file, l->position, dest, l->size);\n\n    if (c < l->size)\n    {\n        I_Error(\"W_ReadLump: only read %i of %i on lump %i\",\n                c, l->size, lump);\n    }\n}\n\n\n\n\n//\n// W_CacheLumpNum\n//\n// Load a lump into memory and return a pointer to a buffer containing\n// the lump data.\n//\n// 'tag' is the type of zone memory buffer to allocate for the lump\n// (usually PU_STATIC or PU_CACHE).  If the lump is loaded as \n// PU_STATIC, it should be released back using W_ReleaseLumpNum\n// when no longer needed (do not use Z_ChangeTag).\n//\n\nvoid *W_CacheLumpNum(lumpindex_t lumpnum, int tag)\n{\n    byte *result;\n    lumpinfo_t *lump;\n\n    if ((unsigned)lumpnum >= numlumps)\n    {\n\tI_Error (\"W_CacheLumpNum: %i >= numlumps\", lumpnum);\n    }\n\n    lump = lumpinfo[lumpnum];\n\n    // Get the pointer to return.  If the lump is in a memory-mapped\n    // file, we can just return a pointer to within the memory-mapped\n    // region.  If the lump is in an ordinary file, we may already\n    // have it cached; otherwise, load it into memory.\n\n    if (lump->wad_file->mapped != NULL)\n    {\n        // Memory mapped file, return from the mmapped region.\n\n        result = lump->wad_file->mapped + lump->position;\n    }\n    else if (lump->cache != NULL)\n    {\n        // Already cached, so just switch the zone tag.\n\n        result = lump->cache;\n        Z_ChangeTag(lump->cache, tag);\n    }\n    else\n    {\n        // Not yet loaded, so load it now\n\n        lump->cache = Z_Malloc(W_LumpLength(lumpnum), tag, &lump->cache);\n\tW_ReadLump (lumpnum, lump->cache);\n        result = lump->cache;\n    }\n\t\n    return result;\n}\n\n\n\n//\n// W_CacheLumpName\n//\nvoid *W_CacheLumpName(const char *name, int tag)\n{\n    return W_CacheLumpNum(W_GetNumForName(name), tag);\n}\n\n// \n// Release a lump back to the cache, so that it can be reused later \n// without having to read from disk again, or alternatively, discarded\n// if we run out of memory.\n//\n// Back in Vanilla Doom, this was just done using Z_ChangeTag \n// directly, but now that we have WAD mmap, things are a bit more\n// complicated ...\n//\n\nvoid W_ReleaseLumpNum(lumpindex_t lumpnum)\n{\n    lumpinfo_t *lump;\n\n    if ((unsigned)lumpnum >= numlumps)\n    {\n\tI_Error (\"W_ReleaseLumpNum: %i >= numlumps\", lumpnum);\n    }\n\n    lump = lumpinfo[lumpnum];\n\n    if (lump->wad_file->mapped != NULL)\n    {\n        // Memory-mapped file, so nothing needs to be done here.\n    }\n    else\n    {\n        Z_ChangeTag(lump->cache, PU_CACHE);\n    }\n}\n\nvoid W_ReleaseLumpName(const char *name)\n{\n    W_ReleaseLumpNum(W_GetNumForName(name));\n}\n\n// Generate a hash table for fast lookups\n\nvoid W_GenerateHashTable(void)\n{\n    lumpindex_t i;\n\n    // Free the old hash table, if there is one:\n    if (lumphash != NULL)\n    {\n        Z_Free(lumphash);\n    }\n\n    // Generate hash table\n    if (numlumps > 0)\n    {\n        lumphash = Z_Malloc(sizeof(lumpindex_t) * numlumps, PU_STATIC, NULL);\n\n        for (i = 0; i < numlumps; ++i)\n        {\n            lumphash[i] = -1;\n        }\n\n        for (i = 0; i < numlumps; ++i)\n        {\n            unsigned int hash;\n\n            hash = W_LumpNameHash(lumpinfo[i]->name) % numlumps;\n\n            // Hook into the hash table\n\n            lumpinfo[i]->next = lumphash[hash];\n            lumphash[hash] = i;\n        }\n    }\n\n    // All done!\n}\n\n// The Doom reload hack. The idea here is that if you give a WAD file to -file\n// prefixed with the ~ hack, that WAD file will be reloaded each time a new\n// level is loaded. This lets you use a level editor in parallel and make\n// incremental changes to the level you're working on without having to restart\n// the game after every change.\n// But: the reload feature is a fragile hack...\nvoid W_Reload(void)\n{\n    char *filename;\n    lumpindex_t i;\n\n    if (reloadname == NULL)\n    {\n        return;\n    }\n\n    // We must free any lumps being cached from the PWAD we're about to reload:\n    for (i = reloadlump; i < numlumps; ++i)\n    {\n        if (lumpinfo[i]->cache != NULL)\n        {\n            Z_Free(lumpinfo[i]->cache);\n        }\n    }\n\n    // Reset numlumps to remove the reload WAD file:\n    numlumps = reloadlump;\n\n    // Now reload the WAD file.\n    filename = reloadname;\n\n    W_CloseFile(reloadhandle);\n    free(reloadlumps);\n\n    reloadname = NULL;\n    reloadlump = -1;\n    reloadhandle = NULL;\n    W_AddFile(filename);\n    free(filename);\n\n    // The WAD directory has changed, so we have to regenerate the\n    // fast lookup hashtable:\n    W_GenerateHashTable();\n}\n\nconst char *W_WadNameForLump(const lumpinfo_t *lump)\n{\n\treturn M_BaseName(lump->wad_file->path);\n}\n\nboolean W_IsIWADLump(const lumpinfo_t *lump)\n{\n\treturn lump->wad_file == lumpinfo[0]->wad_file;\n}\n\nconst lumpinfo_t* W_GetLumpInfoByNum(int lump)\n{\n  if (lump < 0 || lump >= numlumps)\n    I_Error(\"W_GetLumpInfoByNum: lump num %d out of range\", lump);\n\n  return lumpinfo[lump];\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tAll the clipping: columns, horizontal spans, sky columns.\n//\n\n\n\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"i_system.h\"\n\n#include \"doomdef.h\"\n#include \"doomstat.h\"\n\n#include \"r_local.h\"\n#include \"r_sky.h\"\n#include \"r_bmaps.h\" // [crispy] brightmaps\n\n\n// OPTIMIZE: closed two sided lines as single sided\n\n// True if any of the segs textures might be visible.\nboolean\t\tsegtextured;\t\n\n// False if the back side is the same plane.\nboolean\t\tmarkfloor;\t\nboolean\t\tmarkceiling;\n\nboolean\t\tmaskedtexture;\nint\t\ttoptexture;\nint\t\tbottomtexture;\nint\t\tmidtexture;\n\n\nangle_t\t\trw_normalangle;\n// angle to line origin\nint\t\trw_angle1;\t\n\n//\n// regular wall\n//\nint\t\trw_x;\nint\t\trw_stopx;\nangle_t\t\trw_centerangle;\nfixed_t\t\trw_offset;\nfixed_t\t\trw_distance;\nfixed_t\t\trw_scale;\nfixed_t\t\trw_scalestep;\nfixed_t\t\trw_midtexturemid;\nfixed_t\t\trw_toptexturemid;\nfixed_t\t\trw_bottomtexturemid;\n\nint\t\tworldtop;\nint\t\tworldbottom;\nint\t\tworldhigh;\nint\t\tworldlow;\n\nint64_t\t\tpixhigh; // [crispy] WiggleFix\nint64_t\t\tpixlow; // [crispy] WiggleFix\nfixed_t\t\tpixhighstep;\nfixed_t\t\tpixlowstep;\n\nint64_t\t\ttopfrac; // [crispy] WiggleFix\nfixed_t\t\ttopstep;\n\nint64_t\t\tbottomfrac; // [crispy] WiggleFix\nfixed_t\t\tbottomstep;\n\n\nlighttable_t**\twalllights;\n\nint*\t\tmaskedtexturecol; // [crispy] 32-bit integer math\n\n\n// [crispy] WiggleFix: add this code block near the top of r_segs.c\n//\n// R_FixWiggle()\n// Dynamic wall/texture rescaler, AKA \"WiggleHack II\"\n//  by Kurt \"kb1\" Baumgardner (\"kb\") and Andrey \"Entryway\" Budko (\"e6y\")\n//\n//  [kb] When the rendered view is positioned, such that the viewer is\n//   looking almost parallel down a wall, the result of the scale\n//   calculation in R_ScaleFromGlobalAngle becomes very large. And, the\n//   taller the wall, the larger that value becomes. If these large\n//   values were used as-is, subsequent calculations would overflow,\n//   causing full-screen HOM, and possible program crashes.\n//\n//  Therefore, vanilla Doom clamps this scale calculation, preventing it\n//   from becoming larger than 0x400000 (64*FRACUNIT). This number was\n//   chosen carefully, to allow reasonably-tight angles, with reasonably\n//   tall sectors to be rendered, within the limits of the fixed-point\n//   math system being used. When the scale gets clamped, Doom cannot\n//   properly render the wall, causing an undesirable wall-bending\n//   effect that I call \"floor wiggle\". Not a crash, but still ugly.\n//\n//  Modern source ports offer higher video resolutions, which worsens\n//   the issue. And, Doom is simply not adjusted for the taller walls\n//   found in many PWADs.\n//\n//  This code attempts to correct these issues, by dynamically\n//   adjusting the fixed-point math, and the maximum scale clamp,\n//   on a wall-by-wall basis. This has 2 effects:\n//\n//  1. Floor wiggle is greatly reduced and/or eliminated.\n//  2. Overflow is no longer possible, even in levels with maximum\n//     height sectors (65535 is the theoretical height, though Doom\n//     cannot handle sectors > 32767 units in height.\n//\n//  The code is not perfect across all situations. Some floor wiggle can\n//   still be seen, and some texture strips may be slightly misaligned in\n//   extreme cases. These effects cannot be corrected further, without\n//   increasing the precision of various renderer variables, and,\n//   possibly, creating a noticable performance penalty.\n//\n\nstatic int\tmax_rwscale = 64 * FRACUNIT;\nstatic int\theightbits = 12;\nstatic int\theightunit = (1 << 12);\nstatic int\tinvhgtbits = 4;\n\nstatic const struct\n{\n    int clamp;\n    int heightbits;\n} scale_values[8] = {\n    {2048 * FRACUNIT, 12},\n    {1024 * FRACUNIT, 12},\n    {1024 * FRACUNIT, 11},\n    { 512 * FRACUNIT, 11},\n    { 512 * FRACUNIT, 10},\n    { 256 * FRACUNIT, 10},\n    { 256 * FRACUNIT,  9},\n    { 128 * FRACUNIT,  9}\n};\n\nvoid R_FixWiggle (sector_t *sector)\n{\n    static int\tlastheight = 0;\n    int\t\theight = (sector->interpceilingheight - sector->interpfloorheight) >> FRACBITS;\n\n    // disallow negative heights. using 1 forces cache initialization\n    if (height < 1)\n\theight = 1;\n\n    // early out?\n    if (height != lastheight)\n    {\n\tlastheight = height;\n\n\t// initialize, or handle moving sector\n\tif (height != sector->cachedheight)\n\t{\n\t    sector->cachedheight = height;\n\t    sector->scaleindex = 0;\n\t    height >>= 7;\n\n\t    // calculate adjustment\n\t    while (height >>= 1)\n\t\tsector->scaleindex++;\n\t}\n\n\t// fine-tune renderer for this wall\n\tmax_rwscale = scale_values[sector->scaleindex].clamp;\n\theightbits = scale_values[sector->scaleindex].heightbits;\n\theightunit = (1 << heightbits);\n\tinvhgtbits = FRACBITS - heightbits;\n    }\n}\n\n//\n// R_RenderMaskedSegRange\n//\nvoid\nR_RenderMaskedSegRange\n( drawseg_t*\tds,\n  int\t\tx1,\n  int\t\tx2 )\n{\n    unsigned\tindex;\n    column_t*\tcol;\n    int\t\tlightnum;\n    int\t\ttexnum;\n\tsector_t tempsec;      // killough 4/13/98\n    \n    // Calculate light table.\n    // Use different light tables\n    //   for horizontal / vertical / diagonal. Diagonal?\n    // OPTIMIZE: get rid of LIGHTSEGSHIFT globally\n    curline = ds->curline;\n    frontsector = curline->frontsector;\n    backsector = curline->backsector;\n    texnum = texturetranslation[curline->sidedef->midtexture];\n\t\n    lightnum = (R_FakeFlat(frontsector, &tempsec, NULL, NULL, false)->lightlevel >> LIGHTSEGSHIFT)+(extralight * LIGHTBRIGHT);\n\n    // [crispy] smoother fake contrast\n    lightnum += curline->fakecontrast;\n\n    if (lightnum < 0)\t\t\n\twalllights = scalelight[0];\n    else if (lightnum >= LIGHTLEVELS)\n\twalllights = scalelight[LIGHTLEVELS-1];\n    else\n\twalllights = scalelight[lightnum];\n\n    maskedtexturecol = ds->maskedtexturecol;\n\n    rw_scalestep = ds->scalestep;\t\t\n    spryscale = ds->scale1 + (x1 - ds->x1)*rw_scalestep;\n    mfloorclip = ds->sprbottomclip;\n    mceilingclip = ds->sprtopclip;\n    \n    // find positioning\n    if (curline->linedef->flags & ML_DONTPEGBOTTOM)\n    {\n\tdc_texturemid = frontsector->interpfloorheight > backsector->interpfloorheight\n\t    ? frontsector->interpfloorheight : backsector->interpfloorheight;\n\tdc_texturemid = dc_texturemid + textureheight[texnum] - viewz;\n    }\n    else\n    {\n\tdc_texturemid =frontsector->interpceilingheight<backsector->interpceilingheight\n\t    ? frontsector->interpceilingheight : backsector->interpceilingheight;\n\tdc_texturemid = dc_texturemid - viewz;\n    }\n    dc_texturemid += curline->sidedef->rowoffset;\n\t\t\t\n    if (fixedcolormap)\n\tdc_colormap[0] = dc_colormap[1] = fixedcolormap;\n    \n    // draw the columns\n    for (dc_x = x1 ; dc_x <= x2 ; dc_x++)\n    {\n\t// calculate lighting\n\tif (maskedtexturecol[dc_x] != INT_MAX) // [crispy] 32-bit integer math\n\t{\n\t    if (!fixedcolormap)\n\t    {\n\t\tindex = spryscale>>(LIGHTSCALESHIFT /*+ crispy->hires*/);\n\n\t\tif (index >=  MAXLIGHTSCALE )\n\t\t    index = MAXLIGHTSCALE-1;\n\n\t\t// [crispy] no brightmaps for mid-textures\n\t\tdc_colormap[0] = dc_colormap[1] = walllights[index];\n\t    }\n\t\t\t\n\t    // [crispy] apply Killough's int64 sprtopscreen overflow fix\n\t    // from winmbf/Source/r_segs.c:174-191\n\t    // killough 3/2/98:\n\t    //\n\t    // This calculation used to overflow and cause crashes in Doom:\n\t    //\n\t    // sprtopscreen = centeryfrac - FixedMul(dc_texturemid, spryscale);\n\t    //\n\t    // This code fixes it, by using double-precision intermediate\n\t    // arithmetic and by skipping the drawing of 2s normals whose\n\t    // mapping to screen coordinates is totally out of range:\n\n\t    {\n\t\tint64_t t = ((int64_t) centeryfrac << FRACBITS) -\n\t\t             (int64_t) dc_texturemid * spryscale;\n\n\t\tif (t + (int64_t) textureheight[texnum] * spryscale < 0 ||\n\t\t    t > (int64_t) SCREENHEIGHT << FRACBITS*2)\n\t\t{\n\t\t\tspryscale += rw_scalestep; // [crispy] MBF had this in the for-loop iterator\n\t\t\tcontinue; // skip if the texture is out of screen's range\n\t\t}\n\n\t\tsprtopscreen = (int64_t)(t >> FRACBITS); // [crispy] WiggleFix\n\t    }\n\n\t    dc_iscale = 0xffffffffu / (unsigned)spryscale;\n\t    \n\t    // draw the texture\n\t    col = (column_t *)( \n\t\t(byte *)R_GetColumn(texnum,maskedtexturecol[dc_x], false) -3);\n\t\t\t\n\t    R_DrawMaskedColumn (col);\n\t    maskedtexturecol[dc_x] = INT_MAX; // [crispy] 32-bit integer math\n\t}\n\tspryscale += rw_scalestep;\n    }\n\t\n}\n\n\n\n\n//\n// R_RenderSegLoop\n// Draws zero, one, or two textures (and possibly a masked\n//  texture) for walls.\n// Can draw or mark the starting pixel of floor and ceiling\n//  textures.\n// CALLED: CORE LOOPING ROUTINE.\n//\n#define HEIGHTBITS\t\t12\n#define HEIGHTUNIT\t\t(1<<HEIGHTBITS)\n\nvoid R_RenderSegLoop (void)\n{\n    angle_t\t\tangle;\n    unsigned\t\tindex;\n    int\t\t\tyl;\n    int\t\t\tyh;\n    int\t\t\tmid;\n    fixed_t\t\ttexturecolumn;\n    int\t\t\ttop;\n    int\t\t\tbottom;\n\n    for ( ; rw_x < rw_stopx ; rw_x++)\n    {\n\t// mark floor / ceiling areas\n\tyl = (int)((topfrac+heightunit-1)>>heightbits); // [crispy] WiggleFix\n\n\t// no space above wall?\n\tif (yl < ceilingclip[rw_x]+1)\n\t    yl = ceilingclip[rw_x]+1;\n\t\n\tif (markceiling)\n\t{\n\t    top = ceilingclip[rw_x]+1;\n\t    bottom = yl-1;\n\n\t    if (bottom >= floorclip[rw_x])\n\t\tbottom = floorclip[rw_x]-1;\n\n\t    if (top <= bottom)\n\t    {\n\t\tceilingplane->top[rw_x] = top;\n\t\tceilingplane->bottom[rw_x] = bottom;\n\t    }\n\t}\n\t\t\n\tyh = (int)(bottomfrac>>heightbits); // [crispy] WiggleFix\n\n\tif (yh >= floorclip[rw_x])\n\t    yh = floorclip[rw_x]-1;\n\n\tif (markfloor)\n\t{\n\t    top = yh+1;\n\t    bottom = floorclip[rw_x]-1;\n\t    if (top <= ceilingclip[rw_x])\n\t\ttop = ceilingclip[rw_x]+1;\n\t    if (top <= bottom)\n\t    {\n\t\tfloorplane->top[rw_x] = top;\n\t\tfloorplane->bottom[rw_x] = bottom;\n\t    }\n\t}\n\t\n\t// texturecolumn and lighting are independent of wall tiers\n\tif (segtextured)\n\t{\n\t    // calculate texture offset\n\t    angle = (rw_centerangle + xtoviewangle[rw_x])>>ANGLETOFINESHIFT;\n\t    texturecolumn = rw_offset-FixedMul(finetangent[angle],rw_distance);\n\t    texturecolumn >>= FRACBITS;\n\t    // calculate lighting\n\t    index = rw_scale>>(LIGHTSCALESHIFT);\n\n\t    if (index >=  MAXLIGHTSCALE )\n\t\tindex = MAXLIGHTSCALE-1;\n\n\t    // [crispy] optional brightmaps\n\t    dc_colormap[0] = walllights[index];\n\t\tdc_colormap[1] = dc_colormap[0];\n\t    dc_x = rw_x;\n\t    dc_iscale = 0xffffffffu / (unsigned)rw_scale;\n\t}\n        else\n        {\n            // purely to shut up the compiler\n\n            texturecolumn = 0;\n        }\n\t\n\t// draw the wall tiers\n\tif (midtexture)\n\t{\n\t    // single sided line\n\t    dc_yl = yl;\n\t    dc_yh = yh;\n\t    dc_texturemid = rw_midtexturemid;\n\t    dc_source = R_GetColumn(midtexture,texturecolumn,true);\n\t    dc_texheight = textureheight[midtexture]>>FRACBITS; // [crispy] Tutti-Frutti fix\n\t    dc_brightmap = texturebrightmap[midtexture];\n\t    colfunc ();\n\t    ceilingclip[rw_x] = viewheight;\n\t    floorclip[rw_x] = -1;\n\t}\n\telse\n\t{\n\t    // two sided line\n\t    if (toptexture)\n\t    {\n\t\t// top wall\n\t\tmid = (int)(pixhigh>>heightbits); // [crispy] WiggleFix\n\t\tpixhigh += pixhighstep;\n\n\t\tif (mid >= floorclip[rw_x])\n\t\t    mid = floorclip[rw_x]-1;\n\n\t\tif (mid >= yl)\n\t\t{\n\t\t    dc_yl = yl;\n\t\t    dc_yh = mid;\n\t\t    dc_texturemid = rw_toptexturemid;\n\t\t    dc_source = R_GetColumn(toptexture,texturecolumn,true);\n\t\t    dc_texheight = textureheight[toptexture]>>FRACBITS; // [crispy] Tutti-Frutti fix\n\t\t    dc_brightmap = texturebrightmap[toptexture];\n\t\t    colfunc ();\n\t\t    ceilingclip[rw_x] = mid;\n\t\t}\n\t\telse\n\t\t    ceilingclip[rw_x] = yl-1;\n\t    }\n\t    else\n\t    {\n\t\t// no top wall\n\t\tif (markceiling)\n\t\t    ceilingclip[rw_x] = yl-1;\n\t    }\n\t\t\t\n\t    if (bottomtexture)\n\t    {\n\t\t// bottom wall\n\t\tmid = (int)((pixlow+heightunit-1)>>heightbits); // [crispy] WiggleFix\n\t\tpixlow += pixlowstep;\n\n\t\t// no space above wall?\n\t\tif (mid <= ceilingclip[rw_x])\n\t\t    mid = ceilingclip[rw_x]+1;\n\t\t\n\t\tif (mid <= yh)\n\t\t{\n\t\t    dc_yl = mid;\n\t\t    dc_yh = yh;\n\t\t    dc_texturemid = rw_bottomtexturemid;\n\t\t    dc_source = R_GetColumn(bottomtexture,\n\t\t\t\t\t    texturecolumn,true);\n\t\t    dc_texheight = textureheight[bottomtexture]>>FRACBITS; // [crispy] Tutti-Frutti fix\n\t\t    dc_brightmap = texturebrightmap[bottomtexture];\n\t\t    colfunc ();\n\t\t    floorclip[rw_x] = mid;\n\t\t}\n\t\telse\n\t\t    floorclip[rw_x] = yh+1;\n\t    }\n\t    else\n\t    {\n\t\t// no bottom wall\n\t\tif (markfloor)\n\t\t    floorclip[rw_x] = yh+1;\n\t    }\n\t\t\t\n\t    if (maskedtexture)\n\t    {\n\t\t// save texturecol\n\t\t//  for backdrawing of masked mid texture\n\t\tmaskedtexturecol[rw_x] = texturecolumn;\n\t    }\n\t}\n\t\t\n\trw_scale += rw_scalestep;\n\ttopfrac += topstep;\n\tbottomfrac += bottomstep;\n    }\n}\n\n\n\n// [crispy] WiggleFix: move R_ScaleFromGlobalAngle function to r_segs.c,\n// above R_StoreWallRange\nfixed_t R_ScaleFromGlobalAngle (angle_t visangle)\n{\n    int\t\tanglea = ANG90 + (visangle - viewangle);\n    int\t\tangleb = ANG90 + (visangle - rw_normalangle);\n    int\t\tden = FixedMul(rw_distance, finesine[anglea >> ANGLETOFINESHIFT]);\n    fixed_t\tnum = FixedMul(projection, finesine[angleb >> ANGLETOFINESHIFT])<<detailshift;\n    fixed_t \tscale;\n\n    if (den > (num >> 16))\n    {\n\tscale = FixedDiv(num, den);\n\n\t// [kb] When this evaluates True, the scale is clamped,\n\t//  and there will be some wiggling.\n\tif (scale > max_rwscale)\n\t    scale = max_rwscale;\n\telse if (scale < 256)\n\t    scale = 256;\n    }\n    else\n\tscale = max_rwscale;\n\n    return scale;\n}\n\n//\n// R_StoreWallRange\n// A wall segment will be drawn\n//  between start and stop pixels (inclusive).\n//\nvoid\nR_StoreWallRange\n( int\tstart,\n  int\tstop )\n{\n    fixed_t\t\tvtop;\n    int\t\t\tlightnum;\n    int64_t\t\tdx, dy, dx1, dy1, dist; // [crispy] fix long wall wobble\n    const uint32_t\tlen = curline->length;\n\n    // [crispy] remove MAXDRAWSEGS Vanilla limit\n    if (ds_p == &drawsegs[numdrawsegs])\n    {\n\tint numdrawsegs_old = numdrawsegs;\n\n\tnumdrawsegs = numdrawsegs ? 2 * numdrawsegs : MAXDRAWSEGS;\n\tdrawsegs = I_Realloc(drawsegs, numdrawsegs * sizeof(*drawsegs));\n\tmemset(drawsegs + numdrawsegs_old, 0, (numdrawsegs - numdrawsegs_old) * sizeof(*drawsegs));\n\n\tds_p = drawsegs + numdrawsegs_old;\n\n\tif (numdrawsegs_old)\n\t    fprintf(stderr, \"R_StoreWallRange: Hit MAXDRAWSEGS limit at %d, raised to %d.\\n\", numdrawsegs_old, numdrawsegs);\n    }\n\t\t\n#ifdef RANGECHECK\n    if (start >=viewwidth || start > stop)\n\tI_Error (\"Bad R_RenderWallRange: %i to %i\", start , stop);\n#endif\n    \n    sidedef = curline->sidedef;\n    linedef = curline->linedef;\n\n    // mark the segment as visible for auto map\n    linedef->flags |= ML_MAPPED;\n    \n    // [crispy] (flags & ML_MAPPED) is all we need to know for automap\n    if (automapactive /*&& !crispy->automapoverlay*/)\n        return;\n\n    // calculate rw_distance for scale calculation\n    rw_normalangle = curline->r_angle + ANG90; // [crispy] use re-calculated angle\n    \n    // [crispy] fix long wall wobble\n    // thank you very much Linguica, e6y and kb1\n    // http://www.doomworld.com/vb/post/1340718\n    // shift right to avoid possibility of int64 overflow in rw_distance calculation\n    dx = ((int64_t)curline->v2->r_x - curline->v1->r_x) >> 1;\n    dy = ((int64_t)curline->v2->r_y - curline->v1->r_y) >> 1;\n    dx1 = ((int64_t)viewx - curline->v1->r_x) >> 1;\n    dy1 = ((int64_t)viewy - curline->v1->r_y) >> 1;\n    dist = ((dy * dx1 - dx * dy1) / len) << 1;\n    rw_distance = (fixed_t)BETWEEN(INT_MIN, INT_MAX, dist);\n\t\t\n\t\n    ds_p->x1 = rw_x = start;\n    ds_p->x2 = stop;\n    ds_p->curline = curline;\n    rw_stopx = stop+1;\n    \n    // [crispy] WiggleFix: add this line, in r_segs.c:R_StoreWallRange,\n    // right before calls to R_ScaleFromGlobalAngle:\n    R_FixWiggle(frontsector);\n\n    // calculate scale at both ends and step\n    ds_p->scale1 = rw_scale = \n\tR_ScaleFromGlobalAngle (viewangle + xtoviewangle[start]);\n    \n    if (stop > start )\n    {\n\tds_p->scale2 = R_ScaleFromGlobalAngle (viewangle + xtoviewangle[stop]);\n\tds_p->scalestep = rw_scalestep = \n\t    (ds_p->scale2 - rw_scale) / (stop-start);\n    }\n    else\n    {\n\tds_p->scale2 = ds_p->scale1;\n    }\n    \n    // calculate texture boundaries\n    //  and decide if floor / ceiling marks are needed\n    worldtop = frontsector->interpceilingheight - viewz;\n    worldbottom = frontsector->interpfloorheight - viewz;\n\t\n    midtexture = toptexture = bottomtexture = maskedtexture = 0;\n    ds_p->maskedtexturecol = NULL;\n\t\n    if (!backsector)\n    {\n\t// single sided line\n\tmidtexture = texturetranslation[sidedef->midtexture];\n\t// a single sided line is terminal, so it must mark ends\n\tmarkfloor = markceiling = true;\n\tif (linedef->flags & ML_DONTPEGBOTTOM)\n\t{\n\t    vtop = frontsector->interpfloorheight +\n\t\ttextureheight[sidedef->midtexture];\n\t    // bottom of texture at bottom\n\t    rw_midtexturemid = vtop - viewz;\t\n\t}\n\telse\n\t{\n\t    // top of texture at top\n\t    rw_midtexturemid = worldtop;\n\t}\n\trw_midtexturemid += sidedef->rowoffset;\n\n\tds_p->silhouette = SIL_BOTH;\n\tds_p->sprtopclip = screenheightarray;\n\tds_p->sprbottomclip = negonearray;\n\tds_p->bsilheight = INT_MAX;\n\tds_p->tsilheight = INT_MIN;\n    }\n    else\n    {\n\t// [crispy] fix sprites being visible behind closed doors\n\t// adapted from mbfsrc/R_BSP.C:234-257\n\tconst boolean doorclosed =\n\t    // if door is closed because back is shut:\n\t    backsector->interpceilingheight <= backsector->interpfloorheight\n\t    // preserve a kind of transparent door/lift special effect:\n\t    && (backsector->interpceilingheight >= frontsector->interpceilingheight ||\n\t       curline->sidedef->toptexture)\n\t    && (backsector->interpfloorheight <= frontsector->interpfloorheight ||\n\t       curline->sidedef->bottomtexture)\n\t    // properly render skies (consider door \"open\" if both ceilings are sky):\n\t    && (backsector->ceilingpic != skyflatnum ||\n\t       frontsector->ceilingpic != skyflatnum);\n\n\t// two sided line\n\tds_p->sprtopclip = ds_p->sprbottomclip = NULL;\n\tds_p->silhouette = 0;\n\t\n\tif (frontsector->interpfloorheight > backsector->interpfloorheight)\n\t{\n\t    ds_p->silhouette = SIL_BOTTOM;\n\t    ds_p->bsilheight = frontsector->interpfloorheight;\n\t}\n\telse if (backsector->interpfloorheight > viewz)\n\t{\n\t    ds_p->silhouette = SIL_BOTTOM;\n\t    ds_p->bsilheight = INT_MAX;\n\t}\n\t\n\tif (frontsector->interpceilingheight < backsector->interpceilingheight)\n\t{\n\t    ds_p->silhouette |= SIL_TOP;\n\t    ds_p->tsilheight = frontsector->interpceilingheight;\n\t}\n\telse if (backsector->interpceilingheight < viewz)\n\t{\n\t    ds_p->silhouette |= SIL_TOP;\n\t    ds_p->tsilheight = INT_MIN;\n\t}\n\t\t\n\tif (backsector->interpceilingheight <= frontsector->interpfloorheight || doorclosed)\n\t{\n\t    ds_p->sprbottomclip = negonearray;\n\t    ds_p->bsilheight = INT_MAX;\n\t    ds_p->silhouette |= SIL_BOTTOM;\n\t}\n\t\n\tif (backsector->interpfloorheight >= frontsector->interpceilingheight || doorclosed)\n\t{\n\t    ds_p->sprtopclip = screenheightarray;\n\t    ds_p->tsilheight = INT_MIN;\n\t    ds_p->silhouette |= SIL_TOP;\n\t}\n\t\n\tworldhigh = backsector->interpceilingheight - viewz;\n\tworldlow = backsector->interpfloorheight - viewz;\n\t\t\n\t// hack to allow height changes in outdoor areas\n\tif (frontsector->ceilingpic == skyflatnum \n\t    && backsector->ceilingpic == skyflatnum)\n\t{\n\t    worldtop = worldhigh;\n\t}\n\t\n\t\t\t\n\tif (worldlow != worldbottom \n\t    || backsector->floorpic != frontsector->floorpic\n\t    || backsector->lightlevel != frontsector->lightlevel\n\t\t// killough 4/15/98: prevent 2s normals\n        // from bleeding through deep water\n        || frontsector->heightsec != -1\n\n        // killough 4/17/98: draw floors if different light levels\n        || backsector->floorlightsec != frontsector->floorlightsec)\n\t{\n\t    markfloor = true;\n\t}\n\telse\n\t{\n\t    // same plane on both sides\n\t    markfloor = false;\n\t}\n\t\n\t\t\t\n\tif (worldhigh != worldtop \n\t    || backsector->ceilingpic != frontsector->ceilingpic\n\t    || backsector->lightlevel != frontsector->lightlevel\n\t\t// killough 4/15/98: prevent 2s normals\n        // from bleeding through fake ceilings\n        || (frontsector->heightsec != -1 &&\n            frontsector->ceilingpic!=skyflatnum)\n\n        // killough 4/17/98: draw ceilings if different light levels\n        || backsector->ceilinglightsec != frontsector->ceilinglightsec)\n\t{\n\t    markceiling = true;\n\t}\n\telse\n\t{\n\t    // same plane on both sides\n\t    markceiling = false;\n\t}\n\t\n\tif (backsector->interpceilingheight <= frontsector->interpfloorheight\n\t    || backsector->interpfloorheight >= frontsector->interpceilingheight)\n\t{\n\t    // closed door\n\t    markceiling = markfloor = true;\n\t}\n\t\n\n\tif (worldhigh < worldtop)\n\t{\n\t    // top texture\n\t    toptexture = texturetranslation[sidedef->toptexture];\n\t    if (linedef->flags & ML_DONTPEGTOP)\n\t    {\n\t\t// top of texture at top\n\t\trw_toptexturemid = worldtop;\n\t    }\n\t    else\n\t    {\n\t\tvtop =\n\t\t    backsector->interpceilingheight\n\t\t    + textureheight[sidedef->toptexture];\n\t\t\n\t\t// bottom of texture\n\t\trw_toptexturemid = vtop - viewz;\t\n\t    }\n\t}\n\tif (worldlow > worldbottom)\n\t{\n\t    // bottom texture\n\t    bottomtexture = texturetranslation[sidedef->bottomtexture];\n\n\t    if (linedef->flags & ML_DONTPEGBOTTOM )\n\t    {\n\t\t// bottom of texture at bottom\n\t\t// top of texture at top\n\t\trw_bottomtexturemid = worldtop;\n\t    }\n\t    else\t// top of texture at top\n\t\trw_bottomtexturemid = worldlow;\n\t}\n\trw_toptexturemid += sidedef->rowoffset;\n\trw_bottomtexturemid += sidedef->rowoffset;\n\t\n\t// allocate space for masked texture tables\n\tif (sidedef->midtexture)\n\t{\n\t    // masked midtexture\n\t    maskedtexture = true;\n\t    ds_p->maskedtexturecol = maskedtexturecol = lastopening - rw_x;\n\t    lastopening += rw_stopx - rw_x;\n\t}\n    }\n    \n    // calculate rw_offset (only needed for textured lines)\n    segtextured = midtexture | toptexture | bottomtexture | maskedtexture;\n\n    if (segtextured)\n    {\n\t\n\t// [crispy] fix long wall wobble\n\trw_offset = (fixed_t)(((dx*dx1 + dy*dy1) / len) << 1);\n\trw_offset += sidedef->textureoffset + curline->offset;\n\trw_centerangle = ANG90 + viewangle - rw_normalangle;\n\t\n\t// calculate light table\n\t//  use different light tables\n\t//  for horizontal / vertical / diagonal\n\t// OPTIMIZE: get rid of LIGHTSEGSHIFT globally\n\tif (!fixedcolormap)\n\t{\n\t    lightnum = (frontsector->lightlevel >> LIGHTSEGSHIFT)+(extralight * LIGHTBRIGHT);\n\n\t    // [crispy] smoother fake contrast\n\t    lightnum += curline->fakecontrast;\n\n\t    if (lightnum < 0)\t\t\n\t\twalllights = scalelight[0];\n\t    else if (lightnum >= LIGHTLEVELS)\n\t\twalllights = scalelight[LIGHTLEVELS-1];\n\t    else\n\t\twalllights = scalelight[lightnum];\n\t}\n    }\n    \n    // if a floor / ceiling plane is on the wrong side\n    //  of the view plane, it is definitely invisible\n    //  and doesn't need to be marked.\n    \n  // killough 3/7/98: add deep water check\n  if (frontsector->heightsec == -1)\n  {\n    if (frontsector->interpfloorheight >= viewz)\n    {\n\t// above view plane\n\tmarkfloor = false;\n    }\n    \n    if (frontsector->interpceilingheight <= viewz\n\t&& frontsector->ceilingpic != skyflatnum)\n    {\n\t// below view plane\n\tmarkceiling = false;\n    }\n  }\n    \n    // calculate incremental stepping values for texture edges\n    worldtop >>= invhgtbits;\n    worldbottom >>= invhgtbits;\n\t\n    topstep = -FixedMul (rw_scalestep, worldtop);\n    topfrac = ((int64_t)centeryfrac>>invhgtbits) - (((int64_t)worldtop * rw_scale)>>FRACBITS); // [crispy] WiggleFix\n\n    bottomstep = -FixedMul (rw_scalestep,worldbottom);\n    bottomfrac = ((int64_t)centeryfrac>>invhgtbits) - (((int64_t)worldbottom * rw_scale)>>FRACBITS); // [crispy] WiggleFix\n\t\n    if (backsector)\n    {\t\n\tworldhigh >>= invhgtbits;\n\tworldlow >>= invhgtbits;\n\n\tif (worldhigh < worldtop)\n\t{\n\t    pixhigh = ((int64_t)centeryfrac>>invhgtbits) - (((int64_t)worldhigh * rw_scale)>>FRACBITS); // [crispy] WiggleFix\n\t    pixhighstep = -FixedMul (rw_scalestep,worldhigh);\n\t}\n\t\n\tif (worldlow > worldbottom)\n\t{\n\t    pixlow = ((int64_t)centeryfrac>>invhgtbits) - (((int64_t)worldlow * rw_scale)>>FRACBITS); // [crispy] WiggleFix\n\t    pixlowstep = -FixedMul (rw_scalestep,worldlow);\n\t}\n    }\n    \n    // render it\n    if (markceiling)\n\tceilingplane = R_CheckPlane (ceilingplane, rw_x, rw_stopx-1);\n    \n    if (markfloor)\n\tfloorplane = R_CheckPlane (floorplane, rw_x, rw_stopx-1);\n\n    R_RenderSegLoop ();\n\n    \n    // save sprite clipping info\n    if ( ((ds_p->silhouette & SIL_TOP) || maskedtexture)\n\t && !ds_p->sprtopclip)\n    {\n\tmemcpy (lastopening, ceilingclip+start, sizeof(*lastopening)*(rw_stopx-start));\n\tds_p->sprtopclip = lastopening - start;\n\tlastopening += rw_stopx - start;\n    }\n    \n    if ( ((ds_p->silhouette & SIL_BOTTOM) || maskedtexture)\n\t && !ds_p->sprbottomclip)\n    {\n\tmemcpy (lastopening, floorclip+start, sizeof(*lastopening)*(rw_stopx-start));\n\tds_p->sprbottomclip = lastopening - start;\n\tlastopening += rw_stopx - start;\t\n    }\n\n    if (maskedtexture && !(ds_p->silhouette&SIL_TOP))\n    {\n\tds_p->silhouette |= SIL_TOP;\n\tds_p->tsilheight = INT_MIN;\n    }\n    if (maskedtexture && !(ds_p->silhouette&SIL_BOTTOM))\n    {\n\tds_p->silhouette |= SIL_BOTTOM;\n\tds_p->bsilheight = INT_MAX;\n    }\n    ds_p++;\n}\n\n","/* sha1.c - SHA1 hash function\n *\tCopyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n *\n * Please see below for more legal information!\n *\n * This file is part of GnuPG.\n *\n * GnuPG is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * GnuPG is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,\n * USA.\n */\n\n\n/*  Test vectors:\n *\n *  \"abc\"\n *  A999 3E36 4706 816A BA3E  2571 7850 C26C 9CD0 D89D\n *\n *  \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\"\n *  8498 3E44 1C3B D26E BAAE  4AA1 F951 29E5 E546 70F1\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"i_swap.h\"\n#include \"sha1.h\"\n\nvoid SHA1_Init(sha1_context_t *hd)\n{\n    hd->h0 = 0x67452301;\n    hd->h1 = 0xefcdab89;\n    hd->h2 = 0x98badcfe;\n    hd->h3 = 0x10325476;\n    hd->h4 = 0xc3d2e1f0;\n    hd->nblocks = 0;\n    hd->count = 0;\n}\n\n\n/****************\n * Transform the message X which consists of 16 32-bit-words\n */\nstatic void Transform(sha1_context_t *hd, byte *data)\n{\n    uint32_t a,b,c,d,e,tm;\n    uint32_t x[16];\n\n    /* get values from the chaining vars */\n    a = hd->h0;\n    b = hd->h1;\n    c = hd->h2;\n    d = hd->h3;\n    e = hd->h4;\n\n#ifdef SYS_BIG_ENDIAN\n    memcpy(x, data, 64);\n#else\n    {\n        int i;\n        byte *p2;\n        for(i=0, p2=(byte*)x; i < 16; i++, p2 += 4 )\n        {\n            p2[3] = *data++;\n            p2[2] = *data++;\n            p2[1] = *data++;\n            p2[0] = *data++;\n        }\n    }\n#endif\n\n\n#define K1  0x5A827999L\n#define K2  0x6ED9EBA1L\n#define K3  0x8F1BBCDCL\n#define K4  0xCA62C1D6L\n#define F1(x,y,z)   ( z ^ ( x & ( y ^ z ) ) )\n#define F2(x,y,z)   ( x ^ y ^ z )\n#define F3(x,y,z)   ( ( x & y ) | ( z & ( x | y ) ) )\n#define F4(x,y,z)   ( x ^ y ^ z )\n\n#define rol(x,n) ( ((x) << (n)) | ((x) >> (32-(n))) )\n\n#define M(i) ( tm =   x[i&0x0f] ^ x[(i-14)&0x0f] \\\n\t\t    ^ x[(i-8)&0x0f] ^ x[(i-3)&0x0f] \\\n\t       , (x[i&0x0f] = rol(tm,1)) )\n\n#define R(a,b,c,d,e,f,k,m)  do { e += rol( a, 5 )     \\\n\t\t\t\t      + f( b, c, d )  \\\n\t\t\t\t      + k\t      \\\n\t\t\t\t      + m;\t      \\\n\t\t\t\t b = rol( b, 30 );    \\\n\t\t\t       } while(0)\n    R( a, b, c, d, e, F1, K1, x[ 0] );\n    R( e, a, b, c, d, F1, K1, x[ 1] );\n    R( d, e, a, b, c, F1, K1, x[ 2] );\n    R( c, d, e, a, b, F1, K1, x[ 3] );\n    R( b, c, d, e, a, F1, K1, x[ 4] );\n    R( a, b, c, d, e, F1, K1, x[ 5] );\n    R( e, a, b, c, d, F1, K1, x[ 6] );\n    R( d, e, a, b, c, F1, K1, x[ 7] );\n    R( c, d, e, a, b, F1, K1, x[ 8] );\n    R( b, c, d, e, a, F1, K1, x[ 9] );\n    R( a, b, c, d, e, F1, K1, x[10] );\n    R( e, a, b, c, d, F1, K1, x[11] );\n    R( d, e, a, b, c, F1, K1, x[12] );\n    R( c, d, e, a, b, F1, K1, x[13] );\n    R( b, c, d, e, a, F1, K1, x[14] );\n    R( a, b, c, d, e, F1, K1, x[15] );\n    R( e, a, b, c, d, F1, K1, M(16) );\n    R( d, e, a, b, c, F1, K1, M(17) );\n    R( c, d, e, a, b, F1, K1, M(18) );\n    R( b, c, d, e, a, F1, K1, M(19) );\n    R( a, b, c, d, e, F2, K2, M(20) );\n    R( e, a, b, c, d, F2, K2, M(21) );\n    R( d, e, a, b, c, F2, K2, M(22) );\n    R( c, d, e, a, b, F2, K2, M(23) );\n    R( b, c, d, e, a, F2, K2, M(24) );\n    R( a, b, c, d, e, F2, K2, M(25) );\n    R( e, a, b, c, d, F2, K2, M(26) );\n    R( d, e, a, b, c, F2, K2, M(27) );\n    R( c, d, e, a, b, F2, K2, M(28) );\n    R( b, c, d, e, a, F2, K2, M(29) );\n    R( a, b, c, d, e, F2, K2, M(30) );\n    R( e, a, b, c, d, F2, K2, M(31) );\n    R( d, e, a, b, c, F2, K2, M(32) );\n    R( c, d, e, a, b, F2, K2, M(33) );\n    R( b, c, d, e, a, F2, K2, M(34) );\n    R( a, b, c, d, e, F2, K2, M(35) );\n    R( e, a, b, c, d, F2, K2, M(36) );\n    R( d, e, a, b, c, F2, K2, M(37) );\n    R( c, d, e, a, b, F2, K2, M(38) );\n    R( b, c, d, e, a, F2, K2, M(39) );\n    R( a, b, c, d, e, F3, K3, M(40) );\n    R( e, a, b, c, d, F3, K3, M(41) );\n    R( d, e, a, b, c, F3, K3, M(42) );\n    R( c, d, e, a, b, F3, K3, M(43) );\n    R( b, c, d, e, a, F3, K3, M(44) );\n    R( a, b, c, d, e, F3, K3, M(45) );\n    R( e, a, b, c, d, F3, K3, M(46) );\n    R( d, e, a, b, c, F3, K3, M(47) );\n    R( c, d, e, a, b, F3, K3, M(48) );\n    R( b, c, d, e, a, F3, K3, M(49) );\n    R( a, b, c, d, e, F3, K3, M(50) );\n    R( e, a, b, c, d, F3, K3, M(51) );\n    R( d, e, a, b, c, F3, K3, M(52) );\n    R( c, d, e, a, b, F3, K3, M(53) );\n    R( b, c, d, e, a, F3, K3, M(54) );\n    R( a, b, c, d, e, F3, K3, M(55) );\n    R( e, a, b, c, d, F3, K3, M(56) );\n    R( d, e, a, b, c, F3, K3, M(57) );\n    R( c, d, e, a, b, F3, K3, M(58) );\n    R( b, c, d, e, a, F3, K3, M(59) );\n    R( a, b, c, d, e, F4, K4, M(60) );\n    R( e, a, b, c, d, F4, K4, M(61) );\n    R( d, e, a, b, c, F4, K4, M(62) );\n    R( c, d, e, a, b, F4, K4, M(63) );\n    R( b, c, d, e, a, F4, K4, M(64) );\n    R( a, b, c, d, e, F4, K4, M(65) );\n    R( e, a, b, c, d, F4, K4, M(66) );\n    R( d, e, a, b, c, F4, K4, M(67) );\n    R( c, d, e, a, b, F4, K4, M(68) );\n    R( b, c, d, e, a, F4, K4, M(69) );\n    R( a, b, c, d, e, F4, K4, M(70) );\n    R( e, a, b, c, d, F4, K4, M(71) );\n    R( d, e, a, b, c, F4, K4, M(72) );\n    R( c, d, e, a, b, F4, K4, M(73) );\n    R( b, c, d, e, a, F4, K4, M(74) );\n    R( a, b, c, d, e, F4, K4, M(75) );\n    R( e, a, b, c, d, F4, K4, M(76) );\n    R( d, e, a, b, c, F4, K4, M(77) );\n    R( c, d, e, a, b, F4, K4, M(78) );\n    R( b, c, d, e, a, F4, K4, M(79) );\n\n    /* update chainig vars */\n    hd->h0 += a;\n    hd->h1 += b;\n    hd->h2 += c;\n    hd->h3 += d;\n    hd->h4 += e;\n}\n\n\n/* Update the message digest with the contents\n * of INBUF with length INLEN.\n */\nvoid SHA1_Update(sha1_context_t *hd, byte *inbuf, size_t inlen)\n{\n    if (hd->count == 64)\n    {\n        /* flush the buffer */\n\tTransform(hd, hd->buf);\n\thd->count = 0;\n\thd->nblocks++;\n    }\n    if (!inbuf)\n\treturn;\n    if (hd->count)\n    {\n\tfor (; inlen && hd->count < 64; inlen--)\n\t    hd->buf[hd->count++] = *inbuf++;\n\tSHA1_Update(hd, NULL, 0);\n\tif (!inlen)\n\t    return;\n    }\n\n    while (inlen >= 64)\n    {\n\tTransform(hd, inbuf);\n\thd->count = 0;\n\thd->nblocks++;\n\tinlen -= 64;\n\tinbuf += 64;\n    }\n    for (; inlen && hd->count < 64; inlen--)\n\thd->buf[hd->count++] = *inbuf++;\n}\n\n\n/* The routine final terminates the computation and\n * returns the digest.\n * The handle is prepared for a new cycle, but adding bytes to the\n * handle will the destroy the returned buffer.\n * Returns: 20 bytes representing the digest.\n */\n\nvoid SHA1_Final(sha1_digest_t digest, sha1_context_t *hd)\n{\n    uint32_t t, msb, lsb;\n    byte *p;\n\n    SHA1_Update(hd, NULL, 0); /* flush */;\n\n    t = hd->nblocks;\n    /* multiply by 64 to make a byte count */\n    lsb = t << 6;\n    msb = t >> 26;\n    /* add the count */\n    t = lsb;\n    if ((lsb += hd->count) < t)\n\tmsb++;\n    /* multiply by 8 to make a bit count */\n    t = lsb;\n    lsb <<= 3;\n    msb <<= 3;\n    msb |= t >> 29;\n\n    if (hd->count < 56)\n    {\n        /* enough room */\n\thd->buf[hd->count++] = 0x80; /* pad */\n\twhile (hd->count < 56)\n\t    hd->buf[hd->count++] = 0;  /* pad */\n    }\n    else\n    {\n        /* need one extra block */\n\thd->buf[hd->count++] = 0x80; /* pad character */\n\twhile (hd->count < 64)\n\t    hd->buf[hd->count++] = 0;\n\tSHA1_Update(hd, NULL, 0);  /* flush */;\n\tmemset(hd->buf, 0, 56 ); /* fill next block with zeroes */\n    }\n    /* append the 64 bit count */\n    hd->buf[56] = msb >> 24;\n    hd->buf[57] = msb >> 16;\n    hd->buf[58] = msb >>  8;\n    hd->buf[59] = msb\t   ;\n    hd->buf[60] = lsb >> 24;\n    hd->buf[61] = lsb >> 16;\n    hd->buf[62] = lsb >>  8;\n    hd->buf[63] = lsb\t   ;\n    Transform(hd, hd->buf);\n\n    p = hd->buf;\n#ifdef SYS_BIG_ENDIAN\n#define X(a) do { *(uint32_t*)p = hd->h##a ; p += 4; } while(0)\n#else /* little endian */\n#define X(a) do { *p++ = hd->h##a >> 24; *p++ = hd->h##a >> 16;\t \\\n\t\t      *p++ = hd->h##a >> 8; *p++ = hd->h##a; } while(0)\n#endif\n    X(0);\n    X(1);\n    X(2);\n    X(3);\n    X(4);\n#undef X\n\n    memcpy(digest, hd->buf, sizeof(sha1_digest_t));\n}\n\nvoid SHA1_UpdateInt32(sha1_context_t *context, unsigned int val)\n{\n    byte buf[4];\n\n    buf[0] = (val >> 24) & 0xff;\n    buf[1] = (val >> 16) & 0xff;\n    buf[2] = (val >> 8) & 0xff;\n    buf[3] = val & 0xff;\n\n    SHA1_Update(context, buf, 4);\n}\n\nvoid SHA1_UpdateString(sha1_context_t *context, char *str)\n{\n    SHA1_Update(context, (byte *) str, strlen(str) + 1);\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tLookup tables.\n//\tDo not try to look them up :-).\n//\tIn the order of appearance: \n//\n//\tint finetangent[4096]\t- Tangens LUT.\n//\t Should work with BAM fairly well (12 of 16bit,\n//      effectively, by shifting).\n//\n//\tint finesine[10240]\t\t- Sine lookup.\n//\t Guess what, serves as cosine, too.\n//\t Remarkable thing is, how to use BAMs with this? \n//\n//\tint tantoangle[2049]\t- ArcTan LUT,\n//\t  maps tan(angle) to angle fast. Gotta search.\n//\t\n//    \n\n#include \"tables.h\"\n\n// to get a global angle from cartesian coordinates, the coordinates are\n// flipped until they are in the first octant of the coordinate system, then\n// the y (<=x) is scaled and divided by x to get a tangent (slope) value\n// which is looked up in the tantoangle[] table.  The +1 size is to handle\n// the case when x==y without additional checking.\n\nint SlopeDiv(unsigned int num, unsigned int den)\n{\n    unsigned ans;\n    \n    if (den < 512)\n    {\n        return SLOPERANGE;\n    }\n    else\n    {\n        ans = (num << 3) / (den >> 8);\n\n        if (ans <= SLOPERANGE)\n        {\n            return ans;\n        }\n        else\n        {\n            return SLOPERANGE;\n        }\n    }\n}\n\n// [crispy] catch SlopeDiv overflows, only used in rendering\nint SlopeDivCrispy(unsigned int num, unsigned int den)\n{\n    if (den < 512)\n    {\n\treturn SLOPERANGE;\n    }\n    else\n    {\n\tuint64_t ans = ((uint64_t) num << 3) / (den >> 8);\n\n\tif (ans <= SLOPERANGE)\n\t{\n\t    return (int) ans;\n\t}\n\telse\n\t{\n\t    return SLOPERANGE;\n\t}\n    }\n}\n\nconst fixed_t finetangent[4096] =\n{\n    -170910304,-56965752,-34178904,-24413316,-18988036,-15535599,-13145455,-11392683,\n    -10052327,-8994149,-8137527,-7429880,-6835455,-6329090,-5892567,-5512368,\n    -5178251,-4882318,-4618375,-4381502,-4167737,-3973855,-3797206,-3635590,\n    -3487165,-3350381,-3223918,-3106651,-2997613,-2895966,-2800983,-2712030,\n    -2628549,-2550052,-2476104,-2406322,-2340362,-2277919,-2218719,-2162516,\n    -2109087,-2058233,-2009771,-1963536,-1919378,-1877161,-1836758,-1798063,\n    -1760956,-1725348,-1691149,-1658278,-1626658,-1596220,-1566898,-1538632,\n    -1511367,-1485049,-1459630,-1435065,-1411312,-1388330,-1366084,-1344537,\n    -1323658,-1303416,-1283783,-1264730,-1246234,-1228269,-1210813,-1193846,\n    -1177345,-1161294,-1145673,-1130465,-1115654,-1101225,-1087164,-1073455,\n    -1060087,-1047046,-1034322,-1021901,-1009774,-997931,-986361,-975054,\n    -964003,-953199,-942633,-932298,-922186,-912289,-902602,-893117,\n    -883829,-874730,-865817,-857081,-848520,-840127,-831898,-823827,\n    -815910,-808143,-800521,-793041,-785699,-778490,-771411,-764460,\n    -757631,-750922,-744331,-737853,-731486,-725227,-719074,-713023,\n    -707072,-701219,-695462,-689797,-684223,-678737,-673338,-668024,\n    -662792,-657640,-652568,-647572,-642651,-637803,-633028,-628323,\n    -623686,-619117,-614613,-610174,-605798,-601483,-597229,-593033,\n    -588896,-584815,-580789,-576818,-572901,-569035,-565221,-561456,\n    -557741,-554074,-550455,-546881,-543354,-539870,-536431,-533034,\n    -529680,-526366,-523094,-519861,-516667,-513512,-510394,-507313,\n    -504269,-501261,-498287,-495348,-492443,-489571,-486732,-483925,\n    -481150,-478406,-475692,-473009,-470355,-467730,-465133,-462565,\n    -460024,-457511,-455024,-452564,-450129,-447720,-445337,-442978,\n    -440643,-438332,-436045,-433781,-431540,-429321,-427125,-424951,\n    -422798,-420666,-418555,-416465,-414395,-412344,-410314,-408303,\n    -406311,-404338,-402384,-400448,-398530,-396630,-394747,-392882,\n    -391034,-389202,-387387,-385589,-383807,-382040,-380290,-378555,\n    -376835,-375130,-373440,-371765,-370105,-368459,-366826,-365208,\n    -363604,-362013,-360436,-358872,-357321,-355783,-354257,-352744,\n    -351244,-349756,-348280,-346816,-345364,-343924,-342495,-341078,\n    -339671,-338276,-336892,-335519,-334157,-332805,-331464,-330133,\n    -328812,-327502,-326201,-324910,-323629,-322358,-321097,-319844,\n    -318601,-317368,-316143,-314928,-313721,-312524,-311335,-310154,\n    -308983,-307819,-306664,-305517,-304379,-303248,-302126,-301011,\n    -299904,-298805,-297714,-296630,-295554,-294485,-293423,-292369,\n    -291322,-290282,-289249,-288223,-287204,-286192,-285186,-284188,\n    -283195,-282210,-281231,-280258,-279292,-278332,-277378,-276430,\n    -275489,-274553,-273624,-272700,-271782,-270871,-269965,-269064,\n    -268169,-267280,-266397,-265519,-264646,-263779,-262917,-262060,\n    -261209,-260363,-259522,-258686,-257855,-257029,-256208,-255392,\n    -254581,-253774,-252973,-252176,-251384,-250596,-249813,-249035,\n    -248261,-247492,-246727,-245966,-245210,-244458,-243711,-242967,\n    -242228,-241493,-240763,-240036,-239314,-238595,-237881,-237170,\n    -236463,-235761,-235062,-234367,-233676,-232988,-232304,-231624,\n    -230948,-230275,-229606,-228941,-228279,-227621,-226966,-226314,\n    -225666,-225022,-224381,-223743,-223108,-222477,-221849,-221225,\n    -220603,-219985,-219370,-218758,-218149,-217544,-216941,-216341,\n    -215745,-215151,-214561,-213973,-213389,-212807,-212228,-211652,\n    -211079,-210509,-209941,-209376,-208815,-208255,-207699,-207145,\n    -206594,-206045,-205500,-204956,-204416,-203878,-203342,-202809,\n    -202279,-201751,-201226,-200703,-200182,-199664,-199149,-198636,\n    -198125,-197616,-197110,-196606,-196105,-195606,-195109,-194614,\n    -194122,-193631,-193143,-192658,-192174,-191693,-191213,-190736,\n    -190261,-189789,-189318,-188849,-188382,-187918,-187455,-186995,\n    -186536,-186080,-185625,-185173,-184722,-184274,-183827,-183382,\n    -182939,-182498,-182059,-181622,-181186,-180753,-180321,-179891,\n    -179463,-179037,-178612,-178190,-177769,-177349,-176932,-176516,\n    -176102,-175690,-175279,-174870,-174463,-174057,-173653,-173251,\n    -172850,-172451,-172053,-171657,-171263,-170870,-170479,-170089,\n    -169701,-169315,-168930,-168546,-168164,-167784,-167405,-167027,\n    -166651,-166277,-165904,-165532,-165162,-164793,-164426,-164060,\n    -163695,-163332,-162970,-162610,-162251,-161893,-161537,-161182,\n    -160828,-160476,-160125,-159775,-159427,-159079,-158734,-158389,\n    -158046,-157704,-157363,-157024,-156686,-156349,-156013,-155678,\n    -155345,-155013,-154682,-154352,-154024,-153697,-153370,-153045,\n    -152722,-152399,-152077,-151757,-151438,-151120,-150803,-150487,\n    -150172,-149859,-149546,-149235,-148924,-148615,-148307,-148000,\n    -147693,-147388,-147084,-146782,-146480,-146179,-145879,-145580,\n    -145282,-144986,-144690,-144395,-144101,-143808,-143517,-143226,\n    -142936,-142647,-142359,-142072,-141786,-141501,-141217,-140934,\n    -140651,-140370,-140090,-139810,-139532,-139254,-138977,-138701,\n    -138426,-138152,-137879,-137607,-137335,-137065,-136795,-136526,\n    -136258,-135991,-135725,-135459,-135195,-134931,-134668,-134406,\n    -134145,-133884,-133625,-133366,-133108,-132851,-132594,-132339,\n    -132084,-131830,-131576,-131324,-131072,-130821,-130571,-130322,\n    -130073,-129825,-129578,-129332,-129086,-128841,-128597,-128353,\n    -128111,-127869,-127627,-127387,-127147,-126908,-126669,-126432,\n    -126195,-125959,-125723,-125488,-125254,-125020,-124787,-124555,\n    -124324,-124093,-123863,-123633,-123404,-123176,-122949,-122722,\n    -122496,-122270,-122045,-121821,-121597,-121374,-121152,-120930,\n    -120709,-120489,-120269,-120050,-119831,-119613,-119396,-119179,\n    -118963,-118747,-118532,-118318,-118104,-117891,-117678,-117466,\n    -117254,-117044,-116833,-116623,-116414,-116206,-115998,-115790,\n    -115583,-115377,-115171,-114966,-114761,-114557,-114354,-114151,\n    -113948,-113746,-113545,-113344,-113143,-112944,-112744,-112546,\n    -112347,-112150,-111952,-111756,-111560,-111364,-111169,-110974,\n    -110780,-110586,-110393,-110200,-110008,-109817,-109626,-109435,\n    -109245,-109055,-108866,-108677,-108489,-108301,-108114,-107927,\n    -107741,-107555,-107369,-107184,-107000,-106816,-106632,-106449,\n    -106266,-106084,-105902,-105721,-105540,-105360,-105180,-105000,\n    -104821,-104643,-104465,-104287,-104109,-103933,-103756,-103580,\n    -103404,-103229,-103054,-102880,-102706,-102533,-102360,-102187,\n    -102015,-101843,-101671,-101500,-101330,-101159,-100990,-100820,\n    -100651,-100482,-100314,-100146,-99979,-99812,-99645,-99479,\n    -99313,-99148,-98982,-98818,-98653,-98489,-98326,-98163,\n    -98000,-97837,-97675,-97513,-97352,-97191,-97030,-96870,\n    -96710,-96551,-96391,-96233,-96074,-95916,-95758,-95601,\n    -95444,-95287,-95131,-94975,-94819,-94664,-94509,-94354,\n    -94200,-94046,-93892,-93739,-93586,-93434,-93281,-93129,\n    -92978,-92826,-92675,-92525,-92375,-92225,-92075,-91926,\n    -91777,-91628,-91480,-91332,-91184,-91036,-90889,-90742,\n    -90596,-90450,-90304,-90158,-90013,-89868,-89724,-89579,\n    -89435,-89292,-89148,-89005,-88862,-88720,-88577,-88435,\n    -88294,-88152,-88011,-87871,-87730,-87590,-87450,-87310,\n    -87171,-87032,-86893,-86755,-86616,-86479,-86341,-86204,\n    -86066,-85930,-85793,-85657,-85521,-85385,-85250,-85114,\n    -84980,-84845,-84710,-84576,-84443,-84309,-84176,-84043,\n    -83910,-83777,-83645,-83513,-83381,-83250,-83118,-82987,\n    -82857,-82726,-82596,-82466,-82336,-82207,-82078,-81949,\n    -81820,-81691,-81563,-81435,-81307,-81180,-81053,-80925,\n    -80799,-80672,-80546,-80420,-80294,-80168,-80043,-79918,\n    -79793,-79668,-79544,-79420,-79296,-79172,-79048,-78925,\n    -78802,-78679,-78557,-78434,-78312,-78190,-78068,-77947,\n    -77826,-77705,-77584,-77463,-77343,-77223,-77103,-76983,\n    -76864,-76744,-76625,-76506,-76388,-76269,-76151,-76033,\n    -75915,-75797,-75680,-75563,-75446,-75329,-75213,-75096,\n    -74980,-74864,-74748,-74633,-74517,-74402,-74287,-74172,\n    -74058,-73944,-73829,-73715,-73602,-73488,-73375,-73262,\n    -73149,-73036,-72923,-72811,-72699,-72587,-72475,-72363,\n    -72252,-72140,-72029,-71918,-71808,-71697,-71587,-71477,\n    -71367,-71257,-71147,-71038,-70929,-70820,-70711,-70602,\n    -70494,-70385,-70277,-70169,-70061,-69954,-69846,-69739,\n    -69632,-69525,-69418,-69312,-69205,-69099,-68993,-68887,\n    -68781,-68676,-68570,-68465,-68360,-68255,-68151,-68046,\n    -67942,-67837,-67733,-67629,-67526,-67422,-67319,-67216,\n    -67113,-67010,-66907,-66804,-66702,-66600,-66498,-66396,\n    -66294,-66192,-66091,-65989,-65888,-65787,-65686,-65586,\n    -65485,-65385,-65285,-65185,-65085,-64985,-64885,-64786,\n    -64687,-64587,-64488,-64389,-64291,-64192,-64094,-63996,\n    -63897,-63799,-63702,-63604,-63506,-63409,-63312,-63215,\n    -63118,-63021,-62924,-62828,-62731,-62635,-62539,-62443,\n    -62347,-62251,-62156,-62060,-61965,-61870,-61775,-61680,\n    -61585,-61491,-61396,-61302,-61208,-61114,-61020,-60926,\n    -60833,-60739,-60646,-60552,-60459,-60366,-60273,-60181,\n    -60088,-59996,-59903,-59811,-59719,-59627,-59535,-59444,\n    -59352,-59261,-59169,-59078,-58987,-58896,-58805,-58715,\n    -58624,-58534,-58443,-58353,-58263,-58173,-58083,-57994,\n    -57904,-57815,-57725,-57636,-57547,-57458,-57369,-57281,\n    -57192,-57104,-57015,-56927,-56839,-56751,-56663,-56575,\n    -56487,-56400,-56312,-56225,-56138,-56051,-55964,-55877,\n    -55790,-55704,-55617,-55531,-55444,-55358,-55272,-55186,\n    -55100,-55015,-54929,-54843,-54758,-54673,-54587,-54502,\n    -54417,-54333,-54248,-54163,-54079,-53994,-53910,-53826,\n    -53741,-53657,-53574,-53490,-53406,-53322,-53239,-53156,\n    -53072,-52989,-52906,-52823,-52740,-52657,-52575,-52492,\n    -52410,-52327,-52245,-52163,-52081,-51999,-51917,-51835,\n    -51754,-51672,-51591,-51509,-51428,-51347,-51266,-51185,\n    -51104,-51023,-50942,-50862,-50781,-50701,-50621,-50540,\n    -50460,-50380,-50300,-50221,-50141,-50061,-49982,-49902,\n    -49823,-49744,-49664,-49585,-49506,-49427,-49349,-49270,\n    -49191,-49113,-49034,-48956,-48878,-48799,-48721,-48643,\n    -48565,-48488,-48410,-48332,-48255,-48177,-48100,-48022,\n    -47945,-47868,-47791,-47714,-47637,-47560,-47484,-47407,\n    -47331,-47254,-47178,-47102,-47025,-46949,-46873,-46797,\n    -46721,-46646,-46570,-46494,-46419,-46343,-46268,-46193,\n    -46118,-46042,-45967,-45892,-45818,-45743,-45668,-45593,\n    -45519,-45444,-45370,-45296,-45221,-45147,-45073,-44999,\n    -44925,-44851,-44778,-44704,-44630,-44557,-44483,-44410,\n    -44337,-44263,-44190,-44117,-44044,-43971,-43898,-43826,\n    -43753,-43680,-43608,-43535,-43463,-43390,-43318,-43246,\n    -43174,-43102,-43030,-42958,-42886,-42814,-42743,-42671,\n    -42600,-42528,-42457,-42385,-42314,-42243,-42172,-42101,\n    -42030,-41959,-41888,-41817,-41747,-41676,-41605,-41535,\n    -41465,-41394,-41324,-41254,-41184,-41113,-41043,-40973,\n    -40904,-40834,-40764,-40694,-40625,-40555,-40486,-40416,\n    -40347,-40278,-40208,-40139,-40070,-40001,-39932,-39863,\n    -39794,-39726,-39657,-39588,-39520,-39451,-39383,-39314,\n    -39246,-39178,-39110,-39042,-38973,-38905,-38837,-38770,\n    -38702,-38634,-38566,-38499,-38431,-38364,-38296,-38229,\n    -38161,-38094,-38027,-37960,-37893,-37826,-37759,-37692,\n    -37625,-37558,-37491,-37425,-37358,-37291,-37225,-37158,\n    -37092,-37026,-36959,-36893,-36827,-36761,-36695,-36629,\n    -36563,-36497,-36431,-36365,-36300,-36234,-36168,-36103,\n    -36037,-35972,-35907,-35841,-35776,-35711,-35646,-35580,\n    -35515,-35450,-35385,-35321,-35256,-35191,-35126,-35062,\n    -34997,-34932,-34868,-34803,-34739,-34675,-34610,-34546,\n    -34482,-34418,-34354,-34289,-34225,-34162,-34098,-34034,\n    -33970,-33906,-33843,-33779,-33715,-33652,-33588,-33525,\n    -33461,-33398,-33335,-33272,-33208,-33145,-33082,-33019,\n    -32956,-32893,-32830,-32767,-32705,-32642,-32579,-32516,\n    -32454,-32391,-32329,-32266,-32204,-32141,-32079,-32017,\n    -31955,-31892,-31830,-31768,-31706,-31644,-31582,-31520,\n    -31458,-31396,-31335,-31273,-31211,-31150,-31088,-31026,\n    -30965,-30904,-30842,-30781,-30719,-30658,-30597,-30536,\n    -30474,-30413,-30352,-30291,-30230,-30169,-30108,-30048,\n    -29987,-29926,-29865,-29805,-29744,-29683,-29623,-29562,\n    -29502,-29441,-29381,-29321,-29260,-29200,-29140,-29080,\n    -29020,-28959,-28899,-28839,-28779,-28719,-28660,-28600,\n    -28540,-28480,-28420,-28361,-28301,-28241,-28182,-28122,\n    -28063,-28003,-27944,-27884,-27825,-27766,-27707,-27647,\n    -27588,-27529,-27470,-27411,-27352,-27293,-27234,-27175,\n    -27116,-27057,-26998,-26940,-26881,-26822,-26763,-26705,\n    -26646,-26588,-26529,-26471,-26412,-26354,-26295,-26237,\n    -26179,-26120,-26062,-26004,-25946,-25888,-25830,-25772,\n    -25714,-25656,-25598,-25540,-25482,-25424,-25366,-25308,\n    -25251,-25193,-25135,-25078,-25020,-24962,-24905,-24847,\n    -24790,-24732,-24675,-24618,-24560,-24503,-24446,-24389,\n    -24331,-24274,-24217,-24160,-24103,-24046,-23989,-23932,\n    -23875,-23818,-23761,-23704,-23647,-23591,-23534,-23477,\n    -23420,-23364,-23307,-23250,-23194,-23137,-23081,-23024,\n    -22968,-22911,-22855,-22799,-22742,-22686,-22630,-22573,\n    -22517,-22461,-22405,-22349,-22293,-22237,-22181,-22125,\n    -22069,-22013,-21957,-21901,-21845,-21789,-21733,-21678,\n    -21622,-21566,-21510,-21455,-21399,-21343,-21288,-21232,\n    -21177,-21121,-21066,-21010,-20955,-20900,-20844,-20789,\n    -20734,-20678,-20623,-20568,-20513,-20457,-20402,-20347,\n    -20292,-20237,-20182,-20127,-20072,-20017,-19962,-19907,\n    -19852,-19797,-19742,-19688,-19633,-19578,-19523,-19469,\n    -19414,-19359,-19305,-19250,-19195,-19141,-19086,-19032,\n    -18977,-18923,-18868,-18814,-18760,-18705,-18651,-18597,\n    -18542,-18488,-18434,-18380,-18325,-18271,-18217,-18163,\n    -18109,-18055,-18001,-17946,-17892,-17838,-17784,-17731,\n    -17677,-17623,-17569,-17515,-17461,-17407,-17353,-17300,\n    -17246,-17192,-17138,-17085,-17031,-16977,-16924,-16870,\n    -16817,-16763,-16710,-16656,-16603,-16549,-16496,-16442,\n    -16389,-16335,-16282,-16229,-16175,-16122,-16069,-16015,\n    -15962,-15909,-15856,-15802,-15749,-15696,-15643,-15590,\n    -15537,-15484,-15431,-15378,-15325,-15272,-15219,-15166,\n    -15113,-15060,-15007,-14954,-14901,-14848,-14795,-14743,\n    -14690,-14637,-14584,-14531,-14479,-14426,-14373,-14321,\n    -14268,-14215,-14163,-14110,-14057,-14005,-13952,-13900,\n    -13847,-13795,-13742,-13690,-13637,-13585,-13533,-13480,\n    -13428,-13375,-13323,-13271,-13218,-13166,-13114,-13062,\n    -13009,-12957,-12905,-12853,-12800,-12748,-12696,-12644,\n    -12592,-12540,-12488,-12436,-12383,-12331,-12279,-12227,\n    -12175,-12123,-12071,-12019,-11967,-11916,-11864,-11812,\n    -11760,-11708,-11656,-11604,-11552,-11501,-11449,-11397,\n    -11345,-11293,-11242,-11190,-11138,-11086,-11035,-10983,\n    -10931,-10880,-10828,-10777,-10725,-10673,-10622,-10570,\n    -10519,-10467,-10415,-10364,-10312,-10261,-10209,-10158,\n    -10106,-10055,-10004,-9952,-9901,-9849,-9798,-9747,\n    -9695,-9644,-9592,-9541,-9490,-9438,-9387,-9336,\n    -9285,-9233,-9182,-9131,-9080,-9028,-8977,-8926,\n    -8875,-8824,-8772,-8721,-8670,-8619,-8568,-8517,\n    -8466,-8414,-8363,-8312,-8261,-8210,-8159,-8108,\n    -8057,-8006,-7955,-7904,-7853,-7802,-7751,-7700,\n    -7649,-7598,-7547,-7496,-7445,-7395,-7344,-7293,\n    -7242,-7191,-7140,-7089,-7038,-6988,-6937,-6886,\n    -6835,-6784,-6733,-6683,-6632,-6581,-6530,-6480,\n    -6429,-6378,-6327,-6277,-6226,-6175,-6124,-6074,\n    -6023,-5972,-5922,-5871,-5820,-5770,-5719,-5668,\n    -5618,-5567,-5517,-5466,-5415,-5365,-5314,-5264,\n    -5213,-5162,-5112,-5061,-5011,-4960,-4910,-4859,\n    -4808,-4758,-4707,-4657,-4606,-4556,-4505,-4455,\n    -4404,-4354,-4303,-4253,-4202,-4152,-4101,-4051,\n    -4001,-3950,-3900,-3849,-3799,-3748,-3698,-3648,\n    -3597,-3547,-3496,-3446,-3395,-3345,-3295,-3244,\n    -3194,-3144,-3093,-3043,-2992,-2942,-2892,-2841,\n    -2791,-2741,-2690,-2640,-2590,-2539,-2489,-2439,\n    -2388,-2338,-2288,-2237,-2187,-2137,-2086,-2036,\n    -1986,-1935,-1885,-1835,-1784,-1734,-1684,-1633,\n    -1583,-1533,-1483,-1432,-1382,-1332,-1281,-1231,\n    -1181,-1131,-1080,-1030,-980,-929,-879,-829,\n    -779,-728,-678,-628,-578,-527,-477,-427,\n    -376,-326,-276,-226,-175,-125,-75,-25,\n    25,75,125,175,226,276,326,376,\n    427,477,527,578,628,678,728,779,\n    829,879,929,980,1030,1080,1131,1181,\n    1231,1281,1332,1382,1432,1483,1533,1583,\n    1633,1684,1734,1784,1835,1885,1935,1986,\n    2036,2086,2137,2187,2237,2288,2338,2388,\n    2439,2489,2539,2590,2640,2690,2741,2791,\n    2841,2892,2942,2992,3043,3093,3144,3194,\n    3244,3295,3345,3395,3446,3496,3547,3597,\n    3648,3698,3748,3799,3849,3900,3950,4001,\n    4051,4101,4152,4202,4253,4303,4354,4404,\n    4455,4505,4556,4606,4657,4707,4758,4808,\n    4859,4910,4960,5011,5061,5112,5162,5213,\n    5264,5314,5365,5415,5466,5517,5567,5618,\n    5668,5719,5770,5820,5871,5922,5972,6023,\n    6074,6124,6175,6226,6277,6327,6378,6429,\n    6480,6530,6581,6632,6683,6733,6784,6835,\n    6886,6937,6988,7038,7089,7140,7191,7242,\n    7293,7344,7395,7445,7496,7547,7598,7649,\n    7700,7751,7802,7853,7904,7955,8006,8057,\n    8108,8159,8210,8261,8312,8363,8414,8466,\n    8517,8568,8619,8670,8721,8772,8824,8875,\n    8926,8977,9028,9080,9131,9182,9233,9285,\n    9336,9387,9438,9490,9541,9592,9644,9695,\n    9747,9798,9849,9901,9952,10004,10055,10106,\n    10158,10209,10261,10312,10364,10415,10467,10519,\n    10570,10622,10673,10725,10777,10828,10880,10931,\n    10983,11035,11086,11138,11190,11242,11293,11345,\n    11397,11449,11501,11552,11604,11656,11708,11760,\n    11812,11864,11916,11967,12019,12071,12123,12175,\n    12227,12279,12331,12383,12436,12488,12540,12592,\n    12644,12696,12748,12800,12853,12905,12957,13009,\n    13062,13114,13166,13218,13271,13323,13375,13428,\n    13480,13533,13585,13637,13690,13742,13795,13847,\n    13900,13952,14005,14057,14110,14163,14215,14268,\n    14321,14373,14426,14479,14531,14584,14637,14690,\n    14743,14795,14848,14901,14954,15007,15060,15113,\n    15166,15219,15272,15325,15378,15431,15484,15537,\n    15590,15643,15696,15749,15802,15856,15909,15962,\n    16015,16069,16122,16175,16229,16282,16335,16389,\n    16442,16496,16549,16603,16656,16710,16763,16817,\n    16870,16924,16977,17031,17085,17138,17192,17246,\n    17300,17353,17407,17461,17515,17569,17623,17677,\n    17731,17784,17838,17892,17946,18001,18055,18109,\n    18163,18217,18271,18325,18380,18434,18488,18542,\n    18597,18651,18705,18760,18814,18868,18923,18977,\n    19032,19086,19141,19195,19250,19305,19359,19414,\n    19469,19523,19578,19633,19688,19742,19797,19852,\n    19907,19962,20017,20072,20127,20182,20237,20292,\n    20347,20402,20457,20513,20568,20623,20678,20734,\n    20789,20844,20900,20955,21010,21066,21121,21177,\n    21232,21288,21343,21399,21455,21510,21566,21622,\n    21678,21733,21789,21845,21901,21957,22013,22069,\n    22125,22181,22237,22293,22349,22405,22461,22517,\n    22573,22630,22686,22742,22799,22855,22911,22968,\n    23024,23081,23137,23194,23250,23307,23364,23420,\n    23477,23534,23591,23647,23704,23761,23818,23875,\n    23932,23989,24046,24103,24160,24217,24274,24331,\n    24389,24446,24503,24560,24618,24675,24732,24790,\n    24847,24905,24962,25020,25078,25135,25193,25251,\n    25308,25366,25424,25482,25540,25598,25656,25714,\n    25772,25830,25888,25946,26004,26062,26120,26179,\n    26237,26295,26354,26412,26471,26529,26588,26646,\n    26705,26763,26822,26881,26940,26998,27057,27116,\n    27175,27234,27293,27352,27411,27470,27529,27588,\n    27647,27707,27766,27825,27884,27944,28003,28063,\n    28122,28182,28241,28301,28361,28420,28480,28540,\n    28600,28660,28719,28779,28839,28899,28959,29020,\n    29080,29140,29200,29260,29321,29381,29441,29502,\n    29562,29623,29683,29744,29805,29865,29926,29987,\n    30048,30108,30169,30230,30291,30352,30413,30474,\n    30536,30597,30658,30719,30781,30842,30904,30965,\n    31026,31088,31150,31211,31273,31335,31396,31458,\n    31520,31582,31644,31706,31768,31830,31892,31955,\n    32017,32079,32141,32204,32266,32329,32391,32454,\n    32516,32579,32642,32705,32767,32830,32893,32956,\n    33019,33082,33145,33208,33272,33335,33398,33461,\n    33525,33588,33652,33715,33779,33843,33906,33970,\n    34034,34098,34162,34225,34289,34354,34418,34482,\n    34546,34610,34675,34739,34803,34868,34932,34997,\n    35062,35126,35191,35256,35321,35385,35450,35515,\n    35580,35646,35711,35776,35841,35907,35972,36037,\n    36103,36168,36234,36300,36365,36431,36497,36563,\n    36629,36695,36761,36827,36893,36959,37026,37092,\n    37158,37225,37291,37358,37425,37491,37558,37625,\n    37692,37759,37826,37893,37960,38027,38094,38161,\n    38229,38296,38364,38431,38499,38566,38634,38702,\n    38770,38837,38905,38973,39042,39110,39178,39246,\n    39314,39383,39451,39520,39588,39657,39726,39794,\n    39863,39932,40001,40070,40139,40208,40278,40347,\n    40416,40486,40555,40625,40694,40764,40834,40904,\n    40973,41043,41113,41184,41254,41324,41394,41465,\n    41535,41605,41676,41747,41817,41888,41959,42030,\n    42101,42172,42243,42314,42385,42457,42528,42600,\n    42671,42743,42814,42886,42958,43030,43102,43174,\n    43246,43318,43390,43463,43535,43608,43680,43753,\n    43826,43898,43971,44044,44117,44190,44263,44337,\n    44410,44483,44557,44630,44704,44778,44851,44925,\n    44999,45073,45147,45221,45296,45370,45444,45519,\n    45593,45668,45743,45818,45892,45967,46042,46118,\n    46193,46268,46343,46419,46494,46570,46646,46721,\n    46797,46873,46949,47025,47102,47178,47254,47331,\n    47407,47484,47560,47637,47714,47791,47868,47945,\n    48022,48100,48177,48255,48332,48410,48488,48565,\n    48643,48721,48799,48878,48956,49034,49113,49191,\n    49270,49349,49427,49506,49585,49664,49744,49823,\n    49902,49982,50061,50141,50221,50300,50380,50460,\n    50540,50621,50701,50781,50862,50942,51023,51104,\n    51185,51266,51347,51428,51509,51591,51672,51754,\n    51835,51917,51999,52081,52163,52245,52327,52410,\n    52492,52575,52657,52740,52823,52906,52989,53072,\n    53156,53239,53322,53406,53490,53574,53657,53741,\n    53826,53910,53994,54079,54163,54248,54333,54417,\n    54502,54587,54673,54758,54843,54929,55015,55100,\n    55186,55272,55358,55444,55531,55617,55704,55790,\n    55877,55964,56051,56138,56225,56312,56400,56487,\n    56575,56663,56751,56839,56927,57015,57104,57192,\n    57281,57369,57458,57547,57636,57725,57815,57904,\n    57994,58083,58173,58263,58353,58443,58534,58624,\n    58715,58805,58896,58987,59078,59169,59261,59352,\n    59444,59535,59627,59719,59811,59903,59996,60088,\n    60181,60273,60366,60459,60552,60646,60739,60833,\n    60926,61020,61114,61208,61302,61396,61491,61585,\n    61680,61775,61870,61965,62060,62156,62251,62347,\n    62443,62539,62635,62731,62828,62924,63021,63118,\n    63215,63312,63409,63506,63604,63702,63799,63897,\n    63996,64094,64192,64291,64389,64488,64587,64687,\n    64786,64885,64985,65085,65185,65285,65385,65485,\n    65586,65686,65787,65888,65989,66091,66192,66294,\n    66396,66498,66600,66702,66804,66907,67010,67113,\n    67216,67319,67422,67526,67629,67733,67837,67942,\n    68046,68151,68255,68360,68465,68570,68676,68781,\n    68887,68993,69099,69205,69312,69418,69525,69632,\n    69739,69846,69954,70061,70169,70277,70385,70494,\n    70602,70711,70820,70929,71038,71147,71257,71367,\n    71477,71587,71697,71808,71918,72029,72140,72252,\n    72363,72475,72587,72699,72811,72923,73036,73149,\n    73262,73375,73488,73602,73715,73829,73944,74058,\n    74172,74287,74402,74517,74633,74748,74864,74980,\n    75096,75213,75329,75446,75563,75680,75797,75915,\n    76033,76151,76269,76388,76506,76625,76744,76864,\n    76983,77103,77223,77343,77463,77584,77705,77826,\n    77947,78068,78190,78312,78434,78557,78679,78802,\n    78925,79048,79172,79296,79420,79544,79668,79793,\n    79918,80043,80168,80294,80420,80546,80672,80799,\n    80925,81053,81180,81307,81435,81563,81691,81820,\n    81949,82078,82207,82336,82466,82596,82726,82857,\n    82987,83118,83250,83381,83513,83645,83777,83910,\n    84043,84176,84309,84443,84576,84710,84845,84980,\n    85114,85250,85385,85521,85657,85793,85930,86066,\n    86204,86341,86479,86616,86755,86893,87032,87171,\n    87310,87450,87590,87730,87871,88011,88152,88294,\n    88435,88577,88720,88862,89005,89148,89292,89435,\n    89579,89724,89868,90013,90158,90304,90450,90596,\n    90742,90889,91036,91184,91332,91480,91628,91777,\n    91926,92075,92225,92375,92525,92675,92826,92978,\n    93129,93281,93434,93586,93739,93892,94046,94200,\n    94354,94509,94664,94819,94975,95131,95287,95444,\n    95601,95758,95916,96074,96233,96391,96551,96710,\n    96870,97030,97191,97352,97513,97675,97837,98000,\n    98163,98326,98489,98653,98818,98982,99148,99313,\n    99479,99645,99812,99979,100146,100314,100482,100651,\n    100820,100990,101159,101330,101500,101671,101843,102015,\n    102187,102360,102533,102706,102880,103054,103229,103404,\n    103580,103756,103933,104109,104287,104465,104643,104821,\n    105000,105180,105360,105540,105721,105902,106084,106266,\n    106449,106632,106816,107000,107184,107369,107555,107741,\n    107927,108114,108301,108489,108677,108866,109055,109245,\n    109435,109626,109817,110008,110200,110393,110586,110780,\n    110974,111169,111364,111560,111756,111952,112150,112347,\n    112546,112744,112944,113143,113344,113545,113746,113948,\n    114151,114354,114557,114761,114966,115171,115377,115583,\n    115790,115998,116206,116414,116623,116833,117044,117254,\n    117466,117678,117891,118104,118318,118532,118747,118963,\n    119179,119396,119613,119831,120050,120269,120489,120709,\n    120930,121152,121374,121597,121821,122045,122270,122496,\n    122722,122949,123176,123404,123633,123863,124093,124324,\n    124555,124787,125020,125254,125488,125723,125959,126195,\n    126432,126669,126908,127147,127387,127627,127869,128111,\n    128353,128597,128841,129086,129332,129578,129825,130073,\n    130322,130571,130821,131072,131324,131576,131830,132084,\n    132339,132594,132851,133108,133366,133625,133884,134145,\n    134406,134668,134931,135195,135459,135725,135991,136258,\n    136526,136795,137065,137335,137607,137879,138152,138426,\n    138701,138977,139254,139532,139810,140090,140370,140651,\n    140934,141217,141501,141786,142072,142359,142647,142936,\n    143226,143517,143808,144101,144395,144690,144986,145282,\n    145580,145879,146179,146480,146782,147084,147388,147693,\n    148000,148307,148615,148924,149235,149546,149859,150172,\n    150487,150803,151120,151438,151757,152077,152399,152722,\n    153045,153370,153697,154024,154352,154682,155013,155345,\n    155678,156013,156349,156686,157024,157363,157704,158046,\n    158389,158734,159079,159427,159775,160125,160476,160828,\n    161182,161537,161893,162251,162610,162970,163332,163695,\n    164060,164426,164793,165162,165532,165904,166277,166651,\n    167027,167405,167784,168164,168546,168930,169315,169701,\n    170089,170479,170870,171263,171657,172053,172451,172850,\n    173251,173653,174057,174463,174870,175279,175690,176102,\n    176516,176932,177349,177769,178190,178612,179037,179463,\n    179891,180321,180753,181186,181622,182059,182498,182939,\n    183382,183827,184274,184722,185173,185625,186080,186536,\n    186995,187455,187918,188382,188849,189318,189789,190261,\n    190736,191213,191693,192174,192658,193143,193631,194122,\n    194614,195109,195606,196105,196606,197110,197616,198125,\n    198636,199149,199664,200182,200703,201226,201751,202279,\n    202809,203342,203878,204416,204956,205500,206045,206594,\n    207145,207699,208255,208815,209376,209941,210509,211079,\n    211652,212228,212807,213389,213973,214561,215151,215745,\n    216341,216941,217544,218149,218758,219370,219985,220603,\n    221225,221849,222477,223108,223743,224381,225022,225666,\n    226314,226966,227621,228279,228941,229606,230275,230948,\n    231624,232304,232988,233676,234367,235062,235761,236463,\n    237170,237881,238595,239314,240036,240763,241493,242228,\n    242967,243711,244458,245210,245966,246727,247492,248261,\n    249035,249813,250596,251384,252176,252973,253774,254581,\n    255392,256208,257029,257855,258686,259522,260363,261209,\n    262060,262917,263779,264646,265519,266397,267280,268169,\n    269064,269965,270871,271782,272700,273624,274553,275489,\n    276430,277378,278332,279292,280258,281231,282210,283195,\n    284188,285186,286192,287204,288223,289249,290282,291322,\n    292369,293423,294485,295554,296630,297714,298805,299904,\n    301011,302126,303248,304379,305517,306664,307819,308983,\n    310154,311335,312524,313721,314928,316143,317368,318601,\n    319844,321097,322358,323629,324910,326201,327502,328812,\n    330133,331464,332805,334157,335519,336892,338276,339671,\n    341078,342495,343924,345364,346816,348280,349756,351244,\n    352744,354257,355783,357321,358872,360436,362013,363604,\n    365208,366826,368459,370105,371765,373440,375130,376835,\n    378555,380290,382040,383807,385589,387387,389202,391034,\n    392882,394747,396630,398530,400448,402384,404338,406311,\n    408303,410314,412344,414395,416465,418555,420666,422798,\n    424951,427125,429321,431540,433781,436045,438332,440643,\n    442978,445337,447720,450129,452564,455024,457511,460024,\n    462565,465133,467730,470355,473009,475692,478406,481150,\n    483925,486732,489571,492443,495348,498287,501261,504269,\n    507313,510394,513512,516667,519861,523094,526366,529680,\n    533034,536431,539870,543354,546881,550455,554074,557741,\n    561456,565221,569035,572901,576818,580789,584815,588896,\n    593033,597229,601483,605798,610174,614613,619117,623686,\n    628323,633028,637803,642651,647572,652568,657640,662792,\n    668024,673338,678737,684223,689797,695462,701219,707072,\n    713023,719074,725227,731486,737853,744331,750922,757631,\n    764460,771411,778490,785699,793041,800521,808143,815910,\n    823827,831898,840127,848520,857081,865817,874730,883829,\n    893117,902602,912289,922186,932298,942633,953199,964003,\n    975054,986361,997931,1009774,1021901,1034322,1047046,1060087,\n    1073455,1087164,1101225,1115654,1130465,1145673,1161294,1177345,\n    1193846,1210813,1228269,1246234,1264730,1283783,1303416,1323658,\n    1344537,1366084,1388330,1411312,1435065,1459630,1485049,1511367,\n    1538632,1566898,1596220,1626658,1658278,1691149,1725348,1760956,\n    1798063,1836758,1877161,1919378,1963536,2009771,2058233,2109087,\n    2162516,2218719,2277919,2340362,2406322,2476104,2550052,2628549,\n    2712030,2800983,2895966,2997613,3106651,3223918,3350381,3487165,\n    3635590,3797206,3973855,4167737,4381502,4618375,4882318,5178251,\n    5512368,5892567,6329090,6835455,7429880,8137527,8994149,10052327,\n    11392683,13145455,15535599,18988036,24413316,34178904,56965752,170910304\n};\n\n\nconst fixed_t finesine[10240] =\n{\n    25,75,125,175,226,276,326,376,\n    427,477,527,578,628,678,728,779,\n    829,879,929,980,1030,1080,1130,1181,\n    1231,1281,1331,1382,1432,1482,1532,1583,\n    1633,1683,1733,1784,1834,1884,1934,1985,\n    2035,2085,2135,2186,2236,2286,2336,2387,\n    2437,2487,2537,2587,2638,2688,2738,2788,\n    2839,2889,2939,2989,3039,3090,3140,3190,\n    3240,3291,3341,3391,3441,3491,3541,3592,\n    3642,3692,3742,3792,3843,3893,3943,3993,\n    4043,4093,4144,4194,4244,4294,4344,4394,\n    4445,4495,4545,4595,4645,4695,4745,4796,\n    4846,4896,4946,4996,5046,5096,5146,5197,\n    5247,5297,5347,5397,5447,5497,5547,5597,\n    5647,5697,5748,5798,5848,5898,5948,5998,\n    6048,6098,6148,6198,6248,6298,6348,6398,\n    6448,6498,6548,6598,6648,6698,6748,6798,\n    6848,6898,6948,6998,7048,7098,7148,7198,\n    7248,7298,7348,7398,7448,7498,7548,7598,\n    7648,7697,7747,7797,7847,7897,7947,7997,\n    8047,8097,8147,8196,8246,8296,8346,8396,\n    8446,8496,8545,8595,8645,8695,8745,8794,\n    8844,8894,8944,8994,9043,9093,9143,9193,\n    9243,9292,9342,9392,9442,9491,9541,9591,\n    9640,9690,9740,9790,9839,9889,9939,9988,\n    10038,10088,10137,10187,10237,10286,10336,10386,\n    10435,10485,10534,10584,10634,10683,10733,10782,\n    10832,10882,10931,10981,11030,11080,11129,11179,\n    11228,11278,11327,11377,11426,11476,11525,11575,\n    11624,11674,11723,11773,11822,11872,11921,11970,\n    12020,12069,12119,12168,12218,12267,12316,12366,\n    12415,12464,12514,12563,12612,12662,12711,12760,\n    12810,12859,12908,12957,13007,13056,13105,13154,\n    13204,13253,13302,13351,13401,13450,13499,13548,\n    13597,13647,13696,13745,13794,13843,13892,13941,\n    13990,14040,14089,14138,14187,14236,14285,14334,\n    14383,14432,14481,14530,14579,14628,14677,14726,\n    14775,14824,14873,14922,14971,15020,15069,15118,\n    15167,15215,15264,15313,15362,15411,15460,15509,\n    15557,15606,15655,15704,15753,15802,15850,15899,\n    15948,15997,16045,16094,16143,16191,16240,16289,\n    16338,16386,16435,16484,16532,16581,16629,16678,\n    16727,16775,16824,16872,16921,16970,17018,17067,\n    17115,17164,17212,17261,17309,17358,17406,17455,\n    17503,17551,17600,17648,17697,17745,17793,17842,\n    17890,17939,17987,18035,18084,18132,18180,18228,\n    18277,18325,18373,18421,18470,18518,18566,18614,\n    18663,18711,18759,18807,18855,18903,18951,19000,\n    19048,19096,19144,19192,19240,19288,19336,19384,\n    19432,19480,19528,19576,19624,19672,19720,19768,\n    19816,19864,19912,19959,20007,20055,20103,20151,\n    20199,20246,20294,20342,20390,20438,20485,20533,\n    20581,20629,20676,20724,20772,20819,20867,20915,\n    20962,21010,21057,21105,21153,21200,21248,21295,\n    21343,21390,21438,21485,21533,21580,21628,21675,\n    21723,21770,21817,21865,21912,21960,22007,22054,\n    22102,22149,22196,22243,22291,22338,22385,22433,\n    22480,22527,22574,22621,22668,22716,22763,22810,\n    22857,22904,22951,22998,23045,23092,23139,23186,\n    23233,23280,23327,23374,23421,23468,23515,23562,\n    23609,23656,23703,23750,23796,23843,23890,23937,\n    23984,24030,24077,24124,24171,24217,24264,24311,\n    24357,24404,24451,24497,24544,24591,24637,24684,\n    24730,24777,24823,24870,24916,24963,25009,25056,\n    25102,25149,25195,25241,25288,25334,25381,25427,\n    25473,25520,25566,25612,25658,25705,25751,25797,\n    25843,25889,25936,25982,26028,26074,26120,26166,\n    26212,26258,26304,26350,26396,26442,26488,26534,\n    26580,26626,26672,26718,26764,26810,26856,26902,\n    26947,26993,27039,27085,27131,27176,27222,27268,\n    27313,27359,27405,27450,27496,27542,27587,27633,\n    27678,27724,27770,27815,27861,27906,27952,27997,\n    28042,28088,28133,28179,28224,28269,28315,28360,\n    28405,28451,28496,28541,28586,28632,28677,28722,\n    28767,28812,28858,28903,28948,28993,29038,29083,\n    29128,29173,29218,29263,29308,29353,29398,29443,\n    29488,29533,29577,29622,29667,29712,29757,29801,\n    29846,29891,29936,29980,30025,30070,30114,30159,\n    30204,30248,30293,30337,30382,30426,30471,30515,\n    30560,30604,30649,30693,30738,30782,30826,30871,\n    30915,30959,31004,31048,31092,31136,31181,31225,\n    31269,31313,31357,31402,31446,31490,31534,31578,\n    31622,31666,31710,31754,31798,31842,31886,31930,\n    31974,32017,32061,32105,32149,32193,32236,32280,\n    32324,32368,32411,32455,32499,32542,32586,32630,\n    32673,32717,32760,32804,32847,32891,32934,32978,\n    33021,33065,33108,33151,33195,33238,33281,33325,\n    33368,33411,33454,33498,33541,33584,33627,33670,\n    33713,33756,33799,33843,33886,33929,33972,34015,\n    34057,34100,34143,34186,34229,34272,34315,34358,\n    34400,34443,34486,34529,34571,34614,34657,34699,\n    34742,34785,34827,34870,34912,34955,34997,35040,\n    35082,35125,35167,35210,35252,35294,35337,35379,\n    35421,35464,35506,35548,35590,35633,35675,35717,\n    35759,35801,35843,35885,35927,35969,36011,36053,\n    36095,36137,36179,36221,36263,36305,36347,36388,\n    36430,36472,36514,36555,36597,36639,36681,36722,\n    36764,36805,36847,36889,36930,36972,37013,37055,\n    37096,37137,37179,37220,37262,37303,37344,37386,\n    37427,37468,37509,37551,37592,37633,37674,37715,\n    37756,37797,37838,37879,37920,37961,38002,38043,\n    38084,38125,38166,38207,38248,38288,38329,38370,\n    38411,38451,38492,38533,38573,38614,38655,38695,\n    38736,38776,38817,38857,38898,38938,38979,39019,\n    39059,39100,39140,39180,39221,39261,39301,39341,\n    39382,39422,39462,39502,39542,39582,39622,39662,\n    39702,39742,39782,39822,39862,39902,39942,39982,\n    40021,40061,40101,40141,40180,40220,40260,40300,\n    40339,40379,40418,40458,40497,40537,40576,40616,\n    40655,40695,40734,40773,40813,40852,40891,40931,\n    40970,41009,41048,41087,41127,41166,41205,41244,\n    41283,41322,41361,41400,41439,41478,41517,41556,\n    41595,41633,41672,41711,41750,41788,41827,41866,\n    41904,41943,41982,42020,42059,42097,42136,42174,\n    42213,42251,42290,42328,42366,42405,42443,42481,\n    42520,42558,42596,42634,42672,42711,42749,42787,\n    42825,42863,42901,42939,42977,43015,43053,43091,\n    43128,43166,43204,43242,43280,43317,43355,43393,\n    43430,43468,43506,43543,43581,43618,43656,43693,\n    43731,43768,43806,43843,43880,43918,43955,43992,\n    44029,44067,44104,44141,44178,44215,44252,44289,\n    44326,44363,44400,44437,44474,44511,44548,44585,\n    44622,44659,44695,44732,44769,44806,44842,44879,\n    44915,44952,44989,45025,45062,45098,45135,45171,\n    45207,45244,45280,45316,45353,45389,45425,45462,\n    45498,45534,45570,45606,45642,45678,45714,45750,\n    45786,45822,45858,45894,45930,45966,46002,46037,\n    46073,46109,46145,46180,46216,46252,46287,46323,\n    46358,46394,46429,46465,46500,46536,46571,46606,\n    46642,46677,46712,46747,46783,46818,46853,46888,\n    46923,46958,46993,47028,47063,47098,47133,47168,\n    47203,47238,47273,47308,47342,47377,47412,47446,\n    47481,47516,47550,47585,47619,47654,47688,47723,\n    47757,47792,47826,47860,47895,47929,47963,47998,\n    48032,48066,48100,48134,48168,48202,48237,48271,\n    48305,48338,48372,48406,48440,48474,48508,48542,\n    48575,48609,48643,48676,48710,48744,48777,48811,\n    48844,48878,48911,48945,48978,49012,49045,49078,\n    49112,49145,49178,49211,49244,49278,49311,49344,\n    49377,49410,49443,49476,49509,49542,49575,49608,\n    49640,49673,49706,49739,49771,49804,49837,49869,\n    49902,49935,49967,50000,50032,50065,50097,50129,\n    50162,50194,50226,50259,50291,50323,50355,50387,\n    50420,50452,50484,50516,50548,50580,50612,50644,\n    50675,50707,50739,50771,50803,50834,50866,50898,\n    50929,50961,50993,51024,51056,51087,51119,51150,\n    51182,51213,51244,51276,51307,51338,51369,51401,\n    51432,51463,51494,51525,51556,51587,51618,51649,\n    51680,51711,51742,51773,51803,51834,51865,51896,\n    51926,51957,51988,52018,52049,52079,52110,52140,\n    52171,52201,52231,52262,52292,52322,52353,52383,\n    52413,52443,52473,52503,52534,52564,52594,52624,\n    52653,52683,52713,52743,52773,52803,52832,52862,\n    52892,52922,52951,52981,53010,53040,53069,53099,\n    53128,53158,53187,53216,53246,53275,53304,53334,\n    53363,53392,53421,53450,53479,53508,53537,53566,\n    53595,53624,53653,53682,53711,53739,53768,53797,\n    53826,53854,53883,53911,53940,53969,53997,54026,\n    54054,54082,54111,54139,54167,54196,54224,54252,\n    54280,54308,54337,54365,54393,54421,54449,54477,\n    54505,54533,54560,54588,54616,54644,54672,54699,\n    54727,54755,54782,54810,54837,54865,54892,54920,\n    54947,54974,55002,55029,55056,55084,55111,55138,\n    55165,55192,55219,55246,55274,55300,55327,55354,\n    55381,55408,55435,55462,55489,55515,55542,55569,\n    55595,55622,55648,55675,55701,55728,55754,55781,\n    55807,55833,55860,55886,55912,55938,55965,55991,\n    56017,56043,56069,56095,56121,56147,56173,56199,\n    56225,56250,56276,56302,56328,56353,56379,56404,\n    56430,56456,56481,56507,56532,56557,56583,56608,\n    56633,56659,56684,56709,56734,56760,56785,56810,\n    56835,56860,56885,56910,56935,56959,56984,57009,\n    57034,57059,57083,57108,57133,57157,57182,57206,\n    57231,57255,57280,57304,57329,57353,57377,57402,\n    57426,57450,57474,57498,57522,57546,57570,57594,\n    57618,57642,57666,57690,57714,57738,57762,57785,\n    57809,57833,57856,57880,57903,57927,57950,57974,\n    57997,58021,58044,58067,58091,58114,58137,58160,\n    58183,58207,58230,58253,58276,58299,58322,58345,\n    58367,58390,58413,58436,58459,58481,58504,58527,\n    58549,58572,58594,58617,58639,58662,58684,58706,\n    58729,58751,58773,58795,58818,58840,58862,58884,\n    58906,58928,58950,58972,58994,59016,59038,59059,\n    59081,59103,59125,59146,59168,59190,59211,59233,\n    59254,59276,59297,59318,59340,59361,59382,59404,\n    59425,59446,59467,59488,59509,59530,59551,59572,\n    59593,59614,59635,59656,59677,59697,59718,59739,\n    59759,59780,59801,59821,59842,59862,59883,59903,\n    59923,59944,59964,59984,60004,60025,60045,60065,\n    60085,60105,60125,60145,60165,60185,60205,60225,\n    60244,60264,60284,60304,60323,60343,60363,60382,\n    60402,60421,60441,60460,60479,60499,60518,60537,\n    60556,60576,60595,60614,60633,60652,60671,60690,\n    60709,60728,60747,60766,60785,60803,60822,60841,\n    60859,60878,60897,60915,60934,60952,60971,60989,\n    61007,61026,61044,61062,61081,61099,61117,61135,\n    61153,61171,61189,61207,61225,61243,61261,61279,\n    61297,61314,61332,61350,61367,61385,61403,61420,\n    61438,61455,61473,61490,61507,61525,61542,61559,\n    61577,61594,61611,61628,61645,61662,61679,61696,\n    61713,61730,61747,61764,61780,61797,61814,61831,\n    61847,61864,61880,61897,61913,61930,61946,61963,\n    61979,61995,62012,62028,62044,62060,62076,62092,\n    62108,62125,62141,62156,62172,62188,62204,62220,\n    62236,62251,62267,62283,62298,62314,62329,62345,\n    62360,62376,62391,62407,62422,62437,62453,62468,\n    62483,62498,62513,62528,62543,62558,62573,62588,\n    62603,62618,62633,62648,62662,62677,62692,62706,\n    62721,62735,62750,62764,62779,62793,62808,62822,\n    62836,62850,62865,62879,62893,62907,62921,62935,\n    62949,62963,62977,62991,63005,63019,63032,63046,\n    63060,63074,63087,63101,63114,63128,63141,63155,\n    63168,63182,63195,63208,63221,63235,63248,63261,\n    63274,63287,63300,63313,63326,63339,63352,63365,\n    63378,63390,63403,63416,63429,63441,63454,63466,\n    63479,63491,63504,63516,63528,63541,63553,63565,\n    63578,63590,63602,63614,63626,63638,63650,63662,\n    63674,63686,63698,63709,63721,63733,63745,63756,\n    63768,63779,63791,63803,63814,63825,63837,63848,\n    63859,63871,63882,63893,63904,63915,63927,63938,\n    63949,63960,63971,63981,63992,64003,64014,64025,\n    64035,64046,64057,64067,64078,64088,64099,64109,\n    64120,64130,64140,64151,64161,64171,64181,64192,\n    64202,64212,64222,64232,64242,64252,64261,64271,\n    64281,64291,64301,64310,64320,64330,64339,64349,\n    64358,64368,64377,64387,64396,64405,64414,64424,\n    64433,64442,64451,64460,64469,64478,64487,64496,\n    64505,64514,64523,64532,64540,64549,64558,64566,\n    64575,64584,64592,64601,64609,64617,64626,64634,\n    64642,64651,64659,64667,64675,64683,64691,64699,\n    64707,64715,64723,64731,64739,64747,64754,64762,\n    64770,64777,64785,64793,64800,64808,64815,64822,\n    64830,64837,64844,64852,64859,64866,64873,64880,\n    64887,64895,64902,64908,64915,64922,64929,64936,\n    64943,64949,64956,64963,64969,64976,64982,64989,\n    64995,65002,65008,65015,65021,65027,65033,65040,\n    65046,65052,65058,65064,65070,65076,65082,65088,\n    65094,65099,65105,65111,65117,65122,65128,65133,\n    65139,65144,65150,65155,65161,65166,65171,65177,\n    65182,65187,65192,65197,65202,65207,65212,65217,\n    65222,65227,65232,65237,65242,65246,65251,65256,\n    65260,65265,65270,65274,65279,65283,65287,65292,\n    65296,65300,65305,65309,65313,65317,65321,65325,\n    65329,65333,65337,65341,65345,65349,65352,65356,\n    65360,65363,65367,65371,65374,65378,65381,65385,\n    65388,65391,65395,65398,65401,65404,65408,65411,\n    65414,65417,65420,65423,65426,65429,65431,65434,\n    65437,65440,65442,65445,65448,65450,65453,65455,\n    65458,65460,65463,65465,65467,65470,65472,65474,\n    65476,65478,65480,65482,65484,65486,65488,65490,\n    65492,65494,65496,65497,65499,65501,65502,65504,\n    65505,65507,65508,65510,65511,65513,65514,65515,\n    65516,65518,65519,65520,65521,65522,65523,65524,\n    65525,65526,65527,65527,65528,65529,65530,65530,\n    65531,65531,65532,65532,65533,65533,65534,65534,\n    65534,65535,65535,65535,65535,65535,65535,65535,\n    65535,65535,65535,65535,65535,65535,65535,65534,\n    65534,65534,65533,65533,65532,65532,65531,65531,\n    65530,65530,65529,65528,65527,65527,65526,65525,\n    65524,65523,65522,65521,65520,65519,65518,65516,\n    65515,65514,65513,65511,65510,65508,65507,65505,\n    65504,65502,65501,65499,65497,65496,65494,65492,\n    65490,65488,65486,65484,65482,65480,65478,65476,\n    65474,65472,65470,65467,65465,65463,65460,65458,\n    65455,65453,65450,65448,65445,65442,65440,65437,\n    65434,65431,65429,65426,65423,65420,65417,65414,\n    65411,65408,65404,65401,65398,65395,65391,65388,\n    65385,65381,65378,65374,65371,65367,65363,65360,\n    65356,65352,65349,65345,65341,65337,65333,65329,\n    65325,65321,65317,65313,65309,65305,65300,65296,\n    65292,65287,65283,65279,65274,65270,65265,65260,\n    65256,65251,65246,65242,65237,65232,65227,65222,\n    65217,65212,65207,65202,65197,65192,65187,65182,\n    65177,65171,65166,65161,65155,65150,65144,65139,\n    65133,65128,65122,65117,65111,65105,65099,65094,\n    65088,65082,65076,65070,65064,65058,65052,65046,\n    65040,65033,65027,65021,65015,65008,65002,64995,\n    64989,64982,64976,64969,64963,64956,64949,64943,\n    64936,64929,64922,64915,64908,64902,64895,64887,\n    64880,64873,64866,64859,64852,64844,64837,64830,\n    64822,64815,64808,64800,64793,64785,64777,64770,\n    64762,64754,64747,64739,64731,64723,64715,64707,\n    64699,64691,64683,64675,64667,64659,64651,64642,\n    64634,64626,64617,64609,64600,64592,64584,64575,\n    64566,64558,64549,64540,64532,64523,64514,64505,\n    64496,64487,64478,64469,64460,64451,64442,64433,\n    64424,64414,64405,64396,64387,64377,64368,64358,\n    64349,64339,64330,64320,64310,64301,64291,64281,\n    64271,64261,64252,64242,64232,64222,64212,64202,\n    64192,64181,64171,64161,64151,64140,64130,64120,\n    64109,64099,64088,64078,64067,64057,64046,64035,\n    64025,64014,64003,63992,63981,63971,63960,63949,\n    63938,63927,63915,63904,63893,63882,63871,63859,\n    63848,63837,63825,63814,63803,63791,63779,63768,\n    63756,63745,63733,63721,63709,63698,63686,63674,\n    63662,63650,63638,63626,63614,63602,63590,63578,\n    63565,63553,63541,63528,63516,63504,63491,63479,\n    63466,63454,63441,63429,63416,63403,63390,63378,\n    63365,63352,63339,63326,63313,63300,63287,63274,\n    63261,63248,63235,63221,63208,63195,63182,63168,\n    63155,63141,63128,63114,63101,63087,63074,63060,\n    63046,63032,63019,63005,62991,62977,62963,62949,\n    62935,62921,62907,62893,62879,62865,62850,62836,\n    62822,62808,62793,62779,62764,62750,62735,62721,\n    62706,62692,62677,62662,62648,62633,62618,62603,\n    62588,62573,62558,62543,62528,62513,62498,62483,\n    62468,62453,62437,62422,62407,62391,62376,62360,\n    62345,62329,62314,62298,62283,62267,62251,62236,\n    62220,62204,62188,62172,62156,62141,62125,62108,\n    62092,62076,62060,62044,62028,62012,61995,61979,\n    61963,61946,61930,61913,61897,61880,61864,61847,\n    61831,61814,61797,61780,61764,61747,61730,61713,\n    61696,61679,61662,61645,61628,61611,61594,61577,\n    61559,61542,61525,61507,61490,61473,61455,61438,\n    61420,61403,61385,61367,61350,61332,61314,61297,\n    61279,61261,61243,61225,61207,61189,61171,61153,\n    61135,61117,61099,61081,61062,61044,61026,61007,\n    60989,60971,60952,60934,60915,60897,60878,60859,\n    60841,60822,60803,60785,60766,60747,60728,60709,\n    60690,60671,60652,60633,60614,60595,60576,60556,\n    60537,60518,60499,60479,60460,60441,60421,60402,\n    60382,60363,60343,60323,60304,60284,60264,60244,\n    60225,60205,60185,60165,60145,60125,60105,60085,\n    60065,60045,60025,60004,59984,59964,59944,59923,\n    59903,59883,59862,59842,59821,59801,59780,59759,\n    59739,59718,59697,59677,59656,59635,59614,59593,\n    59572,59551,59530,59509,59488,59467,59446,59425,\n    59404,59382,59361,59340,59318,59297,59276,59254,\n    59233,59211,59190,59168,59146,59125,59103,59081,\n    59059,59038,59016,58994,58972,58950,58928,58906,\n    58884,58862,58840,58818,58795,58773,58751,58729,\n    58706,58684,58662,58639,58617,58594,58572,58549,\n    58527,58504,58481,58459,58436,58413,58390,58367,\n    58345,58322,58299,58276,58253,58230,58207,58183,\n    58160,58137,58114,58091,58067,58044,58021,57997,\n    57974,57950,57927,57903,57880,57856,57833,57809,\n    57785,57762,57738,57714,57690,57666,57642,57618,\n    57594,57570,57546,57522,57498,57474,57450,57426,\n    57402,57377,57353,57329,57304,57280,57255,57231,\n    57206,57182,57157,57133,57108,57083,57059,57034,\n    57009,56984,56959,56935,56910,56885,56860,56835,\n    56810,56785,56760,56734,56709,56684,56659,56633,\n    56608,56583,56557,56532,56507,56481,56456,56430,\n    56404,56379,56353,56328,56302,56276,56250,56225,\n    56199,56173,56147,56121,56095,56069,56043,56017,\n    55991,55965,55938,55912,55886,55860,55833,55807,\n    55781,55754,55728,55701,55675,55648,55622,55595,\n    55569,55542,55515,55489,55462,55435,55408,55381,\n    55354,55327,55300,55274,55246,55219,55192,55165,\n    55138,55111,55084,55056,55029,55002,54974,54947,\n    54920,54892,54865,54837,54810,54782,54755,54727,\n    54699,54672,54644,54616,54588,54560,54533,54505,\n    54477,54449,54421,54393,54365,54337,54308,54280,\n    54252,54224,54196,54167,54139,54111,54082,54054,\n    54026,53997,53969,53940,53911,53883,53854,53826,\n    53797,53768,53739,53711,53682,53653,53624,53595,\n    53566,53537,53508,53479,53450,53421,53392,53363,\n    53334,53304,53275,53246,53216,53187,53158,53128,\n    53099,53069,53040,53010,52981,52951,52922,52892,\n    52862,52832,52803,52773,52743,52713,52683,52653,\n    52624,52594,52564,52534,52503,52473,52443,52413,\n    52383,52353,52322,52292,52262,52231,52201,52171,\n    52140,52110,52079,52049,52018,51988,51957,51926,\n    51896,51865,51834,51803,51773,51742,51711,51680,\n    51649,51618,51587,51556,51525,51494,51463,51432,\n    51401,51369,51338,51307,51276,51244,51213,51182,\n    51150,51119,51087,51056,51024,50993,50961,50929,\n    50898,50866,50834,50803,50771,50739,50707,50675,\n    50644,50612,50580,50548,50516,50484,50452,50420,\n    50387,50355,50323,50291,50259,50226,50194,50162,\n    50129,50097,50065,50032,50000,49967,49935,49902,\n    49869,49837,49804,49771,49739,49706,49673,49640,\n    49608,49575,49542,49509,49476,49443,49410,49377,\n    49344,49311,49278,49244,49211,49178,49145,49112,\n    49078,49045,49012,48978,48945,48911,48878,48844,\n    48811,48777,48744,48710,48676,48643,48609,48575,\n    48542,48508,48474,48440,48406,48372,48338,48304,\n    48271,48237,48202,48168,48134,48100,48066,48032,\n    47998,47963,47929,47895,47860,47826,47792,47757,\n    47723,47688,47654,47619,47585,47550,47516,47481,\n    47446,47412,47377,47342,47308,47273,47238,47203,\n    47168,47133,47098,47063,47028,46993,46958,46923,\n    46888,46853,46818,46783,46747,46712,46677,46642,\n    46606,46571,46536,46500,46465,46429,46394,46358,\n    46323,46287,46252,46216,46180,46145,46109,46073,\n    46037,46002,45966,45930,45894,45858,45822,45786,\n    45750,45714,45678,45642,45606,45570,45534,45498,\n    45462,45425,45389,45353,45316,45280,45244,45207,\n    45171,45135,45098,45062,45025,44989,44952,44915,\n    44879,44842,44806,44769,44732,44695,44659,44622,\n    44585,44548,44511,44474,44437,44400,44363,44326,\n    44289,44252,44215,44178,44141,44104,44067,44029,\n    43992,43955,43918,43880,43843,43806,43768,43731,\n    43693,43656,43618,43581,43543,43506,43468,43430,\n    43393,43355,43317,43280,43242,43204,43166,43128,\n    43091,43053,43015,42977,42939,42901,42863,42825,\n    42787,42749,42711,42672,42634,42596,42558,42520,\n    42481,42443,42405,42366,42328,42290,42251,42213,\n    42174,42136,42097,42059,42020,41982,41943,41904,\n    41866,41827,41788,41750,41711,41672,41633,41595,\n    41556,41517,41478,41439,41400,41361,41322,41283,\n    41244,41205,41166,41127,41088,41048,41009,40970,\n    40931,40891,40852,40813,40773,40734,40695,40655,\n    40616,40576,40537,40497,40458,40418,40379,40339,\n    40300,40260,40220,40180,40141,40101,40061,40021,\n    39982,39942,39902,39862,39822,39782,39742,39702,\n    39662,39622,39582,39542,39502,39462,39422,39382,\n    39341,39301,39261,39221,39180,39140,39100,39059,\n    39019,38979,38938,38898,38857,38817,38776,38736,\n    38695,38655,38614,38573,38533,38492,38451,38411,\n    38370,38329,38288,38248,38207,38166,38125,38084,\n    38043,38002,37961,37920,37879,37838,37797,37756,\n    37715,37674,37633,37592,37551,37509,37468,37427,\n    37386,37344,37303,37262,37220,37179,37137,37096,\n    37055,37013,36972,36930,36889,36847,36805,36764,\n    36722,36681,36639,36597,36556,36514,36472,36430,\n    36388,36347,36305,36263,36221,36179,36137,36095,\n    36053,36011,35969,35927,35885,35843,35801,35759,\n    35717,35675,35633,35590,35548,35506,35464,35421,\n    35379,35337,35294,35252,35210,35167,35125,35082,\n    35040,34997,34955,34912,34870,34827,34785,34742,\n    34699,34657,34614,34571,34529,34486,34443,34400,\n    34358,34315,34272,34229,34186,34143,34100,34057,\n    34015,33972,33929,33886,33843,33799,33756,33713,\n    33670,33627,33584,33541,33498,33454,33411,33368,\n    33325,33281,33238,33195,33151,33108,33065,33021,\n    32978,32934,32891,32847,32804,32760,32717,32673,\n    32630,32586,32542,32499,32455,32411,32368,32324,\n    32280,32236,32193,32149,32105,32061,32017,31974,\n    31930,31886,31842,31798,31754,31710,31666,31622,\n    31578,31534,31490,31446,31402,31357,31313,31269,\n    31225,31181,31136,31092,31048,31004,30959,30915,\n    30871,30826,30782,30738,30693,30649,30604,30560,\n    30515,30471,30426,30382,30337,30293,30248,30204,\n    30159,30114,30070,30025,29980,29936,29891,29846,\n    29801,29757,29712,29667,29622,29577,29533,29488,\n    29443,29398,29353,29308,29263,29218,29173,29128,\n    29083,29038,28993,28948,28903,28858,28812,28767,\n    28722,28677,28632,28586,28541,28496,28451,28405,\n    28360,28315,28269,28224,28179,28133,28088,28042,\n    27997,27952,27906,27861,27815,27770,27724,27678,\n    27633,27587,27542,27496,27450,27405,27359,27313,\n    27268,27222,27176,27131,27085,27039,26993,26947,\n    26902,26856,26810,26764,26718,26672,26626,26580,\n    26534,26488,26442,26396,26350,26304,26258,26212,\n    26166,26120,26074,26028,25982,25936,25889,25843,\n    25797,25751,25705,25658,25612,25566,25520,25473,\n    25427,25381,25334,25288,25241,25195,25149,25102,\n    25056,25009,24963,24916,24870,24823,24777,24730,\n    24684,24637,24591,24544,24497,24451,24404,24357,\n    24311,24264,24217,24171,24124,24077,24030,23984,\n    23937,23890,23843,23796,23750,23703,23656,23609,\n    23562,23515,23468,23421,23374,23327,23280,23233,\n    23186,23139,23092,23045,22998,22951,22904,22857,\n    22810,22763,22716,22668,22621,22574,22527,22480,\n    22433,22385,22338,22291,22243,22196,22149,22102,\n    22054,22007,21960,21912,21865,21817,21770,21723,\n    21675,21628,21580,21533,21485,21438,21390,21343,\n    21295,21248,21200,21153,21105,21057,21010,20962,\n    20915,20867,20819,20772,20724,20676,20629,20581,\n    20533,20485,20438,20390,20342,20294,20246,20199,\n    20151,20103,20055,20007,19959,19912,19864,19816,\n    19768,19720,19672,19624,19576,19528,19480,19432,\n    19384,19336,19288,19240,19192,19144,19096,19048,\n    19000,18951,18903,18855,18807,18759,18711,18663,\n    18614,18566,18518,18470,18421,18373,18325,18277,\n    18228,18180,18132,18084,18035,17987,17939,17890,\n    17842,17793,17745,17697,17648,17600,17551,17503,\n    17455,17406,17358,17309,17261,17212,17164,17115,\n    17067,17018,16970,16921,16872,16824,16775,16727,\n    16678,16629,16581,16532,16484,16435,16386,16338,\n    16289,16240,16191,16143,16094,16045,15997,15948,\n    15899,15850,15802,15753,15704,15655,15606,15557,\n    15509,15460,15411,15362,15313,15264,15215,15167,\n    15118,15069,15020,14971,14922,14873,14824,14775,\n    14726,14677,14628,14579,14530,14481,14432,14383,\n    14334,14285,14236,14187,14138,14089,14040,13990,\n    13941,13892,13843,13794,13745,13696,13646,13597,\n    13548,13499,13450,13401,13351,13302,13253,13204,\n    13154,13105,13056,13007,12957,12908,12859,12810,\n    12760,12711,12662,12612,12563,12514,12464,12415,\n    12366,12316,12267,12218,12168,12119,12069,12020,\n    11970,11921,11872,11822,11773,11723,11674,11624,\n    11575,11525,11476,11426,11377,11327,11278,11228,\n    11179,11129,11080,11030,10981,10931,10882,10832,\n    10782,10733,10683,10634,10584,10534,10485,10435,\n    10386,10336,10286,10237,10187,10137,10088,10038,\n    9988,9939,9889,9839,9790,9740,9690,9640,\n    9591,9541,9491,9442,9392,9342,9292,9243,\n    9193,9143,9093,9043,8994,8944,8894,8844,\n    8794,8745,8695,8645,8595,8545,8496,8446,\n    8396,8346,8296,8246,8196,8147,8097,8047,\n    7997,7947,7897,7847,7797,7747,7697,7648,\n    7598,7548,7498,7448,7398,7348,7298,7248,\n    7198,7148,7098,7048,6998,6948,6898,6848,\n    6798,6748,6698,6648,6598,6548,6498,6448,\n    6398,6348,6298,6248,6198,6148,6098,6048,\n    5998,5948,5898,5848,5798,5748,5697,5647,\n    5597,5547,5497,5447,5397,5347,5297,5247,\n    5197,5146,5096,5046,4996,4946,4896,4846,\n    4796,4745,4695,4645,4595,4545,4495,4445,\n    4394,4344,4294,4244,4194,4144,4093,4043,\n    3993,3943,3893,3843,3792,3742,3692,3642,\n    3592,3541,3491,3441,3391,3341,3291,3240,\n    3190,3140,3090,3039,2989,2939,2889,2839,\n    2788,2738,2688,2638,2587,2537,2487,2437,\n    2387,2336,2286,2236,2186,2135,2085,2035,\n    1985,1934,1884,1834,1784,1733,1683,1633,\n    1583,1532,1482,1432,1382,1331,1281,1231,\n    1181,1130,1080,1030,980,929,879,829,\n    779,728,678,628,578,527,477,427,\n    376,326,276,226,175,125,75,25,\n    -25,-75,-125,-175,-226,-276,-326,-376,\n    -427,-477,-527,-578,-628,-678,-728,-779,\n    -829,-879,-929,-980,-1030,-1080,-1130,-1181,\n    -1231,-1281,-1331,-1382,-1432,-1482,-1532,-1583,\n    -1633,-1683,-1733,-1784,-1834,-1884,-1934,-1985,\n    -2035,-2085,-2135,-2186,-2236,-2286,-2336,-2387,\n    -2437,-2487,-2537,-2588,-2638,-2688,-2738,-2788,\n    -2839,-2889,-2939,-2989,-3039,-3090,-3140,-3190,\n    -3240,-3291,-3341,-3391,-3441,-3491,-3541,-3592,\n    -3642,-3692,-3742,-3792,-3843,-3893,-3943,-3993,\n    -4043,-4093,-4144,-4194,-4244,-4294,-4344,-4394,\n    -4445,-4495,-4545,-4595,-4645,-4695,-4745,-4796,\n    -4846,-4896,-4946,-4996,-5046,-5096,-5146,-5197,\n    -5247,-5297,-5347,-5397,-5447,-5497,-5547,-5597,\n    -5647,-5697,-5748,-5798,-5848,-5898,-5948,-5998,\n    -6048,-6098,-6148,-6198,-6248,-6298,-6348,-6398,\n    -6448,-6498,-6548,-6598,-6648,-6698,-6748,-6798,\n    -6848,-6898,-6948,-6998,-7048,-7098,-7148,-7198,\n    -7248,-7298,-7348,-7398,-7448,-7498,-7548,-7598,\n    -7648,-7697,-7747,-7797,-7847,-7897,-7947,-7997,\n    -8047,-8097,-8147,-8196,-8246,-8296,-8346,-8396,\n    -8446,-8496,-8545,-8595,-8645,-8695,-8745,-8794,\n    -8844,-8894,-8944,-8994,-9043,-9093,-9143,-9193,\n    -9243,-9292,-9342,-9392,-9442,-9491,-9541,-9591,\n    -9640,-9690,-9740,-9790,-9839,-9889,-9939,-9988,\n    -10038,-10088,-10137,-10187,-10237,-10286,-10336,-10386,\n    -10435,-10485,-10534,-10584,-10634,-10683,-10733,-10782,\n    -10832,-10882,-10931,-10981,-11030,-11080,-11129,-11179,\n    -11228,-11278,-11327,-11377,-11426,-11476,-11525,-11575,\n    -11624,-11674,-11723,-11773,-11822,-11872,-11921,-11970,\n    -12020,-12069,-12119,-12168,-12218,-12267,-12316,-12366,\n    -12415,-12464,-12514,-12563,-12612,-12662,-12711,-12760,\n    -12810,-12859,-12908,-12957,-13007,-13056,-13105,-13154,\n    -13204,-13253,-13302,-13351,-13401,-13450,-13499,-13548,\n    -13597,-13647,-13696,-13745,-13794,-13843,-13892,-13941,\n    -13990,-14040,-14089,-14138,-14187,-14236,-14285,-14334,\n    -14383,-14432,-14481,-14530,-14579,-14628,-14677,-14726,\n    -14775,-14824,-14873,-14922,-14971,-15020,-15069,-15118,\n    -15167,-15215,-15264,-15313,-15362,-15411,-15460,-15509,\n    -15557,-15606,-15655,-15704,-15753,-15802,-15850,-15899,\n    -15948,-15997,-16045,-16094,-16143,-16191,-16240,-16289,\n    -16338,-16386,-16435,-16484,-16532,-16581,-16629,-16678,\n    -16727,-16775,-16824,-16872,-16921,-16970,-17018,-17067,\n    -17115,-17164,-17212,-17261,-17309,-17358,-17406,-17455,\n    -17503,-17551,-17600,-17648,-17697,-17745,-17793,-17842,\n    -17890,-17939,-17987,-18035,-18084,-18132,-18180,-18228,\n    -18277,-18325,-18373,-18421,-18470,-18518,-18566,-18614,\n    -18663,-18711,-18759,-18807,-18855,-18903,-18951,-19000,\n    -19048,-19096,-19144,-19192,-19240,-19288,-19336,-19384,\n    -19432,-19480,-19528,-19576,-19624,-19672,-19720,-19768,\n    -19816,-19864,-19912,-19959,-20007,-20055,-20103,-20151,\n    -20199,-20246,-20294,-20342,-20390,-20438,-20485,-20533,\n    -20581,-20629,-20676,-20724,-20772,-20819,-20867,-20915,\n    -20962,-21010,-21057,-21105,-21153,-21200,-21248,-21295,\n    -21343,-21390,-21438,-21485,-21533,-21580,-21628,-21675,\n    -21723,-21770,-21817,-21865,-21912,-21960,-22007,-22054,\n    -22102,-22149,-22196,-22243,-22291,-22338,-22385,-22433,\n    -22480,-22527,-22574,-22621,-22668,-22716,-22763,-22810,\n    -22857,-22904,-22951,-22998,-23045,-23092,-23139,-23186,\n    -23233,-23280,-23327,-23374,-23421,-23468,-23515,-23562,\n    -23609,-23656,-23703,-23750,-23796,-23843,-23890,-23937,\n    -23984,-24030,-24077,-24124,-24171,-24217,-24264,-24311,\n    -24357,-24404,-24451,-24497,-24544,-24591,-24637,-24684,\n    -24730,-24777,-24823,-24870,-24916,-24963,-25009,-25056,\n    -25102,-25149,-25195,-25241,-25288,-25334,-25381,-25427,\n    -25473,-25520,-25566,-25612,-25658,-25705,-25751,-25797,\n    -25843,-25889,-25936,-25982,-26028,-26074,-26120,-26166,\n    -26212,-26258,-26304,-26350,-26396,-26442,-26488,-26534,\n    -26580,-26626,-26672,-26718,-26764,-26810,-26856,-26902,\n    -26947,-26993,-27039,-27085,-27131,-27176,-27222,-27268,\n    -27313,-27359,-27405,-27450,-27496,-27542,-27587,-27633,\n    -27678,-27724,-27770,-27815,-27861,-27906,-27952,-27997,\n    -28042,-28088,-28133,-28179,-28224,-28269,-28315,-28360,\n    -28405,-28451,-28496,-28541,-28586,-28632,-28677,-28722,\n    -28767,-28812,-28858,-28903,-28948,-28993,-29038,-29083,\n    -29128,-29173,-29218,-29263,-29308,-29353,-29398,-29443,\n    -29488,-29533,-29577,-29622,-29667,-29712,-29757,-29801,\n    -29846,-29891,-29936,-29980,-30025,-30070,-30114,-30159,\n    -30204,-30248,-30293,-30337,-30382,-30426,-30471,-30515,\n    -30560,-30604,-30649,-30693,-30738,-30782,-30826,-30871,\n    -30915,-30959,-31004,-31048,-31092,-31136,-31181,-31225,\n    -31269,-31313,-31357,-31402,-31446,-31490,-31534,-31578,\n    -31622,-31666,-31710,-31754,-31798,-31842,-31886,-31930,\n    -31974,-32017,-32061,-32105,-32149,-32193,-32236,-32280,\n    -32324,-32368,-32411,-32455,-32499,-32542,-32586,-32630,\n    -32673,-32717,-32760,-32804,-32847,-32891,-32934,-32978,\n    -33021,-33065,-33108,-33151,-33195,-33238,-33281,-33325,\n    -33368,-33411,-33454,-33498,-33541,-33584,-33627,-33670,\n    -33713,-33756,-33799,-33843,-33886,-33929,-33972,-34015,\n    -34057,-34100,-34143,-34186,-34229,-34272,-34315,-34358,\n    -34400,-34443,-34486,-34529,-34571,-34614,-34657,-34699,\n    -34742,-34785,-34827,-34870,-34912,-34955,-34997,-35040,\n    -35082,-35125,-35167,-35210,-35252,-35294,-35337,-35379,\n    -35421,-35464,-35506,-35548,-35590,-35633,-35675,-35717,\n    -35759,-35801,-35843,-35885,-35927,-35969,-36011,-36053,\n    -36095,-36137,-36179,-36221,-36263,-36305,-36347,-36388,\n    -36430,-36472,-36514,-36555,-36597,-36639,-36681,-36722,\n    -36764,-36805,-36847,-36889,-36930,-36972,-37013,-37055,\n    -37096,-37137,-37179,-37220,-37262,-37303,-37344,-37386,\n    -37427,-37468,-37509,-37551,-37592,-37633,-37674,-37715,\n    -37756,-37797,-37838,-37879,-37920,-37961,-38002,-38043,\n    -38084,-38125,-38166,-38207,-38248,-38288,-38329,-38370,\n    -38411,-38451,-38492,-38533,-38573,-38614,-38655,-38695,\n    -38736,-38776,-38817,-38857,-38898,-38938,-38979,-39019,\n    -39059,-39100,-39140,-39180,-39221,-39261,-39301,-39341,\n    -39382,-39422,-39462,-39502,-39542,-39582,-39622,-39662,\n    -39702,-39742,-39782,-39822,-39862,-39902,-39942,-39982,\n    -40021,-40061,-40101,-40141,-40180,-40220,-40260,-40299,\n    -40339,-40379,-40418,-40458,-40497,-40537,-40576,-40616,\n    -40655,-40695,-40734,-40773,-40813,-40852,-40891,-40931,\n    -40970,-41009,-41048,-41087,-41127,-41166,-41205,-41244,\n    -41283,-41322,-41361,-41400,-41439,-41478,-41517,-41556,\n    -41595,-41633,-41672,-41711,-41750,-41788,-41827,-41866,\n    -41904,-41943,-41982,-42020,-42059,-42097,-42136,-42174,\n    -42213,-42251,-42290,-42328,-42366,-42405,-42443,-42481,\n    -42520,-42558,-42596,-42634,-42672,-42711,-42749,-42787,\n    -42825,-42863,-42901,-42939,-42977,-43015,-43053,-43091,\n    -43128,-43166,-43204,-43242,-43280,-43317,-43355,-43393,\n    -43430,-43468,-43506,-43543,-43581,-43618,-43656,-43693,\n    -43731,-43768,-43806,-43843,-43880,-43918,-43955,-43992,\n    -44029,-44067,-44104,-44141,-44178,-44215,-44252,-44289,\n    -44326,-44363,-44400,-44437,-44474,-44511,-44548,-44585,\n    -44622,-44659,-44695,-44732,-44769,-44806,-44842,-44879,\n    -44915,-44952,-44989,-45025,-45062,-45098,-45135,-45171,\n    -45207,-45244,-45280,-45316,-45353,-45389,-45425,-45462,\n    -45498,-45534,-45570,-45606,-45642,-45678,-45714,-45750,\n    -45786,-45822,-45858,-45894,-45930,-45966,-46002,-46037,\n    -46073,-46109,-46145,-46180,-46216,-46252,-46287,-46323,\n    -46358,-46394,-46429,-46465,-46500,-46536,-46571,-46606,\n    -46642,-46677,-46712,-46747,-46783,-46818,-46853,-46888,\n    -46923,-46958,-46993,-47028,-47063,-47098,-47133,-47168,\n    -47203,-47238,-47273,-47308,-47342,-47377,-47412,-47446,\n    -47481,-47516,-47550,-47585,-47619,-47654,-47688,-47723,\n    -47757,-47792,-47826,-47860,-47895,-47929,-47963,-47998,\n    -48032,-48066,-48100,-48134,-48168,-48202,-48236,-48271,\n    -48304,-48338,-48372,-48406,-48440,-48474,-48508,-48542,\n    -48575,-48609,-48643,-48676,-48710,-48744,-48777,-48811,\n    -48844,-48878,-48911,-48945,-48978,-49012,-49045,-49078,\n    -49112,-49145,-49178,-49211,-49244,-49278,-49311,-49344,\n    -49377,-49410,-49443,-49476,-49509,-49542,-49575,-49608,\n    -49640,-49673,-49706,-49739,-49771,-49804,-49837,-49869,\n    -49902,-49935,-49967,-50000,-50032,-50065,-50097,-50129,\n    -50162,-50194,-50226,-50259,-50291,-50323,-50355,-50387,\n    -50420,-50452,-50484,-50516,-50548,-50580,-50612,-50644,\n    -50675,-50707,-50739,-50771,-50803,-50834,-50866,-50898,\n    -50929,-50961,-50993,-51024,-51056,-51087,-51119,-51150,\n    -51182,-51213,-51244,-51276,-51307,-51338,-51369,-51401,\n    -51432,-51463,-51494,-51525,-51556,-51587,-51618,-51649,\n    -51680,-51711,-51742,-51773,-51803,-51834,-51865,-51896,\n    -51926,-51957,-51988,-52018,-52049,-52079,-52110,-52140,\n    -52171,-52201,-52231,-52262,-52292,-52322,-52353,-52383,\n    -52413,-52443,-52473,-52503,-52534,-52564,-52594,-52624,\n    -52653,-52683,-52713,-52743,-52773,-52803,-52832,-52862,\n    -52892,-52922,-52951,-52981,-53010,-53040,-53069,-53099,\n    -53128,-53158,-53187,-53216,-53246,-53275,-53304,-53334,\n    -53363,-53392,-53421,-53450,-53479,-53508,-53537,-53566,\n    -53595,-53624,-53653,-53682,-53711,-53739,-53768,-53797,\n    -53826,-53854,-53883,-53911,-53940,-53969,-53997,-54026,\n    -54054,-54082,-54111,-54139,-54167,-54196,-54224,-54252,\n    -54280,-54308,-54337,-54365,-54393,-54421,-54449,-54477,\n    -54505,-54533,-54560,-54588,-54616,-54644,-54672,-54699,\n    -54727,-54755,-54782,-54810,-54837,-54865,-54892,-54920,\n    -54947,-54974,-55002,-55029,-55056,-55084,-55111,-55138,\n    -55165,-55192,-55219,-55246,-55274,-55300,-55327,-55354,\n    -55381,-55408,-55435,-55462,-55489,-55515,-55542,-55569,\n    -55595,-55622,-55648,-55675,-55701,-55728,-55754,-55781,\n    -55807,-55833,-55860,-55886,-55912,-55938,-55965,-55991,\n    -56017,-56043,-56069,-56095,-56121,-56147,-56173,-56199,\n    -56225,-56250,-56276,-56302,-56328,-56353,-56379,-56404,\n    -56430,-56456,-56481,-56507,-56532,-56557,-56583,-56608,\n    -56633,-56659,-56684,-56709,-56734,-56760,-56785,-56810,\n    -56835,-56860,-56885,-56910,-56935,-56959,-56984,-57009,\n    -57034,-57059,-57083,-57108,-57133,-57157,-57182,-57206,\n    -57231,-57255,-57280,-57304,-57329,-57353,-57377,-57402,\n    -57426,-57450,-57474,-57498,-57522,-57546,-57570,-57594,\n    -57618,-57642,-57666,-57690,-57714,-57738,-57762,-57785,\n    -57809,-57833,-57856,-57880,-57903,-57927,-57950,-57974,\n    -57997,-58021,-58044,-58067,-58091,-58114,-58137,-58160,\n    -58183,-58207,-58230,-58253,-58276,-58299,-58322,-58345,\n    -58367,-58390,-58413,-58436,-58459,-58481,-58504,-58527,\n    -58549,-58572,-58594,-58617,-58639,-58662,-58684,-58706,\n    -58729,-58751,-58773,-58795,-58818,-58840,-58862,-58884,\n    -58906,-58928,-58950,-58972,-58994,-59016,-59038,-59059,\n    -59081,-59103,-59125,-59146,-59168,-59190,-59211,-59233,\n    -59254,-59276,-59297,-59318,-59340,-59361,-59382,-59404,\n    -59425,-59446,-59467,-59488,-59509,-59530,-59551,-59572,\n    -59593,-59614,-59635,-59656,-59677,-59697,-59718,-59739,\n    -59759,-59780,-59801,-59821,-59842,-59862,-59883,-59903,\n    -59923,-59944,-59964,-59984,-60004,-60025,-60045,-60065,\n    -60085,-60105,-60125,-60145,-60165,-60185,-60205,-60225,\n    -60244,-60264,-60284,-60304,-60323,-60343,-60363,-60382,\n    -60402,-60421,-60441,-60460,-60479,-60499,-60518,-60537,\n    -60556,-60576,-60595,-60614,-60633,-60652,-60671,-60690,\n    -60709,-60728,-60747,-60766,-60785,-60803,-60822,-60841,\n    -60859,-60878,-60897,-60915,-60934,-60952,-60971,-60989,\n    -61007,-61026,-61044,-61062,-61081,-61099,-61117,-61135,\n    -61153,-61171,-61189,-61207,-61225,-61243,-61261,-61279,\n    -61297,-61314,-61332,-61350,-61367,-61385,-61403,-61420,\n    -61438,-61455,-61473,-61490,-61507,-61525,-61542,-61559,\n    -61577,-61594,-61611,-61628,-61645,-61662,-61679,-61696,\n    -61713,-61730,-61747,-61764,-61780,-61797,-61814,-61831,\n    -61847,-61864,-61880,-61897,-61913,-61930,-61946,-61963,\n    -61979,-61995,-62012,-62028,-62044,-62060,-62076,-62092,\n    -62108,-62125,-62141,-62156,-62172,-62188,-62204,-62220,\n    -62236,-62251,-62267,-62283,-62298,-62314,-62329,-62345,\n    -62360,-62376,-62391,-62407,-62422,-62437,-62453,-62468,\n    -62483,-62498,-62513,-62528,-62543,-62558,-62573,-62588,\n    -62603,-62618,-62633,-62648,-62662,-62677,-62692,-62706,\n    -62721,-62735,-62750,-62764,-62779,-62793,-62808,-62822,\n    -62836,-62850,-62865,-62879,-62893,-62907,-62921,-62935,\n    -62949,-62963,-62977,-62991,-63005,-63019,-63032,-63046,\n    -63060,-63074,-63087,-63101,-63114,-63128,-63141,-63155,\n    -63168,-63182,-63195,-63208,-63221,-63235,-63248,-63261,\n    -63274,-63287,-63300,-63313,-63326,-63339,-63352,-63365,\n    -63378,-63390,-63403,-63416,-63429,-63441,-63454,-63466,\n    -63479,-63491,-63504,-63516,-63528,-63541,-63553,-63565,\n    -63578,-63590,-63602,-63614,-63626,-63638,-63650,-63662,\n    -63674,-63686,-63698,-63709,-63721,-63733,-63745,-63756,\n    -63768,-63779,-63791,-63803,-63814,-63825,-63837,-63848,\n    -63859,-63871,-63882,-63893,-63904,-63915,-63927,-63938,\n    -63949,-63960,-63971,-63981,-63992,-64003,-64014,-64025,\n    -64035,-64046,-64057,-64067,-64078,-64088,-64099,-64109,\n    -64120,-64130,-64140,-64151,-64161,-64171,-64181,-64192,\n    -64202,-64212,-64222,-64232,-64242,-64252,-64261,-64271,\n    -64281,-64291,-64301,-64310,-64320,-64330,-64339,-64349,\n    -64358,-64368,-64377,-64387,-64396,-64405,-64414,-64424,\n    -64433,-64442,-64451,-64460,-64469,-64478,-64487,-64496,\n    -64505,-64514,-64523,-64532,-64540,-64549,-64558,-64566,\n    -64575,-64584,-64592,-64601,-64609,-64617,-64626,-64634,\n    -64642,-64651,-64659,-64667,-64675,-64683,-64691,-64699,\n    -64707,-64715,-64723,-64731,-64739,-64747,-64754,-64762,\n    -64770,-64777,-64785,-64793,-64800,-64808,-64815,-64822,\n    -64830,-64837,-64844,-64852,-64859,-64866,-64873,-64880,\n    -64887,-64895,-64902,-64908,-64915,-64922,-64929,-64936,\n    -64943,-64949,-64956,-64963,-64969,-64976,-64982,-64989,\n    -64995,-65002,-65008,-65015,-65021,-65027,-65033,-65040,\n    -65046,-65052,-65058,-65064,-65070,-65076,-65082,-65088,\n    -65094,-65099,-65105,-65111,-65117,-65122,-65128,-65133,\n    -65139,-65144,-65150,-65155,-65161,-65166,-65171,-65177,\n    -65182,-65187,-65192,-65197,-65202,-65207,-65212,-65217,\n    -65222,-65227,-65232,-65237,-65242,-65246,-65251,-65256,\n    -65260,-65265,-65270,-65274,-65279,-65283,-65287,-65292,\n    -65296,-65300,-65305,-65309,-65313,-65317,-65321,-65325,\n    -65329,-65333,-65337,-65341,-65345,-65349,-65352,-65356,\n    -65360,-65363,-65367,-65371,-65374,-65378,-65381,-65385,\n    -65388,-65391,-65395,-65398,-65401,-65404,-65408,-65411,\n    -65414,-65417,-65420,-65423,-65426,-65429,-65431,-65434,\n    -65437,-65440,-65442,-65445,-65448,-65450,-65453,-65455,\n    -65458,-65460,-65463,-65465,-65467,-65470,-65472,-65474,\n    -65476,-65478,-65480,-65482,-65484,-65486,-65488,-65490,\n    -65492,-65494,-65496,-65497,-65499,-65501,-65502,-65504,\n    -65505,-65507,-65508,-65510,-65511,-65513,-65514,-65515,\n    -65516,-65518,-65519,-65520,-65521,-65522,-65523,-65524,\n    -65525,-65526,-65527,-65527,-65528,-65529,-65530,-65530,\n    -65531,-65531,-65532,-65532,-65533,-65533,-65534,-65534,\n    -65534,-65535,-65535,-65535,-65535,-65535,-65535,-65535,\n    -65535,-65535,-65535,-65535,-65535,-65535,-65535,-65534,\n    -65534,-65534,-65533,-65533,-65532,-65532,-65531,-65531,\n    -65530,-65530,-65529,-65528,-65527,-65527,-65526,-65525,\n    -65524,-65523,-65522,-65521,-65520,-65519,-65518,-65516,\n    -65515,-65514,-65513,-65511,-65510,-65508,-65507,-65505,\n    -65504,-65502,-65501,-65499,-65497,-65496,-65494,-65492,\n    -65490,-65488,-65486,-65484,-65482,-65480,-65478,-65476,\n    -65474,-65472,-65470,-65467,-65465,-65463,-65460,-65458,\n    -65455,-65453,-65450,-65448,-65445,-65442,-65440,-65437,\n    -65434,-65431,-65429,-65426,-65423,-65420,-65417,-65414,\n    -65411,-65408,-65404,-65401,-65398,-65395,-65391,-65388,\n    -65385,-65381,-65378,-65374,-65371,-65367,-65363,-65360,\n    -65356,-65352,-65349,-65345,-65341,-65337,-65333,-65329,\n    -65325,-65321,-65317,-65313,-65309,-65305,-65300,-65296,\n    -65292,-65287,-65283,-65279,-65274,-65270,-65265,-65260,\n    -65256,-65251,-65246,-65242,-65237,-65232,-65227,-65222,\n    -65217,-65212,-65207,-65202,-65197,-65192,-65187,-65182,\n    -65177,-65171,-65166,-65161,-65155,-65150,-65144,-65139,\n    -65133,-65128,-65122,-65117,-65111,-65105,-65099,-65094,\n    -65088,-65082,-65076,-65070,-65064,-65058,-65052,-65046,\n    -65040,-65033,-65027,-65021,-65015,-65008,-65002,-64995,\n    -64989,-64982,-64976,-64969,-64963,-64956,-64949,-64943,\n    -64936,-64929,-64922,-64915,-64908,-64902,-64895,-64887,\n    -64880,-64873,-64866,-64859,-64852,-64844,-64837,-64830,\n    -64822,-64815,-64808,-64800,-64793,-64785,-64777,-64770,\n    -64762,-64754,-64747,-64739,-64731,-64723,-64715,-64707,\n    -64699,-64691,-64683,-64675,-64667,-64659,-64651,-64642,\n    -64634,-64626,-64617,-64609,-64601,-64592,-64584,-64575,\n    -64566,-64558,-64549,-64540,-64532,-64523,-64514,-64505,\n    -64496,-64487,-64478,-64469,-64460,-64451,-64442,-64433,\n    -64424,-64414,-64405,-64396,-64387,-64377,-64368,-64358,\n    -64349,-64339,-64330,-64320,-64310,-64301,-64291,-64281,\n    -64271,-64261,-64252,-64242,-64232,-64222,-64212,-64202,\n    -64192,-64181,-64171,-64161,-64151,-64140,-64130,-64120,\n    -64109,-64099,-64088,-64078,-64067,-64057,-64046,-64035,\n    -64025,-64014,-64003,-63992,-63981,-63971,-63960,-63949,\n    -63938,-63927,-63915,-63904,-63893,-63882,-63871,-63859,\n    -63848,-63837,-63825,-63814,-63803,-63791,-63779,-63768,\n    -63756,-63745,-63733,-63721,-63709,-63698,-63686,-63674,\n    -63662,-63650,-63638,-63626,-63614,-63602,-63590,-63578,\n    -63565,-63553,-63541,-63528,-63516,-63504,-63491,-63479,\n    -63466,-63454,-63441,-63429,-63416,-63403,-63390,-63378,\n    -63365,-63352,-63339,-63326,-63313,-63300,-63287,-63274,\n    -63261,-63248,-63235,-63221,-63208,-63195,-63182,-63168,\n    -63155,-63141,-63128,-63114,-63101,-63087,-63074,-63060,\n    -63046,-63032,-63019,-63005,-62991,-62977,-62963,-62949,\n    -62935,-62921,-62907,-62893,-62879,-62865,-62850,-62836,\n    -62822,-62808,-62793,-62779,-62764,-62750,-62735,-62721,\n    -62706,-62692,-62677,-62662,-62648,-62633,-62618,-62603,\n    -62588,-62573,-62558,-62543,-62528,-62513,-62498,-62483,\n    -62468,-62453,-62437,-62422,-62407,-62391,-62376,-62360,\n    -62345,-62329,-62314,-62298,-62283,-62267,-62251,-62236,\n    -62220,-62204,-62188,-62172,-62156,-62141,-62125,-62108,\n    -62092,-62076,-62060,-62044,-62028,-62012,-61995,-61979,\n    -61963,-61946,-61930,-61913,-61897,-61880,-61864,-61847,\n    -61831,-61814,-61797,-61780,-61764,-61747,-61730,-61713,\n    -61696,-61679,-61662,-61645,-61628,-61611,-61594,-61577,\n    -61559,-61542,-61525,-61507,-61490,-61473,-61455,-61438,\n    -61420,-61403,-61385,-61367,-61350,-61332,-61314,-61297,\n    -61279,-61261,-61243,-61225,-61207,-61189,-61171,-61153,\n    -61135,-61117,-61099,-61081,-61062,-61044,-61026,-61007,\n    -60989,-60971,-60952,-60934,-60915,-60897,-60878,-60859,\n    -60841,-60822,-60803,-60785,-60766,-60747,-60728,-60709,\n    -60690,-60671,-60652,-60633,-60614,-60595,-60576,-60556,\n    -60537,-60518,-60499,-60479,-60460,-60441,-60421,-60402,\n    -60382,-60363,-60343,-60323,-60304,-60284,-60264,-60244,\n    -60225,-60205,-60185,-60165,-60145,-60125,-60105,-60085,\n    -60065,-60045,-60025,-60004,-59984,-59964,-59944,-59923,\n    -59903,-59883,-59862,-59842,-59821,-59801,-59780,-59759,\n    -59739,-59718,-59697,-59677,-59656,-59635,-59614,-59593,\n    -59572,-59551,-59530,-59509,-59488,-59467,-59446,-59425,\n    -59404,-59382,-59361,-59340,-59318,-59297,-59276,-59254,\n    -59233,-59211,-59189,-59168,-59146,-59125,-59103,-59081,\n    -59059,-59038,-59016,-58994,-58972,-58950,-58928,-58906,\n    -58884,-58862,-58840,-58818,-58795,-58773,-58751,-58729,\n    -58706,-58684,-58662,-58639,-58617,-58594,-58572,-58549,\n    -58527,-58504,-58481,-58459,-58436,-58413,-58390,-58367,\n    -58345,-58322,-58299,-58276,-58253,-58230,-58207,-58183,\n    -58160,-58137,-58114,-58091,-58067,-58044,-58021,-57997,\n    -57974,-57950,-57927,-57903,-57880,-57856,-57833,-57809,\n    -57785,-57762,-57738,-57714,-57690,-57666,-57642,-57618,\n    -57594,-57570,-57546,-57522,-57498,-57474,-57450,-57426,\n    -57402,-57377,-57353,-57329,-57304,-57280,-57255,-57231,\n    -57206,-57182,-57157,-57133,-57108,-57083,-57059,-57034,\n    -57009,-56984,-56959,-56935,-56910,-56885,-56860,-56835,\n    -56810,-56785,-56760,-56734,-56709,-56684,-56659,-56633,\n    -56608,-56583,-56557,-56532,-56507,-56481,-56456,-56430,\n    -56404,-56379,-56353,-56328,-56302,-56276,-56250,-56225,\n    -56199,-56173,-56147,-56121,-56095,-56069,-56043,-56017,\n    -55991,-55965,-55938,-55912,-55886,-55860,-55833,-55807,\n    -55781,-55754,-55728,-55701,-55675,-55648,-55622,-55595,\n    -55569,-55542,-55515,-55489,-55462,-55435,-55408,-55381,\n    -55354,-55327,-55300,-55274,-55246,-55219,-55192,-55165,\n    -55138,-55111,-55084,-55056,-55029,-55002,-54974,-54947,\n    -54920,-54892,-54865,-54837,-54810,-54782,-54755,-54727,\n    -54699,-54672,-54644,-54616,-54588,-54560,-54533,-54505,\n    -54477,-54449,-54421,-54393,-54365,-54337,-54308,-54280,\n    -54252,-54224,-54196,-54167,-54139,-54111,-54082,-54054,\n    -54026,-53997,-53969,-53940,-53911,-53883,-53854,-53826,\n    -53797,-53768,-53739,-53711,-53682,-53653,-53624,-53595,\n    -53566,-53537,-53508,-53479,-53450,-53421,-53392,-53363,\n    -53334,-53304,-53275,-53246,-53216,-53187,-53158,-53128,\n    -53099,-53069,-53040,-53010,-52981,-52951,-52922,-52892,\n    -52862,-52832,-52803,-52773,-52743,-52713,-52683,-52653,\n    -52624,-52594,-52564,-52534,-52503,-52473,-52443,-52413,\n    -52383,-52353,-52322,-52292,-52262,-52231,-52201,-52171,\n    -52140,-52110,-52079,-52049,-52018,-51988,-51957,-51926,\n    -51896,-51865,-51834,-51803,-51773,-51742,-51711,-51680,\n    -51649,-51618,-51587,-51556,-51525,-51494,-51463,-51432,\n    -51401,-51369,-51338,-51307,-51276,-51244,-51213,-51182,\n    -51150,-51119,-51087,-51056,-51024,-50993,-50961,-50929,\n    -50898,-50866,-50834,-50803,-50771,-50739,-50707,-50675,\n    -50644,-50612,-50580,-50548,-50516,-50484,-50452,-50420,\n    -50387,-50355,-50323,-50291,-50259,-50226,-50194,-50162,\n    -50129,-50097,-50065,-50032,-50000,-49967,-49935,-49902,\n    -49869,-49837,-49804,-49771,-49739,-49706,-49673,-49640,\n    -49608,-49575,-49542,-49509,-49476,-49443,-49410,-49377,\n    -49344,-49311,-49278,-49244,-49211,-49178,-49145,-49112,\n    -49078,-49045,-49012,-48978,-48945,-48911,-48878,-48844,\n    -48811,-48777,-48744,-48710,-48676,-48643,-48609,-48575,\n    -48542,-48508,-48474,-48440,-48406,-48372,-48338,-48305,\n    -48271,-48237,-48202,-48168,-48134,-48100,-48066,-48032,\n    -47998,-47963,-47929,-47895,-47860,-47826,-47792,-47757,\n    -47723,-47688,-47654,-47619,-47585,-47550,-47516,-47481,\n    -47446,-47412,-47377,-47342,-47307,-47273,-47238,-47203,\n    -47168,-47133,-47098,-47063,-47028,-46993,-46958,-46923,\n    -46888,-46853,-46818,-46783,-46747,-46712,-46677,-46642,\n    -46606,-46571,-46536,-46500,-46465,-46429,-46394,-46358,\n    -46323,-46287,-46251,-46216,-46180,-46145,-46109,-46073,\n    -46037,-46002,-45966,-45930,-45894,-45858,-45822,-45786,\n    -45750,-45714,-45678,-45642,-45606,-45570,-45534,-45498,\n    -45462,-45425,-45389,-45353,-45316,-45280,-45244,-45207,\n    -45171,-45135,-45098,-45062,-45025,-44989,-44952,-44915,\n    -44879,-44842,-44806,-44769,-44732,-44695,-44659,-44622,\n    -44585,-44548,-44511,-44474,-44437,-44400,-44363,-44326,\n    -44289,-44252,-44215,-44178,-44141,-44104,-44067,-44029,\n    -43992,-43955,-43918,-43880,-43843,-43806,-43768,-43731,\n    -43693,-43656,-43618,-43581,-43543,-43506,-43468,-43430,\n    -43393,-43355,-43317,-43280,-43242,-43204,-43166,-43128,\n    -43091,-43053,-43015,-42977,-42939,-42901,-42863,-42825,\n    -42787,-42749,-42711,-42672,-42634,-42596,-42558,-42520,\n    -42481,-42443,-42405,-42366,-42328,-42290,-42251,-42213,\n    -42174,-42136,-42097,-42059,-42020,-41982,-41943,-41904,\n    -41866,-41827,-41788,-41750,-41711,-41672,-41633,-41595,\n    -41556,-41517,-41478,-41439,-41400,-41361,-41322,-41283,\n    -41244,-41205,-41166,-41127,-41087,-41048,-41009,-40970,\n    -40931,-40891,-40852,-40813,-40773,-40734,-40695,-40655,\n    -40616,-40576,-40537,-40497,-40458,-40418,-40379,-40339,\n    -40299,-40260,-40220,-40180,-40141,-40101,-40061,-40021,\n    -39982,-39942,-39902,-39862,-39822,-39782,-39742,-39702,\n    -39662,-39622,-39582,-39542,-39502,-39462,-39422,-39382,\n    -39341,-39301,-39261,-39221,-39180,-39140,-39100,-39059,\n    -39019,-38979,-38938,-38898,-38857,-38817,-38776,-38736,\n    -38695,-38655,-38614,-38573,-38533,-38492,-38451,-38411,\n    -38370,-38329,-38288,-38248,-38207,-38166,-38125,-38084,\n    -38043,-38002,-37961,-37920,-37879,-37838,-37797,-37756,\n    -37715,-37674,-37633,-37592,-37550,-37509,-37468,-37427,\n    -37386,-37344,-37303,-37262,-37220,-37179,-37137,-37096,\n    -37055,-37013,-36972,-36930,-36889,-36847,-36805,-36764,\n    -36722,-36681,-36639,-36597,-36556,-36514,-36472,-36430,\n    -36388,-36347,-36305,-36263,-36221,-36179,-36137,-36095,\n    -36053,-36011,-35969,-35927,-35885,-35843,-35801,-35759,\n    -35717,-35675,-35633,-35590,-35548,-35506,-35464,-35421,\n    -35379,-35337,-35294,-35252,-35210,-35167,-35125,-35082,\n    -35040,-34997,-34955,-34912,-34870,-34827,-34785,-34742,\n    -34699,-34657,-34614,-34571,-34529,-34486,-34443,-34400,\n    -34358,-34315,-34272,-34229,-34186,-34143,-34100,-34057,\n    -34015,-33972,-33929,-33886,-33843,-33799,-33756,-33713,\n    -33670,-33627,-33584,-33541,-33498,-33454,-33411,-33368,\n    -33325,-33281,-33238,-33195,-33151,-33108,-33065,-33021,\n    -32978,-32934,-32891,-32847,-32804,-32760,-32717,-32673,\n    -32630,-32586,-32542,-32499,-32455,-32411,-32368,-32324,\n    -32280,-32236,-32193,-32149,-32105,-32061,-32017,-31974,\n    -31930,-31886,-31842,-31798,-31754,-31710,-31666,-31622,\n    -31578,-31534,-31490,-31446,-31402,-31357,-31313,-31269,\n    -31225,-31181,-31136,-31092,-31048,-31004,-30959,-30915,\n    -30871,-30826,-30782,-30738,-30693,-30649,-30604,-30560,\n    -30515,-30471,-30426,-30382,-30337,-30293,-30248,-30204,\n    -30159,-30114,-30070,-30025,-29980,-29936,-29891,-29846,\n    -29801,-29757,-29712,-29667,-29622,-29577,-29533,-29488,\n    -29443,-29398,-29353,-29308,-29263,-29218,-29173,-29128,\n    -29083,-29038,-28993,-28948,-28903,-28858,-28812,-28767,\n    -28722,-28677,-28632,-28586,-28541,-28496,-28451,-28405,\n    -28360,-28315,-28269,-28224,-28179,-28133,-28088,-28042,\n    -27997,-27952,-27906,-27861,-27815,-27770,-27724,-27678,\n    -27633,-27587,-27542,-27496,-27450,-27405,-27359,-27313,\n    -27268,-27222,-27176,-27131,-27085,-27039,-26993,-26947,\n    -26902,-26856,-26810,-26764,-26718,-26672,-26626,-26580,\n    -26534,-26488,-26442,-26396,-26350,-26304,-26258,-26212,\n    -26166,-26120,-26074,-26028,-25982,-25936,-25889,-25843,\n    -25797,-25751,-25705,-25658,-25612,-25566,-25520,-25473,\n    -25427,-25381,-25334,-25288,-25241,-25195,-25149,-25102,\n    -25056,-25009,-24963,-24916,-24870,-24823,-24777,-24730,\n    -24684,-24637,-24591,-24544,-24497,-24451,-24404,-24357,\n    -24311,-24264,-24217,-24171,-24124,-24077,-24030,-23984,\n    -23937,-23890,-23843,-23796,-23750,-23703,-23656,-23609,\n    -23562,-23515,-23468,-23421,-23374,-23327,-23280,-23233,\n    -23186,-23139,-23092,-23045,-22998,-22951,-22904,-22857,\n    -22810,-22763,-22716,-22668,-22621,-22574,-22527,-22480,\n    -22432,-22385,-22338,-22291,-22243,-22196,-22149,-22102,\n    -22054,-22007,-21960,-21912,-21865,-21817,-21770,-21723,\n    -21675,-21628,-21580,-21533,-21485,-21438,-21390,-21343,\n    -21295,-21248,-21200,-21153,-21105,-21057,-21010,-20962,\n    -20915,-20867,-20819,-20772,-20724,-20676,-20629,-20581,\n    -20533,-20485,-20438,-20390,-20342,-20294,-20246,-20199,\n    -20151,-20103,-20055,-20007,-19959,-19912,-19864,-19816,\n    -19768,-19720,-19672,-19624,-19576,-19528,-19480,-19432,\n    -19384,-19336,-19288,-19240,-19192,-19144,-19096,-19048,\n    -19000,-18951,-18903,-18855,-18807,-18759,-18711,-18663,\n    -18614,-18566,-18518,-18470,-18421,-18373,-18325,-18277,\n    -18228,-18180,-18132,-18084,-18035,-17987,-17939,-17890,\n    -17842,-17793,-17745,-17697,-17648,-17600,-17551,-17503,\n    -17455,-17406,-17358,-17309,-17261,-17212,-17164,-17115,\n    -17067,-17018,-16970,-16921,-16872,-16824,-16775,-16727,\n    -16678,-16629,-16581,-16532,-16484,-16435,-16386,-16338,\n    -16289,-16240,-16191,-16143,-16094,-16045,-15997,-15948,\n    -15899,-15850,-15802,-15753,-15704,-15655,-15606,-15557,\n    -15509,-15460,-15411,-15362,-15313,-15264,-15215,-15167,\n    -15118,-15069,-15020,-14971,-14922,-14873,-14824,-14775,\n    -14726,-14677,-14628,-14579,-14530,-14481,-14432,-14383,\n    -14334,-14285,-14236,-14187,-14138,-14089,-14040,-13990,\n    -13941,-13892,-13843,-13794,-13745,-13696,-13647,-13597,\n    -13548,-13499,-13450,-13401,-13351,-13302,-13253,-13204,\n    -13154,-13105,-13056,-13007,-12957,-12908,-12859,-12810,\n    -12760,-12711,-12662,-12612,-12563,-12514,-12464,-12415,\n    -12366,-12316,-12267,-12217,-12168,-12119,-12069,-12020,\n    -11970,-11921,-11872,-11822,-11773,-11723,-11674,-11624,\n    -11575,-11525,-11476,-11426,-11377,-11327,-11278,-11228,\n    -11179,-11129,-11080,-11030,-10981,-10931,-10882,-10832,\n    -10782,-10733,-10683,-10634,-10584,-10534,-10485,-10435,\n    -10386,-10336,-10286,-10237,-10187,-10137,-10088,-10038,\n    -9988,-9939,-9889,-9839,-9790,-9740,-9690,-9640,\n    -9591,-9541,-9491,-9442,-9392,-9342,-9292,-9243,\n    -9193,-9143,-9093,-9043,-8994,-8944,-8894,-8844,\n    -8794,-8745,-8695,-8645,-8595,-8545,-8496,-8446,\n    -8396,-8346,-8296,-8246,-8196,-8147,-8097,-8047,\n    -7997,-7947,-7897,-7847,-7797,-7747,-7697,-7648,\n    -7598,-7548,-7498,-7448,-7398,-7348,-7298,-7248,\n    -7198,-7148,-7098,-7048,-6998,-6948,-6898,-6848,\n    -6798,-6748,-6698,-6648,-6598,-6548,-6498,-6448,\n    -6398,-6348,-6298,-6248,-6198,-6148,-6098,-6048,\n    -5998,-5948,-5898,-5848,-5798,-5747,-5697,-5647,\n    -5597,-5547,-5497,-5447,-5397,-5347,-5297,-5247,\n    -5197,-5146,-5096,-5046,-4996,-4946,-4896,-4846,\n    -4796,-4745,-4695,-4645,-4595,-4545,-4495,-4445,\n    -4394,-4344,-4294,-4244,-4194,-4144,-4093,-4043,\n    -3993,-3943,-3893,-3843,-3792,-3742,-3692,-3642,\n    -3592,-3541,-3491,-3441,-3391,-3341,-3291,-3240,\n    -3190,-3140,-3090,-3039,-2989,-2939,-2889,-2839,\n    -2788,-2738,-2688,-2638,-2588,-2537,-2487,-2437,\n    -2387,-2336,-2286,-2236,-2186,-2135,-2085,-2035,\n    -1985,-1934,-1884,-1834,-1784,-1733,-1683,-1633,\n    -1583,-1532,-1482,-1432,-1382,-1331,-1281,-1231,\n    -1181,-1130,-1080,-1030,-980,-929,-879,-829,\n    -779,-728,-678,-628,-578,-527,-477,-427,\n    -376,-326,-276,-226,-175,-125,-75,-25,\n    25,75,125,175,226,276,326,376,\n    427,477,527,578,628,678,728,779,\n    829,879,929,980,1030,1080,1130,1181,\n    1231,1281,1331,1382,1432,1482,1532,1583,\n    1633,1683,1733,1784,1834,1884,1934,1985,\n    2035,2085,2135,2186,2236,2286,2336,2387,\n    2437,2487,2537,2587,2638,2688,2738,2788,\n    2839,2889,2939,2989,3039,3090,3140,3190,\n    3240,3291,3341,3391,3441,3491,3542,3592,\n    3642,3692,3742,3792,3843,3893,3943,3993,\n    4043,4093,4144,4194,4244,4294,4344,4394,\n    4445,4495,4545,4595,4645,4695,4745,4796,\n    4846,4896,4946,4996,5046,5096,5146,5197,\n    5247,5297,5347,5397,5447,5497,5547,5597,\n    5647,5697,5747,5798,5848,5898,5948,5998,\n    6048,6098,6148,6198,6248,6298,6348,6398,\n    6448,6498,6548,6598,6648,6698,6748,6798,\n    6848,6898,6948,6998,7048,7098,7148,7198,\n    7248,7298,7348,7398,7448,7498,7548,7598,\n    7648,7697,7747,7797,7847,7897,7947,7997,\n    8047,8097,8147,8196,8246,8296,8346,8396,\n    8446,8496,8545,8595,8645,8695,8745,8794,\n    8844,8894,8944,8994,9043,9093,9143,9193,\n    9243,9292,9342,9392,9442,9491,9541,9591,\n    9640,9690,9740,9790,9839,9889,9939,9988,\n    10038,10088,10137,10187,10237,10286,10336,10386,\n    10435,10485,10534,10584,10634,10683,10733,10782,\n    10832,10882,10931,10981,11030,11080,11129,11179,\n    11228,11278,11327,11377,11426,11476,11525,11575,\n    11624,11674,11723,11773,11822,11872,11921,11970,\n    12020,12069,12119,12168,12218,12267,12316,12366,\n    12415,12464,12514,12563,12612,12662,12711,12760,\n    12810,12859,12908,12957,13007,13056,13105,13154,\n    13204,13253,13302,13351,13401,13450,13499,13548,\n    13597,13647,13696,13745,13794,13843,13892,13941,\n    13990,14040,14089,14138,14187,14236,14285,14334,\n    14383,14432,14481,14530,14579,14628,14677,14726,\n    14775,14824,14873,14922,14971,15020,15069,15118,\n    15167,15215,15264,15313,15362,15411,15460,15509,\n    15557,15606,15655,15704,15753,15802,15850,15899,\n    15948,15997,16045,16094,16143,16191,16240,16289,\n    16338,16386,16435,16484,16532,16581,16629,16678,\n    16727,16775,16824,16872,16921,16970,17018,17067,\n    17115,17164,17212,17261,17309,17358,17406,17455,\n    17503,17551,17600,17648,17697,17745,17793,17842,\n    17890,17939,17987,18035,18084,18132,18180,18228,\n    18277,18325,18373,18421,18470,18518,18566,18614,\n    18663,18711,18759,18807,18855,18903,18951,19000,\n    19048,19096,19144,19192,19240,19288,19336,19384,\n    19432,19480,19528,19576,19624,19672,19720,19768,\n    19816,19864,19912,19959,20007,20055,20103,20151,\n    20199,20246,20294,20342,20390,20438,20485,20533,\n    20581,20629,20676,20724,20772,20819,20867,20915,\n    20962,21010,21057,21105,21153,21200,21248,21295,\n    21343,21390,21438,21485,21533,21580,21628,21675,\n    21723,21770,21817,21865,21912,21960,22007,22054,\n    22102,22149,22196,22243,22291,22338,22385,22432,\n    22480,22527,22574,22621,22668,22716,22763,22810,\n    22857,22904,22951,22998,23045,23092,23139,23186,\n    23233,23280,23327,23374,23421,23468,23515,23562,\n    23609,23656,23703,23750,23796,23843,23890,23937,\n    23984,24030,24077,24124,24171,24217,24264,24311,\n    24357,24404,24451,24497,24544,24591,24637,24684,\n    24730,24777,24823,24870,24916,24963,25009,25056,\n    25102,25149,25195,25241,25288,25334,25381,25427,\n    25473,25520,25566,25612,25658,25705,25751,25797,\n    25843,25889,25936,25982,26028,26074,26120,26166,\n    26212,26258,26304,26350,26396,26442,26488,26534,\n    26580,26626,26672,26718,26764,26810,26856,26902,\n    26947,26993,27039,27085,27131,27176,27222,27268,\n    27313,27359,27405,27450,27496,27542,27587,27633,\n    27678,27724,27770,27815,27861,27906,27952,27997,\n    28042,28088,28133,28179,28224,28269,28315,28360,\n    28405,28451,28496,28541,28586,28632,28677,28722,\n    28767,28812,28858,28903,28948,28993,29038,29083,\n    29128,29173,29218,29263,29308,29353,29398,29443,\n    29488,29533,29577,29622,29667,29712,29757,29801,\n    29846,29891,29936,29980,30025,30070,30114,30159,\n    30204,30248,30293,30337,30382,30427,30471,30516,\n    30560,30604,30649,30693,30738,30782,30826,30871,\n    30915,30959,31004,31048,31092,31136,31181,31225,\n    31269,31313,31357,31402,31446,31490,31534,31578,\n    31622,31666,31710,31754,31798,31842,31886,31930,\n    31974,32017,32061,32105,32149,32193,32236,32280,\n    32324,32368,32411,32455,32499,32542,32586,32630,\n    32673,32717,32760,32804,32847,32891,32934,32978,\n    33021,33065,33108,33151,33195,33238,33281,33325,\n    33368,33411,33454,33498,33541,33584,33627,33670,\n    33713,33756,33799,33843,33886,33929,33972,34015,\n    34057,34100,34143,34186,34229,34272,34315,34358,\n    34400,34443,34486,34529,34571,34614,34657,34699,\n    34742,34785,34827,34870,34912,34955,34997,35040,\n    35082,35125,35167,35210,35252,35294,35337,35379,\n    35421,35464,35506,35548,35590,35633,35675,35717,\n    35759,35801,35843,35885,35927,35969,36011,36053,\n    36095,36137,36179,36221,36263,36305,36347,36388,\n    36430,36472,36514,36556,36597,36639,36681,36722,\n    36764,36805,36847,36889,36930,36972,37013,37055,\n    37096,37137,37179,37220,37262,37303,37344,37386,\n    37427,37468,37509,37551,37592,37633,37674,37715,\n    37756,37797,37838,37879,37920,37961,38002,38043,\n    38084,38125,38166,38207,38248,38288,38329,38370,\n    38411,38451,38492,38533,38573,38614,38655,38695,\n    38736,38776,38817,38857,38898,38938,38979,39019,\n    39059,39100,39140,39180,39221,39261,39301,39341,\n    39382,39422,39462,39502,39542,39582,39622,39662,\n    39702,39742,39782,39822,39862,39902,39942,39982,\n    40021,40061,40101,40141,40180,40220,40260,40299,\n    40339,40379,40418,40458,40497,40537,40576,40616,\n    40655,40695,40734,40773,40813,40852,40891,40931,\n    40970,41009,41048,41087,41127,41166,41205,41244,\n    41283,41322,41361,41400,41439,41478,41517,41556,\n    41595,41633,41672,41711,41750,41788,41827,41866,\n    41904,41943,41982,42020,42059,42097,42136,42174,\n    42213,42251,42290,42328,42366,42405,42443,42481,\n    42520,42558,42596,42634,42672,42711,42749,42787,\n    42825,42863,42901,42939,42977,43015,43053,43091,\n    43128,43166,43204,43242,43280,43317,43355,43393,\n    43430,43468,43506,43543,43581,43618,43656,43693,\n    43731,43768,43806,43843,43880,43918,43955,43992,\n    44029,44067,44104,44141,44178,44215,44252,44289,\n    44326,44363,44400,44437,44474,44511,44548,44585,\n    44622,44659,44695,44732,44769,44806,44842,44879,\n    44915,44952,44989,45025,45062,45098,45135,45171,\n    45207,45244,45280,45316,45353,45389,45425,45462,\n    45498,45534,45570,45606,45642,45678,45714,45750,\n    45786,45822,45858,45894,45930,45966,46002,46037,\n    46073,46109,46145,46180,46216,46252,46287,46323,\n    46358,46394,46429,46465,46500,46536,46571,46606,\n    46642,46677,46712,46747,46783,46818,46853,46888,\n    46923,46958,46993,47028,47063,47098,47133,47168,\n    47203,47238,47273,47308,47342,47377,47412,47446,\n    47481,47516,47550,47585,47619,47654,47688,47723,\n    47757,47792,47826,47861,47895,47929,47963,47998,\n    48032,48066,48100,48134,48168,48202,48237,48271,\n    48305,48338,48372,48406,48440,48474,48508,48542,\n    48575,48609,48643,48676,48710,48744,48777,48811,\n    48844,48878,48911,48945,48978,49012,49045,49078,\n    49112,49145,49178,49211,49244,49278,49311,49344,\n    49377,49410,49443,49476,49509,49542,49575,49608,\n    49640,49673,49706,49739,49771,49804,49837,49869,\n    49902,49935,49967,50000,50032,50064,50097,50129,\n    50162,50194,50226,50259,50291,50323,50355,50387,\n    50420,50452,50484,50516,50548,50580,50612,50644,\n    50675,50707,50739,50771,50803,50834,50866,50898,\n    50929,50961,50993,51024,51056,51087,51119,51150,\n    51182,51213,51244,51276,51307,51338,51369,51401,\n    51432,51463,51494,51525,51556,51587,51618,51649,\n    51680,51711,51742,51773,51803,51834,51865,51896,\n    51926,51957,51988,52018,52049,52079,52110,52140,\n    52171,52201,52231,52262,52292,52322,52353,52383,\n    52413,52443,52473,52503,52534,52564,52594,52624,\n    52653,52683,52713,52743,52773,52803,52832,52862,\n    52892,52922,52951,52981,53010,53040,53069,53099,\n    53128,53158,53187,53216,53246,53275,53304,53334,\n    53363,53392,53421,53450,53479,53508,53537,53566,\n    53595,53624,53653,53682,53711,53739,53768,53797,\n    53826,53854,53883,53912,53940,53969,53997,54026,\n    54054,54082,54111,54139,54167,54196,54224,54252,\n    54280,54309,54337,54365,54393,54421,54449,54477,\n    54505,54533,54560,54588,54616,54644,54672,54699,\n    54727,54755,54782,54810,54837,54865,54892,54920,\n    54947,54974,55002,55029,55056,55084,55111,55138,\n    55165,55192,55219,55246,55274,55300,55327,55354,\n    55381,55408,55435,55462,55489,55515,55542,55569,\n    55595,55622,55648,55675,55701,55728,55754,55781,\n    55807,55833,55860,55886,55912,55938,55965,55991,\n    56017,56043,56069,56095,56121,56147,56173,56199,\n    56225,56250,56276,56302,56328,56353,56379,56404,\n    56430,56456,56481,56507,56532,56557,56583,56608,\n    56633,56659,56684,56709,56734,56760,56785,56810,\n    56835,56860,56885,56910,56935,56959,56984,57009,\n    57034,57059,57083,57108,57133,57157,57182,57206,\n    57231,57255,57280,57304,57329,57353,57377,57402,\n    57426,57450,57474,57498,57522,57546,57570,57594,\n    57618,57642,57666,57690,57714,57738,57762,57785,\n    57809,57833,57856,57880,57903,57927,57950,57974,\n    57997,58021,58044,58067,58091,58114,58137,58160,\n    58183,58207,58230,58253,58276,58299,58322,58345,\n    58367,58390,58413,58436,58459,58481,58504,58527,\n    58549,58572,58594,58617,58639,58662,58684,58706,\n    58729,58751,58773,58795,58818,58840,58862,58884,\n    58906,58928,58950,58972,58994,59016,59038,59059,\n    59081,59103,59125,59146,59168,59190,59211,59233,\n    59254,59276,59297,59318,59340,59361,59382,59404,\n    59425,59446,59467,59488,59509,59530,59551,59572,\n    59593,59614,59635,59656,59677,59697,59718,59739,\n    59759,59780,59801,59821,59842,59862,59883,59903,\n    59923,59944,59964,59984,60004,60025,60045,60065,\n    60085,60105,60125,60145,60165,60185,60205,60225,\n    60244,60264,60284,60304,60323,60343,60363,60382,\n    60402,60421,60441,60460,60479,60499,60518,60537,\n    60556,60576,60595,60614,60633,60652,60671,60690,\n    60709,60728,60747,60766,60785,60803,60822,60841,\n    60859,60878,60897,60915,60934,60952,60971,60989,\n    61007,61026,61044,61062,61081,61099,61117,61135,\n    61153,61171,61189,61207,61225,61243,61261,61279,\n    61297,61314,61332,61350,61367,61385,61403,61420,\n    61438,61455,61473,61490,61507,61525,61542,61559,\n    61577,61594,61611,61628,61645,61662,61679,61696,\n    61713,61730,61747,61764,61780,61797,61814,61831,\n    61847,61864,61880,61897,61913,61930,61946,61963,\n    61979,61995,62012,62028,62044,62060,62076,62092,\n    62108,62125,62141,62156,62172,62188,62204,62220,\n    62236,62251,62267,62283,62298,62314,62329,62345,\n    62360,62376,62391,62407,62422,62437,62453,62468,\n    62483,62498,62513,62528,62543,62558,62573,62588,\n    62603,62618,62633,62648,62662,62677,62692,62706,\n    62721,62735,62750,62764,62779,62793,62808,62822,\n    62836,62850,62865,62879,62893,62907,62921,62935,\n    62949,62963,62977,62991,63005,63019,63032,63046,\n    63060,63074,63087,63101,63114,63128,63141,63155,\n    63168,63182,63195,63208,63221,63235,63248,63261,\n    63274,63287,63300,63313,63326,63339,63352,63365,\n    63378,63390,63403,63416,63429,63441,63454,63466,\n    63479,63491,63504,63516,63528,63541,63553,63565,\n    63578,63590,63602,63614,63626,63638,63650,63662,\n    63674,63686,63698,63709,63721,63733,63745,63756,\n    63768,63779,63791,63803,63814,63825,63837,63848,\n    63859,63871,63882,63893,63904,63915,63927,63938,\n    63949,63960,63971,63981,63992,64003,64014,64025,\n    64035,64046,64057,64067,64078,64088,64099,64109,\n    64120,64130,64140,64151,64161,64171,64181,64192,\n    64202,64212,64222,64232,64242,64252,64261,64271,\n    64281,64291,64301,64310,64320,64330,64339,64349,\n    64358,64368,64377,64387,64396,64405,64414,64424,\n    64433,64442,64451,64460,64469,64478,64487,64496,\n    64505,64514,64523,64532,64540,64549,64558,64566,\n    64575,64584,64592,64600,64609,64617,64626,64634,\n    64642,64651,64659,64667,64675,64683,64691,64699,\n    64707,64715,64723,64731,64739,64747,64754,64762,\n    64770,64777,64785,64793,64800,64808,64815,64822,\n    64830,64837,64844,64852,64859,64866,64873,64880,\n    64887,64895,64902,64908,64915,64922,64929,64936,\n    64943,64949,64956,64963,64969,64976,64982,64989,\n    64995,65002,65008,65015,65021,65027,65033,65040,\n    65046,65052,65058,65064,65070,65076,65082,65088,\n    65094,65099,65105,65111,65117,65122,65128,65133,\n    65139,65144,65150,65155,65161,65166,65171,65177,\n    65182,65187,65192,65197,65202,65207,65212,65217,\n    65222,65227,65232,65237,65242,65246,65251,65256,\n    65260,65265,65270,65274,65279,65283,65287,65292,\n    65296,65300,65305,65309,65313,65317,65321,65325,\n    65329,65333,65337,65341,65345,65349,65352,65356,\n    65360,65363,65367,65371,65374,65378,65381,65385,\n    65388,65391,65395,65398,65401,65404,65408,65411,\n    65414,65417,65420,65423,65426,65429,65431,65434,\n    65437,65440,65442,65445,65448,65450,65453,65455,\n    65458,65460,65463,65465,65467,65470,65472,65474,\n    65476,65478,65480,65482,65484,65486,65488,65490,\n    65492,65494,65496,65497,65499,65501,65502,65504,\n    65505,65507,65508,65510,65511,65513,65514,65515,\n    65516,65518,65519,65520,65521,65522,65523,65524,\n    65525,65526,65527,65527,65528,65529,65530,65530,\n    65531,65531,65532,65532,65533,65533,65534,65534,\n    65534,65535,65535,65535,65535,65535,65535,65535\n};\n\nconst fixed_t *finecosine = &finesine[FINEANGLES/4];\n\nconst angle_t tantoangle[2049] =\n{\n    0,333772,667544,1001315,1335086,1668857,2002626,2336395,\n    2670163,3003929,3337694,3671457,4005219,4338979,4672736,5006492,\n    5340245,5673995,6007743,6341488,6675230,7008968,7342704,7676435,\n    8010164,8343888,8677609,9011325,9345037,9678744,10012447,10346145,\n    10679838,11013526,11347209,11680887,12014558,12348225,12681885,13015539,\n    13349187,13682829,14016464,14350092,14683714,15017328,15350936,15684536,\n    16018129,16351714,16685291,17018860,17352422,17685974,18019518,18353054,\n    18686582,19020100,19353610,19687110,20020600,20354080,20687552,21021014,\n    21354466,21687906,22021338,22354758,22688168,23021568,23354956,23688332,\n    24021698,24355052,24688396,25021726,25355046,25688352,26021648,26354930,\n    26688200,27021456,27354702,27687932,28021150,28354356,28687548,29020724,\n    29353888,29687038,30020174,30353296,30686404,31019496,31352574,31685636,\n    32018684,32351718,32684734,33017736,33350722,33683692,34016648,34349584,\n    34682508,35015412,35348300,35681172,36014028,36346868,36679688,37012492,\n    37345276,37678044,38010792,38343524,38676240,39008936,39341612,39674272,\n    40006912,40339532,40672132,41004716,41337276,41669820,42002344,42334848,\n    42667332,42999796,43332236,43664660,43997060,44329444,44661800,44994140,\n    45326456,45658752,45991028,46323280,46655512,46987720,47319908,47652072,\n    47984212,48316332,48648428,48980500,49312548,49644576,49976580,50308556,\n    50640512,50972444,51304352,51636236,51968096,52299928,52631740,52963524,\n    53295284,53627020,53958728,54290412,54622068,54953704,55285308,55616888,\n    55948444,56279972,56611472,56942948,57274396,57605816,57937212,58268576,\n    58599916,58931228,59262512,59593768,59924992,60256192,60587364,60918508,\n    61249620,61580704,61911760,62242788,62573788,62904756,63235692,63566604,\n    63897480,64228332,64559148,64889940,65220696,65551424,65882120,66212788,\n    66543420,66874024,67204600,67535136,67865648,68196120,68526568,68856984,\n    69187360,69517712,69848024,70178304,70508560,70838776,71168960,71499112,\n    71829224,72159312,72489360,72819376,73149360,73479304,73809216,74139096,\n    74468936,74798744,75128520,75458264,75787968,76117632,76447264,76776864,\n    77106424,77435952,77765440,78094888,78424304,78753688,79083032,79412336,\n    79741608,80070840,80400032,80729192,81058312,81387392,81716432,82045440,\n    82374408,82703336,83032224,83361080,83689896,84018664,84347400,84676096,\n    85004760,85333376,85661952,85990488,86318984,86647448,86975864,87304240,\n    87632576,87960872,88289128,88617344,88945520,89273648,89601736,89929792,\n    90257792,90585760,90913688,91241568,91569408,91897200,92224960,92552672,\n    92880336,93207968,93535552,93863088,94190584,94518040,94845448,95172816,\n    95500136,95827416,96154648,96481832,96808976,97136080,97463136,97790144,\n    98117112,98444032,98770904,99097736,99424520,99751256,100077944,100404592,\n    100731192,101057744,101384248,101710712,102037128,102363488,102689808,103016080,\n    103342312,103668488,103994616,104320696,104646736,104972720,105298656,105624552,\n    105950392,106276184,106601928,106927624,107253272,107578872,107904416,108229920,\n    108555368,108880768,109206120,109531416,109856664,110181872,110507016,110832120,\n    111157168,111482168,111807112,112132008,112456856,112781648,113106392,113431080,\n    113755720,114080312,114404848,114729328,115053760,115378136,115702464,116026744,\n    116350960,116675128,116999248,117323312,117647320,117971272,118295176,118619024,\n    118942816,119266560,119590248,119913880,120237456,120560984,120884456,121207864,\n    121531224,121854528,122177784,122500976,122824112,123147200,123470224,123793200,\n    124116120,124438976,124761784,125084528,125407224,125729856,126052432,126374960,\n    126697424,127019832,127342184,127664472,127986712,128308888,128631008,128953072,\n    129275080,129597024,129918912,130240744,130562520,130884232,131205888,131527480,\n    131849016,132170496,132491912,132813272,133134576,133455816,133776992,134098120,\n    134419184,134740176,135061120,135382000,135702816,136023584,136344272,136664912,\n    136985488,137306016,137626464,137946864,138267184,138587456,138907664,139227808,\n    139547904,139867920,140187888,140507776,140827616,141147392,141467104,141786752,\n    142106336,142425856,142745312,143064720,143384048,143703312,144022512,144341664,\n    144660736,144979744,145298704,145617584,145936400,146255168,146573856,146892480,\n    147211040,147529536,147847968,148166336,148484640,148802880,149121056,149439152,\n    149757200,150075168,150393072,150710912,151028688,151346400,151664048,151981616,\n    152299136,152616576,152933952,153251264,153568496,153885680,154202784,154519824,\n    154836784,155153696,155470528,155787296,156104000,156420624,156737200,157053696,\n    157370112,157686480,158002768,158318976,158635136,158951216,159267232,159583168,\n    159899040,160214848,160530592,160846256,161161840,161477376,161792832,162108208,\n    162423520,162738768,163053952,163369040,163684080,163999040,164313936,164628752,\n    164943504,165258176,165572784,165887312,166201776,166516160,166830480,167144736,\n    167458912,167773008,168087040,168400992,168714880,169028688,169342432,169656096,\n    169969696,170283216,170596672,170910032,171223344,171536576,171849728,172162800,\n    172475808,172788736,173101600,173414384,173727104,174039728,174352288,174664784,\n    174977200,175289536,175601792,175913984,176226096,176538144,176850096,177161984,\n    177473792,177785536,178097200,178408784,178720288,179031728,179343088,179654368,\n    179965568,180276704,180587744,180898720,181209616,181520448,181831184,182141856,\n    182452448,182762960,183073408,183383760,183694048,184004240,184314368,184624416,\n    184934400,185244288,185554096,185863840,186173504,186483072,186792576,187102000,\n    187411344,187720608,188029808,188338912,188647936,188956896,189265760,189574560,\n    189883264,190191904,190500448,190808928,191117312,191425632,191733872,192042016,\n    192350096,192658096,192966000,193273840,193581584,193889264,194196848,194504352,\n    194811792,195119136,195426400,195733584,196040688,196347712,196654656,196961520,\n    197268304,197574992,197881616,198188144,198494592,198800960,199107248,199413456,\n    199719584,200025616,200331584,200637456,200943248,201248960,201554576,201860128,\n    202165584,202470960,202776256,203081456,203386592,203691632,203996592,204301472,\n    204606256,204910976,205215600,205520144,205824592,206128960,206433248,206737456,\n    207041584,207345616,207649568,207953424,208257216,208560912,208864512,209168048,\n    209471488,209774832,210078112,210381296,210684384,210987408,211290336,211593184,\n    211895936,212198608,212501184,212803680,213106096,213408432,213710672,214012816,\n    214314880,214616864,214918768,215220576,215522288,215823920,216125472,216426928,\n    216728304,217029584,217330784,217631904,217932928,218233856,218534704,218835472,\n    219136144,219436720,219737216,220037632,220337952,220638192,220938336,221238384,\n    221538352,221838240,222138032,222437728,222737344,223036880,223336304,223635664,\n    223934912,224234096,224533168,224832160,225131072,225429872,225728608,226027232,\n    226325776,226624240,226922608,227220880,227519056,227817152,228115168,228413088,\n    228710912,229008640,229306288,229603840,229901312,230198688,230495968,230793152,\n    231090256,231387280,231684192,231981024,232277760,232574416,232870960,233167440,\n    233463808,233760096,234056288,234352384,234648384,234944304,235240128,235535872,\n    235831504,236127056,236422512,236717888,237013152,237308336,237603424,237898416,\n    238193328,238488144,238782864,239077488,239372016,239666464,239960816,240255072,\n    240549232,240843312,241137280,241431168,241724960,242018656,242312256,242605776,\n    242899200,243192512,243485744,243778896,244071936,244364880,244657744,244950496,\n    245243168,245535744,245828224,246120608,246412912,246705104,246997216,247289216,\n    247581136,247872960,248164688,248456320,248747856,249039296,249330640,249621904,\n    249913056,250204128,250495088,250785968,251076736,251367424,251658016,251948512,\n    252238912,252529200,252819408,253109520,253399536,253689456,253979280,254269008,\n    254558640,254848176,255137632,255426976,255716224,256005376,256294432,256583392,\n    256872256,257161024,257449696,257738272,258026752,258315136,258603424,258891600,\n    259179696,259467696,259755600,260043392,260331104,260618704,260906224,261193632,\n    261480960,261768176,262055296,262342320,262629248,262916080,263202816,263489456,\n    263776000,264062432,264348784,264635024,264921168,265207216,265493168,265779024,\n    266064784,266350448,266636000,266921472,267206832,267492096,267777264,268062336,\n    268347312,268632192,268916960,269201632,269486208,269770688,270055072,270339360,\n    270623552,270907616,271191616,271475488,271759296,272042976,272326560,272610048,\n    272893440,273176736,273459936,273743040,274026048,274308928,274591744,274874432,\n    275157024,275439520,275721920,276004224,276286432,276568512,276850528,277132416,\n    277414240,277695936,277977536,278259040,278540448,278821728,279102944,279384032,\n    279665056,279945952,280226752,280507456,280788064,281068544,281348960,281629248,\n    281909472,282189568,282469568,282749440,283029248,283308960,283588544,283868032,\n    284147424,284426720,284705920,284985024,285264000,285542912,285821696,286100384,\n    286378976,286657440,286935840,287214112,287492320,287770400,288048384,288326240,\n    288604032,288881696,289159264,289436768,289714112,289991392,290268576,290545632,\n    290822592,291099456,291376224,291652896,291929440,292205888,292482272,292758528,\n    293034656,293310720,293586656,293862496,294138240,294413888,294689440,294964864,\n    295240192,295515424,295790560,296065600,296340512,296615360,296890080,297164704,\n    297439200,297713632,297987936,298262144,298536256,298810240,299084160,299357952,\n    299631648,299905248,300178720,300452128,300725408,300998592,301271680,301544640,\n    301817536,302090304,302362976,302635520,302908000,303180352,303452608,303724768,\n    303996800,304268768,304540608,304812320,305083968,305355520,305626944,305898272,\n    306169472,306440608,306711616,306982528,307253344,307524064,307794656,308065152,\n    308335552,308605856,308876032,309146112,309416096,309685984,309955744,310225408,\n    310494976,310764448,311033824,311303072,311572224,311841280,312110208,312379040,\n    312647776,312916416,313184960,313453376,313721696,313989920,314258016,314526016,\n    314793920,315061728,315329408,315597024,315864512,316131872,316399168,316666336,\n    316933408,317200384,317467232,317733984,318000640,318267200,318533632,318799968,\n    319066208,319332352,319598368,319864288,320130112,320395808,320661408,320926912,\n    321192320,321457632,321722816,321987904,322252864,322517760,322782528,323047200,\n    323311744,323576192,323840544,324104800,324368928,324632992,324896928,325160736,\n    325424448,325688096,325951584,326215008,326478304,326741504,327004608,327267584,\n    327530464,327793248,328055904,328318496,328580960,328843296,329105568,329367712,\n    329629760,329891680,330153536,330415264,330676864,330938400,331199808,331461120,\n    331722304,331983392,332244384,332505280,332766048,333026752,333287296,333547776,\n    333808128,334068384,334328544,334588576,334848512,335108352,335368064,335627712,\n    335887200,336146624,336405920,336665120,336924224,337183200,337442112,337700864,\n    337959552,338218112,338476576,338734944,338993184,339251328,339509376,339767296,\n    340025120,340282848,340540480,340797984,341055392,341312704,341569888,341826976,\n    342083968,342340832,342597600,342854272,343110848,343367296,343623648,343879904,\n    344136032,344392064,344648000,344903808,345159520,345415136,345670656,345926048,\n    346181344,346436512,346691616,346946592,347201440,347456224,347710880,347965440,\n    348219872,348474208,348728448,348982592,349236608,349490528,349744320,349998048,\n    350251648,350505152,350758528,351011808,351264992,351518048,351771040,352023872,\n    352276640,352529280,352781824,353034272,353286592,353538816,353790944,354042944,\n    354294880,354546656,354798368,355049952,355301440,355552800,355804096,356055264,\n    356306304,356557280,356808128,357058848,357309504,357560032,357810464,358060768,\n    358311008,358561088,358811104,359060992,359310784,359560480,359810048,360059520,\n    360308896,360558144,360807296,361056352,361305312,361554144,361802880,362051488,\n    362300032,362548448,362796736,363044960,363293056,363541024,363788928,364036704,\n    364284384,364531936,364779392,365026752,365274016,365521152,365768192,366015136,\n    366261952,366508672,366755296,367001792,367248192,367494496,367740704,367986784,\n    368232768,368478656,368724416,368970080,369215648,369461088,369706432,369951680,\n    370196800,370441824,370686752,370931584,371176288,371420896,371665408,371909792,\n    372154080,372398272,372642336,372886304,373130176,373373952,373617600,373861152,\n    374104608,374347936,374591168,374834304,375077312,375320224,375563040,375805760,\n    376048352,376290848,376533248,376775520,377017696,377259776,377501728,377743584,\n    377985344,378227008,378468544,378709984,378951328,379192544,379433664,379674688,\n    379915584,380156416,380397088,380637696,380878176,381118560,381358848,381599040,\n    381839104,382079072,382318912,382558656,382798304,383037856,383277280,383516640,\n    383755840,383994976,384233984,384472896,384711712,384950400,385188992,385427488,\n    385665888,385904160,386142336,386380384,386618368,386856224,387093984,387331616,\n    387569152,387806592,388043936,388281152,388518272,388755296,388992224,389229024,\n    389465728,389702336,389938816,390175200,390411488,390647680,390883744,391119712,\n    391355584,391591328,391826976,392062528,392297984,392533312,392768544,393003680,\n    393238720,393473632,393708448,393943168,394177760,394412256,394646656,394880960,\n    395115136,395349216,395583200,395817088,396050848,396284512,396518080,396751520,\n    396984864,397218112,397451264,397684288,397917248,398150080,398382784,398615424,\n    398847936,399080320,399312640,399544832,399776928,400008928,400240832,400472608,\n    400704288,400935872,401167328,401398720,401629984,401861120,402092192,402323136,\n    402553984,402784736,403015360,403245888,403476320,403706656,403936896,404167008,\n    404397024,404626944,404856736,405086432,405316032,405545536,405774912,406004224,\n    406233408,406462464,406691456,406920320,407149088,407377760,407606336,407834784,\n    408063136,408291392,408519520,408747584,408975520,409203360,409431072,409658720,\n    409886240,410113664,410340992,410568192,410795296,411022304,411249216,411476032,\n    411702720,411929312,412155808,412382176,412608480,412834656,413060736,413286720,\n    413512576,413738336,413964000,414189568,414415040,414640384,414865632,415090784,\n    415315840,415540800,415765632,415990368,416215008,416439552,416663968,416888288,\n    417112512,417336640,417560672,417784576,418008384,418232096,418455712,418679200,\n    418902624,419125920,419349120,419572192,419795200,420018080,420240864,420463552,\n    420686144,420908608,421130976,421353280,421575424,421797504,422019488,422241344,\n    422463104,422684768,422906336,423127776,423349120,423570400,423791520,424012576,\n    424233536,424454368,424675104,424895744,425116288,425336736,425557056,425777280,\n    425997408,426217440,426437376,426657184,426876928,427096544,427316064,427535488,\n    427754784,427974016,428193120,428412128,428631040,428849856,429068544,429287168,\n    429505664,429724064,429942368,430160576,430378656,430596672,430814560,431032352,\n    431250048,431467616,431685120,431902496,432119808,432336992,432554080,432771040,\n    432987936,433204736,433421408,433637984,433854464,434070848,434287104,434503296,\n    434719360,434935360,435151232,435367008,435582656,435798240,436013696,436229088,\n    436444352,436659520,436874592,437089568,437304416,437519200,437733856,437948416,\n    438162880,438377248,438591520,438805696,439019744,439233728,439447584,439661344,\n    439875008,440088576,440302048,440515392,440728672,440941824,441154880,441367872,\n    441580736,441793472,442006144,442218720,442431168,442643552,442855808,443067968,\n    443280032,443492000,443703872,443915648,444127296,444338880,444550336,444761696,\n    444972992,445184160,445395232,445606176,445817056,446027840,446238496,446449088,\n    446659552,446869920,447080192,447290400,447500448,447710432,447920320,448130112,\n    448339776,448549376,448758848,448968224,449177536,449386720,449595808,449804800,\n    450013664,450222464,450431168,450639776,450848256,451056640,451264960,451473152,\n    451681248,451889248,452097152,452304960,452512672,452720288,452927808,453135232,\n    453342528,453549760,453756864,453963904,454170816,454377632,454584384,454791008,\n    454997536,455203968,455410304,455616544,455822688,456028704,456234656,456440512,\n    456646240,456851904,457057472,457262912,457468256,457673536,457878688,458083744,\n    458288736,458493600,458698368,458903040,459107616,459312096,459516480,459720768,\n    459924960,460129056,460333056,460536960,460740736,460944448,461148064,461351584,\n    461554976,461758304,461961536,462164640,462367680,462570592,462773440,462976160,\n    463178816,463381344,463583776,463786144,463988384,464190560,464392608,464594560,\n    464796448,464998208,465199872,465401472,465602944,465804320,466005600,466206816,\n    466407904,466608896,466809824,467010624,467211328,467411936,467612480,467812896,\n    468013216,468213440,468413600,468613632,468813568,469013440,469213184,469412832,\n    469612416,469811872,470011232,470210528,470409696,470608800,470807776,471006688,\n    471205472,471404192,471602784,471801312,471999712,472198048,472396288,472594400,\n    472792448,472990400,473188256,473385984,473583648,473781216,473978688,474176064,\n    474373344,474570528,474767616,474964608,475161504,475358336,475555040,475751648,\n    475948192,476144608,476340928,476537184,476733312,476929376,477125344,477321184,\n    477516960,477712640,477908224,478103712,478299104,478494400,478689600,478884704,\n    479079744,479274656,479469504,479664224,479858880,480053408,480247872,480442240,\n    480636512,480830656,481024736,481218752,481412640,481606432,481800128,481993760,\n    482187264,482380704,482574016,482767264,482960416,483153472,483346432,483539296,\n    483732064,483924768,484117344,484309856,484502240,484694560,484886784,485078912,\n    485270944,485462880,485654720,485846464,486038144,486229696,486421184,486612576,\n    486803840,486995040,487186176,487377184,487568096,487758912,487949664,488140320,\n    488330880,488521312,488711712,488901984,489092160,489282240,489472256,489662176,\n    489851968,490041696,490231328,490420896,490610336,490799712,490988960,491178144,\n    491367232,491556224,491745120,491933920,492122656,492311264,492499808,492688256,\n    492876608,493064864,493253056,493441120,493629120,493817024,494004832,494192544,\n    494380160,494567712,494755136,494942496,495129760,495316928,495504000,495691008,\n    495877888,496064704,496251424,496438048,496624608,496811040,496997408,497183680,\n    497369856,497555936,497741920,497927840,498113632,498299360,498484992,498670560,\n    498856000,499041376,499226656,499411840,499596928,499781920,499966848,500151680,\n    500336416,500521056,500705600,500890080,501074464,501258752,501442944,501627040,\n    501811072,501995008,502178848,502362592,502546240,502729824,502913312,503096704,\n    503280000,503463232,503646368,503829408,504012352,504195200,504377984,504560672,\n    504743264,504925760,505108192,505290496,505472736,505654912,505836960,506018944,\n    506200832,506382624,506564320,506745952,506927488,507108928,507290272,507471552,\n    507652736,507833824,508014816,508195744,508376576,508557312,508737952,508918528,\n    509099008,509279392,509459680,509639904,509820032,510000064,510180000,510359872,\n    510539648,510719328,510898944,511078432,511257856,511437216,511616448,511795616,\n    511974688,512153664,512332576,512511392,512690112,512868768,513047296,513225792,\n    513404160,513582432,513760640,513938784,514116800,514294752,514472608,514650368,\n    514828064,515005664,515183168,515360608,515537952,515715200,515892352,516069440,\n    516246432,516423328,516600160,516776896,516953536,517130112,517306592,517482976,\n    517659264,517835488,518011616,518187680,518363648,518539520,518715296,518891008,\n    519066624,519242144,519417600,519592960,519768256,519943424,520118528,520293568,\n    520468480,520643328,520818112,520992800,521167392,521341888,521516320,521690656,\n    521864896,522039072,522213152,522387168,522561056,522734912,522908640,523082304,\n    523255872,523429376,523602784,523776096,523949312,524122464,524295552,524468512,\n    524641440,524814240,524986976,525159616,525332192,525504640,525677056,525849344,\n    526021568,526193728,526365792,526537760,526709632,526881440,527053152,527224800,\n    527396352,527567840,527739200,527910528,528081728,528252864,528423936,528594880,\n    528765760,528936576,529107296,529277920,529448480,529618944,529789344,529959648,\n    530129856,530300000,530470048,530640000,530809888,530979712,531149440,531319072,\n    531488608,531658080,531827488,531996800,532166016,532335168,532504224,532673184,\n    532842080,533010912,533179616,533348288,533516832,533685312,533853728,534022048,\n    534190272,534358432,534526496,534694496,534862400,535030240,535197984,535365632,\n    535533216,535700704,535868128,536035456,536202720,536369888,536536992,536704000,\n    536870912\n};\n\n// Now where did these came from?\nconst byte gammatable[5][256] =\n{\n    {\n        1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,\n        17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n        33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,\n        49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,\n        65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,\n        81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,\n        97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,\n        113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,\n        128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\n        144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,\n        160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,\n        176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,\n        192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,\n        208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,\n        224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,\n        240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255\n    },\n\n    {\n        2,4,5,7,8,10,11,12,14,15,16,18,19,20,21,23,\n        24,25,26,27,29,30,31,32,33,34,36,37,38,39,40,41,\n        42,44,45,46,47,48,49,50,51,52,54,55,56,57,58,59,\n        60,61,62,63,64,65,66,67,69,70,71,72,73,74,75,76,\n        77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n        93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,\n        109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,\n        125,126,127,128,129,129,130,131,132,133,134,135,136,137,138,139,\n        140,141,142,143,144,145,146,147,148,148,149,150,151,152,153,154,\n        155,156,157,158,159,160,161,162,163,163,164,165,166,167,168,169,\n        170,171,172,173,174,175,175,176,177,178,179,180,181,182,183,184,\n        185,186,186,187,188,189,190,191,192,193,194,195,196,196,197,198,\n        199,200,201,202,203,204,205,205,206,207,208,209,210,211,212,213,\n        214,214,215,216,217,218,219,220,221,222,222,223,224,225,226,227,\n        228,229,230,230,231,232,233,234,235,236,237,237,238,239,240,241,\n        242,243,244,245,245,246,247,248,249,250,251,252,252,253,254,255\n    },\n\n    {\n        4,7,9,11,13,15,17,19,21,22,24,26,27,29,30,32,\n        33,35,36,38,39,40,42,43,45,46,47,48,50,51,52,54,\n        55,56,57,59,60,61,62,63,65,66,67,68,69,70,72,73,\n        74,75,76,77,78,79,80,82,83,84,85,86,87,88,89,90,\n        91,92,93,94,95,96,97,98,100,101,102,103,104,105,106,107,\n        108,109,110,111,112,113,114,114,115,116,117,118,119,120,121,122,\n        123,124,125,126,127,128,129,130,131,132,133,133,134,135,136,137,\n        138,139,140,141,142,143,144,144,145,146,147,148,149,150,151,152,\n        153,153,154,155,156,157,158,159,160,160,161,162,163,164,165,166,\n        166,167,168,169,170,171,172,172,173,174,175,176,177,178,178,179,\n        180,181,182,183,183,184,185,186,187,188,188,189,190,191,192,193,\n        193,194,195,196,197,197,198,199,200,201,201,202,203,204,205,206,\n        206,207,208,209,210,210,211,212,213,213,214,215,216,217,217,218,\n        219,220,221,221,222,223,224,224,225,226,227,228,228,229,230,231,\n        231,232,233,234,235,235,236,237,238,238,239,240,241,241,242,243,\n        244,244,245,246,247,247,248,249,250,251,251,252,253,254,254,255\n    },\n\n    {\n        8,12,16,19,22,24,27,29,31,34,36,38,40,41,43,45,\n        47,49,50,52,53,55,57,58,60,61,63,64,65,67,68,70,\n        71,72,74,75,76,77,79,80,81,82,84,85,86,87,88,90,\n        91,92,93,94,95,96,98,99,100,101,102,103,104,105,106,107,\n        108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,\n        124,125,126,127,128,129,130,131,132,133,134,135,135,136,137,138,\n        139,140,141,142,143,143,144,145,146,147,148,149,150,150,151,152,\n        153,154,155,155,156,157,158,159,160,160,161,162,163,164,165,165,\n        166,167,168,169,169,170,171,172,173,173,174,175,176,176,177,178,\n        179,180,180,181,182,183,183,184,185,186,186,187,188,189,189,190,\n        191,192,192,193,194,195,195,196,197,197,198,199,200,200,201,202,\n        202,203,204,205,205,206,207,207,208,209,210,210,211,212,212,213,\n        214,214,215,216,216,217,218,219,219,220,221,221,222,223,223,224,\n        225,225,226,227,227,228,229,229,230,231,231,232,233,233,234,235,\n        235,236,237,237,238,238,239,240,240,241,242,242,243,244,244,245,\n        246,246,247,247,248,249,249,250,251,251,252,253,253,254,254,255\n    },\n\n\n    {\n        16,23,28,32,36,39,42,45,48,50,53,55,57,60,62,64,\n        66,68,69,71,73,75,76,78,80,81,83,84,86,87,89,90,\n        92,93,94,96,97,98,100,101,102,103,105,106,107,108,109,110,\n        112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,128,\n        128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\n        143,144,145,146,147,148,149,150,150,151,152,153,154,155,155,156,\n        157,158,159,159,160,161,162,163,163,164,165,166,166,167,168,169,\n        169,170,171,172,172,173,174,175,175,176,177,177,178,179,180,180,\n        181,182,182,183,184,184,185,186,187,187,188,189,189,190,191,191,\n        192,193,193,194,195,195,196,196,197,198,198,199,200,200,201,202,\n        202,203,203,204,205,205,206,207,207,208,208,209,210,210,211,211,\n        212,213,213,214,214,215,216,216,217,217,218,219,219,220,220,221,\n        221,222,223,223,224,224,225,225,226,227,227,228,228,229,229,230,\n        230,231,232,232,233,233,234,234,235,235,236,236,237,237,238,239,\n        239,240,240,241,241,242,242,243,243,244,244,245,245,246,246,247,\n        247,248,248,249,249,250,250,251,251,252,252,253,254,254,255,255\n    }\n};\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tDisk load indicator.\n//\n\n#include \"doomtype.h\"\n#include \"deh_str.h\"\n#include \"i_swap.h\"\n#include \"i_video.h\"\n#include \"m_argv.h\"\n#include \"v_video.h\"\n#include \"w_wad.h\"\n#include \"z_zone.h\"\n\n#include \"v_diskicon.h\"\n\n// Only display the disk icon if more then this much bytes have been read\n// during the previous tic.\n\nstatic const int diskicon_threshold = 20*1024;\n\n// Two buffers: disk_data contains the data representing the disk icon\n// (raw, not a patch_t) while saved_background is an equivalently-sized\n// buffer where we save the background data while the disk is on screen.\nstatic pixel_t *disk_data;\nstatic pixel_t *saved_background;\n\nstatic int loading_disk_xoffs = 0;\nstatic int loading_disk_yoffs = 0;\n\n// Number of bytes read since the last call to V_DrawDiskIcon().\nstatic size_t recent_bytes_read = 0;\nstatic boolean disk_drawn;\n\nstatic void CopyRegion(pixel_t *dest, int dest_pitch,\n                       pixel_t *src, int src_pitch,\n                       int w, int h)\n{\n    pixel_t *s, *d;\n    int y;\n\n    s = src; d = dest;\n    for (y = 0; y < h; ++y)\n    {\n        memcpy(d, s, w * sizeof(*d));\n        s += src_pitch;\n        d += dest_pitch;\n    }\n}\n\nstatic void SaveDiskData(const char *disk_lump, int xoffs, int yoffs)\n{\n    pixel_t *tmpscreen;\n    patch_t *disk;\n\n    // Allocate a complete temporary screen where we'll draw the patch.\n    tmpscreen = Z_Malloc(SCREENWIDTH * SCREENHEIGHT * sizeof(*tmpscreen),\n                         PU_STATIC, NULL);\n    memset(tmpscreen, 0, SCREENWIDTH * SCREENHEIGHT * sizeof(*tmpscreen));\n    V_UseBuffer(tmpscreen);\n\n    // Buffer where we'll save the disk data.\n    disk_data = Z_Malloc(LOADING_DISK_W * LOADING_DISK_H * sizeof(*disk_data),\n                         PU_STATIC, NULL);\n\n    // Draw the patch and save the result to disk_data.\n    disk = W_CacheLumpName(disk_lump, PU_STATIC);\n    V_DrawPatch(loading_disk_xoffs, loading_disk_yoffs, disk);\n    CopyRegion(disk_data, LOADING_DISK_W,\n               tmpscreen + yoffs * SCREENWIDTH + xoffs, SCREENWIDTH,\n               LOADING_DISK_W, LOADING_DISK_H);\n    W_ReleaseLumpName(disk_lump);\n\n    V_RestoreBuffer();\n    Z_Free(tmpscreen);\n}\n\nvoid V_EnableLoadingDisk(const char *lump_name, int xoffs, int yoffs)\n{\n    loading_disk_xoffs = xoffs;\n    loading_disk_yoffs = yoffs;\n\n    saved_background = Z_Malloc(LOADING_DISK_W * LOADING_DISK_H\n                                 * sizeof(*saved_background),\n                                PU_STATIC, NULL);\n    SaveDiskData(lump_name, xoffs, yoffs);\n}\n\nvoid V_BeginRead(size_t nbytes)\n{\n    recent_bytes_read += nbytes;\n}\n\nstatic pixel_t *DiskRegionPointer(void)\n{\n    return I_VideoBuffer\n         + loading_disk_yoffs * SCREENWIDTH\n         + loading_disk_xoffs;\n}\n\nvoid V_DrawDiskIcon(void)\n{\n    if (disk_data != NULL && recent_bytes_read > diskicon_threshold)\n    {\n        // Save the background behind the disk before we draw it.\n        CopyRegion(saved_background, LOADING_DISK_W,\n                   DiskRegionPointer(), SCREENWIDTH,\n                   LOADING_DISK_W, LOADING_DISK_H);\n\n        // Write the disk to the screen buffer.\n        CopyRegion(DiskRegionPointer(), SCREENWIDTH,\n                   disk_data, LOADING_DISK_W,\n                   LOADING_DISK_W, LOADING_DISK_H);\n        disk_drawn = true;\n    }\n\n    recent_bytes_read = 0;\n}\n\nvoid V_RestoreDiskBackground(void)\n{\n    if (disk_drawn)\n    {\n        // Restore the background.\n        CopyRegion(DiskRegionPointer(), SCREENWIDTH,\n                   saved_background, LOADING_DISK_W,\n                   LOADING_DISK_W, LOADING_DISK_H);\n\n        disk_drawn = false;\n    }\n}\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n// Copyright(C) 2014 Fabian Greffrath, Paul Haeberli\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Color translation tables\n//\n\n#include <math.h>\n\n#include \"doomtype.h\"\n#include \"v_trans.h\"\n\n// [crispy] here used to be static color translation tables based on\n// the ones found in Boom and MBF. Nowadays these are recalculated\n// by means of actual color space conversions in r_data:R_InitColormaps().\n\n// this one will be the identity matrix\nstatic byte cr_none[256];\n// this one will be the ~50% darker matrix\nstatic byte cr_dark[256];\nstatic byte cr_gray[256];\nstatic byte cr_green[256];\nstatic byte cr_gold[256];\nstatic byte cr_red[256];\nstatic byte cr_blue[256];\n\nstatic const byte cr_red2blue[256] =\n    {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n     16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n     32,33,34,35,36,37,38,39,40,41,42,43,207,207,46,207,\n     48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n     64,65,66,207,68,69,70,71,72,73,74,75,76,77,78,79,\n     80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,\n     96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,\n     112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,\n     128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\n     144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,\n     160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,\n     200,200,201,201,202,202,203,203,204,204,205,205,206,206,207,207,\n     192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,\n     208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,\n     224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,\n     240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255};\n\nstatic const byte cr_red2green[256] =\n    {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n     16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n     32,33,34,35,36,37,38,39,40,41,42,43,127,127,46,127,\n     48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n     64,65,66,127,68,69,70,71,72,73,74,75,76,77,78,79,\n     80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,\n     96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,\n     112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,\n     128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\n     144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,\n     160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,\n     114,115,116,117,118,119,120,121,122,123,124,125,126,126,127,127,\n     192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,\n     208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,\n     224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,\n     240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255};\n\nbyte *cr[] =\n{\n    (byte *) &cr_none,\n    (byte *) &cr_dark,\n    (byte *) &cr_gray,\n    (byte *) &cr_green,\n    (byte *) &cr_gold,\n    (byte *) &cr_red,\n    (byte *) &cr_blue,\n    (byte *) &cr_red2blue,\n    (byte *) &cr_red2green\n};\n\nchar **crstr = 0;\n\n/*\nDate: Sun, 26 Oct 2014 10:36:12 -0700\nFrom: paul haeberli <paulhaeberli@yahoo.com>\nSubject: Re: colors and color conversions\nTo: Fabian Greffrath <fabian@greffrath.com>\n\nYes, this seems exactly like the solution I was looking for. I just\ncouldn't find code to do the HSV->RGB conversion. Speaking of the code,\nwould you allow me to use this code in my software? The Doom source code\nis licensed under the GNU GPL, so this code yould have to be under a\ncompatible license.\n\n    Yes. I'm happy to contribute this code to your project.  GNU GPL or anything\n    compatible sounds fine.\n\nRegarding the conversions, the procedure you sent me will leave grays\n(r=g=b) untouched, no matter what I set as HUE, right? Is it possible,\nthen, to also use this routine to convert colors *to* gray?\n\n    You can convert any color to an equivalent grey by setting the saturation\n    to 0.0\n\n\n    - Paul Haeberli\n*/\n\n#define CTOLERANCE      (0.0001)\n\ntypedef struct vect {\n    float x;\n    float y;\n    float z;\n} vect;\n\nstatic void hsv_to_rgb(vect *hsv, vect *rgb)\n{\n    float h, s, v;\n\n    h = hsv->x;\n    s = hsv->y;\n    v = hsv->z;\n    h *= 360.0;\n    if (s<CTOLERANCE) {\n        rgb->x = v;\n        rgb->y = v;\n        rgb->z = v;\n    } else {\n        int i;\n        float f, p, q, t;\n\n        if (h>=360.0)\n            h  -= 360.0;\n        h /= 60.0;\n        i = floor(h);\n        f = h - i;\n        p = v*(1.0-s);\n        q = v*(1.0-(s*f));\n        t = v*(1.0-(s*(1.0-f)));\n        switch (i) {\n            case 0 :\n                rgb->x = v;\n                rgb->y = t;\n                rgb->z = p;\n                break;\n            case 1 :\n                rgb->x = q;\n                rgb->y = v;\n                rgb->z = p;\n                break;\n            case 2 :\n                rgb->x = p;\n                rgb->y = v;\n                rgb->z = t;\n                break;\n            case 3 :\n                rgb->x = p;\n                rgb->y = q;\n                rgb->z = v;\n                break;\n            case 4 :\n                rgb->x = t;\n                rgb->y = p;\n                rgb->z = v;\n                break;\n            case 5 :\n                rgb->x = v;\n                rgb->y = p;\n                rgb->z = q;\n                break;\n        }\n    }\n}\n\nstatic void rgb_to_hsv(vect *rgb, vect *hsv)\n{\n    float h, s, v;\n    float cmax, cmin;\n    float r, g, b;\n\n    r = rgb->x;\n    g = rgb->y;\n    b = rgb->z;\n    /* find the cmax and cmin of r g b */\n    cmax = r;\n    cmin = r;\n    cmax = (g>cmax ? g:cmax);\n    cmin = (g<cmin ? g:cmin);\n    cmax = (b>cmax ? b:cmax);\n    cmin = (b<cmin ? b:cmin);\n    v = cmax;           /* value */\n    if (cmax>CTOLERANCE)\n        s = (cmax - cmin)/cmax;\n    else {\n        s = 0.0;\n        h = 0.0;\n    }\n    if (s<CTOLERANCE)\n        h = 0.0;\n    else {\n        float cdelta;\n        float rc, gc, bc;\n\n        cdelta = cmax-cmin;\n        rc = (cmax-r)/cdelta;\n        gc = (cmax-g)/cdelta;\n        bc = (cmax-b)/cdelta;\n        if (r==cmax)\n            h = bc-gc;\n        else\n            if (g==cmax)\n                h = 2.0+rc-bc;\n            else\n                h = 4.0+gc-rc;\n        h = h*60.0;\n        if (h<0.0)\n            h += 360.0;\n    }\n    hsv->x = h/360.0;\n    hsv->y = s;\n    hsv->z = v;\n}\n\n// [crispy] copied over from i_video.c\nstatic int I_GetPaletteIndex2(byte *palette, int r, int g, int b)\n{\n    int best, best_diff, diff;\n    int i;\n\n    best = 0; best_diff = INT_MAX;\n\n    for (i = 0; i < 256; ++i)\n    {\n        diff = (r - palette[3 * i + 0]) * (r - palette[3 * i + 0])\n             + (g - palette[3 * i + 1]) * (g - palette[3 * i + 1])\n             + (b - palette[3 * i + 2]) * (b - palette[3 * i + 2]);\n\n        if (diff < best_diff)\n        {\n            best = i;\n            best_diff = diff;\n        }\n\n        if (diff == 0)\n        {\n            break;\n        }\n    }\n\n    return best;\n}\n\nbyte V_Colorize (byte *playpal, int cr, byte source, boolean keepgray109)\n{\n    vect rgb, hsv;\n\n    // [crispy] preserve gray drop shadow in IWAD status bar numbers\n    if (cr == CR_NONE || (keepgray109 && source == 109))\n\treturn source;\n\n    rgb.x = playpal[3 * source + 0] / 255.;\n    rgb.y = playpal[3 * source + 1] / 255.;\n    rgb.z = playpal[3 * source + 2] / 255.;\n\n    rgb_to_hsv(&rgb, &hsv);\n\n    if (cr == CR_DARK)\n\thsv.z *= 0.5;\n    else\n    if (cr == CR_GRAY)\n\thsv.y = 0;\n    else\n    {\n\t// [crispy] hack colors to full saturation\n\thsv.y = 1.0;\n\n\tif (cr == CR_GREEN)\n\t{\n\t    hsv.x = 135./360.;\n\t}\n\telse\n\tif (cr == CR_GOLD)\n\t{\n\t    hsv.x = 45./360.;\n\t}\n\telse\n\tif (cr == CR_RED)\n\t{\n\t    hsv.x = 0.;\n\t}\n\telse\n\tif (cr == CR_BLUE)\n\t{\n\t    hsv.x = 240./360.;\n\t}\n    }\n\n    hsv_to_rgb(&hsv, &rgb);\n\n    rgb.x *= 255.;\n    rgb.y *= 255.;\n    rgb.z *= 255.;\n\n    return I_GetPaletteIndex2(playpal, (int) rgb.x, (int) rgb.y, (int) rgb.z);\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tMoving object handling. Spawn functions.\n//\n\n#include <stdio.h>\n\n#include \"i_system.h\"\n#include \"z_zone.h\"\n#include \"m_random.h\"\n\n#include \"doomdef.h\"\n#include \"p_local.h\"\n#include \"sounds.h\"\n\n#include \"st_stuff.h\"\n#include \"hu_stuff.h\"\n\n#include \"s_sound.h\"\n\n#include \"doomstat.h\"\n\n\nvoid G_PlayerReborn (int player);\nvoid P_SpawnMapThing (mapthing_t*\tmthing);\n\n\n//\n// P_SetMobjState\n// Returns true if the mobj is still present.\n//\nint test;\n\n// Use a heuristic approach to detect infinite state cycles: Count the number\n// of times the loop in P_SetMobjState() executes and exit with an error once\n// an arbitrary very large limit is reached.\n\n#define MOBJ_CYCLE_LIMIT 1000000\n\nboolean\nP_SetMobjState\n( mobj_t*\tmobj,\n  statenum_t\tstate )\n{\n    state_t*\tst;\n    int\tcycle_counter = 0;\n\n    do\n    {\n\tif (state == S_NULL)\n\t{\n\t    mobj->state = (state_t *) S_NULL;\n\t    P_RemoveMobj (mobj);\n\t    return false;\n\t}\n\n\tst = &states[state];\n\tmobj->state = st;\n\tmobj->tics = st->tics;\n\tmobj->sprite = st->sprite;\n\tmobj->frame = st->frame;\n\n\t// Modified handling.\n\t// Call action functions when the state is set\n\tif (st->action.acp1)\t\t\n\t    st->action.acp1(mobj);\t\n\t\n\tstate = st->nextstate;\n\n\tif (cycle_counter++ > MOBJ_CYCLE_LIMIT)\n\t{\n\t    I_Error(\"P_SetMobjState: Infinite state cycle detected!\");\n\t}\n    } while (!mobj->tics);\n\t\t\t\t\n    return true;\n}\n\n\n//\n// P_ExplodeMissile  \n//\nvoid P_ExplodeMissile (mobj_t* mo)\n{\n    mo->momx = mo->momy = mo->momz = 0;\n\n    P_SetMobjState (mo, mobjinfo[mo->type].deathstate);\n\n    mo->tics -= P_Random()&3;\n\n    if (mo->tics < 1)\n\tmo->tics = 1;\n\n    mo->flags &= ~MF_MISSILE;\n\n    if (mo->info->deathsound)\n\tS_StartSound (mo, mo->info->deathsound);\n}\n\n\n//\n// P_XYMovement  \n//\n#define STOPSPEED\t\t0x1000\n#define FRICTION\t\t0xe800\n\nvoid P_XYMovement (mobj_t* mo) \n{ \t\n    fixed_t \tptryx;\n    fixed_t\tptryy;\n    player_t*\tplayer;\n    fixed_t\txmove;\n    fixed_t\tymove;\n\t\t\t\n    if (!mo->momx && !mo->momy)\n    {\n\tif (mo->flags & MF_SKULLFLY)\n\t{\n\t    // the skull slammed into something\n\t    mo->flags &= ~MF_SKULLFLY;\n\t    mo->momx = mo->momy = mo->momz = 0;\n\n\t    P_SetMobjState (mo, mo->info->spawnstate);\n\t}\n\treturn;\n    }\n\t\n    player = mo->player;\n\t\t\n    if (mo->momx > MAXMOVE)\n\tmo->momx = MAXMOVE;\n    else if (mo->momx < -MAXMOVE)\n\tmo->momx = -MAXMOVE;\n\n    if (mo->momy > MAXMOVE)\n\tmo->momy = MAXMOVE;\n    else if (mo->momy < -MAXMOVE)\n\tmo->momy = -MAXMOVE;\n\t\t\n    xmove = mo->momx;\n    ymove = mo->momy;\n\t\n    do\n    {\n\tif (xmove > MAXMOVE/2 || ymove > MAXMOVE/2)\n\t{\n\t    ptryx = mo->x + xmove/2;\n\t    ptryy = mo->y + ymove/2;\n\t    xmove >>= 1;\n\t    ymove >>= 1;\n\t}\n\telse\n\t{\n\t    ptryx = mo->x + xmove;\n\t    ptryy = mo->y + ymove;\n\t    xmove = ymove = 0;\n\t}\n\t\t\n\tif (!P_TryMove (mo, ptryx, ptryy))\n\t{\n\t    // blocked move\n\t    if (mo->player)\n\t    {\t// try to slide along it\n\t\tP_SlideMove (mo);\n\t    }\n\t    else if (mo->flags & MF_MISSILE)\n\t    {\n\t\t// explode a missile\n\t\tif (ceilingline &&\n\t\t    ceilingline->backsector &&\n\t\t    ceilingline->backsector->ceilingpic == skyflatnum)\n\t\t{\n\t\t    // Hack to prevent missiles exploding\n\t\t    // against the sky.\n\t\t    // Does not handle sky floors.\n\t\t    P_RemoveMobj (mo);\n\t\t    return;\n\t\t}\n\t\tP_ExplodeMissile (mo);\n\t    }\n\t    else\n\t\tmo->momx = mo->momy = 0;\n\t}\n    } while (xmove || ymove);\n    \n    // slow down\n    if (player && player->cheats & CF_NOMOMENTUM)\n    {\n\t// debug option for no sliding at all\n\tmo->momx = mo->momy = 0;\n\treturn;\n    }\n\n    if (mo->flags & (MF_MISSILE | MF_SKULLFLY) )\n\treturn; \t// no friction for missiles ever\n\t\t\n    if (mo->z > mo->floorz)\n\treturn;\t\t// no friction when airborne\n\n    if (mo->flags & MF_CORPSE)\n    {\n\t// do not stop sliding\n\t//  if halfway off a step with some momentum\n\tif (mo->momx > FRACUNIT/4\n\t    || mo->momx < -FRACUNIT/4\n\t    || mo->momy > FRACUNIT/4\n\t    || mo->momy < -FRACUNIT/4)\n\t{\n\t    if (mo->floorz != mo->subsector->sector->floorheight)\n\t\treturn;\n\t}\n    }\n\n    if (mo->momx > -STOPSPEED\n\t&& mo->momx < STOPSPEED\n\t&& mo->momy > -STOPSPEED\n\t&& mo->momy < STOPSPEED\n\t&& (!player\n\t    || (player->cmd.forwardmove== 0\n\t\t&& player->cmd.sidemove == 0 ) ) )\n    {\n\t// if in a walking frame, stop moving\n\tif ( player&&(unsigned)((player->mo->state - states)- S_PLAY_RUN1) < 4)\n\t    P_SetMobjState (player->mo, S_PLAY);\n\t\n\tmo->momx = 0;\n\tmo->momy = 0;\n    }\n    else\n    {\n\tmo->momx = FixedMul (mo->momx, FRICTION);\n\tmo->momy = FixedMul (mo->momy, FRICTION);\n    }\n}\n\n//\n// P_ZMovement\n//\nvoid P_ZMovement (mobj_t* mo)\n{\n    fixed_t\tdist;\n    fixed_t\tdelta;\n    \n    // check for smooth step up\n    if (mo->player && mo->z < mo->floorz)\n    {\n\tmo->player->viewheight -= mo->floorz-mo->z;\n\n\tmo->player->deltaviewheight\n\t    = (VIEWHEIGHT - mo->player->viewheight)>>3;\n    }\n    \n    // adjust height\n    mo->z += mo->momz;\n\t\n    if ( mo->flags & MF_FLOAT\n\t && mo->target)\n    {\n\t// float down towards target if too close\n\tif ( !(mo->flags & MF_SKULLFLY)\n\t     && !(mo->flags & MF_INFLOAT) )\n\t{\n\t    dist = P_AproxDistance (mo->x - mo->target->x,\n\t\t\t\t    mo->y - mo->target->y);\n\t    \n\t    delta =(mo->target->z + (mo->height>>1)) - mo->z;\n\n\t    if (delta<0 && dist < -(delta*3) )\n\t\tmo->z -= FLOATSPEED;\n\t    else if (delta>0 && dist < (delta*3) )\n\t\tmo->z += FLOATSPEED;\t\t\t\n\t}\n\t\n    }\n    \n    // clip movement\n    if (mo->z <= mo->floorz)\n    {\n\t// hit the floor\n\n\t// Note (id):\n\t//  somebody left this after the setting momz to 0,\n\t//  kinda useless there.\n\t//\n\t// cph - This was the a bug in the linuxdoom-1.10 source which\n\t//  caused it not to sync Doom 2 v1.9 demos. Someone\n\t//  added the above comment and moved up the following code. So\n\t//  demos would desync in close lost soul fights.\n\t// Note that this only applies to original Doom 1 or Doom2 demos - not\n\t//  Final Doom and Ultimate Doom.  So we test demo_compatibility *and*\n\t//  gamemission. (Note we assume that Doom1 is always Ult Doom, which\n\t//  seems to hold for most published demos.)\n        //  \n        //  fraggle - cph got the logic here slightly wrong.  There are three\n        //  versions of Doom 1.9:\n        //\n        //  * The version used in registered doom 1.9 + doom2 - no bounce\n        //  * The version used in ultimate doom - has bounce\n        //  * The version used in final doom - has bounce\n        //\n        // So we need to check that this is either retail or commercial\n        // (but not doom2)\n\t\n\tint correct_lost_soul_bounce = gameversion >= exe_ultimate;\n\n\tif (correct_lost_soul_bounce && mo->flags & MF_SKULLFLY)\n\t{\n\t    // the skull slammed into something\n\t    mo->momz = -mo->momz;\n\t}\n\t\n\tif (mo->momz < 0)\n\t{\n\t    if (mo->player\n\t\t&& mo->momz < -GRAVITY*8)\t\n\t    {\n\t\t// Squat down.\n\t\t// Decrease viewheight for a moment\n\t\t// after hitting the ground (hard),\n\t\t// and utter appropriate sound.\n\t\tmo->player->deltaviewheight = mo->momz>>3;\n\t\tS_StartSound (mo, sfx_oof);\n\t    }\n\t    mo->momz = 0;\n\t}\n\tmo->z = mo->floorz;\n\n\n\t// cph 2001/05/26 -\n\t// See lost soul bouncing comment above. We need this here for bug\n\t// compatibility with original Doom2 v1.9 - if a soul is charging and\n\t// hit by a raising floor this incorrectly reverses its Y momentum.\n\t//\n\n        if (!correct_lost_soul_bounce && mo->flags & MF_SKULLFLY)\n            mo->momz = -mo->momz;\n\n\tif ( (mo->flags & MF_MISSILE)\n\t     && !(mo->flags & MF_NOCLIP) )\n\t{\n\t    P_ExplodeMissile (mo);\n\t    return;\n\t}\n    }\n    else if (! (mo->flags & MF_NOGRAVITY) )\n    {\n\tif (mo->momz == 0)\n\t    mo->momz = -GRAVITY*2;\n\telse\n\t    mo->momz -= GRAVITY;\n    }\n\t\n    if (mo->z + mo->height > mo->ceilingz)\n    {\n\t// hit the ceiling\n\tif (mo->momz > 0)\n\t    mo->momz = 0;\n\t{\n\t    mo->z = mo->ceilingz - mo->height;\n\t}\n\n\tif (mo->flags & MF_SKULLFLY)\n\t{\t// the skull slammed into something\n\t    mo->momz = -mo->momz;\n\t}\n\t\n\tif ( (mo->flags & MF_MISSILE)\n\t     && !(mo->flags & MF_NOCLIP) )\n\t{\n\t    P_ExplodeMissile (mo);\n\t    return;\n\t}\n    }\n} \n\n\n\n//\n// P_NightmareRespawn\n//\nvoid\nP_NightmareRespawn (mobj_t* mobj)\n{\n    fixed_t\t\tx;\n    fixed_t\t\ty;\n    fixed_t\t\tz; \n    subsector_t*\tss; \n    mobj_t*\t\tmo;\n    mapthing_t*\t\tmthing;\n\t\t\n    x = mobj->spawnpoint.x << FRACBITS; \n    y = mobj->spawnpoint.y << FRACBITS; \n\n    // somthing is occupying it's position?\n    if (!P_CheckPosition (mobj, x, y) ) \n\treturn;\t// no respwan\n\n    // spawn a teleport fog at old spot\n    // because of removal of the body?\n    mo = P_SpawnMobj (mobj->x,\n\t\t      mobj->y,\n\t\t      mobj->subsector->sector->floorheight , MT_TFOG); \n    // initiate teleport sound\n    S_StartSound (mo, sfx_telept);\n\n    // spawn a teleport fog at the new spot\n    ss = R_PointInSubsector (x,y); \n\n    mo = P_SpawnMobj (x, y, ss->sector->floorheight , MT_TFOG); \n\n    S_StartSound (mo, sfx_telept);\n\n    // spawn the new monster\n    mthing = &mobj->spawnpoint;\n\t\n    // spawn it\n    if (mobj->info->flags & MF_SPAWNCEILING)\n\tz = ONCEILINGZ;\n    else\n\tz = ONFLOORZ;\n\n    // inherit attributes from deceased one\n    mo = P_SpawnMobj (x,y,z, mobj->type);\n    mo->spawnpoint = mobj->spawnpoint;\t\n    mo->angle = ANG45 * (mthing->angle/45);\n\n    if (mthing->options & MTF_AMBUSH)\n\tmo->flags |= MF_AMBUSH;\n\n    mo->reactiontime = 18;\n\t\n    // remove the old monster,\n    P_RemoveMobj (mobj);\n}\n\n\n//\n// P_MobjThinker\n//\nvoid P_MobjThinker (mobj_t* mobj)\n{\n    // momentum movement\n    if (mobj->momx\n\t|| mobj->momy\n\t|| (mobj->flags&MF_SKULLFLY) )\n    {\n\tP_XYMovement (mobj);\n\n\t// FIXME: decent NOP/NULL/Nil function pointer please.\n\tif (mobj->thinker.function.acv == (actionf_v) (-1))\n\t    return;\t\t// mobj was removed\n    }\n    if ( (mobj->z != mobj->floorz)\n\t || mobj->momz )\n    {\n\tP_ZMovement (mobj);\n\t\n\t// FIXME: decent NOP/NULL/Nil function pointer please.\n\tif (mobj->thinker.function.acv == (actionf_v) (-1))\n\t    return;\t\t// mobj was removed\n    }\n\n    \n    // cycle through states,\n    // calling action functions at transitions\n    if (mobj->tics != -1)\n    {\n\tmobj->tics--;\n\t\t\n\t// you can cycle through multiple states in a tic\n\tif (!mobj->tics)\n\t    if (!P_SetMobjState (mobj, mobj->state->nextstate) )\n\t\treturn;\t\t// freed itself\n    }\n    else\n    {\n\t// check for nightmare respawn\n\tif (! (mobj->flags & MF_COUNTKILL) )\n\t    return;\n\n\tif (!respawnmonsters)\n\t    return;\n\n\tmobj->movecount++;\n\n\tif (mobj->movecount < 12*TICRATE)\n\t    return;\n\n\tif ( leveltime&31 )\n\t    return;\n\n\tif (P_Random () > 4)\n\t    return;\n\n\tP_NightmareRespawn (mobj);\n    }\n\n}\n\n\n//\n// P_SpawnMobj\n//\nmobj_t*\nP_SpawnMobj\n( fixed_t\tx,\n  fixed_t\ty,\n  fixed_t\tz,\n  mobjtype_t\ttype )\n{\n    mobj_t*\tmobj;\n    state_t*\tst;\n    mobjinfo_t*\tinfo;\n\t\n    mobj = Z_Malloc (sizeof(*mobj), PU_LEVEL, NULL);\n    memset (mobj, 0, sizeof (*mobj));\n    info = &mobjinfo[type];\n\t\n    mobj->type = type;\n    mobj->info = info;\n    mobj->x = x;\n    mobj->y = y;\n    mobj->radius = info->radius;\n    mobj->height = info->height;\n    mobj->flags = info->flags;\n    mobj->health = info->spawnhealth;\n\n    if (gameskill != sk_nightmare)\n\tmobj->reactiontime = info->reactiontime;\n    \n    mobj->lastlook = P_Random () % MAXPLAYERS;\n    // do not set the state with P_SetMobjState,\n    // because action routines can not be called yet\n    st = &states[info->spawnstate];\n\n    mobj->state = st;\n    mobj->tics = st->tics;\n    mobj->sprite = st->sprite;\n    mobj->frame = st->frame;\n\n    // set subsector and/or block links\n    P_SetThingPosition (mobj);\n\t\n    mobj->floorz = mobj->subsector->sector->floorheight;\n    mobj->ceilingz = mobj->subsector->sector->ceilingheight;\n\n    if (z == ONFLOORZ)\n\tmobj->z = mobj->floorz;\n    else if (z == ONCEILINGZ)\n\tmobj->z = mobj->ceilingz - mobj->info->height;\n    else \n\tmobj->z = z;\n\n    mobj->thinker.function.acp1 = (actionf_p1)P_MobjThinker;\n\t\n    P_AddThinker (&mobj->thinker);\n\n    return mobj;\n}\n\n\n//\n// P_RemoveMobj\n//\nmapthing_t\titemrespawnque[ITEMQUESIZE];\nint\t\titemrespawntime[ITEMQUESIZE];\nint\t\tiquehead;\nint\t\tiquetail;\n\n\nvoid P_RemoveMobj (mobj_t* mobj)\n{\n    if ((mobj->flags & MF_SPECIAL)\n\t&& !(mobj->flags & MF_DROPPED)\n\t&& (mobj->type != MT_INV)\n\t&& (mobj->type != MT_INS))\n    {\n\titemrespawnque[iquehead] = mobj->spawnpoint;\n\titemrespawntime[iquehead] = leveltime;\n\tiquehead = (iquehead+1)&(ITEMQUESIZE-1);\n\n\t// lose one off the end?\n\tif (iquehead == iquetail)\n\t    iquetail = (iquetail+1)&(ITEMQUESIZE-1);\n    }\n\t\n    // unlink from sector and block lists\n    P_UnsetThingPosition (mobj);\n    \n    // stop any playing sound\n    S_StopSound (mobj);\n    \n    // free block\n    P_RemoveThinker ((thinker_t*)mobj);\n}\n\n\n\n\n//\n// P_RespawnSpecials\n//\nvoid P_RespawnSpecials (void)\n{\n    fixed_t\t\tx;\n    fixed_t\t\ty;\n    fixed_t\t\tz;\n    \n    subsector_t*\tss; \n    mobj_t*\t\tmo;\n    mapthing_t*\t\tmthing;\n    \n    int\t\t\ti;\n\n    // only respawn items in deathmatch\n    if (deathmatch != 2)\n\treturn;\t// \n\n    // nothing left to respawn?\n    if (iquehead == iquetail)\n\treturn;\t\t\n\n    // wait at least 30 seconds\n    if (leveltime - itemrespawntime[iquetail] < 30*TICRATE)\n\treturn;\t\t\t\n\n    mthing = &itemrespawnque[iquetail];\n\t\n    x = mthing->x << FRACBITS; \n    y = mthing->y << FRACBITS; \n\t  \n    // spawn a teleport fog at the new spot\n    ss = R_PointInSubsector (x,y); \n    mo = P_SpawnMobj (x, y, ss->sector->floorheight , MT_IFOG); \n    S_StartSound (mo, sfx_itmbk);\n\n    // find which type to spawn\n    for (i=0 ; i< NUMMOBJTYPES ; i++)\n    {\n\tif (mthing->type == mobjinfo[i].doomednum)\n\t    break;\n    }\n\n    if (i >= NUMMOBJTYPES)\n    {\n        I_Error(\"P_RespawnSpecials: Failed to find mobj type with doomednum \"\n                \"%d when respawning thing. This would cause a buffer overrun \"\n                \"in vanilla Doom\", mthing->type);\n    }\n\n    // spawn it\n    if (mobjinfo[i].flags & MF_SPAWNCEILING)\n\tz = ONCEILINGZ;\n    else\n\tz = ONFLOORZ;\n\n    mo = P_SpawnMobj (x,y,z, i);\n    mo->spawnpoint = *mthing;\t\n    mo->angle = ANG45 * (mthing->angle/45);\n\n    // pull it from the que\n    iquetail = (iquetail+1)&(ITEMQUESIZE-1);\n}\n\n\n\n\n//\n// P_SpawnPlayer\n// Called when a player is spawned on the level.\n// Most of the player structure stays unchanged\n//  between levels.\n//\nvoid P_SpawnPlayer (mapthing_t* mthing)\n{\n    player_t*\t\tp;\n    fixed_t\t\tx;\n    fixed_t\t\ty;\n    fixed_t\t\tz;\n\n    mobj_t*\t\tmobj;\n\n    int\t\t\ti;\n\n    if (mthing->type == 0)\n    {\n        return;\n    }\n\n    // not playing?\n    if (!playeringame[mthing->type-1])\n\treturn;\t\t\t\t\t\n\t\t\n    p = &players[mthing->type-1];\n\n    if (p->playerstate == PST_REBORN)\n\tG_PlayerReborn (mthing->type-1);\n\n    x \t\t= mthing->x << FRACBITS;\n    y \t\t= mthing->y << FRACBITS;\n    z\t\t= ONFLOORZ;\n    mobj\t= P_SpawnMobj (x,y,z, MT_PLAYER);\n\n    // set color translations for player sprites\n    if (mthing->type > 1)\t\t\n\tmobj->flags |= (mthing->type-1)<<MF_TRANSSHIFT;\n\t\t\n    mobj->angle\t= ANG45 * (mthing->angle/45);\n    mobj->player = p;\n    mobj->health = p->health;\n\n    p->mo = mobj;\n    p->playerstate = PST_LIVE;\t\n    p->refire = 0;\n    p->message = NULL;\n    p->damagecount = 0;\n    p->bonuscount = 0;\n    p->extralight = 0;\n    p->fixedcolormap = 0;\n    p->viewheight = VIEWHEIGHT;\n\n    // setup gun psprite\n    P_SetupPsprites (p);\n    \n    // give all cards in death match mode\n    if (deathmatch)\n\tfor (i=0 ; i<NUMCARDS ; i++)\n\t    p->cards[i] = true;\n\t\t\t\n    if (mthing->type-1 == consoleplayer)\n    {\n\t// wake up the status bar\n\tST_Start ();\n\t// wake up the heads up text\n\tHU_Start ();\t\t\n    }\n}\n\n\n//\n// P_SpawnMapThing\n// The fields of the mapthing should\n// already be in host byte order.\n//\nvoid P_SpawnMapThing (mapthing_t* mthing)\n{\n    int\t\t\ti;\n    int\t\t\tbit;\n    mobj_t*\t\tmobj;\n    fixed_t\t\tx;\n    fixed_t\t\ty;\n    fixed_t\t\tz;\n\t\t\n    // count deathmatch start positions\n    if (mthing->type == 11)\n    {\n\tif (deathmatch_p < &deathmatchstarts[10])\n\t{\n\t    memcpy (deathmatch_p, mthing, sizeof(*mthing));\n\t    deathmatch_p++;\n\t}\n\treturn;\n    }\n\n    if (mthing->type <= 0)\n    {\n        // Thing type 0 is actually \"player -1 start\".  \n        // For some reason, Vanilla Doom accepts/ignores this.\n\n        return;\n    }\n\t\n    // check for players specially\n    if (mthing->type <= 4)\n    {\n\t// save spots for respawning in network games\n\tplayerstarts[mthing->type-1] = *mthing;\n\tif (!deathmatch)\n\t    P_SpawnPlayer (mthing);\n\n\treturn;\n    }\n\n    // check for apropriate skill level\n    if (!netgame && (mthing->options & 16) )\n\treturn;\n\t\t\n    if (gameskill == sk_baby)\n\tbit = 1;\n    else if (gameskill == sk_nightmare)\n\tbit = 4;\n    else\n\tbit = 1<<(gameskill-1);\n\n    if (!(mthing->options & bit) )\n\treturn;\n\t\n    // find which type to spawn\n    for (i=0 ; i< NUMMOBJTYPES ; i++)\n\tif (mthing->type == mobjinfo[i].doomednum)\n\t    break;\n\t\n    if (i==NUMMOBJTYPES)\n\tI_Error (\"P_SpawnMapThing: Unknown type %i at (%i, %i)\",\n\t\t mthing->type,\n\t\t mthing->x, mthing->y);\n\t\t\n    // don't spawn keycards and players in deathmatch\n    if (deathmatch && mobjinfo[i].flags & MF_NOTDMATCH)\n\treturn;\n\t\t\n    // don't spawn any monsters if -nomonsters\n    if (nomonsters\n\t&& ( i == MT_SKULL\n\t     || (mobjinfo[i].flags & MF_COUNTKILL)) )\n    {\n\treturn;\n    }\n    \n    // spawn it\n    x = mthing->x << FRACBITS;\n    y = mthing->y << FRACBITS;\n\n    if (mobjinfo[i].flags & MF_SPAWNCEILING)\n\tz = ONCEILINGZ;\n    else\n\tz = ONFLOORZ;\n    \n    mobj = P_SpawnMobj (x,y,z, i);\n    mobj->spawnpoint = *mthing;\n\n    if (mobj->tics > 0)\n\tmobj->tics = 1 + (P_Random () % mobj->tics);\n    if (mobj->flags & MF_COUNTKILL)\n\ttotalkills++;\n    if (mobj->flags & MF_COUNTITEM)\n\ttotalitems++;\n\t\t\n    mobj->angle = ANG45 * (mthing->angle/45);\n    if (mthing->options & MTF_AMBUSH)\n\tmobj->flags |= MF_AMBUSH;\n}\n\n\n\n//\n// GAME SPAWN FUNCTIONS\n//\n\n\n//\n// P_SpawnPuff\n//\nextern fixed_t attackrange;\n\nvoid\nP_SpawnPuff\n( fixed_t\tx,\n  fixed_t\ty,\n  fixed_t\tz )\n{\n    mobj_t*\tth;\n\t\n    z += (P_SubRandom() << 10);\n\n    th = P_SpawnMobj (x,y,z, MT_PUFF);\n    th->momz = FRACUNIT;\n    th->tics -= P_Random()&3;\n\n    if (th->tics < 1)\n\tth->tics = 1;\n\t\n    // don't make punches spark on the wall\n    if (attackrange == MELEERANGE)\n\tP_SetMobjState (th, S_PUFF3);\n}\n\n\n\n//\n// P_SpawnBlood\n// \nvoid\nP_SpawnBlood\n( fixed_t\tx,\n  fixed_t\ty,\n  fixed_t\tz,\n  int\t\tdamage )\n{\n    mobj_t*\tth;\n\t\n    z += (P_SubRandom() << 10);\n    th = P_SpawnMobj (x,y,z, MT_BLOOD);\n    th->momz = FRACUNIT*2;\n    th->tics -= P_Random()&3;\n\n    if (th->tics < 1)\n\tth->tics = 1;\n\t\t\n    if (damage <= 12 && damage >= 9)\n\tP_SetMobjState (th,S_BLOOD2);\n    else if (damage < 9)\n\tP_SetMobjState (th,S_BLOOD3);\n}\n\n\n\n//\n// P_CheckMissileSpawn\n// Moves the missile forward a bit\n//  and possibly explodes it right there.\n//\nvoid P_CheckMissileSpawn (mobj_t* th)\n{\n    th->tics -= P_Random()&3;\n    if (th->tics < 1)\n\tth->tics = 1;\n    \n    // move a little forward so an angle can\n    // be computed if it immediately explodes\n    th->x += (th->momx>>1);\n    th->y += (th->momy>>1);\n    th->z += (th->momz>>1);\n\n    if (!P_TryMove (th, th->x, th->y))\n\tP_ExplodeMissile (th);\n}\n\n// Certain functions assume that a mobj_t pointer is non-NULL,\n// causing a crash in some situations where it is NULL.  Vanilla\n// Doom did not crash because of the lack of proper memory \n// protection. This function substitutes NULL pointers for\n// pointers to a dummy mobj, to avoid a crash.\n\nmobj_t *P_SubstNullMobj(mobj_t *mobj)\n{\n    if (mobj == NULL)\n    {\n        static mobj_t dummy_mobj;\n\n        dummy_mobj.x = 0;\n        dummy_mobj.y = 0;\n        dummy_mobj.z = 0;\n        dummy_mobj.flags = 0;\n\n        mobj = &dummy_mobj;\n    }\n\n    return mobj;\n}\n\n//\n// P_SpawnMissile\n//\nmobj_t*\nP_SpawnMissile\n( mobj_t*\tsource,\n  mobj_t*\tdest,\n  mobjtype_t\ttype )\n{\n    mobj_t*\tth;\n    angle_t\tan;\n    int\t\tdist;\n\n    th = P_SpawnMobj (source->x,\n\t\t      source->y,\n\t\t      source->z + 4*8*FRACUNIT, type);\n    \n    if (th->info->seesound)\n\tS_StartSound (th, th->info->seesound);\n\n    th->target = source;\t// where it came from\n    an = R_PointToAngle2 (source->x, source->y, dest->x, dest->y);\n\n    // fuzzy player\n    if (dest->flags & MF_SHADOW)\n\tan += P_SubRandom() << 20;\n\n    th->angle = an;\n    an >>= ANGLETOFINESHIFT;\n    th->momx = FixedMul (th->info->speed, finecosine[an]);\n    th->momy = FixedMul (th->info->speed, finesine[an]);\n\t\n    dist = P_AproxDistance (dest->x - source->x, dest->y - source->y);\n    dist = dist / th->info->speed;\n\n    if (dist < 1)\n\tdist = 1;\n\n    th->momz = (dest->z - source->z) / dist;\n    P_CheckMissileSpawn (th);\n\t\n    return th;\n}\n\n\n//\n// P_SpawnPlayerMissile\n// Tries to aim at a nearby monster\n//\nvoid\nP_SpawnPlayerMissile\n( mobj_t*\tsource,\n  mobjtype_t\ttype )\n{\n    mobj_t*\tth;\n    angle_t\tan;\n    \n    fixed_t\tx;\n    fixed_t\ty;\n    fixed_t\tz;\n    fixed_t\tslope;\n    \n    // see which target is to be aimed at\n    an = source->angle;\n    slope = P_AimLineAttack (source, an, 16*64*FRACUNIT);\n    \n    if (!linetarget)\n    {\n\tan += 1<<26;\n\tslope = P_AimLineAttack (source, an, 16*64*FRACUNIT);\n\n\tif (!linetarget)\n\t{\n\t    an -= 2<<26;\n\t    slope = P_AimLineAttack (source, an, 16*64*FRACUNIT);\n\t}\n\n\tif (!linetarget)\n\t{\n\t    an = source->angle;\n\t    slope = 0;\n\t}\n    }\n\t\t\n    x = source->x;\n    y = source->y;\n    z = source->z + 4*8*FRACUNIT;\n\t\n    th = P_SpawnMobj (x,y,z, type);\n\n    if (th->info->seesound)\n\tS_StartSound (th, th->info->seesound);\n\n    th->target = source;\n    th->angle = an;\n    th->momx = FixedMul( th->info->speed,\n\t\t\t finecosine[an>>ANGLETOFINESHIFT]);\n    th->momy = FixedMul( th->info->speed,\n\t\t\t finesine[an>>ANGLETOFINESHIFT]);\n    th->momz = FixedMul( th->info->speed, slope);\n\n    P_CheckMissileSpawn (th);\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tHandling interactions (i.e., collisions).\n//\n\n\n\n\n// Data.\n#include \"doomdef.h\"\n#include \"dstrings.h\"\n#include \"sounds.h\"\n\n#include \"deh_main.h\"\n#include \"deh_misc.h\"\n#include \"doomstat.h\"\n\n#include \"m_random.h\"\n#include \"i_system.h\"\n\n#include \"am_map.h\"\n\n#include \"p_local.h\"\n\n#include \"s_sound.h\"\n\n#include \"p_inter.h\"\n\n#include \"hu_stuff.h\"\n#include \"f_finale.h\"\n#include <emscripten.h>\n\n#define BONUSADD\t6\n\n\n\n\n// a weapon is found with two clip loads,\n// a big item has five clip loads\nint\tmaxammo[NUMAMMO] = {200, 50, 300, 50};\nint\tclipammo[NUMAMMO] = {10, 4, 20, 1};\n\n\n//\n// GET STUFF\n//\n\n//\n// P_GiveAmmo\n// Num is the number of clip loads,\n// not the individual count (0= 1/2 clip).\n// Returns false if the ammo can't be picked up at all\n//\n\nboolean\nP_GiveAmmo\n( player_t*\tplayer,\n  ammotype_t\tammo,\n  int\t\tnum )\n{\n    int\t\toldammo;\n\n    if (ammo == am_noammo)\n\treturn false;\n\n    if (ammo > NUMAMMO)\n\tI_Error (\"P_GiveAmmo: bad type %i\", ammo);\n\n    if ( player->ammo[ammo] == player->maxammo[ammo]  )\n\treturn false;\n\n    if (num)\n\tnum *= clipammo[ammo];\n    else\n\tnum = clipammo[ammo]/2;\n\n    if (gameskill == sk_baby\n\t|| gameskill == sk_nightmare)\n    {\n\t// give double ammo in trainer mode,\n\t// you'll need in nightmare\n\tnum <<= 1;\n    }\n\n\n    oldammo = player->ammo[ammo];\n    player->ammo[ammo] += num;\n\n    if (player->ammo[ammo] > player->maxammo[ammo])\n\tplayer->ammo[ammo] = player->maxammo[ammo];\n\n    // If non zero ammo,\n    // don't change up weapons,\n    // player was lower on purpose.\n    if (oldammo)\n\treturn true;\n\n    // We were down to zero,\n    // so select a new weapon.\n    // Preferences are not user selectable.\n    switch (ammo)\n    {\n      case am_clip:\n\tif (player->readyweapon == wp_fist)\n\t{\n\t    if (player->weaponowned[wp_chaingun])\n\t\tplayer->pendingweapon = wp_chaingun;\n\t    else\n\t\tplayer->pendingweapon = wp_pistol;\n\t}\n\tbreak;\n\n      case am_shell:\n\tif (player->readyweapon == wp_fist\n\t    || player->readyweapon == wp_pistol)\n\t{\n\t    if (player->weaponowned[wp_shotgun])\n\t\tplayer->pendingweapon = wp_shotgun;\n\t}\n\tbreak;\n\n      case am_cell:\n\tif (player->readyweapon == wp_fist\n\t    || player->readyweapon == wp_pistol)\n\t{\n\t    if (player->weaponowned[wp_plasma])\n\t\tplayer->pendingweapon = wp_plasma;\n\t}\n\tbreak;\n\n      case am_misl:\n\tif (player->readyweapon == wp_fist)\n\t{\n\t    if (player->weaponowned[wp_missile])\n\t\tplayer->pendingweapon = wp_missile;\n\t}\n      default:\n\tbreak;\n    }\n\n    return true;\n}\n\n\n//\n// P_GiveWeapon\n// The weapon name may have a MF_DROPPED flag ored in.\n//\nboolean\nP_GiveWeapon\n( player_t*\tplayer,\n  weapontype_t\tweapon,\n  boolean\tdropped )\n{\n    boolean\tgaveammo;\n    boolean\tgaveweapon;\n\n    if (netgame\n\t&& (deathmatch!=2)\n\t && !dropped )\n    {\n\t// leave placed weapons forever on net games\n\tif (player->weaponowned[weapon])\n\t    return false;\n\n\tplayer->bonuscount += BONUSADD;\n\tplayer->weaponowned[weapon] = true;\n\n\tif (deathmatch)\n\t    P_GiveAmmo (player, weaponinfo[weapon].ammo, 5);\n\telse\n\t    P_GiveAmmo (player, weaponinfo[weapon].ammo, 2);\n\tplayer->pendingweapon = weapon;\n\n\tif (player == &players[consoleplayer])\n\t    S_StartSound (NULL, sfx_wpnup);\n\treturn false;\n    }\n\n    if (weaponinfo[weapon].ammo != am_noammo)\n    {\n\t// give one clip with a dropped weapon,\n\t// two clips with a found weapon\n\tif (dropped)\n\t    gaveammo = P_GiveAmmo (player, weaponinfo[weapon].ammo, 1);\n\telse\n\t    gaveammo = P_GiveAmmo (player, weaponinfo[weapon].ammo, 2);\n    }\n    else\n\tgaveammo = false;\n\n    if (player->weaponowned[weapon])\n\tgaveweapon = false;\n    else\n    {\n\tgaveweapon = true;\n\tplayer->weaponowned[weapon] = true;\n\tplayer->pendingweapon = weapon;\n    }\n\n    return (gaveweapon || gaveammo);\n}\n\n\n\n//\n// P_GiveBody\n// Returns false if the body isn't needed at all\n//\nboolean\nP_GiveBody\n( player_t*\tplayer,\n  int\t\tnum )\n{\n    if (player->health >= MAXHEALTH)\n\treturn false;\n\n    player->health += num;\n    if (player->health > MAXHEALTH)\n\tplayer->health = MAXHEALTH;\n    player->mo->health = player->health;\n\n    return true;\n}\n\n\n\n//\n// P_GiveArmor\n// Returns false if the armor is worse\n// than the current armor.\n//\nboolean\nP_GiveArmor\n( player_t*\tplayer,\n  int\t\tarmortype )\n{\n    int\t\thits;\n\n    hits = armortype*100;\n    if (player->armorpoints >= hits)\n\treturn false;\t// don't pick up\n\n    player->armortype = armortype;\n    player->armorpoints = hits;\n\n    return true;\n}\n\n\n\n//\n// P_GiveCard\n//\nvoid\nP_GiveCard\n( player_t*\tplayer,\n  card_t\tcard )\n{\n    if (player->cards[card])\n\treturn;\n\n    player->bonuscount = BONUSADD;\n    player->cards[card] = 1;\n}\n\n\n//\n// P_GivePower\n//\nboolean\nP_GivePower\n( player_t*\tplayer,\n  int /*powertype_t*/\tpower )\n{\n    if (power == pw_invulnerability)\n    {\n\tplayer->powers[power] = INVULNTICS;\n\treturn true;\n    }\n\n    if (power == pw_invisibility)\n    {\n\tplayer->powers[power] = INVISTICS;\n\tplayer->mo->flags |= MF_SHADOW;\n\treturn true;\n    }\n\n    if (power == pw_infrared)\n    {\n\tplayer->powers[power] = INFRATICS;\n\treturn true;\n    }\n\n    if (power == pw_ironfeet)\n    {\n\tplayer->powers[power] = IRONTICS;\n\treturn true;\n    }\n\n    if (power == pw_strength)\n    {\n\tP_GiveBody (player, 100);\n\tplayer->powers[power] = 1;\n\treturn true;\n    }\n\n    if (player->powers[power])\n\treturn false;\t// already got it\n\n    player->powers[power] = 1;\n    return true;\n}\n\n\n\n//\n// P_TouchSpecialThing\n//\nvoid\nP_TouchSpecialThing\n( mobj_t*\tspecial,\n  mobj_t*\ttoucher )\n{\n    player_t*\tplayer;\n    int\t\ti;\n    fixed_t\tdelta;\n    int\t\tsound;\n\n    delta = special->z - toucher->z;\n\n    if (delta > toucher->height\n\t|| delta < -8*FRACUNIT)\n    {\n\t// out of reach\n\treturn;\n    }\n\n\n    sound = sfx_itemup;\n    player = toucher->player;\n\n    // Dead thing touching.\n    // Can happen with a sliding player corpse.\n    if (toucher->health <= 0)\n\treturn;\n\n    // Identify by sprite.\n    switch (special->sprite)\n    {\n\t// armor\n      case SPR_ARM1:\n\tif (!P_GiveArmor (player, deh_green_armor_class))\n\t    return;\n\tplayer->message = DEH_String(GOTARMOR);\n\tbreak;\n\n      case SPR_ARM2:\n\tif (!P_GiveArmor (player, deh_blue_armor_class))\n\t    return;\n\tplayer->message = DEH_String(GOTMEGA);\n\tbreak;\n\n\t// bonus items\n      case SPR_BON1:\n\tplayer->health++;\t\t// can go over 100%\n\tif (player->health > deh_max_health)\n\t    player->health = deh_max_health;\n\tplayer->mo->health = player->health;\n\tplayer->message = DEH_String(GOTHTHBONUS);\n\tbreak;\n\n      case SPR_BON2:\n\tplayer->armorpoints++;\t\t// can go over 100%\n\tif (player->armorpoints > deh_max_armor)\n\t    player->armorpoints = deh_max_armor;\n        // deh_green_armor_class only applies to the green armor shirt;\n        // for the armor helmets, armortype 1 is always used.\n\tif (!player->armortype)\n\t    player->armortype = 1;\n\tplayer->message = DEH_String(GOTARMBONUS);\n\tbreak;\n\n      case SPR_SOUL:\n\tplayer->health += deh_soulsphere_health;\n\tif (player->health > deh_max_soulsphere)\n\t    player->health = deh_max_soulsphere;\n\tplayer->mo->health = player->health;\n\tplayer->message = DEH_String(GOTSUPER);\n\tsound = sfx_getpow;\n\tbreak;\n\n      case SPR_MEGA:\n\tif (gamemode != commercial)\n\t    return;\n\tplayer->health = deh_megasphere_health;\n\tplayer->mo->health = player->health;\n        // We always give armor type 2 for the megasphere; dehacked only\n        // affects the MegaArmor.\n\tP_GiveArmor (player, 2);\n\tplayer->message = DEH_String(GOTMSPHERE);\n\tsound = sfx_getpow;\n\tbreak;\n\n\t// cards\n\t// leave cards for everyone\n      case SPR_BKEY:\n\tif (!player->cards[it_bluecard])\n\t    player->message = DEH_String(GOTBLUECARD);\n\tP_GiveCard (player, it_bluecard);\n\tif (!netgame)\n\t    break;\n\treturn;\n\n      case SPR_YKEY:\n\tif (!player->cards[it_yellowcard])\n\t    player->message = DEH_String(GOTYELWCARD);\n\tP_GiveCard (player, it_yellowcard);\n\tif (!netgame)\n\t    break;\n\treturn;\n\n      case SPR_RKEY:\n\tif (!player->cards[it_redcard])\n\t    player->message = DEH_String(GOTREDCARD);\n\tP_GiveCard (player, it_redcard);\n\tif (!netgame)\n\t    break;\n\treturn;\n\n      case SPR_BSKU:\n\tif (!player->cards[it_blueskull])\n\t    player->message = DEH_String(GOTBLUESKUL);\n\tP_GiveCard (player, it_blueskull);\n\tif (!netgame)\n\t    break;\n\treturn;\n\n      case SPR_YSKU:\n\tif (!player->cards[it_yellowskull])\n\t    player->message = DEH_String(GOTYELWSKUL);\n\tP_GiveCard (player, it_yellowskull);\n\tif (!netgame)\n\t    break;\n\treturn;\n\n      case SPR_RSKU:\n\tif (!player->cards[it_redskull])\n\t    player->message = DEH_String(GOTREDSKULL);\n\tP_GiveCard (player, it_redskull);\n\tif (!netgame)\n\t    break;\n\treturn;\n\n\t// medikits, heals\n      case SPR_STIM:\n\tif (!P_GiveBody (player, 10))\n\t    return;\n\tplayer->message = DEH_String(GOTSTIM);\n\tbreak;\n\n      case SPR_MEDI:\n\tif (!P_GiveBody (player, 25))\n\t    return;\n\n\tif (player->health < 25)\n\t    player->message = DEH_String(GOTMEDINEED);\n\telse\n\t    player->message = DEH_String(GOTMEDIKIT);\n\tbreak;\n\n\n\t// power ups\n      case SPR_PINV:\n\tif (!P_GivePower (player, pw_invulnerability))\n\t    return;\n\tplayer->message = DEH_String(GOTINVUL);\n\tsound = sfx_getpow;\n\tbreak;\n\n      case SPR_PSTR:\n\tif (!P_GivePower (player, pw_strength))\n\t    return;\n\tplayer->message = DEH_String(GOTBERSERK);\n\tif (player->readyweapon != wp_fist)\n\t    player->pendingweapon = wp_fist;\n\tsound = sfx_getpow;\n\tbreak;\n\n      case SPR_PINS:\n\tif (!P_GivePower (player, pw_invisibility))\n\t    return;\n\tplayer->message = DEH_String(GOTINVIS);\n\tsound = sfx_getpow;\n\tbreak;\n\n      case SPR_SUIT:\n\tif (!P_GivePower (player, pw_ironfeet))\n\t    return;\n\tplayer->message = DEH_String(GOTSUIT);\n\tsound = sfx_getpow;\n\tbreak;\n\n      case SPR_PMAP:\n\tif (!P_GivePower (player, pw_allmap))\n\t    return;\n\tplayer->message = DEH_String(GOTMAP);\n\tsound = sfx_getpow;\n\tbreak;\n\n      case SPR_PVIS:\n\tif (!P_GivePower (player, pw_infrared))\n\t    return;\n\tplayer->message = DEH_String(GOTVISOR);\n\tsound = sfx_getpow;\n\tbreak;\n\n\t// ammo\n      case SPR_CLIP:\n\tif (special->flags & MF_DROPPED)\n\t{\n\t    if (!P_GiveAmmo (player,am_clip,0))\n\t\treturn;\n\t}\n\telse\n\t{\n\t    if (!P_GiveAmmo (player,am_clip,1))\n\t\treturn;\n\t}\n\tplayer->message = DEH_String(GOTCLIP);\n\tbreak;\n\n      case SPR_AMMO:\n\tif (!P_GiveAmmo (player, am_clip,5))\n\t    return;\n\tplayer->message = DEH_String(GOTCLIPBOX);\n\tbreak;\n\n      case SPR_ROCK:\n\tif (!P_GiveAmmo (player, am_misl,1))\n\t    return;\n\tplayer->message = DEH_String(GOTROCKET);\n\tbreak;\n\n      case SPR_BROK:\n\tif (!P_GiveAmmo (player, am_misl,5))\n\t    return;\n\tplayer->message = DEH_String(GOTROCKBOX);\n\tbreak;\n\n      case SPR_CELL:\n\tif (!P_GiveAmmo (player, am_cell,1))\n\t    return;\n\tplayer->message = DEH_String(GOTCELL);\n\tbreak;\n\n      case SPR_CELP:\n\tif (!P_GiveAmmo (player, am_cell,5))\n\t    return;\n\tplayer->message = DEH_String(GOTCELLBOX);\n\tbreak;\n\n      case SPR_SHEL:\n\tif (!P_GiveAmmo (player, am_shell,1))\n\t    return;\n\tplayer->message = DEH_String(GOTSHELLS);\n\tbreak;\n\n      case SPR_SBOX:\n\tif (!P_GiveAmmo (player, am_shell,5))\n\t    return;\n\tplayer->message = DEH_String(GOTSHELLBOX);\n\tbreak;\n\n      case SPR_BPAK:\n\tif (!player->backpack)\n\t{\n\t    for (i=0 ; i<NUMAMMO ; i++)\n\t\tplayer->maxammo[i] *= 2;\n\t    player->backpack = true;\n\t}\n\tfor (i=0 ; i<NUMAMMO ; i++)\n\t    P_GiveAmmo (player, i, 1);\n\tplayer->message = DEH_String(GOTBACKPACK);\n\tbreak;\n\n\t// weapons\n      case SPR_BFUG:\n\tif (!P_GiveWeapon (player, wp_bfg, false) )\n\t    return;\n\tplayer->message = DEH_String(GOTBFG9000);\n\tsound = sfx_wpnup;\n\tbreak;\n\n      case SPR_MGUN:\n        if (!P_GiveWeapon(player, wp_chaingun,\n                          (special->flags & MF_DROPPED) != 0))\n            return;\n\tplayer->message = DEH_String(GOTCHAINGUN);\n\tsound = sfx_wpnup;\n\tbreak;\n\n      case SPR_CSAW:\n\tif (!P_GiveWeapon (player, wp_chainsaw, false) )\n\t    return;\n\tplayer->message = DEH_String(GOTCHAINSAW);\n\tsound = sfx_wpnup;\n\tbreak;\n\n      case SPR_LAUN:\n\tif (!P_GiveWeapon (player, wp_missile, false) )\n\t    return;\n\tplayer->message = DEH_String(GOTLAUNCHER);\n\tsound = sfx_wpnup;\n\tbreak;\n\n      case SPR_PLAS:\n\tif (!P_GiveWeapon (player, wp_plasma, false) )\n\t    return;\n\tplayer->message = DEH_String(GOTPLASMA);\n\tsound = sfx_wpnup;\n\tbreak;\n\n      case SPR_SHOT:\n        if (!P_GiveWeapon(player, wp_shotgun,\n                          (special->flags & MF_DROPPED) != 0))\n            return;\n\tplayer->message = DEH_String(GOTSHOTGUN);\n\tsound = sfx_wpnup;\n\tbreak;\n\n      case SPR_SGN2:\n        if (!P_GiveWeapon(player, wp_supershotgun,\n                          (special->flags & MF_DROPPED) != 0))\n            return;\n\tplayer->message = DEH_String(GOTSHOTGUN2);\n\tsound = sfx_wpnup;\n\tbreak;\n\n      default:\n\tI_Error (\"P_SpecialThing: Unknown gettable thing\");\n    }\n\n    if (special->flags & MF_COUNTITEM)\n\tplayer->itemcount++;\n    P_RemoveMobj (special);\n    player->bonuscount += BONUSADD;\n    if (player == &players[consoleplayer])\n\tS_StartSound (NULL, sound);\n}\n\nextern castinfo_t castorder[];\n//\n// KillMobj\n//\nvoid\nP_KillMobj\n( mobj_t*\tsource,\n  mobj_t*\ttarget )\n{\n    mobjtype_t\titem;\n    mobj_t*\tmo;\n\n    target->flags &= ~(MF_SHOOTABLE|MF_FLOAT|MF_SKULLFLY);\n\n    if (target->type != MT_SKULL)\n\ttarget->flags &= ~MF_NOGRAVITY;\n\n    target->flags |= MF_CORPSE|MF_DROPOFF;\n    target->height >>= 2;\n\n    if (source && source->player)\n    {\n\t// count for intermission\n\tif (target->flags & MF_COUNTKILL)\n\t    source->player->killcount++;\n\n\tif (target->player)\n\t    source->player->frags[target->player-players]++;\n    }\n    else if (!netgame && (target->flags & MF_COUNTKILL) )\n    {\n\t// count all monster deaths,\n\t// even those caused by other monsters\n\tplayers[0].killcount++;\n    }\n\n    if (target->player)\n    {\n\t// count environment kills against you\n\tif (!source)\n\t    target->player->frags[target->player-players]++;\n\n\ttarget->flags &= ~MF_SOLID;\n\ttarget->player->playerstate = PST_DEAD;\n\n\tint i = 0;\n\tconst char *t = \"UNKNOWN\";\n\twhile (castorder[i].name != NULL)\n\t{\n\t\tif (castorder[i].type == source->type)\n\t\t{\n\t\t\tt = castorder[i].name;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\n\tconst char *s = HU_GetMapName();\n\tEM_ASM_({\n        document.dispatchEvent(new CustomEvent(\"P_KillMobj\", { detail: { mapname: Module.UTF8ToString($0), source: Module.UTF8ToString($1) } }));\n    }, s, t);\n\n\tP_DropWeapon (target->player);\n\n\tif (target->player == &players[consoleplayer]\n\t    && automapactive)\n\t{\n\t    // don't die in auto map,\n\t    // switch view prior to dying\n\t    AM_Stop ();\n\t}\n\n    }\n\n    if (target->health < -target->info->spawnhealth\n\t&& target->info->xdeathstate)\n    {\n\tP_SetMobjState (target, target->info->xdeathstate);\n    }\n    else\n\tP_SetMobjState (target, target->info->deathstate);\n    target->tics -= P_Random()&3;\n\n    if (target->tics < 1)\n\ttarget->tics = 1;\n\n    //\tI_StartSound (&actor->r, actor->info->deathsound);\n\n    // In Chex Quest, monsters don't drop items.\n\n    if (gameversion == exe_chex)\n    {\n        return;\n    }\n\n    // Drop stuff.\n    // This determines the kind of object spawned\n    // during the death frame of a thing.\n    switch (target->type)\n    {\n      case MT_WOLFSS:\n      case MT_POSSESSED:\n\titem = MT_CLIP;\n\tbreak;\n\n      case MT_SHOTGUY:\n\titem = MT_SHOTGUN;\n\tbreak;\n\n      case MT_CHAINGUY:\n\titem = MT_CHAINGUN;\n\tbreak;\n\n      default:\n\treturn;\n    }\n\n    mo = P_SpawnMobj (target->x,target->y,ONFLOORZ, item);\n    mo->flags |= MF_DROPPED;\t// special versions of items\n}\n\n\n\n\n//\n// P_DamageMobj\n// Damages both enemies and players\n// \"inflictor\" is the thing that caused the damage\n//  creature or missile, can be NULL (slime, etc)\n// \"source\" is the thing to target after taking damage\n//  creature or NULL\n// Source and inflictor are the same for melee attacks.\n// Source can be NULL for slime, barrel explosions\n// and other environmental stuff.\n//\nvoid\nP_DamageMobj\n( mobj_t*\ttarget,\n  mobj_t*\tinflictor,\n  mobj_t*\tsource,\n  int \t\tdamage )\n{\n    unsigned\tang;\n    int\t\tsaved;\n    player_t*\tplayer;\n    fixed_t\tthrust;\n    int\t\ttemp;\n\n    if ( !(target->flags & MF_SHOOTABLE) )\n\treturn;\t// shouldn't happen...\n\n    if (target->health <= 0)\n\treturn;\n\n    if ( target->flags & MF_SKULLFLY )\n    {\n\ttarget->momx = target->momy = target->momz = 0;\n    }\n\n    player = target->player;\n    if (player && gameskill == sk_baby)\n\tdamage >>= 1; \t// take half damage in trainer mode\n\n\n    // Some close combat weapons should not\n    // inflict thrust and push the victim out of reach,\n    // thus kick away unless using the chainsaw.\n    if (inflictor\n\t&& !(target->flags & MF_NOCLIP)\n\t&& (!source\n\t    || !source->player\n\t    || source->player->readyweapon != wp_chainsaw))\n    {\n\tang = R_PointToAngle2 ( inflictor->x,\n\t\t\t\tinflictor->y,\n\t\t\t\ttarget->x,\n\t\t\t\ttarget->y);\n\n\tthrust = damage*(FRACUNIT>>3)*100/target->info->mass;\n\n\t// make fall forwards sometimes\n\tif ( damage < 40\n\t     && damage > target->health\n\t     && target->z - inflictor->z > 64*FRACUNIT\n\t     && (P_Random ()&1) )\n\t{\n\t    ang += ANG180;\n\t    thrust *= 4;\n\t}\n\n\tang >>= ANGLETOFINESHIFT;\n\ttarget->momx += FixedMul (thrust, finecosine[ang]);\n\ttarget->momy += FixedMul (thrust, finesine[ang]);\n    }\n\n    // player specific\n    if (player)\n    {\n\t// end of game hell hack\n\tif (target->subsector->sector->special == 11\n\t    && damage >= target->health)\n\t{\n\t    damage = target->health - 1;\n\t}\n\n\n\t// Below certain threshold,\n\t// ignore damage in GOD mode, or with INVUL power.\n\tif ( damage < 1000\n\t     && ( (player->cheats&CF_GODMODE)\n\t\t  || player->powers[pw_invulnerability] ) )\n\t{\n\t    return;\n\t}\n\n\tif (player->armortype)\n\t{\n\t    if (player->armortype == 1)\n\t\tsaved = damage/3;\n\t    else\n\t\tsaved = damage/2;\n\n\t    if (player->armorpoints <= saved)\n\t    {\n\t\t// armor is used up\n\t\tsaved = player->armorpoints;\n\t\tplayer->armortype = 0;\n\t    }\n\t    player->armorpoints -= saved;\n\t    damage -= saved;\n\t}\n\tplayer->health -= damage; \t// mirror mobj health here for Dave\n\tif (player->health < 0)\n\t    player->health = 0;\n\n\tplayer->attacker = source;\n\tplayer->damagecount += damage;\t// add damage after armor / invuln\n\n\tif (player->damagecount > 100)\n\t    player->damagecount = 100;\t// teleport stomp does 10k points...\n\n\ttemp = damage < 100 ? damage : 100;\n\n\tif (player == &players[consoleplayer])\n\t    I_Tactile (40,10,40+temp*2);\n    }\n\n    // do the damage\n    target->health -= damage;\n    if (target->health <= 0)\n    {\n\tP_KillMobj (source, target);\n\treturn;\n    }\n\n    if ( (P_Random () < target->info->painchance)\n\t && !(target->flags&MF_SKULLFLY) )\n    {\n\ttarget->flags |= MF_JUSTHIT;\t// fight back!\n\n\tP_SetMobjState (target, target->info->painstate);\n    }\n\n    target->reactiontime = 0;\t\t// we're awake now...\n\n    if ( (!target->threshold || target->type == MT_VILE)\n\t && source && source != target\n\t && source->type != MT_VILE)\n    {\n\t// if not intent on another player,\n\t// chase after this one\n\ttarget->target = source;\n\ttarget->threshold = BASETHRESHOLD;\n\tif (target->state == &states[target->info->spawnstate]\n\t    && target->info->seestate != S_NULL)\n\t    P_SetMobjState (target, target->info->seestate);\n    }\n\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tHandle Sector base lighting effects.\n//\tMuzzle flash?\n//\n\n\n\n#include \"z_zone.h\"\n#include \"m_random.h\"\n\n#include \"doomdef.h\"\n#include \"p_local.h\"\n\n\n// State.\n#include \"r_state.h\"\n\n//\n// FIRELIGHT FLICKER\n//\n\n//\n// T_FireFlicker\n//\nvoid T_FireFlicker (fireflicker_t* flick)\n{\n    int\tamount;\n\t\n    if (--flick->count)\n\treturn;\n\t\n    amount = (P_Random()&3)*16;\n    \n    if (flick->sector->lightlevel - amount < flick->minlight)\n\tflick->sector->lightlevel = flick->minlight;\n    else\n\tflick->sector->lightlevel = flick->maxlight - amount;\n\n    flick->count = 4;\n}\n\n\n\n//\n// P_SpawnFireFlicker\n//\nvoid P_SpawnFireFlicker (sector_t*\tsector)\n{\n    fireflicker_t*\tflick;\n\t\n    // Note that we are resetting sector attributes.\n    // Nothing special about it during gameplay.\n    sector->special = 0; \n\t\n    flick = Z_Malloc ( sizeof(*flick), PU_LEVSPEC, 0);\n\n    P_AddThinker (&flick->thinker);\n\n    flick->thinker.function.acp1 = (actionf_p1) T_FireFlicker;\n    flick->sector = sector;\n    flick->maxlight = sector->lightlevel;\n    flick->minlight = P_FindMinSurroundingLight(sector,sector->lightlevel)+16;\n    flick->count = 4;\n}\n\n\n\n//\n// BROKEN LIGHT FLASHING\n//\n\n\n//\n// T_LightFlash\n// Do flashing lights.\n//\nvoid T_LightFlash (lightflash_t* flash)\n{\n    if (--flash->count)\n\treturn;\n\t\n    if (flash->sector->lightlevel == flash->maxlight)\n    {\n\tflash-> sector->lightlevel = flash->minlight;\n\tflash->count = (P_Random()&flash->mintime)+1;\n    }\n    else\n    {\n\tflash-> sector->lightlevel = flash->maxlight;\n\tflash->count = (P_Random()&flash->maxtime)+1;\n    }\n\n}\n\n\n\n\n//\n// P_SpawnLightFlash\n// After the map has been loaded, scan each sector\n// for specials that spawn thinkers\n//\nvoid P_SpawnLightFlash (sector_t*\tsector)\n{\n    lightflash_t*\tflash;\n\n    // nothing special about it during gameplay\n    sector->special = 0;\t\n\t\n    flash = Z_Malloc ( sizeof(*flash), PU_LEVSPEC, 0);\n\n    P_AddThinker (&flash->thinker);\n\n    flash->thinker.function.acp1 = (actionf_p1) T_LightFlash;\n    flash->sector = sector;\n    flash->maxlight = sector->lightlevel;\n\n    flash->minlight = P_FindMinSurroundingLight(sector,sector->lightlevel);\n    flash->maxtime = 64;\n    flash->mintime = 7;\n    flash->count = (P_Random()&flash->maxtime)+1;\n}\n\n\n\n//\n// STROBE LIGHT FLASHING\n//\n\n\n//\n// T_StrobeFlash\n//\nvoid T_StrobeFlash (strobe_t*\t\tflash)\n{\n    if (--flash->count)\n\treturn;\n\t\n    if (flash->sector->lightlevel == flash->minlight)\n    {\n\tflash-> sector->lightlevel = flash->maxlight;\n\tflash->count = flash->brighttime;\n    }\n    else\n    {\n\tflash-> sector->lightlevel = flash->minlight;\n\tflash->count =flash->darktime;\n    }\n\n}\n\n\n\n//\n// P_SpawnStrobeFlash\n// After the map has been loaded, scan each sector\n// for specials that spawn thinkers\n//\nvoid\nP_SpawnStrobeFlash\n( sector_t*\tsector,\n  int\t\tfastOrSlow,\n  int\t\tinSync )\n{\n    strobe_t*\tflash;\n\t\n    flash = Z_Malloc ( sizeof(*flash), PU_LEVSPEC, 0);\n\n    P_AddThinker (&flash->thinker);\n\n    flash->sector = sector;\n    flash->darktime = fastOrSlow;\n    flash->brighttime = STROBEBRIGHT;\n    flash->thinker.function.acp1 = (actionf_p1) T_StrobeFlash;\n    flash->maxlight = sector->lightlevel;\n    flash->minlight = P_FindMinSurroundingLight(sector, sector->lightlevel);\n\t\t\n    if (flash->minlight == flash->maxlight)\n\tflash->minlight = 0;\n\n    // nothing special about it during gameplay\n    sector->special = 0;\t\n\n    if (!inSync)\n\tflash->count = (P_Random()&7)+1;\n    else\n\tflash->count = 1;\n}\n\n\n//\n// Start strobing lights (usually from a trigger)\n//\nvoid EV_StartLightStrobing(line_t*\tline)\n{\n    int\t\tsecnum;\n    sector_t*\tsec;\n\t\n    secnum = -1;\n    while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n    {\n\tsec = &sectors[secnum];\n\tif (sec->lightingdata)\n\t    continue;\n\t\n\tP_SpawnStrobeFlash (sec,SLOWDARK, 0);\n    }\n}\n\n\n\n//\n// TURN LINE'S TAG LIGHTS OFF\n//\nvoid EV_TurnTagLightsOff(line_t* line)\n{\n    int\t\t\ti;\n    int\t\t\tj;\n    int\t\t\tmin;\n    sector_t*\t\tsector;\n    sector_t*\t\ttsec;\n    line_t*\t\ttempline;\n\t\n    sector = sectors;\n    \n    for (j = 0;j < numsectors; j++, sector++)\n    {\n\tif (sector->tag == line->tag)\n\t{\n\t    min = sector->lightlevel;\n\t    for (i = 0;i < sector->linecount; i++)\n\t    {\n\t\ttempline = sector->lines[i];\n\t\ttsec = getNextSector(templine,sector);\n\t\tif (!tsec)\n\t\t    continue;\n\t\tif (tsec->lightlevel < min)\n\t\t    min = tsec->lightlevel;\n\t    }\n\t    sector->lightlevel = min;\n\t}\n    }\n}\n\n\n//\n// TURN LINE'S TAG LIGHTS ON\n//\nvoid\nEV_LightTurnOn\n( line_t*\tline,\n  int\t\tbright )\n{\n    int\t\ti;\n    int\t\tj;\n    sector_t*\tsector;\n    sector_t*\ttemp;\n    line_t*\ttempline;\n\t\n    sector = sectors;\n\t\n    for (i=0;i<numsectors;i++, sector++)\n    {\n\tif (sector->tag == line->tag)\n\t{\n\t    // bright = 0 means to search\n\t    // for highest light level\n\t    // surrounding sector\n\t    if (!bright)\n\t    {\n\t\tfor (j = 0;j < sector->linecount; j++)\n\t\t{\n\t\t    templine = sector->lines[j];\n\t\t    temp = getNextSector(templine,sector);\n\n\t\t    if (!temp)\n\t\t\tcontinue;\n\n\t\t    if (temp->lightlevel > bright)\n\t\t\tbright = temp->lightlevel;\n\t\t}\n\t    }\n\t    sector-> lightlevel = bright;\n\t}\n    }\n}\n\n    \n//\n// Spawn glowing light\n//\n\nvoid T_Glow(glow_t*\tg)\n{\n    switch(g->direction)\n    {\n      case -1:\n\t// DOWN\n\tg->sector->lightlevel -= GLOWSPEED;\n\tif (g->sector->lightlevel <= g->minlight)\n\t{\n\t    g->sector->lightlevel += GLOWSPEED;\n\t    g->direction = 1;\n\t}\n\tbreak;\n\t\n      case 1:\n\t// UP\n\tg->sector->lightlevel += GLOWSPEED;\n\tif (g->sector->lightlevel >= g->maxlight)\n\t{\n\t    g->sector->lightlevel -= GLOWSPEED;\n\t    g->direction = -1;\n\t}\n\tbreak;\n    }\n}\n\n\nvoid P_SpawnGlowingLight(sector_t*\tsector)\n{\n    glow_t*\tg;\n\t\n    g = Z_Malloc( sizeof(*g), PU_LEVSPEC, 0);\n\n    P_AddThinker(&g->thinker);\n\n    g->sector = sector;\n    g->minlight = P_FindMinSurroundingLight(sector,sector->lightlevel);\n    g->maxlight = sector->lightlevel;\n    g->thinker.function.acp1 = (actionf_p1) T_Glow;\n    g->direction = -1;\n\n    sector->special = 0;\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// Emulates the IO functions in C stdio.h reading and writing to \n// memory.\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"memio.h\"\n\n#include \"z_zone.h\"\n\ntypedef enum {\n\tMODE_READ,\n\tMODE_WRITE,\n} memfile_mode_t;\n\nstruct _MEMFILE {\n\tunsigned char *buf;\n\tsize_t buflen;\n\tsize_t alloced;\n\tunsigned int position;\n\tmemfile_mode_t mode;\n};\n\n// Open a memory area for reading\n\nMEMFILE *mem_fopen_read(void *buf, size_t buflen)\n{\n\tMEMFILE *file;\n\n\tfile = Z_Malloc(sizeof(MEMFILE), PU_STATIC, 0);\n\n\tfile->buf = (unsigned char *) buf;\n\tfile->buflen = buflen;\n\tfile->position = 0;\n\tfile->mode = MODE_READ;\n\n\treturn file;\n}\n\n// Read bytes\n\nsize_t mem_fread(void *buf, size_t size, size_t nmemb, MEMFILE *stream)\n{\n\tsize_t items;\n\n\tif (stream->mode != MODE_READ)\n\t{\n\t\treturn -1;\n\t}\n\n\t// Trying to read more bytes than we have left?\n\t\n\titems = nmemb;\n\n\tif (items * size > stream->buflen - stream->position) \n\t{\n\t\titems = (stream->buflen - stream->position) / size;\n\t}\n\t\n\t// Copy bytes to buffer\n\t\n\tmemcpy(buf, stream->buf + stream->position, items * size);\n\n\t// Update position\n\n\tstream->position += items * size;\n\t\n\treturn items;\n}\n\n// Open a memory area for writing\n\nMEMFILE *mem_fopen_write(void)\n{\n\tMEMFILE *file;\n\n\tfile = Z_Malloc(sizeof(MEMFILE), PU_STATIC, 0);\n\n\tfile->alloced = 1024;\n\tfile->buf = Z_Malloc(file->alloced, PU_STATIC, 0);\n\tfile->buflen = 0;\n\tfile->position = 0;\n\tfile->mode = MODE_WRITE;\n\n\treturn file;\n}\n\n// Write bytes to stream\n\nsize_t mem_fwrite(const void *ptr, size_t size, size_t nmemb, MEMFILE *stream)\n{\n\tsize_t bytes;\n\n\tif (stream->mode != MODE_WRITE)\n\t{\n\t\treturn -1;\n\t}\n\t\n\t// More bytes than can fit in the buffer?\n\t// If so, reallocate bigger.\n\n\tbytes = size * nmemb;\n\t\n\twhile (bytes > stream->alloced - stream->position)\n\t{\n\t\tunsigned char *newbuf;\n\n\t\tnewbuf = Z_Malloc(stream->alloced * 2, PU_STATIC, 0);\n\t\tmemcpy(newbuf, stream->buf, stream->alloced);\n\t\tZ_Free(stream->buf);\n\t\tstream->buf = newbuf;\n\t\tstream->alloced *= 2;\n\t}\n\n\t// Copy into buffer\n\t\n\tmemcpy(stream->buf + stream->position, ptr, bytes);\n\tstream->position += bytes;\n\n\tif (stream->position > stream->buflen)\n\t\tstream->buflen = stream->position;\n\n\treturn nmemb;\n}\n\nvoid mem_get_buf(MEMFILE *stream, void **buf, size_t *buflen)\n{\n\t*buf = stream->buf;\n\t*buflen = stream->buflen;\n}\n\nvoid mem_fclose(MEMFILE *stream)\n{\n\tif (stream->mode == MODE_WRITE)\n\t{\n\t\tZ_Free(stream->buf);\n\t}\n\n\tZ_Free(stream);\n}\n\nlong mem_ftell(MEMFILE *stream)\n{\n\treturn stream->position;\n}\n\nint mem_fseek(MEMFILE *stream, signed long position, mem_rel_t whence)\n{\n\tunsigned int newpos;\n\n\tswitch (whence)\n\t{\n\t\tcase MEM_SEEK_SET:\n\t\t\tnewpos = (int) position;\n\t\t\tbreak;\n\n\t\tcase MEM_SEEK_CUR:\n\t\t\tnewpos = (int) (stream->position + position);\n\t\t\tbreak;\n\t\t\t\n\t\tcase MEM_SEEK_END:\n\t\t\tnewpos = (int) (stream->buflen + position);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -1;\n\t}\n\n\tif (newpos < stream->buflen)\n\t{\n\t\tstream->position = newpos;\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\treturn -1;\n\t}\n}\n\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//    Reading of MIDI files.\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n\n#include \"doomtype.h\"\n#include \"i_swap.h\"\n#include \"i_system.h\"\n#include \"midifile.h\"\n\n#define HEADER_CHUNK_ID \"MThd\"\n#define TRACK_CHUNK_ID  \"MTrk\"\n#define MAX_BUFFER_SIZE 0x10000\n\n// haleyjd 09/09/10: packing required\n#ifdef _MSC_VER\n#pragma pack(push, 1)\n#endif\n\ntypedef PACKED_STRUCT (\n{\n    byte chunk_id[4];\n    unsigned int chunk_size;\n}) chunk_header_t;\n\ntypedef PACKED_STRUCT (\n{\n    chunk_header_t chunk_header;\n    unsigned short format_type;\n    unsigned short num_tracks;\n    unsigned short time_division;\n}) midi_header_t;\n\n// haleyjd 09/09/10: packing off.\n#ifdef _MSC_VER\n#pragma pack(pop)\n#endif\n\ntypedef struct\n{\n    // Length in bytes:\n\n    unsigned int data_len;\n\n    // Events in this track:\n\n    midi_event_t *events;\n    int num_events;\n} midi_track_t;\n\nstruct midi_track_iter_s\n{\n    midi_track_t *track;\n    unsigned int position;\n};\n\nstruct midi_file_s\n{\n    midi_header_t header;\n\n    // All tracks in this file:\n    midi_track_t *tracks;\n    unsigned int num_tracks;\n\n    // Data buffer used to store data read for SysEx or meta events:\n    byte *buffer;\n    unsigned int buffer_size;\n};\n\n// Check the header of a chunk:\n\nstatic boolean CheckChunkHeader(chunk_header_t *chunk,\n                                const char *expected_id)\n{\n    boolean result;\n    \n    result = (memcmp((char *) chunk->chunk_id, expected_id, 4) == 0);\n\n    if (!result)\n    {\n        fprintf(stderr, \"CheckChunkHeader: Expected '%s' chunk header, \"\n                        \"got '%c%c%c%c'\\n\",\n                        expected_id,\n                        chunk->chunk_id[0], chunk->chunk_id[1],\n                        chunk->chunk_id[2], chunk->chunk_id[3]);\n    }\n\n    return result;\n}\n\n// Read a single byte.  Returns false on error.\n\nstatic boolean ReadByte(byte *result, FILE *stream)\n{\n    int c;\n\n    c = fgetc(stream);\n\n    if (c == EOF)\n    {\n        fprintf(stderr, \"ReadByte: Unexpected end of file\\n\");\n        return false;\n    }\n    else\n    {\n        *result = (byte) c;\n\n        return true;\n    }\n}\n\n// Read a variable-length value.\n\nstatic boolean ReadVariableLength(unsigned int *result, FILE *stream)\n{\n    int i;\n    byte b = 0;\n\n    *result = 0;\n\n    for (i=0; i<4; ++i)\n    {\n        if (!ReadByte(&b, stream))\n        {\n            fprintf(stderr, \"ReadVariableLength: Error while reading \"\n                            \"variable-length value\\n\");\n            return false;\n        }\n\n        // Insert the bottom seven bits from this byte.\n\n        *result <<= 7;\n        *result |= b & 0x7f;\n\n        // If the top bit is not set, this is the end.\n\n        if ((b & 0x80) == 0)\n        {\n            return true;\n        }\n    }\n\n    fprintf(stderr, \"ReadVariableLength: Variable-length value too \"\n                    \"long: maximum of four bytes\\n\");\n    return false;\n}\n\n// Read a byte sequence into the data buffer.\n\nstatic void *ReadByteSequence(unsigned int num_bytes, FILE *stream)\n{\n    unsigned int i;\n    byte *result;\n\n    // Allocate a buffer. Allocate one extra byte, as malloc(0) is\n    // non-portable.\n\n    result = malloc(num_bytes + 1);\n\n    if (result == NULL)\n    {\n        fprintf(stderr, \"ReadByteSequence: Failed to allocate buffer\\n\");\n        return NULL;\n    }\n\n    // Read the data:\n\n    for (i=0; i<num_bytes; ++i)\n    {\n        if (!ReadByte(&result[i], stream))\n        {\n            fprintf(stderr, \"ReadByteSequence: Error while reading byte %u\\n\",\n                            i);\n            free(result);\n            return NULL;\n        }\n    }\n\n    return result;\n}\n\n// Read a MIDI channel event.\n// two_param indicates that the event type takes two parameters\n// (three byte) otherwise it is single parameter (two byte)\n\nstatic boolean ReadChannelEvent(midi_event_t *event,\n                                byte event_type, boolean two_param,\n                                FILE *stream)\n{\n    byte b = 0;\n\n    // Set basics:\n\n    event->event_type = event_type & 0xf0;\n    event->data.channel.channel = event_type & 0x0f;\n\n    // Read parameters:\n\n    if (!ReadByte(&b, stream))\n    {\n        fprintf(stderr, \"ReadChannelEvent: Error while reading channel \"\n                        \"event parameters\\n\");\n        return false;\n    }\n\n    event->data.channel.param1 = b;\n\n    // Second parameter:\n\n    if (two_param)\n    {\n        if (!ReadByte(&b, stream))\n        {\n            fprintf(stderr, \"ReadChannelEvent: Error while reading channel \"\n                            \"event parameters\\n\");\n            return false;\n        }\n\n        event->data.channel.param2 = b;\n    }\n\n    return true;\n}\n\n// Read sysex event:\n\nstatic boolean ReadSysExEvent(midi_event_t *event, int event_type,\n                              FILE *stream)\n{\n    event->event_type = event_type;\n\n    if (!ReadVariableLength(&event->data.sysex.length, stream))\n    {\n        fprintf(stderr, \"ReadSysExEvent: Failed to read length of \"\n                                        \"SysEx block\\n\");\n        return false;\n    }\n\n    // Read the byte sequence:\n\n    event->data.sysex.data = ReadByteSequence(event->data.sysex.length, stream);\n\n    if (event->data.sysex.data == NULL)\n    {\n        fprintf(stderr, \"ReadSysExEvent: Failed while reading SysEx event\\n\");\n        return false;\n    }\n\n    return true;\n}\n\n// Read meta event:\n\nstatic boolean ReadMetaEvent(midi_event_t *event, FILE *stream)\n{\n    byte b = 0;\n\n    event->event_type = MIDI_EVENT_META;\n\n    // Read meta event type:\n\n    if (!ReadByte(&b, stream))\n    {\n        fprintf(stderr, \"ReadMetaEvent: Failed to read meta event type\\n\");\n        return false;\n    }\n\n    event->data.meta.type = b;\n\n    // Read length of meta event data:\n\n    if (!ReadVariableLength(&event->data.meta.length, stream))\n    {\n        fprintf(stderr, \"ReadSysExEvent: Failed to read length of \"\n                                        \"SysEx block\\n\");\n        return false;\n    }\n\n    // Read the byte sequence:\n\n    event->data.meta.data = ReadByteSequence(event->data.meta.length, stream);\n\n    if (event->data.meta.data == NULL)\n    {\n        fprintf(stderr, \"ReadSysExEvent: Failed while reading SysEx event\\n\");\n        return false;\n    }\n\n    return true;\n}\n\nstatic boolean ReadEvent(midi_event_t *event, unsigned int *last_event_type,\n                         FILE *stream)\n{\n    byte event_type = 0;\n\n    if (!ReadVariableLength(&event->delta_time, stream))\n    {\n        fprintf(stderr, \"ReadEvent: Failed to read event timestamp\\n\");\n        return false;\n    }\n\n    if (!ReadByte(&event_type, stream))\n    {\n        fprintf(stderr, \"ReadEvent: Failed to read event type\\n\");\n        return false;\n    }\n\n    // All event types have their top bit set.  Therefore, if \n    // the top bit is not set, it is because we are using the \"same\n    // as previous event type\" shortcut to save a byte.  Skip back\n    // a byte so that we read this byte again.\n\n    if ((event_type & 0x80) == 0)\n    {\n        event_type = *last_event_type;\n\n        if (fseek(stream, -1, SEEK_CUR) < 0)\n        {\n            fprintf(stderr, \"ReadEvent: Unable to seek in stream\\n\");\n            return false;\n        }\n    }\n    else\n    {\n        *last_event_type = event_type;\n    }\n\n    // Check event type:\n\n    switch (event_type & 0xf0)\n    {\n        // Two parameter channel events:\n\n        case MIDI_EVENT_NOTE_OFF:\n        case MIDI_EVENT_NOTE_ON:\n        case MIDI_EVENT_AFTERTOUCH:\n        case MIDI_EVENT_CONTROLLER:\n        case MIDI_EVENT_PITCH_BEND:\n            return ReadChannelEvent(event, event_type, true, stream);\n\n        // Single parameter channel events:\n\n        case MIDI_EVENT_PROGRAM_CHANGE:\n        case MIDI_EVENT_CHAN_AFTERTOUCH:\n            return ReadChannelEvent(event, event_type, false, stream);\n\n        default:\n            break;\n    }\n\n    // Specific value?\n\n    switch (event_type)\n    {\n        case MIDI_EVENT_SYSEX:\n        case MIDI_EVENT_SYSEX_SPLIT:\n            return ReadSysExEvent(event, event_type, stream);\n\n        case MIDI_EVENT_META:\n            return ReadMetaEvent(event, stream);\n\n        default:\n            break;\n    }\n\n    fprintf(stderr, \"ReadEvent: Unknown MIDI event type: 0x%x\\n\", event_type);\n    return false;\n}\n\n// Free an event:\n\nstatic void FreeEvent(midi_event_t *event)\n{\n    // Some event types have dynamically allocated buffers assigned\n    // to them that must be freed.\n\n    switch (event->event_type)\n    {\n        case MIDI_EVENT_SYSEX:\n        case MIDI_EVENT_SYSEX_SPLIT:\n            free(event->data.sysex.data);\n            break;\n\n        case MIDI_EVENT_META:\n            free(event->data.meta.data);\n            break;\n\n        default:\n            // Nothing to do.\n            break;\n    }\n}\n\n// Read and check the track chunk header\n\nstatic boolean ReadTrackHeader(midi_track_t *track, FILE *stream)\n{\n    size_t records_read;\n    chunk_header_t chunk_header;\n\n    records_read = fread(&chunk_header, sizeof(chunk_header_t), 1, stream);\n\n    if (records_read < 1)\n    {\n        return false;\n    }\n\n    if (!CheckChunkHeader(&chunk_header, TRACK_CHUNK_ID))\n    {\n        return false;\n    }\n\n    track->data_len = SDL_SwapBE32(chunk_header.chunk_size);\n\n    return true;\n}\n\nstatic boolean ReadTrack(midi_track_t *track, FILE *stream)\n{\n    midi_event_t *new_events;\n    midi_event_t *event;\n    unsigned int last_event_type;\n\n    track->num_events = 0;\n    track->events = NULL;\n\n    // Read the header:\n\n    if (!ReadTrackHeader(track, stream))\n    {\n        return false;\n    }\n\n    // Then the events:\n\n    last_event_type = 0;\n\n    for (;;)\n    {\n        // Resize the track slightly larger to hold another event:\n\n        new_events = I_Realloc(track->events, \n                             sizeof(midi_event_t) * (track->num_events + 1));\n        track->events = new_events;\n\n        // Read the next event:\n\n        event = &track->events[track->num_events];\n        if (!ReadEvent(event, &last_event_type, stream))\n        {\n            return false;\n        }\n\n        ++track->num_events;\n\n        // End of track?\n\n        if (event->event_type == MIDI_EVENT_META\n         && event->data.meta.type == MIDI_META_END_OF_TRACK)\n        {\n            break;\n        }\n    }\n\n    return true;\n}\n\n// Free a track:\n\nstatic void FreeTrack(midi_track_t *track)\n{\n    unsigned int i;\n\n    for (i=0; i<track->num_events; ++i)\n    {\n        FreeEvent(&track->events[i]);\n    }\n\n    free(track->events);\n}\n\nstatic boolean ReadAllTracks(midi_file_t *file, FILE *stream)\n{\n    unsigned int i;\n\n    // Allocate list of tracks and read each track:\n\n    file->tracks = malloc(sizeof(midi_track_t) * file->num_tracks);\n\n    if (file->tracks == NULL)\n    {\n        return false;\n    }\n\n    memset(file->tracks, 0, sizeof(midi_track_t) * file->num_tracks);\n\n    // Read each track:\n\n    for (i=0; i<file->num_tracks; ++i)\n    {\n        if (!ReadTrack(&file->tracks[i], stream))\n        {\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Read and check the header chunk.\n\nstatic boolean ReadFileHeader(midi_file_t *file, FILE *stream)\n{\n    size_t records_read;\n    unsigned int format_type;\n\n    records_read = fread(&file->header, sizeof(midi_header_t), 1, stream);\n\n    if (records_read < 1)\n    {\n        return false;\n    }\n\n    if (!CheckChunkHeader(&file->header.chunk_header, HEADER_CHUNK_ID)\n     || SDL_SwapBE32(file->header.chunk_header.chunk_size) != 6)\n    {\n        fprintf(stderr, \"ReadFileHeader: Invalid MIDI chunk header! \"\n                        \"chunk_size=%i\\n\",\n                        SDL_SwapBE32(file->header.chunk_header.chunk_size));\n        return false;\n    }\n\n    format_type = SDL_SwapBE16(file->header.format_type);\n    file->num_tracks = SDL_SwapBE16(file->header.num_tracks);\n\n    if ((format_type != 0 && format_type != 1)\n     || file->num_tracks < 1)\n    {\n        fprintf(stderr, \"ReadFileHeader: Only type 0/1 \"\n                                         \"MIDI files supported!\\n\");\n        return false;\n    }\n\n    return true;\n}\n\nvoid MIDI_FreeFile(midi_file_t *file)\n{\n    int i;\n\n    if (file->tracks != NULL)\n    {\n        for (i=0; i<file->num_tracks; ++i)\n        {\n            FreeTrack(&file->tracks[i]);\n        }\n\n        free(file->tracks);\n    }\n\n    free(file);\n}\n\nmidi_file_t *MIDI_LoadFile(char *filename)\n{\n    midi_file_t *file;\n    FILE *stream;\n\n    file = malloc(sizeof(midi_file_t));\n\n    if (file == NULL)\n    {\n        return NULL;\n    }\n\n    file->tracks = NULL;\n    file->num_tracks = 0;\n    file->buffer = NULL;\n    file->buffer_size = 0;\n\n    // Open file\n\n    stream = fopen(filename, \"rb\");\n\n    if (stream == NULL)\n    {\n        fprintf(stderr, \"MIDI_LoadFile: Failed to open '%s'\\n\", filename);\n        MIDI_FreeFile(file);\n        return NULL;\n    }\n\n    // Read MIDI file header\n\n    if (!ReadFileHeader(file, stream))\n    {\n        fclose(stream);\n        MIDI_FreeFile(file);\n        return NULL;\n    }\n\n    // Read all tracks:\n\n    if (!ReadAllTracks(file, stream))\n    {\n        fclose(stream);\n        MIDI_FreeFile(file);\n        return NULL;\n    }\n\n    fclose(stream);\n\n    return file;\n}\n\n// Get the number of tracks in a MIDI file.\n\nunsigned int MIDI_NumTracks(midi_file_t *file)\n{\n    return file->num_tracks;\n}\n\n// Start iterating over the events in a track.\n\nmidi_track_iter_t *MIDI_IterateTrack(midi_file_t *file, unsigned int track)\n{\n    midi_track_iter_t *iter;\n\n    assert(track < file->num_tracks);\n\n    iter = malloc(sizeof(*iter));\n    iter->track = &file->tracks[track];\n    iter->position = 0;\n\n    return iter;\n}\n\nvoid MIDI_FreeIterator(midi_track_iter_t *iter)\n{\n    free(iter);\n}\n\n// Get the time until the next MIDI event in a track.\n\nunsigned int MIDI_GetDeltaTime(midi_track_iter_t *iter)\n{\n    if (iter->position < iter->track->num_events)\n    {\n        midi_event_t *next_event;\n\n        next_event = &iter->track->events[iter->position];\n\n        return next_event->delta_time;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\n// Get a pointer to the next MIDI event.\n\nint MIDI_GetNextEvent(midi_track_iter_t *iter, midi_event_t **event)\n{\n    if (iter->position < iter->track->num_events)\n    {\n        *event = &iter->track->events[iter->position];\n        ++iter->position;\n\n        return 1;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\nunsigned int MIDI_GetFileTimeDivision(midi_file_t *file)\n{\n    short result = SDL_SwapBE16(file->header.time_division);\n\n    // Negative time division indicates SMPTE time and must be handled\n    // differently.\n    if (result < 0)\n    {\n        return (signed int)(-(result/256))\n             * (signed int)(result & 0xFF);\n    }\n    else\n    {\n        return result;\n    }\n}\n\nvoid MIDI_RestartIterator(midi_track_iter_t *iter)\n{\n    iter->position = 0;\n}\n\n#ifdef TEST\n\nstatic char *MIDI_EventTypeToString(midi_event_type_t event_type)\n{\n    switch (event_type)\n    {\n        case MIDI_EVENT_NOTE_OFF:\n            return \"MIDI_EVENT_NOTE_OFF\";\n        case MIDI_EVENT_NOTE_ON:\n            return \"MIDI_EVENT_NOTE_ON\";\n        case MIDI_EVENT_AFTERTOUCH:\n            return \"MIDI_EVENT_AFTERTOUCH\";\n        case MIDI_EVENT_CONTROLLER:\n            return \"MIDI_EVENT_CONTROLLER\";\n        case MIDI_EVENT_PROGRAM_CHANGE:\n            return \"MIDI_EVENT_PROGRAM_CHANGE\";\n        case MIDI_EVENT_CHAN_AFTERTOUCH:\n            return \"MIDI_EVENT_CHAN_AFTERTOUCH\";\n        case MIDI_EVENT_PITCH_BEND:\n            return \"MIDI_EVENT_PITCH_BEND\";\n        case MIDI_EVENT_SYSEX:\n            return \"MIDI_EVENT_SYSEX\";\n        case MIDI_EVENT_SYSEX_SPLIT:\n            return \"MIDI_EVENT_SYSEX_SPLIT\";\n        case MIDI_EVENT_META:\n            return \"MIDI_EVENT_META\";\n\n        default:\n            return \"(unknown)\";\n    }\n}\n\nvoid PrintTrack(midi_track_t *track)\n{\n    midi_event_t *event;\n    unsigned int i;\n\n    for (i=0; i<track->num_events; ++i)\n    {\n        event = &track->events[i];\n\n        if (event->delta_time > 0)\n        {\n            printf(\"Delay: %i ticks\\n\", event->delta_time);\n        }\n\n        printf(\"Event type: %s (%i)\\n\",\n               MIDI_EventTypeToString(event->event_type),\n               event->event_type);\n\n        switch(event->event_type)\n        {\n            case MIDI_EVENT_NOTE_OFF:\n            case MIDI_EVENT_NOTE_ON:\n            case MIDI_EVENT_AFTERTOUCH:\n            case MIDI_EVENT_CONTROLLER:\n            case MIDI_EVENT_PROGRAM_CHANGE:\n            case MIDI_EVENT_CHAN_AFTERTOUCH:\n            case MIDI_EVENT_PITCH_BEND:\n                printf(\"\\tChannel: %i\\n\", event->data.channel.channel);\n                printf(\"\\tParameter 1: %i\\n\", event->data.channel.param1);\n                printf(\"\\tParameter 2: %i\\n\", event->data.channel.param2);\n                break;\n\n            case MIDI_EVENT_SYSEX:\n            case MIDI_EVENT_SYSEX_SPLIT:\n                printf(\"\\tLength: %i\\n\", event->data.sysex.length);\n                break;\n\n            case MIDI_EVENT_META:\n                printf(\"\\tMeta type: %i\\n\", event->data.meta.type);\n                printf(\"\\tLength: %i\\n\", event->data.meta.length);\n                break;\n        }\n    }\n}\n\nint main(int argc, char *argv[])\n{\n    midi_file_t *file;\n    unsigned int i;\n\n    if (argc < 2)\n    {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        exit(1);\n    }\n\n    file = MIDI_LoadFile(argv[1]);\n\n    if (file == NULL)\n    {\n        fprintf(stderr, \"Failed to open %s\\n\", argv[1]);\n        exit(1);\n    }\n\n    for (i=0; i<file->num_tracks; ++i)\n    {\n        printf(\"\\n== Track %i ==\\n\\n\", i);\n\n        PrintTrack(&file->tracks[i]);\n    }\n\n    return 0;\n}\n\n#endif\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n// Copyright(C) 2006 Ben Ryves 2006\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// mus2mid.c - Ben Ryves 2006 - http://benryves.com - benryves@benryves.com\n// Use to convert a MUS file into a single track, type 0 MIDI file.\n\n#include <stdio.h>\n\n#include \"doomtype.h\"\n#include \"i_swap.h\"\n\n#include \"memio.h\"\n#include \"mus2mid.h\"\n\n#define NUM_CHANNELS 16\n\n#define MIDI_PERCUSSION_CHAN 9\n#define MUS_PERCUSSION_CHAN 15\n\n// MUS event codes\ntypedef enum\n{\n    mus_releasekey = 0x00,\n    mus_presskey = 0x10,\n    mus_pitchwheel = 0x20,\n    mus_systemevent = 0x30,\n    mus_changecontroller = 0x40,\n    mus_scoreend = 0x60\n} musevent;\n\n// MIDI event codes\ntypedef enum\n{\n    midi_releasekey = 0x80,\n    midi_presskey = 0x90,\n    midi_aftertouchkey = 0xA0,\n    midi_changecontroller = 0xB0,\n    midi_changepatch = 0xC0,\n    midi_aftertouchchannel = 0xD0,\n    midi_pitchwheel = 0xE0\n} midievent;\n\n// Structure to hold MUS file header\ntypedef PACKED_STRUCT (\n{\n    byte id[4];\n    unsigned short scorelength;\n    unsigned short scorestart;\n    unsigned short primarychannels;\n    unsigned short secondarychannels;\n    unsigned short instrumentcount;\n}) musheader;\n\n// Standard MIDI type 0 header + track header\nstatic const byte midiheader[] =\n{\n    'M', 'T', 'h', 'd',     // Main header\n    0x00, 0x00, 0x00, 0x06, // Header size\n    0x00, 0x00,             // MIDI type (0)\n    0x00, 0x01,             // Number of tracks\n    0x00, 0x46,             // Resolution\n    'M', 'T', 'r', 'k',        // Start of track\n    0x00, 0x00, 0x00, 0x00  // Placeholder for track length\n};\n\n// Cached channel velocities\nstatic byte channelvelocities[] =\n{\n    127, 127, 127, 127, 127, 127, 127, 127,\n    127, 127, 127, 127, 127, 127, 127, 127\n};\n\n// Timestamps between sequences of MUS events\n\nstatic unsigned int queuedtime = 0;\n\n// Counter for the length of the track\n\nstatic unsigned int tracksize;\n\nstatic const byte controller_map[] =\n{\n    0x00, 0x20, 0x01, 0x07, 0x0A, 0x0B, 0x5B, 0x5D,\n    0x40, 0x43, 0x78, 0x7B, 0x7E, 0x7F, 0x79\n};\n\nstatic int channel_map[NUM_CHANNELS];\n\n// Write timestamp to a MIDI file.\n\nstatic boolean WriteTime(unsigned int time, MEMFILE *midioutput)\n{\n    unsigned int buffer = time & 0x7F;\n    byte writeval;\n\n    while ((time >>= 7) != 0)\n    {\n        buffer <<= 8;\n        buffer |= ((time & 0x7F) | 0x80);\n    }\n\n    for (;;)\n    {\n        writeval = (byte)(buffer & 0xFF);\n\n        if (mem_fwrite(&writeval, 1, 1, midioutput) != 1)\n        {\n            return true;\n        }\n\n        ++tracksize;\n\n        if ((buffer & 0x80) != 0)\n        {\n            buffer >>= 8;\n        }\n        else\n        {\n            queuedtime = 0;\n            return false;\n        }\n    }\n}\n\n\n// Write the end of track marker\nstatic boolean WriteEndTrack(MEMFILE *midioutput)\n{\n    byte endtrack[] = {0xFF, 0x2F, 0x00};\n\n    if (WriteTime(queuedtime, midioutput))\n    {\n        return true;\n    }\n\n    if (mem_fwrite(endtrack, 1, 3, midioutput) != 3)\n    {\n        return true;\n    }\n\n    tracksize += 3;\n    return false;\n}\n\n// Write a key press event\nstatic boolean WritePressKey(byte channel, byte key,\n                             byte velocity, MEMFILE *midioutput)\n{\n    byte working = midi_presskey | channel;\n\n    if (WriteTime(queuedtime, midioutput))\n    {\n        return true;\n    }\n\n    if (mem_fwrite(&working, 1, 1, midioutput) != 1)\n    {\n        return true;\n    }\n\n    working = key & 0x7F;\n\n    if (mem_fwrite(&working, 1, 1, midioutput) != 1)\n    {\n        return true;\n    }\n\n    working = velocity & 0x7F;\n\n    if (mem_fwrite(&working, 1, 1, midioutput) != 1)\n    {\n        return true;\n    }\n\n    tracksize += 3;\n\n    return false;\n}\n\n// Write a key release event\nstatic boolean WriteReleaseKey(byte channel, byte key,\n                               MEMFILE *midioutput)\n{\n    byte working = midi_releasekey | channel;\n\n    if (WriteTime(queuedtime, midioutput))\n    {\n        return true;\n    }\n\n    if (mem_fwrite(&working, 1, 1, midioutput) != 1)\n    {\n        return true;\n    }\n\n    working = key & 0x7F;\n\n    if (mem_fwrite(&working, 1, 1, midioutput) != 1)\n    {\n        return true;\n    }\n\n    working = 0;\n\n    if (mem_fwrite(&working, 1, 1, midioutput) != 1)\n    {\n        return true;\n    }\n\n    tracksize += 3;\n\n    return false;\n}\n\n// Write a pitch wheel/bend event\nstatic boolean WritePitchWheel(byte channel, short wheel,\n                               MEMFILE *midioutput)\n{\n    byte working = midi_pitchwheel | channel;\n\n    if (WriteTime(queuedtime, midioutput))\n    {\n        return true;\n    }\n\n    if (mem_fwrite(&working, 1, 1, midioutput) != 1)\n    {\n        return true;\n    }\n\n    working = wheel & 0x7F;\n\n    if (mem_fwrite(&working, 1, 1, midioutput) != 1)\n    {\n        return true;\n    }\n\n    working = (wheel >> 7) & 0x7F;\n\n    if (mem_fwrite(&working, 1, 1, midioutput) != 1)\n    {\n        return true;\n    }\n\n    tracksize += 3;\n    return false;\n}\n\n// Write a patch change event\nstatic boolean WriteChangePatch(byte channel, byte patch,\n                                MEMFILE *midioutput)\n{\n    byte working = midi_changepatch | channel;\n\n    if (WriteTime(queuedtime, midioutput))\n    {\n        return true;\n    }\n\n    if (mem_fwrite(&working, 1, 1, midioutput) != 1)\n    {\n        return true;\n    }\n\n    working = patch & 0x7F;\n\n    if (mem_fwrite(&working, 1, 1, midioutput) != 1)\n    {\n        return true;\n    }\n\n    tracksize += 2;\n\n    return false;\n}\n\n// Write a valued controller change event\n\nstatic boolean WriteChangeController_Valued(byte channel,\n                                            byte control,\n                                            byte value,\n                                            MEMFILE *midioutput)\n{\n    byte working = midi_changecontroller | channel;\n\n    if (WriteTime(queuedtime, midioutput))\n    {\n        return true;\n    }\n\n    if (mem_fwrite(&working, 1, 1, midioutput) != 1)\n    {\n        return true;\n    }\n\n    working = control & 0x7F;\n\n    if (mem_fwrite(&working, 1, 1, midioutput) != 1)\n    {\n        return true;\n    }\n\n    // Quirk in vanilla DOOM? MUS controller values should be\n    // 7-bit, not 8-bit.\n\n    working = value;// & 0x7F;\n\n    // Fix on said quirk to stop MIDI players from complaining that\n    // the value is out of range:\n\n    if (working & 0x80)\n    {\n        working = 0x7F;\n    }\n\n    if (mem_fwrite(&working, 1, 1, midioutput) != 1)\n    {\n        return true;\n    }\n\n    tracksize += 3;\n\n    return false;\n}\n\n// Write a valueless controller change event\nstatic boolean WriteChangeController_Valueless(byte channel,\n                                               byte control,\n                                               MEMFILE *midioutput)\n{\n    return WriteChangeController_Valued(channel, control, 0,\n                                             midioutput);\n}\n\n// Allocate a free MIDI channel.\n\nstatic int AllocateMIDIChannel(void)\n{\n    int result;\n    int max;\n    int i;\n\n    // Find the current highest-allocated channel.\n\n    max = -1;\n\n    for (i=0; i<NUM_CHANNELS; ++i)\n    {\n        if (channel_map[i] > max)\n        {\n            max = channel_map[i];\n        }\n    }\n\n    // max is now equal to the highest-allocated MIDI channel.  We can\n    // now allocate the next available channel.  This also works if\n    // no channels are currently allocated (max=-1)\n\n    result = max + 1;\n\n    // Don't allocate the MIDI percussion channel!\n\n    if (result == MIDI_PERCUSSION_CHAN)\n    {\n        ++result;\n    }\n\n    return result;\n}\n\n// Given a MUS channel number, get the MIDI channel number to use\n// in the outputted file.\n\nstatic int GetMIDIChannel(int mus_channel, MEMFILE *midioutput)\n{\n    // Find the MIDI channel to use for this MUS channel.\n    // MUS channel 15 is the percusssion channel.\n\n    if (mus_channel == MUS_PERCUSSION_CHAN)\n    {\n        return MIDI_PERCUSSION_CHAN;\n    }\n    else\n    {\n        // If a MIDI channel hasn't been allocated for this MUS channel\n        // yet, allocate the next free MIDI channel.\n\n        if (channel_map[mus_channel] == -1)\n        {\n            channel_map[mus_channel] = AllocateMIDIChannel();\n\n            // First time using the channel, send an \"all notes off\"\n            // event. This fixes \"The D_DDTBLU disease\" described here:\n            // https://www.doomworld.com/vb/source-ports/66802-the\n            WriteChangeController_Valueless(channel_map[mus_channel], 0x7b,\n                                            midioutput);\n        }\n\n        return channel_map[mus_channel];\n    }\n}\n\nstatic boolean ReadMusHeader(MEMFILE *file, musheader *header)\n{\n    boolean result;\n\n    result = mem_fread(&header->id, sizeof(byte), 4, file) == 4\n          && mem_fread(&header->scorelength, sizeof(short), 1, file) == 1\n          && mem_fread(&header->scorestart, sizeof(short), 1, file) == 1\n          && mem_fread(&header->primarychannels, sizeof(short), 1, file) == 1\n          && mem_fread(&header->secondarychannels, sizeof(short), 1, file) == 1\n          && mem_fread(&header->instrumentcount, sizeof(short), 1, file) == 1;\n\n    if (result)\n    {\n        header->scorelength = SHORT(header->scorelength);\n        header->scorestart = SHORT(header->scorestart);\n        header->primarychannels = SHORT(header->primarychannels);\n        header->secondarychannels = SHORT(header->secondarychannels);\n        header->instrumentcount = SHORT(header->instrumentcount);\n    }\n\n    return result;\n}\n\n\n// Read a MUS file from a stream (musinput) and output a MIDI file to\n// a stream (midioutput).\n//\n// Returns 0 on success or 1 on failure.\n\nboolean mus2mid(MEMFILE *musinput, MEMFILE *midioutput)\n{\n    // Header for the MUS file\n    musheader musfileheader;\n\n    // Descriptor for the current MUS event\n    byte eventdescriptor;\n    int channel; // Channel number\n    musevent event;\n\n\n    // Bunch of vars read from MUS lump\n    byte key;\n    byte controllernumber;\n    byte controllervalue;\n\n    // Buffer used for MIDI track size record\n    byte tracksizebuffer[4];\n\n    // Flag for when the score end marker is hit.\n    int hitscoreend = 0;\n\n    // Temp working byte\n    byte working;\n    // Used in building up time delays\n    unsigned int timedelay;\n\n    // Initialise channel map to mark all channels as unused.\n\n    for (channel=0; channel<NUM_CHANNELS; ++channel)\n    {\n        channel_map[channel] = -1;\n    }\n\n    // Grab the header\n\n    if (!ReadMusHeader(musinput, &musfileheader))\n    {\n        return true;\n    }\n\n#ifdef CHECK_MUS_HEADER\n    // Check MUS header\n    if (musfileheader.id[0] != 'M'\n     || musfileheader.id[1] != 'U'\n     || musfileheader.id[2] != 'S'\n     || musfileheader.id[3] != 0x1A)\n    {\n        return true;\n    }\n#endif\n\n    // Seek to where the data is held\n    if (mem_fseek(musinput, (long)musfileheader.scorestart,\n                  MEM_SEEK_SET) != 0)\n    {\n        return true;\n    }\n\n    // So, we can assume the MUS file is faintly legit. Let's start\n    // writing MIDI data...\n\n    mem_fwrite(midiheader, 1, sizeof(midiheader), midioutput);\n    tracksize = 0;\n\n    // Now, process the MUS file:\n    while (!hitscoreend)\n    {\n        // Handle a block of events:\n\n        while (!hitscoreend)\n        {\n            // Fetch channel number and event code:\n\n            if (mem_fread(&eventdescriptor, 1, 1, musinput) != 1)\n            {\n                return true;\n            }\n\n            channel = GetMIDIChannel(eventdescriptor & 0x0F, midioutput);\n            event = eventdescriptor & 0x70;\n\n            switch (event)\n            {\n                case mus_releasekey:\n                    if (mem_fread(&key, 1, 1, musinput) != 1)\n                    {\n                        return true;\n                    }\n\n                    if (WriteReleaseKey(channel, key, midioutput))\n                    {\n                        return true;\n                    }\n\n                    break;\n\n                case mus_presskey:\n                    if (mem_fread(&key, 1, 1, musinput) != 1)\n                    {\n                        return true;\n                    }\n\n                    if (key & 0x80)\n                    {\n                        if (mem_fread(&channelvelocities[channel], 1, 1, musinput) != 1)\n                        {\n                            return true;\n                        }\n\n                        channelvelocities[channel] &= 0x7F;\n                    }\n\n                    if (WritePressKey(channel, key,\n                                      channelvelocities[channel], midioutput))\n                    {\n                        return true;\n                    }\n\n                    break;\n\n                case mus_pitchwheel:\n                    if (mem_fread(&key, 1, 1, musinput) != 1)\n                    {\n                        break;\n                    }\n                    if (WritePitchWheel(channel, (short)(key * 64), midioutput))\n                    {\n                        return true;\n                    }\n\n                    break;\n\n                case mus_systemevent:\n                    if (mem_fread(&controllernumber, 1, 1, musinput) != 1)\n                    {\n                        return true;\n                    }\n                    if (controllernumber < 10 || controllernumber > 14)\n                    {\n                        return true;\n                    }\n\n                    if (WriteChangeController_Valueless(channel,\n                                                        controller_map[controllernumber],\n                                                        midioutput))\n                    {\n                        return true;\n                    }\n\n                    break;\n\n                case mus_changecontroller:\n                    if (mem_fread(&controllernumber, 1, 1, musinput) != 1)\n                    {\n                        return true;\n                    }\n\n                    if (mem_fread(&controllervalue, 1, 1, musinput) != 1)\n                    {\n                        return true;\n                    }\n\n                    if (controllernumber == 0)\n                    {\n                        if (WriteChangePatch(channel, controllervalue,\n                                             midioutput))\n                        {\n                            return true;\n                        }\n                    }\n                    else\n                    {\n                        if (controllernumber < 1 || controllernumber > 9)\n                        {\n                            return true;\n                        }\n\n                        if (WriteChangeController_Valued(channel,\n                                                         controller_map[controllernumber],\n                                                         controllervalue,\n                                                         midioutput))\n                        {\n                            return true;\n                        }\n                    }\n\n                    break;\n\n                case mus_scoreend:\n                    hitscoreend = 1;\n                    break;\n\n                default:\n                    return true;\n                    break;\n            }\n\n            if (eventdescriptor & 0x80)\n            {\n                break;\n            }\n        }\n        // Now we need to read the time code:\n        if (!hitscoreend)\n        {\n            timedelay = 0;\n            for (;;)\n            {\n                if (mem_fread(&working, 1, 1, musinput) != 1)\n                {\n                    return true;\n                }\n\n                timedelay = timedelay * 128 + (working & 0x7F);\n                if ((working & 0x80) == 0)\n                {\n                    break;\n                }\n            }\n            queuedtime += timedelay;\n        }\n    }\n\n    // End of track\n    if (WriteEndTrack(midioutput))\n    {\n        return true;\n    }\n\n    // Write the track size into the stream\n    if (mem_fseek(midioutput, 18, MEM_SEEK_SET))\n    {\n        return true;\n    }\n\n    tracksizebuffer[0] = (tracksize >> 24) & 0xff;\n    tracksizebuffer[1] = (tracksize >> 16) & 0xff;\n    tracksizebuffer[2] = (tracksize >> 8) & 0xff;\n    tracksizebuffer[3] = tracksize & 0xff;\n\n    if (mem_fwrite(tracksizebuffer, 1, 4, midioutput) != 4)\n    {\n        return true;\n    }\n\n    return false;\n}\n\n#ifdef STANDALONE\n\n#include \"m_misc.h\"\n#include \"z_zone.h\"\n\nint main(int argc, char *argv[])\n{\n    MEMFILE *src, *dst;\n    byte *infile;\n    long infile_len;\n    void *outfile;\n    size_t outfile_len;\n\n    if (argc != 3)\n    {\n        printf(\"Usage: %s <musfile> <midfile>\\n\", argv[0]);\n        exit(-1);\n    }\n\n    Z_Init();\n\n    infile_len = M_ReadFile(argv[1], &infile);\n\n    src = mem_fopen_read(infile, infile_len);\n    dst = mem_fopen_write();\n\n    if (mus2mid(src, dst))\n    {\n        fprintf(stderr, \"mus2mid() failed\\n\");\n        exit(-1);\n    }\n\n    // Write result to output file:\n\n    mem_get_buf(dst, &outfile, &outfile_len);\n\n    M_WriteFile(argv[2], outfile, outfile_len);\n\n    return 0;\n}\n\n#endif\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tPlats (i.e. elevator platforms) code, raising/lowering.\n//\n\n#include <stdio.h>\n\n#include \"i_system.h\"\n#include \"z_zone.h\"\n#include \"m_random.h\"\n\n#include \"doomdef.h\"\n#include \"p_local.h\"\n\n#include \"s_sound.h\"\n\n// State.\n#include \"doomstat.h\"\n#include \"r_state.h\"\n\n// Data.\n#include \"sounds.h\"\n\n\nplat_t*\t\tactiveplats[MAXPLATS];\n\n\n\n//\n// Move a plat up and down\n//\nvoid T_PlatRaise(plat_t* plat)\n{\n    result_e\tres;\n\t\n    switch(plat->status)\n    {\n      case up:\n\tres = T_MovePlane(plat->sector,\n\t\t\t  plat->speed,\n\t\t\t  plat->high,\n\t\t\t  plat->crush,0,1);\n\t\t\t\t\t\n\tif (plat->type == raiseAndChange\n\t    || plat->type == raiseToNearestAndChange)\n\t{\n\t    if (!(leveltime&7))\n\t\tS_StartSound(&plat->sector->soundorg, sfx_stnmov);\n\t}\n\t\n\t\t\t\t\n\tif (res == crushed && (!plat->crush))\n\t{\n\t    plat->count = plat->wait;\n\t    plat->status = down;\n\t    S_StartSound(&plat->sector->soundorg, sfx_pstart);\n\t}\n\telse\n\t{\n\t    if (res == pastdest)\n\t    {\n\t\tplat->count = plat->wait;\n\t\tplat->status = waiting;\n\t\tS_StartSound(&plat->sector->soundorg, sfx_pstop);\n\n\t\tswitch(plat->type)\n\t\t{\n\t\t  case blazeDWUS:\n\t\t  case downWaitUpStay:\n\t\t    P_RemoveActivePlat(plat);\n\t\t    break;\n\t\t    \n\t\t  case raiseAndChange:\n\t\t  case raiseToNearestAndChange:\n\t\t    P_RemoveActivePlat(plat);\n\t\t    break;\n\t\t    \n\t\t  default:\n\t\t    break;\n\t\t}\n\t    }\n\t}\n\tbreak;\n\t\n      case\tdown:\n\tres = T_MovePlane(plat->sector,plat->speed,plat->low,false,0,-1);\n\n\tif (res == pastdest)\n\t{\n\t    plat->count = plat->wait;\n\t    plat->status = waiting;\n\t    S_StartSound(&plat->sector->soundorg,sfx_pstop);\n\t}\n\tbreak;\n\t\n      case\twaiting:\n\tif (!--plat->count)\n\t{\n\t    if (plat->sector->floorheight == plat->low)\n\t\tplat->status = up;\n\t    else\n\t\tplat->status = down;\n\t    S_StartSound(&plat->sector->soundorg,sfx_pstart);\n\t}\n      case\tin_stasis:\n\tbreak;\n    }\n}\n\n\n//\n// Do Platforms\n//  \"amount\" is only used for SOME platforms.\n//\nint\nEV_DoPlat\n( line_t*\tline,\n  plattype_e\ttype,\n  int\t\tamount )\n{\n    plat_t*\tplat;\n    int\t\tsecnum;\n    int\t\trtn;\n    sector_t*\tsec;\n\t\n    secnum = -1;\n    rtn = 0;\n\n    \n    //\tActivate all <type> plats that are in_stasis\n    switch(type)\n    {\n      case perpetualRaise:\n\tP_ActivateInStasis(line->tag);\n\tbreak;\n\t\n      default:\n\tbreak;\n    }\n\t\n    while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n    {\n\tsec = &sectors[secnum];\n\n\tif (sec->floordata)\n\t    continue;\n\t\n\t// Find lowest & highest floors around sector\n\trtn = 1;\n\tplat = Z_Malloc( sizeof(*plat), PU_LEVSPEC, 0);\n\tP_AddThinker(&plat->thinker);\n\t\t\n\tplat->type = type;\n\tplat->sector = sec;\n\tplat->sector->floordata = plat;\n\tplat->thinker.function.acp1 = (actionf_p1) T_PlatRaise;\n\tplat->crush = false;\n\tplat->tag = line->tag;\n\t\n\tswitch(type)\n\t{\n\t  case raiseToNearestAndChange:\n\t    plat->speed = PLATSPEED/2;\n\t    sec->floorpic = sides[line->sidenum[0]].sector->floorpic;\n\t    plat->high = P_FindNextHighestFloor(sec,sec->floorheight);\n\t    plat->wait = 0;\n\t    plat->status = up;\n\t    // NO MORE DAMAGE, IF APPLICABLE\n\t    sec->special = 0;\t\t\n\n\t    S_StartSound(&sec->soundorg,sfx_stnmov);\n\t    break;\n\t    \n\t  case raiseAndChange:\n\t    plat->speed = PLATSPEED/2;\n\t    sec->floorpic = sides[line->sidenum[0]].sector->floorpic;\n\t    plat->high = sec->floorheight + amount*FRACUNIT;\n\t    plat->wait = 0;\n\t    plat->status = up;\n\n\t    S_StartSound(&sec->soundorg,sfx_stnmov);\n\t    break;\n\t    \n\t  case downWaitUpStay:\n\t    plat->speed = PLATSPEED * 4;\n\t    plat->low = P_FindLowestFloorSurrounding(sec);\n\n\t    if (plat->low > sec->floorheight)\n\t\tplat->low = sec->floorheight;\n\n\t    plat->high = sec->floorheight;\n\t    plat->wait = TICRATE*PLATWAIT;\n\t    plat->status = down;\n\t    S_StartSound(&sec->soundorg,sfx_pstart);\n\t    break;\n\t    \n\t  case blazeDWUS:\n\t    plat->speed = PLATSPEED * 8;\n\t    plat->low = P_FindLowestFloorSurrounding(sec);\n\n\t    if (plat->low > sec->floorheight)\n\t\tplat->low = sec->floorheight;\n\n\t    plat->high = sec->floorheight;\n\t    plat->wait = TICRATE*PLATWAIT;\n\t    plat->status = down;\n\t    S_StartSound(&sec->soundorg,sfx_pstart);\n\t    break;\n\t    \n\t  case perpetualRaise:\n\t    plat->speed = PLATSPEED;\n\t    plat->low = P_FindLowestFloorSurrounding(sec);\n\n\t    if (plat->low > sec->floorheight)\n\t\tplat->low = sec->floorheight;\n\n\t    plat->high = P_FindHighestFloorSurrounding(sec);\n\n\t    if (plat->high < sec->floorheight)\n\t\tplat->high = sec->floorheight;\n\n\t    plat->wait = TICRATE*PLATWAIT;\n\t    plat->status = P_Random()&1;\n\n\t    S_StartSound(&sec->soundorg,sfx_pstart);\n\t    break;\n\t}\n\tP_AddActivePlat(plat);\n    }\n    return rtn;\n}\n\n\n\nvoid P_ActivateInStasis(int tag)\n{\n    int\t\ti;\n\t\n    for (i = 0;i < MAXPLATS;i++)\n\tif (activeplats[i]\n\t    && (activeplats[i])->tag == tag\n\t    && (activeplats[i])->status == in_stasis)\n\t{\n\t    (activeplats[i])->status = (activeplats[i])->oldstatus;\n\t    (activeplats[i])->thinker.function.acp1\n\t      = (actionf_p1) T_PlatRaise;\n\t}\n}\n\nvoid EV_StopPlat(line_t* line)\n{\n    int\t\tj;\n\t\n    for (j = 0;j < MAXPLATS;j++)\n\tif (activeplats[j]\n\t    && ((activeplats[j])->status != in_stasis)\n\t    && ((activeplats[j])->tag == line->tag))\n\t{\n\t    (activeplats[j])->oldstatus = (activeplats[j])->status;\n\t    (activeplats[j])->status = in_stasis;\n\t    (activeplats[j])->thinker.function.acv = (actionf_v)NULL;\n\t}\n}\n\nvoid P_AddActivePlat(plat_t* plat)\n{\n    int\t\ti;\n    \n    for (i = 0;i < MAXPLATS;i++)\n\tif (activeplats[i] == NULL)\n\t{\n\t    activeplats[i] = plat;\n\t    return;\n\t}\n    I_Error (\"P_AddActivePlat: no more plats!\");\n}\n\nvoid P_RemoveActivePlat(plat_t* plat)\n{\n    int\t\ti;\n    for (i = 0;i < MAXPLATS;i++)\n\tif (plat == activeplats[i])\n\t{\n\t    (activeplats[i])->sector->floordata = NULL;\n\t    P_RemoveThinker(&(activeplats[i])->thinker);\n\t    activeplats[i] = NULL;\n\t    \n\t    return;\n\t}\n    I_Error (\"P_RemoveActivePlat: can't find plat!\");\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tWeapon sprite animation, weapon objects.\n//\tAction functions for weapons.\n//\n\n\n#include \"doomdef.h\"\n#include \"d_event.h\"\n\n#include \"deh_misc.h\"\n\n#include \"m_random.h\"\n#include \"p_local.h\"\n#include \"s_sound.h\"\n\n// State.\n#include \"doomstat.h\"\n\n// Data.\n#include \"sounds.h\"\n\n#include \"p_pspr.h\"\n\n#define LOWERSPEED\t\tFRACUNIT*6\n#define RAISESPEED\t\tFRACUNIT*6\n\n#define WEAPONBOTTOM\t128*FRACUNIT\n#define WEAPONTOP\t\t32*FRACUNIT\n\n\n\n//\n// P_SetPsprite\n//\nvoid\nP_SetPsprite\n( player_t*\tplayer,\n  int\t\tposition,\n  statenum_t\tstnum ) \n{\n    pspdef_t*\tpsp;\n    state_t*\tstate;\n\t\n    psp = &player->psprites[position];\n\t\n    do\n    {\n\tif (!stnum)\n\t{\n\t    // object removed itself\n\t    psp->state = NULL;\n\t    break;\t\n\t}\n\t\n\tstate = &states[stnum];\n\tpsp->state = state;\n\tpsp->tics = state->tics;\t// could be 0\n\n\tif (state->misc1)\n\t{\n\t    // coordinate set\n\t    psp->sx = state->misc1 << FRACBITS;\n\t    psp->sy = state->misc2 << FRACBITS;\n\t}\n\t\n\t// Call action routine.\n\t// Modified handling.\n\tif (state->action.acp2)\n\t{\n\t    state->action.acp2(player, psp);\n\t    if (!psp->state)\n\t\tbreak;\n\t}\n\t\n\tstnum = psp->state->nextstate;\n\t\n    } while (!psp->tics);\n    // an initial state of 0 could cycle through\n}\n\n\n\n//\n// P_CalcSwing\n//\t\nfixed_t\t\tswingx;\nfixed_t\t\tswingy;\n\nvoid P_CalcSwing (player_t*\tplayer)\n{\n    fixed_t\tswing;\n    int\t\tangle;\n\t\n    // OPTIMIZE: tablify this.\n    // A LUT would allow for different modes,\n    //  and add flexibility.\n\n    swing = player->bob;\n\n    angle = (FINEANGLES/70*leveltime)&FINEMASK;\n    swingx = FixedMul ( swing, finesine[angle]);\n\n    angle = (FINEANGLES/70*leveltime+FINEANGLES/2)&FINEMASK;\n    swingy = -FixedMul ( swingx, finesine[angle]);\n}\n\n\n\n//\n// P_BringUpWeapon\n// Starts bringing the pending weapon up\n// from the bottom of the screen.\n// Uses player\n//\nvoid P_BringUpWeapon (player_t* player)\n{\n    statenum_t\tnewstate;\n\t\n    if (player->pendingweapon == wp_nochange)\n\tplayer->pendingweapon = player->readyweapon;\n\t\t\n    if (player->pendingweapon == wp_chainsaw)\n\tS_StartSound (player->mo, sfx_sawup);\n\t\t\n    newstate = weaponinfo[player->pendingweapon].upstate;\n\n    player->pendingweapon = wp_nochange;\n    player->psprites[ps_weapon].sy = WEAPONBOTTOM;\n\n    P_SetPsprite (player, ps_weapon, newstate);\n}\n\n//\n// P_CheckAmmo\n// Returns true if there is enough ammo to shoot.\n// If not, selects the next weapon to use.\n//\nboolean P_CheckAmmo (player_t* player)\n{\n    ammotype_t\t\tammo;\n    int\t\t\tcount;\n\n    ammo = weaponinfo[player->readyweapon].ammo;\n\n    // Minimal amount for one shot varies.\n    if (player->readyweapon == wp_bfg)\n\tcount = deh_bfg_cells_per_shot;\n    else if (player->readyweapon == wp_supershotgun)\n\tcount = 2;\t// Double barrel.\n    else\n\tcount = 1;\t// Regular.\n\n    // Some do not need ammunition anyway.\n    // Return if current ammunition sufficient.\n    if (ammo == am_noammo || player->ammo[ammo] >= count)\n\treturn true;\n\t\t\n    // Out of ammo, pick a weapon to change to.\n    // Preferences are set here.\n    do\n    {\n\tif (player->weaponowned[wp_plasma]\n\t    && player->ammo[am_cell]\n\t    && (gamemode != shareware) )\n\t{\n\t    player->pendingweapon = wp_plasma;\n\t}\n\telse if (player->weaponowned[wp_supershotgun] \n\t\t && player->ammo[am_shell]>2\n\t\t && (gamemode == commercial) )\n\t{\n\t    player->pendingweapon = wp_supershotgun;\n\t}\n\telse if (player->weaponowned[wp_chaingun]\n\t\t && player->ammo[am_clip])\n\t{\n\t    player->pendingweapon = wp_chaingun;\n\t}\n\telse if (player->weaponowned[wp_shotgun]\n\t\t && player->ammo[am_shell])\n\t{\n\t    player->pendingweapon = wp_shotgun;\n\t}\n\telse if (player->ammo[am_clip])\n\t{\n\t    player->pendingweapon = wp_pistol;\n\t}\n\telse if (player->weaponowned[wp_chainsaw])\n\t{\n\t    player->pendingweapon = wp_chainsaw;\n\t}\n\telse if (player->weaponowned[wp_missile]\n\t\t && player->ammo[am_misl])\n\t{\n\t    player->pendingweapon = wp_missile;\n\t}\n\telse if (player->weaponowned[wp_bfg]\n\t\t && player->ammo[am_cell]>40\n\t\t && (gamemode != shareware) )\n\t{\n\t    player->pendingweapon = wp_bfg;\n\t}\n\telse\n\t{\n\t    // If everything fails.\n\t    player->pendingweapon = wp_fist;\n\t}\n\t\n    } while (player->pendingweapon == wp_nochange);\n\n    // Now set appropriate weapon overlay.\n    P_SetPsprite (player,\n\t\t  ps_weapon,\n\t\t  weaponinfo[player->readyweapon].downstate);\n\n    return false;\t\n}\n\n\n//\n// P_FireWeapon.\n//\nvoid P_FireWeapon (player_t* player)\n{\n    statenum_t\tnewstate;\n\t\n    if (!P_CheckAmmo (player))\n\treturn;\n\t\n    P_SetMobjState (player->mo, S_PLAY_ATK1);\n    newstate = weaponinfo[player->readyweapon].atkstate;\n    P_SetPsprite (player, ps_weapon, newstate);\n    P_NoiseAlert (player->mo, player->mo);\n}\n\n\n\n//\n// P_DropWeapon\n// Player died, so put the weapon away.\n//\nvoid P_DropWeapon (player_t* player)\n{\n    P_SetPsprite (player,\n\t\t  ps_weapon,\n\t\t  weaponinfo[player->readyweapon].downstate);\n}\n\n\n\n//\n// A_WeaponReady\n// The player can fire the weapon\n// or change to another weapon at this time.\n// Follows after getting weapon up,\n// or after previous attack/fire sequence.\n//\nvoid\nA_WeaponReady\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\t\n    statenum_t\tnewstate;\n    int\t\tangle;\n    \n    // get out of attack state\n    if (player->mo->state == &states[S_PLAY_ATK1]\n\t|| player->mo->state == &states[S_PLAY_ATK2] )\n    {\n\tP_SetMobjState (player->mo, S_PLAY);\n    }\n    \n    if (player->readyweapon == wp_chainsaw\n\t&& psp->state == &states[S_SAW])\n    {\n\tS_StartSound (player->mo, sfx_sawidl);\n    }\n    \n    // check for change\n    //  if player is dead, put the weapon away\n    if (player->pendingweapon != wp_nochange || !player->health)\n    {\n\t// change weapon\n\t//  (pending weapon should allready be validated)\n\tnewstate = weaponinfo[player->readyweapon].downstate;\n\tP_SetPsprite (player, ps_weapon, newstate);\n\treturn;\t\n    }\n    \n    // check for fire\n    //  the missile launcher and bfg do not auto fire\n    if (player->cmd.buttons & BT_ATTACK)\n    {\n\tif ( !player->attackdown\n\t     || (player->readyweapon != wp_missile\n\t\t && player->readyweapon != wp_bfg) )\n\t{\n\t    player->attackdown = true;\n\t    P_FireWeapon (player);\t\t\n\t    return;\n\t}\n    }\n    else\n\tplayer->attackdown = false;\n    \n    // bob the weapon based on movement speed\n    angle = (128*leveltime)&FINEMASK;\n    psp->sx = FRACUNIT + FixedMul (player->bob, finecosine[angle]);\n    angle &= FINEANGLES/2-1;\n    psp->sy = WEAPONTOP + FixedMul (player->bob, finesine[angle]);\n}\n\n\n\n//\n// A_ReFire\n// The player can re-fire the weapon\n// without lowering it entirely.\n//\nvoid A_ReFire\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\n    \n    // check for fire\n    //  (if a weaponchange is pending, let it go through instead)\n    if ( (player->cmd.buttons & BT_ATTACK) \n\t && player->pendingweapon == wp_nochange\n\t && player->health)\n    {\n\tplayer->refire++;\n\tP_FireWeapon (player);\n    }\n    else\n    {\n\tplayer->refire = 0;\n\tP_CheckAmmo (player);\n    }\n}\n\n\nvoid\nA_CheckReload\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\n    P_CheckAmmo (player);\n#if 0\n    if (player->ammo[am_shell]<2)\n\tP_SetPsprite (player, ps_weapon, S_DSNR1);\n#endif\n}\n\n\n\n//\n// A_Lower\n// Lowers current weapon,\n//  and changes weapon at bottom.\n//\nvoid\nA_Lower\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\t\n    psp->sy += LOWERSPEED;\n\n    // Is already down.\n    if (psp->sy < WEAPONBOTTOM )\n\treturn;\n\n    // Player is dead.\n    if (player->playerstate == PST_DEAD)\n    {\n\tpsp->sy = WEAPONBOTTOM;\n\n\t// don't bring weapon back up\n\treturn;\t\t\n    }\n    \n    // The old weapon has been lowered off the screen,\n    // so change the weapon and start raising it\n    if (!player->health)\n    {\n\t// Player is dead, so keep the weapon off screen.\n\tP_SetPsprite (player,  ps_weapon, S_NULL);\n\treturn;\t\n    }\n\t\n    player->readyweapon = player->pendingweapon; \n\n    P_BringUpWeapon (player);\n}\n\n\n//\n// A_Raise\n//\nvoid\nA_Raise\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\n    statenum_t\tnewstate;\n\t\n    psp->sy -= RAISESPEED;\n\n    if (psp->sy > WEAPONTOP )\n\treturn;\n    \n    psp->sy = WEAPONTOP;\n    \n    // The weapon has been raised all the way,\n    //  so change to the ready state.\n    newstate = weaponinfo[player->readyweapon].readystate;\n\n    P_SetPsprite (player, ps_weapon, newstate);\n}\n\n\n\n//\n// A_GunFlash\n//\nvoid\nA_GunFlash\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    P_SetMobjState (player->mo, S_PLAY_ATK2);\n    P_SetPsprite (player,ps_flash,weaponinfo[player->readyweapon].flashstate);\n}\n\n\n\n//\n// WEAPON ATTACKS\n//\n\n\n//\n// A_Punch\n//\nvoid\nA_Punch\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    angle_t\tangle;\n    int\t\tdamage;\n    int\t\tslope;\n\t\n    damage = (P_Random ()%10+1)<<1;\n\n    if (player->powers[pw_strength])\t\n\tdamage *= 10;\n\n    angle = player->mo->angle;\n    angle += P_SubRandom() << 18;\n    slope = P_AimLineAttack (player->mo, angle, MELEERANGE);\n    P_LineAttack (player->mo, angle, MELEERANGE, slope, damage);\n\n    // turn to face target\n    if (linetarget)\n    {\n\tS_StartSound (player->mo, sfx_punch);\n\tplayer->mo->angle = R_PointToAngle2 (player->mo->x,\n\t\t\t\t\t     player->mo->y,\n\t\t\t\t\t     linetarget->x,\n\t\t\t\t\t     linetarget->y);\n    }\n}\n\n\n//\n// A_Saw\n//\nvoid\nA_Saw\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    angle_t\tangle;\n    int\t\tdamage;\n    int\t\tslope;\n\n    damage = 2*(P_Random ()%10+1);\n    angle = player->mo->angle;\n    angle += P_SubRandom() << 18;\n    \n    // use meleerange + 1 se the puff doesn't skip the flash\n    slope = P_AimLineAttack (player->mo, angle, MELEERANGE+1);\n    P_LineAttack (player->mo, angle, MELEERANGE+1, slope, damage);\n\n    if (!linetarget)\n    {\n\tS_StartSound (player->mo, sfx_sawful);\n\treturn;\n    }\n    S_StartSound (player->mo, sfx_sawhit);\n\t\n    // turn to face target\n    angle = R_PointToAngle2 (player->mo->x, player->mo->y,\n\t\t\t     linetarget->x, linetarget->y);\n    if (angle - player->mo->angle > ANG180)\n    {\n\tif ((signed int) (angle - player->mo->angle) < -ANG90/20)\n\t    player->mo->angle = angle + ANG90/21;\n\telse\n\t    player->mo->angle -= ANG90/20;\n    }\n    else\n    {\n\tif (angle - player->mo->angle > ANG90/20)\n\t    player->mo->angle = angle - ANG90/21;\n\telse\n\t    player->mo->angle += ANG90/20;\n    }\n    player->mo->flags |= MF_JUSTATTACKED;\n}\n\n// Doom does not check the bounds of the ammo array.  As a result,\n// it is possible to use an ammo type > 4 that overflows into the\n// maxammo array and affects that instead.  Through dehacked, for\n// example, it is possible to make a weapon that decreases the max\n// number of ammo for another weapon.  Emulate this.\n\nstatic void DecreaseAmmo(player_t *player, int ammonum, int amount)\n{\n    if (ammonum < NUMAMMO)\n    {\n        player->ammo[ammonum] -= amount;\n    }\n    else\n    {\n        player->maxammo[ammonum - NUMAMMO] -= amount;\n    }\n}\n\n\n//\n// A_FireMissile\n//\nvoid\nA_FireMissile\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    DecreaseAmmo(player, weaponinfo[player->readyweapon].ammo, 1);\n    P_SpawnPlayerMissile (player->mo, MT_ROCKET);\n}\n\n\n//\n// A_FireBFG\n//\nvoid\nA_FireBFG\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    DecreaseAmmo(player, weaponinfo[player->readyweapon].ammo, \n                 deh_bfg_cells_per_shot);\n    P_SpawnPlayerMissile (player->mo, MT_BFG);\n}\n\n\n\n//\n// A_FirePlasma\n//\nvoid\nA_FirePlasma\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    DecreaseAmmo(player, weaponinfo[player->readyweapon].ammo, 1);\n\n    P_SetPsprite (player,\n\t\t  ps_flash,\n\t\t  weaponinfo[player->readyweapon].flashstate+(P_Random ()&1) );\n\n    P_SpawnPlayerMissile (player->mo, MT_PLASMA);\n}\n\n\n\n//\n// P_BulletSlope\n// Sets a slope so a near miss is at aproximately\n// the height of the intended target\n//\nfixed_t\t\tbulletslope;\n\n\nvoid P_BulletSlope (mobj_t*\tmo)\n{\n    angle_t\tan;\n    \n    // see which target is to be aimed at\n    an = mo->angle;\n    bulletslope = P_AimLineAttack (mo, an, 16*64*FRACUNIT);\n\n    if (!linetarget)\n    {\n\tan += 1<<26;\n\tbulletslope = P_AimLineAttack (mo, an, 16*64*FRACUNIT);\n\tif (!linetarget)\n\t{\n\t    an -= 2<<26;\n\t    bulletslope = P_AimLineAttack (mo, an, 16*64*FRACUNIT);\n\t}\n    }\n}\n\n\n//\n// P_GunShot\n//\nvoid\nP_GunShot\n( mobj_t*\tmo,\n  boolean\taccurate )\n{\n    angle_t\tangle;\n    int\t\tdamage;\n\t\n    damage = 5*(P_Random ()%3+1);\n    angle = mo->angle;\n\n    if (!accurate)\n\tangle += P_SubRandom() << 18;\n\n    P_LineAttack (mo, angle, MISSILERANGE, bulletslope, damage);\n}\n\n\n//\n// A_FirePistol\n//\nvoid\nA_FirePistol\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    S_StartSound (player->mo, sfx_pistol);\n\n    P_SetMobjState (player->mo, S_PLAY_ATK2);\n    DecreaseAmmo(player, weaponinfo[player->readyweapon].ammo, 1);\n\n    P_SetPsprite (player,\n\t\t  ps_flash,\n\t\t  weaponinfo[player->readyweapon].flashstate);\n\n    P_BulletSlope (player->mo);\n    P_GunShot (player->mo, !player->refire);\n}\n\n\n//\n// A_FireShotgun\n//\nvoid\nA_FireShotgun\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    int\t\ti;\n\t\n    S_StartSound (player->mo, sfx_shotgn);\n    P_SetMobjState (player->mo, S_PLAY_ATK2);\n\n    DecreaseAmmo(player, weaponinfo[player->readyweapon].ammo, 1);\n\n    P_SetPsprite (player,\n\t\t  ps_flash,\n\t\t  weaponinfo[player->readyweapon].flashstate);\n\n    P_BulletSlope (player->mo);\n\t\n    for (i=0 ; i<7 ; i++)\n\tP_GunShot (player->mo, false);\n}\n\n\n\n//\n// A_FireShotgun2\n//\nvoid\nA_FireShotgun2\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    int\t\ti;\n    angle_t\tangle;\n    int\t\tdamage;\n\t\t\n\t\n    S_StartSound (player->mo, sfx_dshtgn);\n    P_SetMobjState (player->mo, S_PLAY_ATK2);\n\n    DecreaseAmmo(player, weaponinfo[player->readyweapon].ammo, 2);\n\n    P_SetPsprite (player,\n\t\t  ps_flash,\n\t\t  weaponinfo[player->readyweapon].flashstate);\n\n    P_BulletSlope (player->mo);\n\t\n    for (i=0 ; i<20 ; i++)\n    {\n\tdamage = 5*(P_Random ()%3+1);\n\tangle = player->mo->angle;\n\tangle += P_SubRandom() << ANGLETOFINESHIFT;\n\tP_LineAttack (player->mo,\n\t\t      angle,\n\t\t      MISSILERANGE,\n\t\t      bulletslope + (P_SubRandom() << 5), damage);\n    }\n}\n\n\n//\n// A_FireCGun\n//\nvoid\nA_FireCGun\n( player_t*\tplayer,\n  pspdef_t*\tpsp ) \n{\n    S_StartSound (player->mo, sfx_pistol);\n\n    if (!player->ammo[weaponinfo[player->readyweapon].ammo])\n\treturn;\n\t\t\n    P_SetMobjState (player->mo, S_PLAY_ATK2);\n    DecreaseAmmo(player, weaponinfo[player->readyweapon].ammo, 1);\n\n    P_SetPsprite (player,\n\t\t  ps_flash,\n\t\t  weaponinfo[player->readyweapon].flashstate\n\t\t  + psp->state\n\t\t  - &states[S_CHAIN1] );\n\n    P_BulletSlope (player->mo);\n\t\n    P_GunShot (player->mo, !player->refire);\n}\n\n\n\n//\n// ?\n//\nvoid A_Light0 (player_t *player, pspdef_t *psp)\n{\n    player->extralight = 0;\n}\n\nvoid A_Light1 (player_t *player, pspdef_t *psp)\n{\n    player->extralight = 1;\n}\n\nvoid A_Light2 (player_t *player, pspdef_t *psp)\n{\n    player->extralight = 2;\n}\n\n\n//\n// A_BFGSpray\n// Spawn a BFG explosion on every monster in view\n//\nvoid A_BFGSpray (mobj_t* mo) \n{\n    int\t\t\ti;\n    int\t\t\tj;\n    int\t\t\tdamage;\n    angle_t\t\tan;\n\t\n    // offset angles from its attack angle\n    for (i=0 ; i<40 ; i++)\n    {\n\tan = mo->angle - ANG90/2 + ANG90/40*i;\n\n\t// mo->target is the originator (player)\n\t//  of the missile\n\tP_AimLineAttack (mo->target, an, 16*64*FRACUNIT);\n\n\tif (!linetarget)\n\t    continue;\n\n\tP_SpawnMobj (linetarget->x,\n\t\t     linetarget->y,\n\t\t     linetarget->z + (linetarget->height>>2),\n\t\t     MT_EXTRABFG);\n\t\n\tdamage = 0;\n\tfor (j=0;j<15;j++)\n\t    damage += (P_Random()&7) + 1;\n\n\tP_DamageMobj (linetarget, mo->target,mo->target, damage);\n    }\n}\n\n\n//\n// A_BFGsound\n//\nvoid\nA_BFGsound\n( player_t*\tplayer,\n  pspdef_t*\tpsp )\n{\n    S_StartSound (player->mo, sfx_bfg);\n}\n\n\n\n//\n// P_SetupPsprites\n// Called at start of level for each player.\n//\nvoid P_SetupPsprites (player_t* player) \n{\n    int\ti;\n\t\n    // remove all psprites\n    for (i=0 ; i<NUMPSPRITES ; i++)\n\tplayer->psprites[i].state = NULL;\n\t\t\n    // spawn the gun\n    player->pendingweapon = player->readyweapon;\n    P_BringUpWeapon (player);\n}\n\n\n\n\n//\n// P_MovePsprites\n// Called every tic by player thinking routine.\n//\nvoid P_MovePsprites (player_t* player) \n{\n    int\t\ti;\n    pspdef_t*\tpsp;\n    state_t*\tstate;\n\t\n    psp = &player->psprites[0];\n    for (i=0 ; i<NUMPSPRITES ; i++, psp++)\n    {\n\t// a null state means not active\n\tif ( (state = psp->state) )\t\n\t{\n\t    // drop tic count and possibly change state\n\n\t    // a -1 tic count never changes\n\t    if (psp->tics != -1)\t\n\t    {\n\t\tpsp->tics--;\n\t\tif (!psp->tics)\n\t\t    P_SetPsprite (player, i, psp->state->nextstate);\n\t    }\t\t\t\t\n\t}\n    }\n    \n    player->psprites[ps_flash].sx = player->psprites[ps_weapon].sx;\n    player->psprites[ps_flash].sy = player->psprites[ps_weapon].sy;\n}\n\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tZone Memory Allocation. Neat.\n//\n//\tThis is an implementation of the zone memory API which\n//\tuses native calls to malloc() and free().\n//\n\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"z_zone.h\"\n#include \"i_system.h\"\n#include \"doomtype.h\"\n\n#define ZONEID\t0x1d4a11\n\ntypedef struct memblock_s memblock_t;\n\nstruct memblock_s\n{\n    int id; // = ZONEID\n    int tag;\n    int size;\n    void **user;\n    memblock_t *prev;\n    memblock_t *next;\n};\n\n// Linked list of allocated blocks for each tag type\n \nstatic memblock_t *allocated_blocks[PU_NUM_TAGS];\n\n#ifdef TESTING\n\nstatic int test_malloced = 0;\n\nvoid *test_malloc(size_t size)\n{\n    int *result;\n\n    if (test_malloced + size > 2 * 1024 * 1024)\n    {\n        return NULL;\n    }\n\n    test_malloced += size;\n\n    result = malloc(size + sizeof(int));\n\n    *result = size;\n\n    return result + 1;\n}\n\nvoid test_free(void *data)\n{\n    int *i;\n\n    i = ((int *) data) - 1;\n\n    test_malloced -= *i;\n\n    free(i);\n}\n\n#define malloc test_malloc\n#define free test_free\n\n#endif /* #ifdef TESTING */\n\n\n// Add a block into the linked list for its type.\n\nstatic void Z_InsertBlock(memblock_t *block)\n{\n    block->prev = NULL;\n    block->next = allocated_blocks[block->tag];\n    allocated_blocks[block->tag] = block;\n    \n    if (block->next != NULL)\n    {\n        block->next->prev = block;\n    }\n}\n\n// Remove a block from its linked list.\n\nstatic void Z_RemoveBlock(memblock_t *block)\n{\n    // Unlink from list\n\n    if (block->prev == NULL)\n    {\n        // Start of list\n\n        allocated_blocks[block->tag] = block->next;\n    }\n    else\n    {\n        block->prev->next = block->next;\n    }\n\n    if (block->next != NULL)\n    {\n        block->next->prev = block->prev;\n    }\n}\n\n//\n// Z_Init\n//\nvoid Z_Init (void)\n{\n    memset(allocated_blocks, 0, sizeof(allocated_blocks));\n    printf(\"zone memory: Using native C allocator.\\n\");\n}\n\n\n//\n// Z_Free\n//\nvoid Z_Free (void* ptr)\n{\n    memblock_t*\t\tblock;\n\n    block = (memblock_t *) ((byte *)ptr - sizeof(memblock_t));\n\n    if (block->id != ZONEID)\n    {\n        I_Error (\"Z_Free: freed a pointer without ZONEID\");\n    }\n\t\t\n    if (block->tag != PU_FREE && block->user != NULL)\n    {\n        // clear the user's mark\n\n        *block->user = NULL;\n    }\n\n    Z_RemoveBlock(block);\n\n    // Free back to system\n\n    free(block);\n}\n\n// Empty data from the cache list to allocate enough data of the size\n// required.\n//\n// Returns true if any blocks were freed.\n\nstatic boolean ClearCache(int size)\n{\n    memblock_t *block;\n    memblock_t *next_block;\n    int remaining;\n\n    block = allocated_blocks[PU_CACHE];\n\n    if (block == NULL)\n    {\n        // Cache is already empty.\n\n        return false;\n    }\n\n    // Search to the end of the PU_CACHE list.  The blocks at the end\n    // of the list are the ones that have been free for longer and\n    // are more likely to be unneeded now.\n\n    while (block->next != NULL)\n    {\n        block = block->next;\n    }\n\n    // Search backwards through the list freeing blocks until we have\n    // freed the amount of memory required.\n\n    remaining = size;\n\n    while (remaining > 0)\n    {\n        if (block == NULL)\n        {\n            // No blocks left to free; we've done our best.\n  \n            break;\n        }\n\n        next_block = block->prev;\n\n        Z_RemoveBlock(block);\n\n        remaining -= block->size;\n\n        if (block->user)\n        {\n            *block->user = NULL;\n        }\n\n        free(block);\n\n        block = next_block;\n    }\n\n    return true;\n}\n\n//\n// Z_Malloc\n// You can pass a NULL user if the tag is < PU_PURGELEVEL.\n//\n\nvoid *Z_Malloc(int size, int tag, void *user)\n{\n    memblock_t *newblock;\n    unsigned char *data;\n    void *result;\n\n    if (tag < 0 || tag >= PU_NUM_TAGS || tag == PU_FREE)\n    {\n        I_Error(\"Z_Malloc: attempted to allocate a block with an invalid \"\n                \"tag: %i\", tag);\n    }\n\n    if (user == NULL && tag >= PU_PURGELEVEL)\n    {\n        I_Error (\"Z_Malloc: an owner is required for purgable blocks\");\n    }\n\n    // Malloc a block of the required size\n    \n    newblock = NULL;\n\n    while (newblock == NULL)\n    {\n        newblock = (memblock_t *) malloc(sizeof(memblock_t) + size);\n\n        if (newblock == NULL)\n        {\n            if (!ClearCache(sizeof(memblock_t) + size))\n            {\n                I_Error(\"Z_Malloc: failed on allocation of %i bytes\", size);\n            }\n        }\n    }\n\n    newblock->tag = tag;\n    \n    // Hook into the linked list for this tag type\n\n    newblock->id = ZONEID;\n    newblock->user = user;\n    newblock->size = size;\n\n    Z_InsertBlock(newblock);\n\n    data = (unsigned char *) newblock;\n    result = data + sizeof(memblock_t);\n\n    if (user != NULL)\n    {\n        *newblock->user = result;\n    }\n    \n    return result;\n}\n\n\n\n//\n// Z_FreeTags\n//\n\nvoid Z_FreeTags(int lowtag, int hightag)\n{\n    int i;\n\n    for (i=lowtag; i<= hightag; ++i)\n    {\n        memblock_t *block;\n        memblock_t *next;\n\n        // Free all in this chain\n\n        for (block=allocated_blocks[i]; block != NULL; )\n        {\n            next = block->next;\n\n            // Free this block\n\n            if (block->user != NULL)\n            {\n                *block->user = NULL;\n            }\n            \n            free(block);\n\n            // Jump to the next in the chain\n\n            block = next;\n        }\n\n\t// This chain is empty now\n\n\tallocated_blocks[i] = NULL;\n    }\n}\n\n\n\n//\n// Z_DumpHeap\n//\nvoid Z_DumpHeap(int lowtag, int\thightag)\n{\n    // broken\n\n#if 0\n    memblock_t*\tblock;\n\t\n    printf (\"zone size: %i  location: %p\\n\",\n\t    mainzone->size,mainzone);\n    \n    printf (\"tag range: %i to %i\\n\",\n\t    lowtag, hightag);\n\t\n    for (block = mainzone->blocklist.next ; ; block = block->next)\n    {\n\tif (block->tag >= lowtag && block->tag <= hightag)\n\t    printf (\"block:%p    size:%7i    user:%p    tag:%3i\\n\",\n\t\t    block, block->size, block->user, block->tag);\n\t\t\n\tif (block->next == &mainzone->blocklist)\n\t{\n\t    // all blocks have been hit\n\t    break;\n\t}\n\t\n\tif ( (byte *)block + block->size != (byte *)block->next)\n\t    printf (\"ERROR: block size does not touch the next block\\n\");\n\n\tif ( block->next->prev != block)\n\t    printf (\"ERROR: next block doesn't have proper back link\\n\");\n\n\tif (block->tag == PU_FREE && block->next->tag == PU_FREE)\n\t    printf (\"ERROR: two consecutive free blocks\\n\");\n    }\n#endif\n}\n\n\n//\n// Z_FileDumpHeap\n//\nvoid Z_FileDumpHeap(FILE *f)\n{\n    // broken\n#if 0\n    memblock_t*\tblock;\n\t\n    fprintf (f,\"zone size: %i  location: %p\\n\",mainzone->size,mainzone);\n\t\n    for (block = mainzone->blocklist.next ; ; block = block->next)\n    {\n\tfprintf (f,\"block:%p    size:%7i    user:%p    tag:%3i\\n\",\n\t\t block, block->size, block->user, block->tag);\n\t\t\n\tif (block->next == &mainzone->blocklist)\n\t{\n\t    // all blocks have been hit\n\t    break;\n\t}\n\t\n\tif ( (byte *)block + block->size != (byte *)block->next)\n\t    fprintf (f,\"ERROR: block size does not touch the next block\\n\");\n\n\tif ( block->next->prev != block)\n\t    fprintf (f,\"ERROR: next block doesn't have proper back link\\n\");\n\n\tif (block->tag == PU_FREE && block->next->tag == PU_FREE)\n\t    fprintf (f,\"ERROR: two consecutive free blocks\\n\");\n    }\n#endif\n}\n\n\n\n//\n// Z_CheckHeap\n//\nvoid Z_CheckHeap (void)\n{\n    memblock_t *block;\n    memblock_t *prev;\n    int i;\n\n    // Check all chains\n\n    for (i=0; i<PU_NUM_TAGS; ++i)\n    {\n        prev = NULL;\n\n        for (block=allocated_blocks[i]; block != NULL; block = block->next)\n        {\n            if (block->id != ZONEID)\n            {\n                I_Error(\"Z_CheckHeap: Block without a ZONEID!\");\n            }\n            \n            if (block->prev != prev)\n            {\n                I_Error(\"Z_CheckHeap: Doubly-linked list corrupted!\");\n            }\n            \n            prev = block;\n        }\n    }\n}\n\n\n\n\n//\n// Z_ChangeTag\n//\n\nvoid Z_ChangeTag2(void *ptr, int tag, const char *file, int line)\n{\n    memblock_t*\tblock;\n\t\n    block = (memblock_t *) ((byte *)ptr - sizeof(memblock_t));\n\n    if (block->id != ZONEID)\n        I_Error(\"%s:%i: Z_ChangeTag: block without a ZONEID!\",\n                file, line);\n\n    if (tag >= PU_PURGELEVEL && block->user == NULL)\n        I_Error(\"%s:%i: Z_ChangeTag: an owner is required \"\n                \"for purgable blocks\", file, line);\n\n    // Remove the block from its current list, and rehook it into\n    // its new list.\n\n    Z_RemoveBlock(block);\n    block->tag = tag;\n    Z_InsertBlock(block);\n}\n\nvoid Z_ChangeUser(void *ptr, void **user)\n{\n    memblock_t*\tblock;\n\n    block = (memblock_t *) ((byte *)ptr - sizeof(memblock_t));\n\n    if (block->id != ZONEID)\n    {\n        I_Error(\"Z_ChangeUser: Tried to change user for invalid block!\");\n    }\n\n    block->user = user;\n    *user = ptr;\n}\n\n\n//\n// Z_FreeMemory\n//\n\nint Z_FreeMemory(void)\n{\n    // Limited by the system??\n\n    return -1;\n}\n\nunsigned int Z_ZoneSize(void)\n{\n    return 0;\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:  none\n//\n\n\n\n#include <string.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include <emscripten.h>\n\n#include \"doomdef.h\"\n#include \"doomkeys.h\"\n#include \"doomstat.h\"\n\n#include \"deh_main.h\"\n#include \"deh_misc.h\"\n\n#include \"z_zone.h\"\n#include \"f_finale.h\"\n#include \"m_argv.h\"\n#include \"m_controls.h\"\n#include \"m_misc.h\"\n#include \"m_menu.h\"\n#include \"m_random.h\"\n#include \"i_system.h\"\n#include \"i_timer.h\"\n#include \"i_input.h\"\n#include \"i_video.h\"\n\n#include \"p_setup.h\"\n#include \"p_saveg.h\"\n#include \"p_tick.h\"\n\n#include \"d_main.h\"\n\n#include \"wi_stuff.h\"\n#include \"hu_stuff.h\"\n#include \"st_stuff.h\"\n#include \"am_map.h\"\n#include \"statdump.h\"\n\n// Needs access to LFB.\n#include \"v_video.h\"\n\n#include \"w_wad.h\"\n\n#include \"p_local.h\"\n\n#include \"s_sound.h\"\n\n// Data.\n#include \"dstrings.h\"\n#include \"sounds.h\"\n\n// SKY handling - still the wrong place.\n#include \"r_data.h\"\n#include \"r_sky.h\"\n\n\n\n#include \"g_game.h\"\n\n#include <emscripten.h>\n\n\n#define SAVEGAMESIZE\t0x2c000\n\nvoid\tG_ReadDemoTiccmd (ticcmd_t* cmd);\nvoid\tG_WriteDemoTiccmd (ticcmd_t* cmd);\nvoid\tG_PlayerReborn (int player);\n\nvoid\tG_DoReborn (int playernum);\n\nvoid\tG_DoLoadLevel (void);\nvoid\tG_DoNewGame (void);\nboolean\tG_DoPlayDemo (void);\nvoid\tG_DoCompleted (void);\nvoid\tG_DoVictory (void);\nvoid\tG_DoWorldDone (void);\nvoid\tG_DoSaveGame (void);\n\n// Inspect mode\nextern boolean inspectmode;\n\n// Crispy\nextern boolean havee1m10;\nextern boolean havemap33;\n\n// Gamestate the last time G_Ticker was called.\n\ngamestate_t     oldgamestate;\n\ngameaction_t    gameaction;\ngamestate_t     gamestate;\nskill_t         gameskill;\nboolean\t\trespawnmonsters;\nint             gameepisode;\nint             gamemap;\n\n// If non-zero, exit the level after this number of minutes.\n\nint             timelimit;\n\nboolean         paused;\nboolean         sendpause;             \t// send a pause event next tic\nboolean         sendsave;             \t// send a save event next tic\nboolean         usergame;               // ok to save / end game\n\nboolean         timingdemo;             // if true, exit with report on completion\nboolean         nodrawers;              // for comparative timing purposes\nint             starttime;          \t// for comparative timing purposes\n\nboolean         viewactive;\n\nint             deathmatch;           \t// only if started as net death\nboolean         netgame;                // only true if packets are broadcast\nboolean         playeringame[MAXPLAYERS];\nplayer_t        players[MAXPLAYERS];\n\nboolean         turbodetected[MAXPLAYERS];\n\nint             consoleplayer;          // player taking events and displaying\nint             displayplayer;          // view being displayed\nint             levelstarttic;          // gametic at level start\nint             totalkills, totalitems, totalsecret;    // for intermission\nint             extrakills;             // [crispy] count spawned monsters\nint             totalleveltimes;        // [crispy] CPhipps - total time for all completed levels\nint             demostarttic;           // [crispy] fix revenant internal demo bug\n\nchar           *demoname;\nboolean         demorecording;\nboolean         longtics;               // cph's doom 1.91 longtics hack\nboolean         lowres_turn;            // low resolution turning for longtics\nboolean         demoplayback;\nboolean\t\tnetdemo;\nbyte*\t\tdemobuffer;\nbyte*\t\tdemo_p;\nbyte*\t\tdemoend;\nboolean         singledemo;            \t// quit after playing a demo from cmdline\n\nboolean         precache = true;        // if true, load all graphics at start\n\nboolean         testcontrols = false;    // Invoked by setup to test controls\nint             testcontrols_mousespeed;\n\n\n\nwbstartstruct_t wminfo;               \t// parms for world map / intermission\n\nbyte\t\tconsistancy[MAXPLAYERS][BACKUPTICS];\n\n#define MAXPLMOVE\t\t(forwardmove[1])\n\n#define TURBOTHRESHOLD\t0x32\n\nfixed_t         forwardmove[2] = {0x19, 0x32};\nfixed_t         sidemove[2] = {0x18, 0x28};\nfixed_t         angleturn[3] = {640, 1280, 320};    // + slow turn\n\nstatic int *weapon_keys[] = {\n    &key_weapon1,\n    &key_weapon2,\n    &key_weapon3,\n    &key_weapon4,\n    &key_weapon5,\n    &key_weapon6,\n    &key_weapon7,\n    &key_weapon8\n};\n\n// Set to -1 or +1 to switch to the previous or next weapon.\n\nstatic int next_weapon = 0;\n\n// Used for prev/next weapon keys.\n\nstatic const struct\n{\n    weapontype_t weapon;\n    weapontype_t weapon_num;\n} weapon_order_table[] = {\n    { wp_fist,            wp_fist },\n    { wp_chainsaw,        wp_fist },\n    { wp_pistol,          wp_pistol },\n    { wp_shotgun,         wp_shotgun },\n    { wp_supershotgun,    wp_shotgun },\n    { wp_chaingun,        wp_chaingun },\n    { wp_missile,         wp_missile },\n    { wp_plasma,          wp_plasma },\n    { wp_bfg,             wp_bfg }\n};\n\n#define SLOWTURNTICS\t6\n\n#define NUMKEYS\t\t256\n#define MAX_JOY_BUTTONS 20\n\nstatic boolean  gamekeydown[NUMKEYS];\nstatic int      turnheld;\t\t// for accelerative turning\n\nstatic boolean  mousearray[MAX_MOUSE_BUTTONS + 1];\nstatic boolean *mousebuttons = &mousearray[1];  // allow [-1]\n\n// mouse values are used once\nint             mousex;\nint             mousey;\n\nstatic int      dclicktime;\nstatic boolean  dclickstate;\nstatic int      dclicks;\nstatic int      dclicktime2;\nstatic boolean  dclickstate2;\nstatic int      dclicks2;\n\n// joystick values are repeated\nstatic int      joyxmove;\nstatic int      joyymove;\nstatic int      joystrafemove;\nstatic boolean  joyarray[MAX_JOY_BUTTONS + 1];\nstatic boolean *joybuttons = &joyarray[1];\t\t// allow [-1]\n\nstatic int      savegameslot;\nstatic char     savedescription[32];\n\n#define\tBODYQUESIZE\t32\n\nmobj_t*\t\tbodyque[BODYQUESIZE];\nint\t\tbodyqueslot;\n\nint             vanilla_savegame_limit = 0;\nint             vanilla_demo_limit = 0;\n\nint G_CmdChecksum (ticcmd_t* cmd)\n{\n    size_t\t\ti;\n    int\t\tsum = 0;\n\n    for (i=0 ; i< sizeof(*cmd)/4 - 1 ; i++)\n\tsum += ((int *)cmd)[i];\n\n    return sum;\n}\n\nstatic boolean WeaponSelectable(weapontype_t weapon)\n{\n    // Can't select the super shotgun in Doom 1.\n\n    if (weapon == wp_supershotgun && logical_gamemission == doom)\n    {\n        return false;\n    }\n\n    // These weapons aren't available in shareware.\n\n    if ((weapon == wp_plasma || weapon == wp_bfg)\n     && gamemission == doom && gamemode == shareware)\n    {\n        return false;\n    }\n\n    // Can't select a weapon if we don't own it.\n\n    if (!players[consoleplayer].weaponowned[weapon])\n    {\n        return false;\n    }\n\n    // Can't select the fist if we have the chainsaw, unless\n    // we also have the berserk pack.\n\n    if (weapon == wp_fist\n     && players[consoleplayer].weaponowned[wp_chainsaw]\n     && !players[consoleplayer].powers[pw_strength])\n    {\n        return false;\n    }\n\n    return true;\n}\n\nstatic int G_NextWeapon(int direction)\n{\n    weapontype_t weapon;\n    int start_i, i;\n\n    // Find index in the table.\n\n    if (players[consoleplayer].pendingweapon == wp_nochange)\n    {\n        weapon = players[consoleplayer].readyweapon;\n    }\n    else\n    {\n        weapon = players[consoleplayer].pendingweapon;\n    }\n\n    for (i=0; i<arrlen(weapon_order_table); ++i)\n    {\n        if (weapon_order_table[i].weapon == weapon)\n        {\n            break;\n        }\n    }\n\n    // Switch weapon. Don't loop forever.\n    start_i = i;\n    do\n    {\n        i += direction;\n        i = (i + arrlen(weapon_order_table)) % arrlen(weapon_order_table);\n    } while (i != start_i && !WeaponSelectable(weapon_order_table[i].weapon));\n\n    return weapon_order_table[i].weapon_num;\n}\n\n//\n// G_BuildTiccmd\n// Builds a ticcmd from all of the available inputs\n// or reads it from the demo buffer.\n// If recording a demo, write it out\n//\nvoid G_BuildTiccmd (ticcmd_t* cmd, int maketic)\n{\n    int\t\ti;\n    boolean\tstrafe;\n    boolean\tbstrafe;\n    int\t\tspeed;\n    int\t\ttspeed;\n    int\t\tforward;\n    int\t\tside;\n\n    memset(cmd, 0, sizeof(ticcmd_t));\n\n    cmd->consistancy =\n\tconsistancy[consoleplayer][maketic%BACKUPTICS];\n\n    strafe = gamekeydown[key_strafe] || mousebuttons[mousebstrafe]\n\t|| joybuttons[joybstrafe];\n\n    // fraggle: support the old \"joyb_speed = 31\" hack which\n    // allowed an autorun effect\n\n    speed = key_speed >= NUMKEYS\n         || joybspeed >= MAX_JOY_BUTTONS\n         || gamekeydown[key_speed]\n         || joybuttons[joybspeed];\n\n    forward = side = 0;\n\n    // use two stage accelerative turning\n    // on the keyboard and joystick\n    if (joyxmove < 0\n\t|| joyxmove > 0\n\t|| gamekeydown[key_right]\n\t|| gamekeydown[key_left])\n\tturnheld += ticdup;\n    else\n\tturnheld = 0;\n\n    if (turnheld < SLOWTURNTICS)\n\ttspeed = 2;             // slow turn\n    else\n\ttspeed = speed;\n\n    // let movement keys cancel each other out\n    if (strafe)\n    {\n\tif (gamekeydown[key_right])\n\t{\n\t    side += sidemove[speed];\n\t}\n\tif (gamekeydown[key_left])\n\t{\n\t    side -= sidemove[speed];\n\t}\n\n    }\n    else\n    {\n\tif (gamekeydown[key_right])\n\t    cmd->angleturn -= angleturn[tspeed];\n\tif (gamekeydown[key_left])\n\t    cmd->angleturn += angleturn[tspeed];\n\tif (joyxmove > 0)\n\t    cmd->angleturn -= joyxmove >> (6 - speed);\n\tif (joyxmove < 0)\n\t    cmd->angleturn += -joyxmove >> (6 - speed);\n    }\n\n    if (gamekeydown[key_up])\n    {\n\tforward += forwardmove[speed];\n    }\n    if (gamekeydown[key_down])\n    {\n\tforward -= forwardmove[speed];\n    }\n\n    if (joyymove < 0)\n        forward += -joyymove >> (10 - speed);\n    if (joyymove > 0)\n        forward -= joyymove >> (10 - speed);\n\n    if (gamekeydown[key_strafeleft]\n     || joybuttons[joybstrafeleft]\n     || mousebuttons[mousebstrafeleft])\n    {\n        side -= sidemove[speed];\n    }\n\n    if (gamekeydown[key_straferight]\n     || joybuttons[joybstraferight]\n     || mousebuttons[mousebstraferight])\n    {\n        side += sidemove[speed];\n    }\n\n    if (joystrafemove < 0)\n        side -= (-joystrafemove >> (10 - speed)) - 8;\n    if (joystrafemove > 0)\n        side += (joystrafemove >> (10 - speed)) - 8;\n\n    // buttons\n    cmd->chatchar = HU_dequeueChatChar();\n\n    if (gamekeydown[key_fire] || mousebuttons[mousebfire]\n\t|| joybuttons[joybfire])\n\tcmd->buttons |= BT_ATTACK;\n\n    if (gamekeydown[key_use]\n     || joybuttons[joybuse]\n     || mousebuttons[mousebuse])\n    {\n\tcmd->buttons |= BT_USE;\n\t// clear double clicks if hit use button\n\tdclicks = 0;\n    }\n\n    // If the previous or next weapon button is pressed, the\n    // next_weapon variable is set to change weapons when\n    // we generate a ticcmd.  Choose a new weapon.\n\n    if (gamestate == GS_LEVEL && next_weapon != 0)\n    {\n        i = G_NextWeapon(next_weapon);\n        cmd->buttons |= BT_CHANGE;\n        cmd->buttons |= i << BT_WEAPONSHIFT;\n    }\n    else\n    {\n        // Check weapon keys.\n\n        for (i=0; i<arrlen(weapon_keys); ++i)\n        {\n            int key = *weapon_keys[i];\n\n            if (gamekeydown[key])\n            {\n                cmd->buttons |= BT_CHANGE;\n                cmd->buttons |= i<<BT_WEAPONSHIFT;\n                break;\n            }\n        }\n    }\n\n    next_weapon = 0;\n\n    // mouse\n    if (mousebuttons[mousebforward])\n    {\n\tforward += forwardmove[speed];\n    }\n    if (mousebuttons[mousebbackward])\n    {\n        forward -= forwardmove[speed];\n    }\n\n    if (dclick_use)\n    {\n        // forward double click\n        if (mousebuttons[mousebforward] != dclickstate && dclicktime > 1 )\n        {\n            dclickstate = mousebuttons[mousebforward];\n            if (dclickstate)\n                dclicks++;\n            if (dclicks == 2)\n            {\n                cmd->buttons |= BT_USE;\n                dclicks = 0;\n            }\n            else\n                dclicktime = 0;\n        }\n        else\n        {\n            dclicktime += ticdup;\n            if (dclicktime > 20)\n            {\n                dclicks = 0;\n                dclickstate = 0;\n            }\n        }\n\n        // strafe double click\n        bstrafe =\n            mousebuttons[mousebstrafe]\n            || joybuttons[joybstrafe];\n        if (bstrafe != dclickstate2 && dclicktime2 > 1 )\n        {\n            dclickstate2 = bstrafe;\n            if (dclickstate2)\n                dclicks2++;\n            if (dclicks2 == 2)\n            {\n                cmd->buttons |= BT_USE;\n                dclicks2 = 0;\n            }\n            else\n                dclicktime2 = 0;\n        }\n        else\n        {\n            dclicktime2 += ticdup;\n            if (dclicktime2 > 20)\n            {\n                dclicks2 = 0;\n                dclickstate2 = 0;\n            }\n        }\n    }\n\n    forward += mousey * 2;\n\n    if (strafe)\n\t    side += mousex*2;\n    else\n      cmd->angleturn -= mousex * 0x8;\n\n    if (mousex == 0)\n    {\n        // No movement in the previous frame\n\n        testcontrols_mousespeed = 0;\n    }\n\n    mousex = mousey = 0;\n\n    if (forward > MAXPLMOVE)\n\tforward = MAXPLMOVE;\n    else if (forward < -MAXPLMOVE)\n\tforward = -MAXPLMOVE;\n    if (side > MAXPLMOVE)\n\tside = MAXPLMOVE;\n    else if (side < -MAXPLMOVE)\n\tside = -MAXPLMOVE;\n\n    cmd->forwardmove += forward;\n    cmd->sidemove += side;\n\n    // special buttons\n    if (sendpause)\n    {\n\tsendpause = false;\n\tcmd->buttons = BT_SPECIAL | BTS_PAUSE;\n    }\n\n    if (sendsave)\n    {\n\tsendsave = false;\n\tcmd->buttons = BT_SPECIAL | BTS_SAVEGAME | (savegameslot<<BTS_SAVESHIFT);\n    }\n\n    // low-res turning\n\n    if (lowres_turn)\n    {\n        static signed short carry = 0;\n        signed short desired_angleturn;\n\n        desired_angleturn = cmd->angleturn + carry;\n\n        // round angleturn to the nearest 256 unit boundary\n        // for recording demos with single byte values for turn\n\n        cmd->angleturn = (desired_angleturn + 128) & 0xff00;\n\n        // Carry forward the error from the reduced resolution to the\n        // next tic, so that successive small movements can accumulate.\n\n        carry = desired_angleturn - cmd->angleturn;\n    }\n}\n\n\n//\n// G_DoLoadLevel\n//\nvoid G_DoLoadLevel (void)\n{\n    int             i;\n\n    // Set the sky map.\n    // First thing, we have a dummy sky texture name,\n    //  a flat. The data is in the WAD only because\n    //  we look for an actual index, instead of simply\n    //  setting one.\n\n    skyflatnum = R_FlatNumForName(DEH_String(SKYFLATNAME));\n\n    // The \"Sky never changes in Doom II\" bug was fixed in\n    // the id Anthology version of doom2.exe for Final Doom.\n    if ((gamemode == commercial)\n     && (gameversion == exe_final2 || gameversion == exe_chex))\n    {\n        const char *skytexturename;\n\n        if (gamemap < 12)\n        {\n            skytexturename = \"SKY1\";\n        }\n        else if (gamemap < 21)\n        {\n            skytexturename = \"SKY2\";\n        }\n        else\n        {\n            skytexturename = \"SKY3\";\n        }\n\n        skytexturename = DEH_String(skytexturename);\n\n        skytexture = R_TextureNumForName(skytexturename);\n    }\n\n    levelstarttic = gametic;        // for time calculation\n\n    if (wipegamestate == GS_LEVEL)\n\twipegamestate = -1;             // force a wipe\n\n    gamestate = GS_LEVEL;\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tturbodetected[i] = false;\n\tif (playeringame[i] && players[i].playerstate == PST_DEAD)\n\t    players[i].playerstate = PST_REBORN;\n\tmemset (players[i].frags,0,sizeof(players[i].frags));\n    }\n\n    P_SetupLevel (gameepisode, gamemap, 0, gameskill);\n    displayplayer = consoleplayer;\t\t// view the guy you are playing\n    gameaction = ga_nothing;\n    Z_CheckHeap ();\n\n    // clear cmd building stuff\n\n    memset (gamekeydown, 0, sizeof(gamekeydown));\n    joyxmove = joyymove = joystrafemove = 0;\n    mousex = mousey = 0;\n    sendpause = sendsave = paused = false;\n    memset(mousearray, 0, sizeof(mousearray));\n    memset(joyarray, 0, sizeof(joyarray));\n\n    if (testcontrols)\n    {\n        players[consoleplayer].message = \"Press escape to quit.\";\n    }\n\n    const char *s = HU_GetMapName();\n\n    EM_ASM_({\n        document.dispatchEvent(new CustomEvent(\"G_DoLoadLevel\", { detail: { mapname: Module.UTF8ToString($0) } }));\n    }, s);\n}\n\nstatic void SetJoyButtons(unsigned int buttons_mask)\n{\n    int i;\n\n    for (i=0; i<MAX_JOY_BUTTONS; ++i)\n    {\n        int button_on = (buttons_mask & (1 << i)) != 0;\n\n        // Detect button press:\n\n        if (!joybuttons[i] && button_on)\n        {\n            // Weapon cycling:\n\n            if (i == joybprevweapon)\n            {\n                next_weapon = -1;\n            }\n            else if (i == joybnextweapon)\n            {\n                next_weapon = 1;\n            }\n        }\n\n        joybuttons[i] = button_on;\n    }\n}\n\nstatic void SetMouseButtons(unsigned int buttons_mask)\n{\n    int i;\n\n    for (i=0; i<MAX_MOUSE_BUTTONS; ++i)\n    {\n        unsigned int button_on = (buttons_mask & (1 << i)) != 0;\n\n        // Detect button press:\n\n        if (!mousebuttons[i] && button_on)\n        {\n            if (i == mousebprevweapon)\n            {\n                next_weapon = -1;\n            }\n            else if (i == mousebnextweapon)\n            {\n                next_weapon = 1;\n            }\n        }\n\n\tmousebuttons[i] = button_on;\n    }\n}\n\n//\n// G_Responder\n// Get info needed to make ticcmd_ts for the players.\n//\nboolean G_Responder (event_t* ev)\n{\n    // allow spy mode changes even during the demo\n    if (gamestate == GS_LEVEL && ev->type == ev_keydown\n     && ev->data1 == key_spy && (singledemo || !deathmatch) )\n    {\n\t// spy mode\n\tdo\n\t{\n\t    displayplayer++;\n\t    if (displayplayer == MAXPLAYERS)\n\t\tdisplayplayer = 0;\n\t} while (!playeringame[displayplayer] && displayplayer != consoleplayer);\n\treturn true;\n    }\n\n    // any other key pops up menu if in demos\n    if (gameaction == ga_nothing && !singledemo &&\n\t(demoplayback || gamestate == GS_DEMOSCREEN)\n\t)\n    {\n\tif (ev->type == ev_keydown ||\n\t    (ev->type == ev_mouse && ev->data1) ||\n\t    (ev->type == ev_joystick && ev->data1) )\n\t{\n\t    M_StartControlPanel ();\n\t    return true;\n\t}\n\treturn false;\n    }\n\n    if (gamestate == GS_LEVEL)\n    {\n\tif (HU_Responder (ev))\n\t    return true;\t// chat ate the event\n\tif (ST_Responder (ev))\n\t    return true;\t// status window ate it\n\tif (AM_Responder (ev))\n\t    return true;\t// automap ate it\n    }\n\n    if (gamestate == GS_FINALE)\n    {\n\tif (F_Responder (ev))\n\t    return true;\t// finale ate the event\n    }\n\n    if (testcontrols && ev->type == ev_mouse)\n    {\n        // If we are invoked by setup to test the controls, save the\n        // mouse speed so that we can display it on-screen.\n        // Perform a low pass filter on this so that the thermometer\n        // appears to move smoothly.\n\n        testcontrols_mousespeed = abs(ev->data2);\n    }\n\n    // If the next/previous weapon keys are pressed, set the next_weapon\n    // variable to change weapons when the next ticcmd is generated.\n\n    if (ev->type == ev_keydown && ev->data1 == key_prevweapon)\n    {\n        next_weapon = -1;\n    }\n    else if (ev->type == ev_keydown && ev->data1 == key_nextweapon)\n    {\n        next_weapon = 1;\n    }\n\n    switch (ev->type)\n    {\n      case ev_keydown:\n\tif (ev->data1 == key_pause)\n\t{\n\t    sendpause = true;\n\t}\n        else if (ev->data1 <NUMKEYS)\n        {\n\t    gamekeydown[ev->data1] = true;\n        }\n\n\treturn true;    // eat key down events\n\n      case ev_keyup:\n\tif (ev->data1 <NUMKEYS)\n\t    gamekeydown[ev->data1] = false;\n\treturn false;   // always let key up events filter down\n\n      case ev_mouse:\n        SetMouseButtons(ev->data1);\n\tmousex = ev->data2*(mouseSensitivity+5)/10;\n\tmousey = ev->data3*(mouseSensitivity+5)/10;\n\treturn true;    // eat events\n\n      case ev_joystick:\n        SetJoyButtons(ev->data1);\n\tjoyxmove = ev->data2;\n\tjoyymove = ev->data3;\n        joystrafemove = ev->data4;\n\treturn true;    // eat events\n\n      default:\n\tbreak;\n    }\n\n    return false;\n}\n\n//\n// G_Ticker\n// Make ticcmd_ts for the players.\n//\nvoid G_Ticker (void)\n{\n    int\t\ti;\n    int\t\tbuf;\n    ticcmd_t*\tcmd;\n\n    // do player reborns if needed\n    for (i=0 ; i<MAXPLAYERS ; i++)\n\tif (playeringame[i] && players[i].playerstate == PST_REBORN)\n\t    G_DoReborn (i);\n\n    // do things to change the game state\n    while (gameaction != ga_nothing)\n    {\n\tswitch (gameaction)\n\t{\n\t  case ga_loadlevel:\n\t    G_DoLoadLevel ();\n\t    break;\n\t  case ga_newgame:\n\t    G_DoNewGame ();\n\t    break;\n\t  case ga_loadgame:\n\t    G_DoLoadGame ();\n\t    break;\n\t  case ga_savegame:\n\t    G_DoSaveGame ();\n\t    break;\n\t  case ga_playdemo:\n\t    if ( !G_DoPlayDemo () )\n            D_AdvanceDemo();\n\t    break;\n\t  case ga_completed:\n\t    G_DoCompleted ();\n\t    break;\n\t  case ga_victory:\n\t    F_StartFinale ();\n\t    break;\n\t  case ga_worlddone:\n\t    G_DoWorldDone ();\n\t    break;\n\t  case ga_screenshot:\n\t    V_ScreenShot(\"DOOM%02i.%s\");\n        if (!inspectmode) players[consoleplayer].message = DEH_String(\"screen shot\");\n\t    gameaction = ga_nothing;\n\t    break;\n\t  case ga_nothing:\n\t    break;\n\t}\n    }\n\n    // get commands, check consistancy,\n    // and build new consistancy check\n    buf = (gametic/ticdup)%BACKUPTICS;\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (playeringame[i])\n\t{\n\t    cmd = &players[i].cmd;\n\n\t    memcpy(cmd, &netcmds[i], sizeof(ticcmd_t));\n\n\t    if (demoplayback)\n\t\tG_ReadDemoTiccmd (cmd);\n\t    if (demorecording)\n\t\tG_WriteDemoTiccmd (cmd);\n\t}\n    }\n\n    // check for special buttons\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\tif (playeringame[i])\n\t{\n\t    if (players[i].cmd.buttons & BT_SPECIAL)\n\t    {\n\t\tswitch (players[i].cmd.buttons & BT_SPECIALMASK)\n\t\t{\n\t\t  case BTS_PAUSE:\n\t\t    paused ^= 1;\n\t\t    if (paused)\n\t\t\tS_PauseSound ();\n\t\t    else\n\t\t\tS_ResumeSound ();\n\t\t    break;\n\n\t\t  case BTS_SAVEGAME:\n\t\t    if (!savedescription[0])\n                    {\n                        M_StringCopy(savedescription, \"NET GAME\",\n                                     sizeof(savedescription));\n                    }\n\n\t\t    savegameslot =\n\t\t\t(players[i].cmd.buttons & BTS_SAVEMASK)>>BTS_SAVESHIFT;\n\t\t    gameaction = ga_savegame;\n\t\t    break;\n\t\t}\n\t    }\n\t}\n    }\n\n    // Have we just finished displaying an intermission screen?\n\n    if (oldgamestate == GS_INTERMISSION && gamestate != GS_INTERMISSION)\n    {\n        WI_End();\n    }\n\n    oldgamestate = gamestate;\n\n    // do main actions\n    switch (gamestate)\n    {\n      case GS_LEVEL:\n\tP_Ticker ();\n\tST_Ticker ();\n\tAM_Ticker ();\n\tHU_Ticker ();\n\tbreak;\n\n      case GS_INTERMISSION:\n\tWI_Ticker ();\n\tbreak;\n\n      case GS_FINALE:\n\tF_Ticker ();\n\tbreak;\n\n      case GS_DEMOSCREEN:\n\tD_PageTicker ();\n\tbreak;\n    }\n}\n\n\n//\n// PLAYER STRUCTURE FUNCTIONS\n// also see P_SpawnPlayer in P_Things\n//\n\n//\n// G_InitPlayer\n// Called at the start.\n// Called by the game initialization functions.\n//\nvoid G_InitPlayer (int player)\n{\n    // clear everything else to defaults\n    G_PlayerReborn (player);\n}\n\n\n\n//\n// G_PlayerFinishLevel\n// Can when a player completes a level.\n//\nvoid G_PlayerFinishLevel (int player)\n{\n    player_t*\tp;\n\n    p = &players[player];\n\n    memset (p->powers, 0, sizeof (p->powers));\n    memset (p->cards, 0, sizeof (p->cards));\n    p->mo->flags &= ~MF_SHADOW;\t\t// cancel invisibility\n    p->extralight = 0;\t\t\t// cancel gun flashes\n    p->fixedcolormap = 0;\t\t// cancel ir gogles\n    p->damagecount = 0;\t\t\t// no palette changes\n    p->bonuscount = 0;\n}\n\n\n//\n// G_PlayerReborn\n// Called after a player dies\n// almost everything is cleared and initialized\n//\nvoid G_PlayerReborn (int player)\n{\n    player_t*\tp;\n    int\t\ti;\n    int\t\tfrags[MAXPLAYERS];\n    int\t\tkillcount;\n    int\t\titemcount;\n    int\t\tsecretcount;\n\n    memcpy (frags,players[player].frags,sizeof(frags));\n    killcount = players[player].killcount;\n    itemcount = players[player].itemcount;\n    secretcount = players[player].secretcount;\n\n    p = &players[player];\n    memset (p, 0, sizeof(*p));\n\n    memcpy (players[player].frags, frags, sizeof(players[player].frags));\n    players[player].killcount = killcount;\n    players[player].itemcount = itemcount;\n    players[player].secretcount = secretcount;\n\n    p->usedown = p->attackdown = true;\t// don't do anything immediately\n    p->playerstate = PST_LIVE;\n    p->health = deh_initial_health;     // Use dehacked value\n    p->readyweapon = p->pendingweapon = wp_pistol;\n    p->weaponowned[wp_fist] = true;\n    p->weaponowned[wp_pistol] = true;\n    p->ammo[am_clip] = deh_initial_bullets;\n\n    for (i=0 ; i<NUMAMMO ; i++)\n\tp->maxammo[i] = maxammo[i];\n\n}\n\n//\n// G_CheckSpot\n// Returns false if the player cannot be respawned\n// at the given mapthing_t spot\n// because something is occupying it\n//\nvoid P_SpawnPlayer (mapthing_t* mthing);\n\nboolean\nG_CheckSpot\n( int\t\tplayernum,\n  mapthing_t*\tmthing )\n{\n    fixed_t\t\tx;\n    fixed_t\t\ty;\n    subsector_t*\tss;\n    mobj_t*\t\tmo;\n    int\t\t\ti;\n\n    if (!players[playernum].mo)\n    {\n\t// first spawn of level, before corpses\n\tfor (i=0 ; i<playernum ; i++)\n\t    if (players[i].mo->x == mthing->x << FRACBITS\n\t\t&& players[i].mo->y == mthing->y << FRACBITS)\n\t\treturn false;\n\treturn true;\n    }\n\n    x = mthing->x << FRACBITS;\n    y = mthing->y << FRACBITS;\n\n    if (!P_CheckPosition (players[playernum].mo, x, y) )\n\treturn false;\n\n    // flush an old corpse if needed\n    if (bodyqueslot >= BODYQUESIZE)\n\tP_RemoveMobj (bodyque[bodyqueslot%BODYQUESIZE]);\n    bodyque[bodyqueslot%BODYQUESIZE] = players[playernum].mo;\n    bodyqueslot++;\n\n    // spawn a teleport fog\n    ss = R_PointInSubsector (x,y);\n\n\n    // The code in the released source looks like this:\n    //\n    //    an = ( ANG45 * (((unsigned int) mthing->angle)/45) )\n    //         >> ANGLETOFINESHIFT;\n    //    mo = P_SpawnMobj (x+20*finecosine[an], y+20*finesine[an]\n    //                     , ss->sector->floorheight\n    //                     , MT_TFOG);\n    //\n    // But 'an' can be a signed value in the DOS version. This means that\n    // we get a negative index and the lookups into finecosine/finesine\n    // end up dereferencing values in finetangent[].\n    // A player spawning on a deathmatch start facing directly west spawns\n    // \"silently\" with no spawn fog. Emulate this.\n    //\n    // This code is imported from PrBoom+.\n\n    {\n        fixed_t xa, ya;\n        signed int an;\n\n        // This calculation overflows in Vanilla Doom, but here we deliberately\n        // avoid integer overflow as it is undefined behavior, so the value of\n        // 'an' will always be positive.\n        an = (ANG45 >> ANGLETOFINESHIFT) * ((signed int) mthing->angle / 45);\n\n        switch (an)\n        {\n            case 4096:  // -4096:\n                xa = finetangent[2048];    // finecosine[-4096]\n                ya = finetangent[0];       // finesine[-4096]\n                break;\n            case 5120:  // -3072:\n                xa = finetangent[3072];    // finecosine[-3072]\n                ya = finetangent[1024];    // finesine[-3072]\n                break;\n            case 6144:  // -2048:\n                xa = finesine[0];          // finecosine[-2048]\n                ya = finetangent[2048];    // finesine[-2048]\n                break;\n            case 7168:  // -1024:\n                xa = finesine[1024];       // finecosine[-1024]\n                ya = finetangent[3072];    // finesine[-1024]\n                break;\n            case 0:\n            case 1024:\n            case 2048:\n            case 3072:\n                xa = finecosine[an];\n                ya = finesine[an];\n                break;\n            default:\n                I_Error(\"G_CheckSpot: unexpected angle %d\\n\", an);\n                xa = ya = 0;\n                break;\n        }\n        mo = P_SpawnMobj(x + 20 * xa, y + 20 * ya,\n                         ss->sector->floorheight, MT_TFOG);\n    }\n\n    if (players[consoleplayer].viewz != 1)\n\tS_StartSound (mo, sfx_telept);\t// don't start sound on first frame\n\n    return true;\n}\n\n\n//\n// G_DeathMatchSpawnPlayer\n// Spawns a player at one of the random death match spots\n// called at level load and each death\n//\nvoid G_DeathMatchSpawnPlayer (int playernum)\n{\n    int             i,j;\n    int\t\t\t\tselections;\n\n    selections = deathmatch_p - deathmatchstarts;\n    if (selections < 4)\n\tI_Error (\"Only %i deathmatch spots, 4 required\", selections);\n\n    for (j=0 ; j<20 ; j++)\n    {\n\ti = P_Random() % selections;\n\tif (G_CheckSpot (playernum, &deathmatchstarts[i]) )\n\t{\n\t    deathmatchstarts[i].type = playernum+1;\n\t    P_SpawnPlayer (&deathmatchstarts[i]);\n\t    return;\n\t}\n    }\n\n    // no good spot, so the player will probably get stuck\n    P_SpawnPlayer (&playerstarts[playernum]);\n}\n\n//\n// G_DoReborn\n//\nvoid G_DoReborn (int playernum)\n{\n    int                             i;\n\n    if (!netgame)\n    {\n\t// reload the level from scratch\n\tgameaction = ga_loadlevel;\n    }\n    else\n    {\n\t// respawn at the start\n\n\t// first dissasociate the corpse\n\tplayers[playernum].mo->player = NULL;\n\n\t// spawn at random spot if in death match\n\tif (deathmatch)\n\t{\n\t    G_DeathMatchSpawnPlayer (playernum);\n\t    return;\n\t}\n\n\tif (G_CheckSpot (playernum, &playerstarts[playernum]) )\n\t{\n\t    P_SpawnPlayer (&playerstarts[playernum]);\n\t    return;\n\t}\n\n\t// try to spawn at one of the other players spots\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t{\n\t    if (G_CheckSpot (playernum, &playerstarts[i]) )\n\t    {\n\t\tplayerstarts[i].type = playernum+1;\t// fake as other player\n\t\tP_SpawnPlayer (&playerstarts[i]);\n\t\tplayerstarts[i].type = i+1;\t\t// restore\n\t\treturn;\n\t    }\n\t    // he's going to be inside something.  Too bad.\n\t}\n\tP_SpawnPlayer (&playerstarts[playernum]);\n    }\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid G_ScreenShot (void)\n{\n    gameaction = ga_screenshot;\n}\n\n\n\n// DOOM Par Times\nint pars[4][10] =\n{\n    {0},\n    {0,30,75,120,90,165,180,180,30,165},\n    {0,90,90,90,120,90,360,240,30,170},\n    {0,90,45,90,150,90,90,165,30,135}\n};\n\n// DOOM II Par Times\nint cpars[32] =\n{\n    30,90,120,120,90,150,120,120,270,90,\t//  1-10\n    210,150,150,150,210,150,420,150,210,150,\t// 11-20\n    240,150,180,150,150,300,330,420,300,180,\t// 21-30\n    120,30\t\t\t\t\t// 31-32\n};\n\n// [crispy] Episode 4 par times from the BFG Edition\nstatic int e4pars[10] =\n{\n    0,165,255,135,150,180,390,135,360,180\n};\n\n// [crispy] No Rest For The Living par times from the BFG Edition\nstatic int npars[9] =\n{\n    75,105,120,105,210,105,165,105,135\n};\n\n//\n// G_DoCompleted\n//\nboolean\t\tsecretexit;\nextern char*\tpagename;\n\nvoid G_ExitLevel (void)\n{\n    secretexit = false;\n    gameaction = ga_completed;\n}\n\n// Here's for the german edition.\nvoid G_SecretExitLevel (void)\n{\n    // IF NO WOLF3D LEVELS, NO SECRET EXIT!\n    if ( (gamemode == commercial)\n      && (W_CheckNumForName(\"map31\")<0))\n\tsecretexit = false;\n    else\n\tsecretexit = true;\n    gameaction = ga_completed;\n}\n\nvoid G_DoCompleted (void)\n{\n    int             i;\n    extern int bex_pars[4][10], bex_cpars[32]; // [crispy] support [PARS] sections in BEX files\n\n    gameaction = ga_nothing;\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n\tif (playeringame[i])\n\t    G_PlayerFinishLevel (i);        // take away cards and stuff\n\n    if (automapactive)\n\tAM_Stop ();\n\n    if (gamemode != commercial)\n    {\n        // Chex Quest ends after 5 levels, rather than 8.\n\n        if (gameversion == exe_chex)\n        {\n            if (gamemap == 5)\n            {\n                gameaction = ga_victory;\n                return;\n            }\n        }\n        else\n        {\n            switch(gamemap)\n            {\n              case 8:\n                gameaction = ga_victory;\n                return;\n              case 9:\n                for (i=0 ; i<MAXPLAYERS ; i++)\n                    players[i].didsecret = true;\n                break;\n            }\n        }\n    }\n\n//#if 0  Hmmm - why?\n    if ( (gamemap == 8)\n\t && (gamemode != commercial) )\n    {\n\t// victory\n\tgameaction = ga_victory;\n\treturn;\n    }\n\n    if ( (gamemap == 9)\n\t && (gamemode != commercial) )\n    {\n\t// exit secret level\n\tfor (i=0 ; i<MAXPLAYERS ; i++)\n\t    players[i].didsecret = true;\n    }\n//#endif\n\n\n    wminfo.didsecret = players[consoleplayer].didsecret;\n    wminfo.epsd = gameepisode -1;\n    wminfo.last = gamemap -1;\n\n    // wminfo.next is 0 biased, unlike gamemap\n    if ( gamemission == pack_nerve )\n    {\n\tif (secretexit)\n\t    switch(gamemap)\n\t    {\n\t      case  4: wminfo.next = 8; break;\n\t    }\n\telse\n\t    switch(gamemap)\n\t    {\n\t      case  9: wminfo.next = 4; break;\n\t      default: wminfo.next = gamemap;\n\t    }\n    }\n    else\n    if ( gamemission == pack_master )\n    {\n\twminfo.next = gamemap;\n    }\n    else\n    if ( gamemode == commercial)\n    {\n\tif (secretexit)\n        if (gamemap == 2 && havemap33)\n\t      wminfo.next = 32;\n\t    else\n\t    switch(gamemap)\n\t    {\n\t      case 15: wminfo.next = 30; break;\n\t      case 31: wminfo.next = 31; break;\n\t    }\n\telse\n        if (gamemap == 33 && havemap33)\n\t      wminfo.next = 2;\n\t    else\n\t    switch(gamemap)\n\t    {\n\t      case 31:\n\t      case 32: wminfo.next = 15; break;\n\t      default: wminfo.next = gamemap;\n\t    }\n    }\n    else\n    {\n\tif (secretexit)\n    {\n        if (havee1m10 && gameepisode == 1 && gamemap == 1)\n\t    wminfo.next = 9; // [crispy] go to secret level E1M10 \"Sewers\"\n\t    else\n\t    wminfo.next = 8; \t// go to secret level\n    }\n\telse if (gamemap == 9)\n\t{\n\t    // returning from secret level\n\t    switch (gameepisode)\n\t    {\n\t      case 1:\n\t\twminfo.next = 3;\n\t\tbreak;\n\t      case 2:\n\t\twminfo.next = 5;\n\t\tbreak;\n\t      case 3:\n\t\twminfo.next = 6;\n\t\tbreak;\n\t      case 4:\n\t\twminfo.next = 2;\n\t\tbreak;\n\t    }\n\t}\n\telse\n    if (havee1m10 && gameepisode == 1 && gamemap == 10)\n\t    wminfo.next = 1; // [crispy] returning from secret level E1M10 \"Sewers\"\n\telse\n\t    wminfo.next = gamemap;          // go to next level\n    }\n\n    wminfo.maxkills = totalkills;\n    wminfo.maxitems = totalitems;\n    wminfo.maxsecret = totalsecret;\n    wminfo.maxfrags = 0;\n\n    if (gamemap == 33 || (havee1m10 && gameepisode == 1 && gamemap == 10))\n    {\n        // [crispy] par time for inofficial maps sucks\n        wminfo.partime = INT_MAX;\n    }\n    else\n    if (gamemission == pack_nerve /*&& crispy->singleplayer*/)\n    {\n        wminfo.partime = TICRATE*npars[gamemap-1];\n    }\n    else\n    // Set par time. Exceptions are added for purposes of\n    // statcheck regression testing.\n    if (gamemode == commercial)\n    {\n        // map33 has no official time: initialize to zero\n        if (gamemap == 33)\n        {\n            wminfo.partime = 0;\n        }\n        else\n        // [crispy] support [PARS] sections in BEX files\n        if (bex_cpars[gamemap-1])\n        {\n            wminfo.partime = TICRATE*bex_cpars[gamemap-1];\n        }\n        else\n        {\n            wminfo.partime = TICRATE*cpars[gamemap-1];\n        }\n    }\n    // Doom episode 4 doesn't have a par time, so this\n    // overflows into the cpars array.\n    else if (gameepisode < 4)\n    {\n        wminfo.partime = TICRATE*pars[gameepisode][gamemap];\n    }\n    else if (gameepisode == 4)\n    {\n        wminfo.partime = TICRATE*e4pars[gamemap];\n    }\n    else\n    {\n        wminfo.partime = TICRATE*cpars[gamemap];\n    }\n\n    wminfo.pnum = consoleplayer;\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n    {\n\twminfo.plyr[i].in = playeringame[i];\n\twminfo.plyr[i].skills = players[i].killcount;\n\twminfo.plyr[i].sitems = players[i].itemcount;\n\twminfo.plyr[i].ssecret = players[i].secretcount;\n\twminfo.plyr[i].stime = leveltime;\n\tmemcpy (wminfo.plyr[i].frags, players[i].frags\n\t\t, sizeof(wminfo.plyr[i].frags));\n    }\n\n    gamestate = GS_INTERMISSION;\n    viewactive = false;\n    automapactive = false;\n\n    StatCopy(&wminfo);\n\n    WI_Start (&wminfo);\n\n    const char *s = HU_GetMapName();\n\n    EM_ASM_({\n        var maxkills = $1;\n        var maxitems = $2;\n        var maxsecret = $3;\n        var partime = $4;\n        var killcount = $5;\n        var itemcount = $6;\n        var secretcount = $7;\n        var leveltime = $8;\n        document.dispatchEvent(new CustomEvent(\"G_DoCompleted\", {\n            detail: {\n                mapname: Module.UTF8ToString($0),\n                maxkills: maxkills,\n                maxitems: maxitems,\n                maxsecret: maxsecret,\n                partime: partime / 35,\n                killcount: killcount,\n                itemcount: itemcount,\n                secretcount: secretcount,\n                leveltime: leveltime / 35\n            }\n        }));\n    }, s, wminfo.maxkills, wminfo.maxitems, wminfo.maxsecret, wminfo.partime, players[0].killcount, players[0].itemcount, players[0].secretcount, leveltime);\n}\n\n\n//\n// G_WorldDone\n//\nvoid G_WorldDone (void)\n{\n    gameaction = ga_worlddone;\n\n    if (secretexit)\n    // [crispy] special-casing for E1M10 \"Sewers\" support\n      // i.e. avoid drawing the splat for E1M9 already\n      if (!havee1m10 || gameepisode != 1 || gamemap != 1)\n\tplayers[consoleplayer].didsecret = true;\n\n    if ( gamemission == pack_nerve )\n    {\n\tswitch (gamemap)\n\t{\n\t  case 8:\n\t    F_StartFinale ();\n\t    break;\n\t}\n    }\n    else\n    if ( gamemission == pack_master )\n    {\n\tswitch (gamemap)\n\t{\n\t  case 20:\n\t    if (secretexit)\n\t\tbreak;\n\t  case 21:\n\t    F_StartFinale ();\n\t    break;\n\t}\n    }\n    else\n    if ( gamemode == commercial )\n    {\n\tswitch (gamemap)\n\t{\n\t  case 15:\n\t  case 31:\n\t    if (!secretexit)\n\t\tbreak;\n\t  case 6:\n\t  case 11:\n\t  case 20:\n\t  case 30:\n\t    F_StartFinale ();\n\t    break;\n\t}\n    }\n}\n\nvoid G_DoWorldDone (void)\n{\n    gamestate = GS_LEVEL;\n    gamemap = wminfo.next+1;\n    G_DoLoadLevel ();\n    gameaction = ga_nothing;\n    viewactive = true;\n}\n\n\n\n//\n// G_InitFromSavegame\n// Can be called by the startup code or the menu task.\n//\nextern boolean setsizeneeded;\nvoid R_ExecuteSetViewSize (void);\n\nchar\tsavename[256];\n\nvoid G_LoadGame (char* name)\n{\n    M_StringCopy(savename, name, sizeof(savename));\n    gameaction = ga_loadgame;\n}\n\nvoid G_DoLoadGame (void)\n{\n    int savedleveltime;\n\n    gameaction = ga_nothing;\n\n    save_stream = fopen(savename, \"rb\");\n\n    if (save_stream == NULL)\n    {\n        I_Error(\"Could not load savegame %s\", savename);\n    }\n\n    savegame_error = false;\n\n    if (!P_ReadSaveGameHeader())\n    {\n        fclose(save_stream);\n        return;\n    }\n\n    savedleveltime = leveltime;\n\n    // load a base level\n    G_InitNew (gameskill, gameepisode, gamemap);\n\n    leveltime = savedleveltime;\n\n    // dearchive all the modifications\n    P_UnArchivePlayers ();\n    P_UnArchiveWorld ();\n    P_UnArchiveThinkers ();\n    P_UnArchiveSpecials ();\n\n    if (!P_ReadSaveGameEOF())\n\tI_Error (\"Bad savegame\");\n\n    fclose(save_stream);\n\n    if (setsizeneeded)\n\tR_ExecuteSetViewSize ();\n\n    // draw the pattern into the back screen\n    R_FillBackScreen ();\n}\n\n\n//\n// G_SaveGame\n// Called by the menu task.\n// Description is a 24 byte text string\n//\nvoid\nG_SaveGame\n( int\tslot,\n  char*\tdescription )\n{\n    savegameslot = slot;\n    M_StringCopy(savedescription, description, sizeof(savedescription));\n    sendsave = true;\n}\n\nvoid G_DoSaveGame (void)\n{\n    char *savegame_file;\n    char *temp_savegame_file;\n    char *recovery_savegame_file;\n\n    recovery_savegame_file = NULL;\n    temp_savegame_file = P_TempSaveGameFile();\n    savegame_file = P_SaveGameFile(savegameslot);\n\n    // Open the savegame file for writing.  We write to a temporary file\n    // and then rename it at the end if it was successfully written.\n    // This prevents an existing savegame from being overwritten by\n    // a corrupted one, or if a savegame buffer overrun occurs.\n    save_stream = fopen(temp_savegame_file, \"wb\");\n\n    if (save_stream == NULL)\n    {\n        // Failed to save the game, so we're going to have to abort. But\n        // to be nice, save to somewhere else before we call I_Error().\n        recovery_savegame_file = M_TempFile(\"recovery.dsg\");\n        save_stream = fopen(recovery_savegame_file, \"wb\");\n        if (save_stream == NULL)\n        {\n            I_Error(\"Failed to open either '%s' or '%s' to write savegame.\",\n                    temp_savegame_file, recovery_savegame_file);\n        }\n    }\n\n    savegame_error = false;\n\n    P_WriteSaveGameHeader(savedescription);\n\n    P_ArchivePlayers ();\n    P_ArchiveWorld ();\n    P_ArchiveThinkers ();\n    P_ArchiveSpecials ();\n\n    P_WriteSaveGameEOF();\n\n    // Enforce the same savegame size limit as in Vanilla Doom,\n    // except if the vanilla_savegame_limit setting is turned off.\n\n    if (vanilla_savegame_limit && ftell(save_stream) > SAVEGAMESIZE)\n    {\n        I_Error(\"Savegame buffer overrun\");\n    }\n\n    // Finish up, close the savegame file.\n\n    fclose(save_stream);\n\n    if (recovery_savegame_file != NULL)\n    {\n        // We failed to save to the normal location, but we wrote a\n        // recovery file to the temp directory. Now we can bomb out\n        // with an error.\n        I_Error(\"Failed to open savegame file '%s' for writing.\\n\"\n                \"But your game has been saved to '%s' for recovery.\",\n                temp_savegame_file, recovery_savegame_file);\n    }\n\n    // Now rename the temporary savegame file to the actual savegame\n    // file, overwriting the old savegame if there was one there.\n\n    remove(savegame_file);\n    rename(temp_savegame_file, savegame_file);\n\n    gameaction = ga_nothing;\n    M_StringCopy(savedescription, \"\", sizeof(savedescription));\n\n    players[consoleplayer].message = DEH_String(GGSAVED);\n\n    // draw the pattern into the back screen\n    R_FillBackScreen ();\n\n    EM_ASM_({\n        try{\n            var filename = Module.UTF8ToString($0);\n            var buffer = Module.FS.readFile(filename).buffer;\n            document.dispatchEvent(new CustomEvent(\"G_SaveGame\", { detail: { filename: filename, buffer: buffer } }));\n        }catch(err){}\n    }, savegame_file);\n}\n\n\n//\n// G_InitNew\n// Can be called by the startup code or the menu task,\n// consoleplayer, displayplayer, playeringame[] should be set.\n//\nskill_t\td_skill;\nint     d_episode;\nint     d_map;\n\nvoid\nG_DeferedInitNew\n( skill_t\tskill,\n  int\t\tepisode,\n  int\t\tmap)\n{\n    d_skill = skill;\n    d_episode = episode;\n    d_map = map;\n    gameaction = ga_newgame;\n}\n\n\nvoid G_DoNewGame (void)\n{\n    demoplayback = false;\n    netdemo = false;\n    netgame = false;\n    deathmatch = false;\n    playeringame[1] = playeringame[2] = playeringame[3] = 0;\n\n    //!\n    // @category game\n    // @vanilla\n    //\n    // Disable monsters.\n    //\n\n    nomonsters = M_CheckParm (\"-nomonsters\");\n\n    //!\n    // @category game\n    // @vanilla\n    //\n    // Monsters respawn after being killed.\n    //\n\n    respawnparm = M_CheckParm (\"-respawn\");\n\n    //!\n    // @category game\n    // @vanilla\n    //\n    // Monsters move faster.\n    //\n\n    fastparm = M_CheckParm (\"-fast\");\n\n    consoleplayer = 0;\n    G_InitNew (d_skill, d_episode, d_map);\n    gameaction = ga_nothing;\n}\n\nvoid G_GetGameInfo ( gameinfo_t *state )\n{\n    state->skill = gameskill;\n    state->episode = gameepisode;\n    state->map = gamemap;\n}\n\nextern boolean firstScreen;\nEMSCRIPTEN_KEEPALIVE\nvoid\nG_InitNew\n( skill_t\tskill,\n  int\t\tepisode,\n  int\t\tmap )\n{\n    EM_ASM_({\n        document.dispatchEvent(new CustomEvent(\"G_InitNew\", { detail: { skill: $0, episode: $1, map: $2 } }));\n    }, skill, episode, map);\n\n    const char *skytexturename;\n    int             i;\n\n    if (paused)\n    {\n\tpaused = false;\n\tS_ResumeSound ();\n    }\n\n    if (skill > sk_nightmare)\n\tskill = sk_nightmare;\n\n    if (gameversion >= exe_ultimate)\n    {\n        if (episode == 0)\n        {\n            episode = 4;\n        }\n    }\n    else\n    {\n        if (episode < 1)\n        {\n            episode = 1;\n        }\n        if (episode > 3)\n        {\n            episode = 3;\n        }\n    }\n\n    if (episode > 1 && gamemode == shareware)\n    {\n        episode = 1;\n    }\n\n    if (map < 1)\n\tmap = 1;\n\n    if ( (map > 9) )\n    {\n    if (gamemode != commercial)\n    {\n      // [crispy] support E1M10 \"Sewers\"\n      if (!havee1m10 || episode != 1)\n      map = 9;\n      else\n      map = 10;\n    }\n    else\n    if (map == 33 && !havemap33)\n    map = 32;\n    }\n\n    M_ClearRandom ();\n\n    if (skill == sk_nightmare || respawnparm )\n\trespawnmonsters = true;\n    else\n\trespawnmonsters = false;\n\n    if (fastparm || (skill == sk_nightmare && gameskill != sk_nightmare) )\n    {\n\tfor (i=S_SARG_RUN1 ; i<=S_SARG_PAIN2 ; i++)\n\t    states[i].tics >>= 1;\n\tmobjinfo[MT_BRUISERSHOT].speed = 20*FRACUNIT;\n\tmobjinfo[MT_HEADSHOT].speed = 20*FRACUNIT;\n\tmobjinfo[MT_TROOPSHOT].speed = 20*FRACUNIT;\n    }\n    else if (skill != sk_nightmare && gameskill == sk_nightmare)\n    {\n\tfor (i=S_SARG_RUN1 ; i<=S_SARG_PAIN2 ; i++)\n\t    states[i].tics <<= 1;\n\tmobjinfo[MT_BRUISERSHOT].speed = 15*FRACUNIT;\n\tmobjinfo[MT_HEADSHOT].speed = 10*FRACUNIT;\n\tmobjinfo[MT_TROOPSHOT].speed = 10*FRACUNIT;\n    }\n\n    // force players to be initialized upon first level load\n    for (i=0 ; i<MAXPLAYERS ; i++)\n\tplayers[i].playerstate = PST_REBORN;\n\n    usergame = true;                // will be set false if a demo\n    paused = false;\n    demoplayback = false;\n    automapactive = false;\n    viewactive = true;\n    gameepisode = episode;\n    gamemap = map;\n    gameskill = skill;\n\n    viewactive = true;\n\n    // Set the sky to use.\n    //\n    // Note: This IS broken, but it is how Vanilla Doom behaves.\n    // See http://doomwiki.org/wiki/Sky_never_changes_in_Doom_II.\n    //\n    // Because we set the sky here at the start of a game, not at the\n    // start of a level, the sky texture never changes unless we\n    // restore from a saved game.  This was fixed before the Doom\n    // source release, but this IS the way Vanilla DOS Doom behaves.\n\n    if (gamemode == commercial)\n    {\n        if (gamemap < 12)\n            skytexturename = \"SKY1\";\n        else if (gamemap < 21)\n            skytexturename = \"SKY2\";\n        else\n            skytexturename = \"SKY3\";\n    }\n    else\n    {\n        switch (gameepisode)\n        {\n          default:\n          case 1:\n            skytexturename = \"SKY1\";\n            break;\n          case 2:\n            skytexturename = \"SKY2\";\n            break;\n          case 3:\n            skytexturename = \"SKY3\";\n            break;\n          case 4:        // Special Edition sky\n            skytexturename = \"SKY4\";\n            break;\n        }\n    }\n\n    skytexturename = DEH_String(skytexturename);\n\n    skytexture = R_TextureNumForName(skytexturename);\n\n    firstScreen = true;\n    G_DoLoadLevel ();\n}\n\n\n//\n// DEMO RECORDING\n//\n#define DEMOMARKER\t\t0x80\n\n\nvoid G_ReadDemoTiccmd (ticcmd_t* cmd)\n{\n    if (*demo_p == DEMOMARKER)\n    {\n\t// end of demo data stream\n\tG_CheckDemoStatus ();\n\treturn;\n    }\n    cmd->forwardmove = ((signed char)*demo_p++);\n    cmd->sidemove = ((signed char)*demo_p++);\n\n    // If this is a longtics demo, read back in higher resolution\n\n    if (longtics)\n    {\n        cmd->angleturn = *demo_p++;\n        cmd->angleturn |= (*demo_p++) << 8;\n    }\n    else\n    {\n        cmd->angleturn = ((unsigned char) *demo_p++)<<8;\n    }\n\n    cmd->buttons = (unsigned char)*demo_p++;\n}\n\nvoid G_WriteDemoTiccmd (ticcmd_t* cmd)\n{\n}\n\n//\n// G_RecordDemo\n//\nvoid G_RecordDemo (char *name)\n{\n    size_t demoname_size;\n    int i;\n    int maxsize;\n\n    usergame = false;\n    demoname_size = strlen(name) + 5;\n    demoname = Z_Malloc(demoname_size, PU_STATIC, NULL);\n    M_snprintf(demoname, demoname_size, \"%s.lmp\", name);\n    maxsize = 0x20000;\n\n    //!\n    // @arg <size>\n    // @category demo\n    // @vanilla\n    //\n    // Specify the demo buffer size (KiB)\n    //\n\n    i = M_CheckParmWithArgs(\"-maxdemo\", 1);\n    if (i)\n\tmaxsize = atoi(myargv[i+1])*1024;\n\n    demobuffer = Z_Malloc (maxsize,PU_STATIC,NULL);\n    demoend = demobuffer + maxsize;\n\n    demorecording = true;\n}\n\n// Get the demo version code appropriate for the version set in gameversion.\nint G_VanillaVersionCode(void)\n{\n    switch (gameversion)\n    {\n        case exe_doom_1_2:\n            I_Error(\"Doom 1.2 does not have a version code!\");\n        case exe_doom_1_666:\n            return 106;\n        case exe_doom_1_7:\n            return 107;\n        case exe_doom_1_8:\n            return 108;\n        case exe_doom_1_9:\n        default:  // All other versions are variants on v1.9:\n            return 109;\n    }\n}\n\nvoid G_BeginRecording (void)\n{\n    int             i;\n\n    demo_p = demobuffer;\n\n    //!\n    // @category demo\n    //\n    // Record a high resolution \"Doom 1.91\" demo.\n    //\n\n    longtics = D_NonVanillaRecord(M_ParmExists(\"-longtics\"),\n                                  \"Doom 1.91 demo format\");\n\n    // If not recording a longtics demo, record in low res\n    lowres_turn = !longtics;\n\n    if (longtics)\n    {\n        *demo_p++ = DOOM_191_VERSION;\n    }\n    else\n    {\n        *demo_p++ = G_VanillaVersionCode();\n    }\n\n    *demo_p++ = gameskill;\n    *demo_p++ = gameepisode;\n    *demo_p++ = gamemap;\n    *demo_p++ = deathmatch;\n    *demo_p++ = respawnparm;\n    *demo_p++ = fastparm;\n    *demo_p++ = nomonsters;\n    *demo_p++ = consoleplayer;\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n\t*demo_p++ = playeringame[i];\n}\n\n\n//\n// G_PlayDemo\n//\n\nstatic const char *defdemoname;\n\nvoid G_DeferedPlayDemo(const char *name)\n{\n    defdemoname = name;\n    gameaction = ga_playdemo;\n}\n\nboolean G_DoPlayDemo (void)\n{\n    skill_t skill;\n    int i, lumpnum, episode, map;\n    int demoversion;\n\n    lumpnum = W_GetNumForName(defdemoname);\n    gameaction = ga_nothing;\n    demobuffer = W_CacheLumpNum(lumpnum, PU_STATIC);\n    demo_p = demobuffer;\n\n    demoversion = *demo_p++;\n\n    longtics = false;\n\n    // Longtics demos use the modified format that is generated by cph's\n    // hacked \"v1.91\" doom exe. This is a non-vanilla extension.\n    if (D_NonVanillaPlayback(demoversion == DOOM_191_VERSION, lumpnum,\n                             \"Doom 1.91 demo format\"))\n    {\n        longtics = true;\n    }\n    else if (demoversion != G_VanillaVersionCode())\n    {\n        // char *message = \"Demo is from a different game version!\\n\"\n        //                 \"(read %i, should be %i)\\n\"\n        //                 \"\\n\"\n        //                 \"*** You may need to upgrade your version \"\n        //                     \"of Doom to v1.9. ***\\n\"\n        //                 \"    See: https://www.doomworld.com/classicdoom\"\n        //                           \"/info/patches.php\\n\"\n        //                 \"    This appears to be %s.\";\n\n        // I_Error(message, demoversion, G_VanillaVersionCode(),\n        //                  DemoVersionDescription(demoversion));\n        return false;\n    }\n\n    skill = *demo_p++;\n    episode = *demo_p++;\n    map = *demo_p++;\n    deathmatch = *demo_p++;\n    respawnparm = *demo_p++;\n    fastparm = *demo_p++;\n    nomonsters = *demo_p++;\n    consoleplayer = *demo_p++;\n\n    for (i=0 ; i<MAXPLAYERS ; i++)\n\tplayeringame[i] = *demo_p++;\n\n    if (playeringame[1] || M_CheckParm(\"-solo-net\") > 0\n                        || M_CheckParm(\"-netdemo\") > 0)\n    {\n\tnetgame = true;\n\tnetdemo = true;\n    }\n\n    // don't spend a lot of time in loadlevel\n    precache = false;\n    G_InitNew (skill, episode, map);\n    precache = true;\n    starttime = I_GetTime ();\n\n    usergame = false;\n    demoplayback = true;\n\n    return true;\n}\n\n//\n// G_TimeDemo\n//\nvoid G_TimeDemo (char* name)\n{\n    //!\n    // @category video\n    // @vanilla\n    //\n    // Disable rendering the screen entirely.\n    //\n\n    nodrawers = M_CheckParm (\"-nodraw\");\n\n    timingdemo = true;\n    singletics = true;\n\n    defdemoname = name;\n    gameaction = ga_playdemo;\n}\n\n\n/*\n===================\n=\n= G_CheckDemoStatus\n=\n= Called after a death or level completion to allow demos to be cleaned up\n= Returns true if a new demo loop action will take place\n===================\n*/\n\nboolean G_CheckDemoStatus (void)\n{\n    int             endtime;\n\n    if (timingdemo)\n    {\n        float fps;\n        int realtics;\n\n\tendtime = I_GetTime ();\n        realtics = endtime - starttime;\n        fps = ((float) gametic * TICRATE) / realtics;\n\n        // Prevent recursive calls\n        timingdemo = false;\n        demoplayback = false;\n\n\tI_Error (\"timed %i gametics in %i realtics (%f fps)\",\n                 gametic, realtics, fps);\n    }\n\n    if (demoplayback)\n    {\n        W_ReleaseLumpName(defdemoname);\n\tdemoplayback = false;\n\tnetdemo = false;\n\tnetgame = false;\n\tdeathmatch = false;\n\tplayeringame[1] = playeringame[2] = playeringame[3] = 0;\n\n    //!\n    // @category game\n    // @vanilla\n    //\n    // Disable monsters.\n    //\n\n    nomonsters = M_CheckParm (\"-nomonsters\");\n\n    //!\n    // @category game\n    // @vanilla\n    //\n    // Monsters respawn after being killed.\n    //\n\n    respawnparm = M_CheckParm (\"-respawn\");\n\n    //!\n    // @category game\n    // @vanilla\n    //\n    // Monsters move faster.\n    //\n\n    fastparm = M_CheckParm (\"-fast\");\n\n\tconsoleplayer = 0;\n\n        if (singledemo)\n            I_Quit ();\n        else\n            D_AdvanceDemo ();\n\n\treturn true;\n    }\n\n    if (demorecording)\n    {\n\t*demo_p++ = DEMOMARKER;\n\tM_WriteFile (demoname, demobuffer, demo_p - demobuffer);\n\tZ_Free (demobuffer);\n\tdemorecording = false;\n    return true;\n    }\n\n    return false;\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid SendPause(boolean state)\n{\n    paused = state;\n    if (paused)\n    S_PauseSound ();\n    else\n    S_ResumeSound ();\n}\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Parses \"Cheat\" sections in dehacked files\n//\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"doomtype.h\"\n\n#include \"deh_defs.h\"\n#include \"deh_io.h\"\n#include \"deh_main.h\"\n#include \"am_map.h\"\n#include \"st_stuff.h\"\n\ntypedef struct \n{\n    const char *name;\n    cheatseq_t *seq;\n} deh_cheat_t;\n\nstatic deh_cheat_t allcheats[] =\n{\n    {\"Change music\",        &cheat_mus },\n    {\"Chainsaw\",            &cheat_choppers },\n    {\"God mode\",            &cheat_god },\n    {\"Ammo & Keys\",         &cheat_ammo },\n    {\"Ammo\",                &cheat_ammonokey },\n    {\"No Clipping 1\",       &cheat_noclip },\n    {\"No Clipping 2\",       &cheat_commercial_noclip },\n    {\"Invincibility\",       &cheat_powerup[0] },\n    {\"Berserk\",             &cheat_powerup[1] },\n    {\"Invisibility\",        &cheat_powerup[2] },\n    {\"Radiation Suit\",      &cheat_powerup[3] },\n    {\"Auto-map\",            &cheat_powerup[4] },\n    {\"Lite-Amp Goggles\",    &cheat_powerup[5] },\n    {\"BEHOLD menu\",         &cheat_powerup[6] },\n    {\"Level Warp\",          &cheat_clev },\n    {\"Player Position\",     &cheat_mypos },\n    {\"Map cheat\",           &cheat_amap },\n};\n\nstatic deh_cheat_t *FindCheatByName(char *name)\n{\n    size_t i;\n    \n    for (i=0; i<arrlen(allcheats); ++i)\n    {\n        if (!strcasecmp(allcheats[i].name, name))\n            return &allcheats[i];\n    }\n\n    return NULL;\n}\n\nstatic void *DEH_CheatStart(deh_context_t *context, char *line)\n{\n    return NULL;\n}\n\nstatic void DEH_CheatParseLine(deh_context_t *context, char *line, void *tag)\n{\n    deh_cheat_t *cheat;\n    char *variable_name;\n    char *value;\n    unsigned char *unsvalue;\n    unsigned int i;\n\n    if (!DEH_ParseAssignment(line, &variable_name, &value))\n    {\n        // Failed to parse\n\n        DEH_Warning(context, \"Failed to parse assignment\");\n        return;\n    }\n\n    unsvalue = (unsigned char *) value;\n\n    cheat = FindCheatByName(variable_name);\n\n    if (cheat == NULL)\n    {\n        DEH_Warning(context, \"Unknown cheat '%s'\", variable_name);\n        return;\n    }\n\n    // write the value into the cheat sequence\n\n    i = 0;\n\n    while (unsvalue[i] != 0 && unsvalue[i] != 0xff)\n    {\n        // If the cheat length exceeds the Vanilla limit, stop.  This\n        // does not apply if we have the limit turned off.\n\n        if (!deh_allow_long_cheats && i >= cheat->seq->sequence_len)\n        {\n            DEH_Warning(context, \"Cheat sequence longer than supported by \"\n                                 \"Vanilla dehacked\");\n            break;\n        }\n\n\tif (deh_apply_cheats)\n\t{\n\t    cheat->seq->sequence[i] = unsvalue[i];\n\t}\n        ++i;\n\n        // Absolute limit - don't exceed\n\n        if (i >= MAX_CHEAT_LEN - cheat->seq->parameter_chars)\n        {\n            DEH_Error(context, \"Cheat sequence too long!\");\n            return;\n        }\n    }\n\n    if (deh_apply_cheats)\n    {\n        cheat->seq->sequence[i] = '\\0';\n    }\n}\n\ndeh_section_t deh_section_cheat =\n{\n    \"Cheat\",\n    NULL,\n    DEH_CheatStart,\n    DEH_CheatParseLine,\n    NULL,\n    NULL,\n};\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Parses \"Frame\" sections in dehacked files\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"doomtype.h\"\n#include \"d_items.h\"\n#include \"info.h\"\n\n#include \"deh_defs.h\"\n#include \"deh_io.h\"\n#include \"deh_main.h\"\n#include \"deh_mapping.h\"\n\nDEH_BEGIN_MAPPING(state_mapping, state_t)\n  DEH_MAPPING(\"Sprite number\",    sprite)\n  DEH_MAPPING(\"Sprite subnumber\", frame)\n  DEH_MAPPING(\"Duration\",         tics)\n  DEH_MAPPING(\"Next frame\",       nextstate)\n  DEH_MAPPING(\"Unknown 1\",        misc1)\n  DEH_MAPPING(\"Unknown 2\",        misc2)\n  DEH_UNSUPPORTED_MAPPING(\"Codep frame\")\nDEH_END_MAPPING\n\nstatic void *DEH_FrameStart(deh_context_t *context, char *line)\n{\n    int frame_number = 0;\n    state_t *state;\n    \n    if (sscanf(line, \"Frame %i\", &frame_number) != 1)\n    {\n        DEH_Warning(context, \"Parse error on section start\");\n        return NULL;\n    }\n    \n    if (frame_number < 0 || frame_number >= NUMSTATES)\n    {\n        DEH_Warning(context, \"Invalid frame number: %i\", frame_number);\n        return NULL;\n    }\n\n    if (frame_number >= DEH_VANILLA_NUMSTATES) \n    {\n        DEH_Warning(context, \"Attempt to modify frame %i: this will cause \"\n                             \"problems in Vanilla dehacked.\", frame_number);\n    }\n\n    state = &states[frame_number];\n\n    return state;\n}\n\n// Simulate a frame overflow: Doom has 967 frames in the states[] array, but\n// DOS dehacked internally only allocates memory for 966.  As a result, \n// attempts to set frame 966 (the last frame) will overflow the dehacked\n// array and overwrite the weaponinfo[] array instead.\n//\n// This is noticable in Batman Doom where it is impossible to switch weapons\n// away from the fist once selected.\n\nstatic void DEH_FrameOverflow(deh_context_t *context, char *varname, int value)\n{\n    if (!strcasecmp(varname, \"Duration\"))\n    {\n        weaponinfo[0].ammo = value;\n    }\n    else if (!strcasecmp(varname, \"Codep frame\")) \n    {\n        weaponinfo[0].upstate = value;\n    }\n    else if (!strcasecmp(varname, \"Next frame\")) \n    {\n        weaponinfo[0].downstate = value;\n    }\n    else if (!strcasecmp(varname, \"Unknown 1\"))\n    {\n        weaponinfo[0].readystate = value;\n    }\n    else if (!strcasecmp(varname, \"Unknown 2\"))\n    {\n        weaponinfo[0].atkstate = value;\n    }\n    else\n    {\n        DEH_Error(context, \"Unable to simulate frame overflow: field '%s'\",\n                  varname);\n    }\n}\n\nstatic void DEH_FrameParseLine(deh_context_t *context, char *line, void *tag)\n{\n    state_t *state;\n    char *variable_name, *value;\n    int ivalue;\n    \n    if (tag == NULL)\n       return;\n\n    state = (state_t *) tag;\n\n    // Parse the assignment\n\n    if (!DEH_ParseAssignment(line, &variable_name, &value))\n    {\n        // Failed to parse\n\n        DEH_Warning(context, \"Failed to parse assignment\");\n        return;\n    }\n    \n    // all values are integers\n\n    ivalue = atoi(value);\n    \n    if (state == &states[NUMSTATES - 1])\n    {\n        DEH_FrameOverflow(context, variable_name, ivalue);\n    }\n    else\n    {\n        // set the appropriate field\n\n        DEH_SetMapping(context, &state_mapping, state, variable_name, ivalue);\n    }\n}\n\nstatic void DEH_FrameSHA1Sum(sha1_context_t *context)\n{\n    int i;\n\n    for (i=0; i<NUMSTATES; ++i)\n    {\n        DEH_StructSHA1Sum(context, &state_mapping, &states[i]);\n    }\n}\n\ndeh_section_t deh_section_frame =\n{\n    \"Frame\",\n    NULL,\n    DEH_FrameStart,\n    DEH_FrameParseLine,\n    NULL,\n    DEH_FrameSHA1Sum,\n};\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Parses \"Misc\" sections in dehacked files\n//\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"doomtype.h\"\n#include \"deh_defs.h\"\n#include \"deh_io.h\"\n#include \"deh_main.h\"\n#include \"deh_misc.h\"\n\n// Dehacked: \"Initial Health\" \n// This is the initial health a player has when starting anew.\n// See G_PlayerReborn in g_game.c\n\nint deh_initial_health = DEH_DEFAULT_INITIAL_HEALTH;\n\n// Dehacked: \"Initial bullets\"\n// This is the number of bullets the player has when starting anew.\n// See G_PlayerReborn in g_game.c\n\nint deh_initial_bullets = DEH_DEFAULT_INITIAL_BULLETS;\n\n// Dehacked: \"Max Health\"\n// This is the maximum health that can be reached using medikits \n// alone.  See P_TouchSpecialThing in p_inter.c\n\nint deh_max_health = DEH_DEFAULT_MAX_HEALTH;\n\n// Dehacked: \"Max Armor\"\n// This is the maximum armor which can be reached by picking up\n// armor helmets. See P_TouchSpecialThing in p_inter.c\n\nint deh_max_armor = DEH_DEFAULT_MAX_ARMOR;\n\n// Dehacked: \"Green Armor Class\"\n// This is the armor class that is given when picking up the green \n// armor or an armor helmet. See P_TouchSpecialThing in p_inter.c\n//\n// DOS dehacked only modifies the behavior of the green armor shirt,\n// the armor class set by armor helmets is not affected.\n\nint deh_green_armor_class = DEH_DEFAULT_GREEN_ARMOR_CLASS;\n\n// Dehacked: \"Blue Armor Class\"\n// This is the armor class that is given when picking up the blue \n// armor or a megasphere. See P_TouchSpecialThing in p_inter.c\n//\n// DOS dehacked only modifies the MegaArmor behavior and not\n// the MegaSphere, which always gives armor type 2.\n\nint deh_blue_armor_class = DEH_DEFAULT_BLUE_ARMOR_CLASS;\n\n// Dehacked: \"Max soulsphere\"\n// The maximum health which can be reached by picking up the\n// soulsphere.  See P_TouchSpecialThing in p_inter.c\n\nint deh_max_soulsphere = DEH_DEFAULT_MAX_SOULSPHERE;\n\n// Dehacked: \"Soulsphere health\"\n// The amount of health bonus that picking up a soulsphere\n// gives.  See P_TouchSpecialThing in p_inter.c\n\nint deh_soulsphere_health = DEH_DEFAULT_SOULSPHERE_HEALTH;\n\n// Dehacked: \"Megasphere health\"\n// This is what the health is set to after picking up a \n// megasphere.  See P_TouchSpecialThing in p_inter.c\n\nint deh_megasphere_health = DEH_DEFAULT_MEGASPHERE_HEALTH;\n\n// Dehacked: \"God mode health\"\n// This is what the health value is set to when cheating using\n// the IDDQD god mode cheat.  See ST_Responder in st_stuff.c\n\nint deh_god_mode_health = DEH_DEFAULT_GOD_MODE_HEALTH;\n\n// Dehacked: \"IDFA Armor\"\n// This is what the armor is set to when using the IDFA cheat.\n// See ST_Responder in st_stuff.c\n\nint deh_idfa_armor = DEH_DEFAULT_IDFA_ARMOR;\n\n// Dehacked: \"IDFA Armor Class\"\n// This is what the armor class is set to when using the IDFA cheat.\n// See ST_Responder in st_stuff.c\n\nint deh_idfa_armor_class = DEH_DEFAULT_IDFA_ARMOR_CLASS;\n\n// Dehacked: \"IDKFA Armor\"\n// This is what the armor is set to when using the IDKFA cheat.\n// See ST_Responder in st_stuff.c\n\nint deh_idkfa_armor = DEH_DEFAULT_IDKFA_ARMOR;\n\n// Dehacked: \"IDKFA Armor Class\"\n// This is what the armor class is set to when using the IDKFA cheat.\n// See ST_Responder in st_stuff.c\n\nint deh_idkfa_armor_class = DEH_DEFAULT_IDKFA_ARMOR_CLASS;\n\n// Dehacked: \"BFG Cells/Shot\"\n// This is the number of CELLs firing the BFG uses up.\n// See P_CheckAmmo and A_FireBFG in p_pspr.c\n\nint deh_bfg_cells_per_shot = DEH_DEFAULT_BFG_CELLS_PER_SHOT;\n\n// Dehacked: \"Monsters infight\"\n// This controls whether monsters can harm other monsters of the same \n// species.  For example, whether an imp fireball will damage other\n// imps.  The value of this in dehacked patches is weird - '202' means\n// off, while '221' means on.\n//\n// See PIT_CheckThing in p_map.c\n\nint deh_species_infighting = DEH_DEFAULT_SPECIES_INFIGHTING;\n\nstatic struct\n{\n    const char *deh_name;\n    int *value;\n} misc_settings[] = {\n    {\"Initial Health\",      &deh_initial_health},\n    {\"Initial Bullets\",     &deh_initial_bullets},\n    {\"Max Health\",          &deh_max_health},\n    {\"Max Armor\",           &deh_max_armor},\n    {\"Green Armor Class\",   &deh_green_armor_class},\n    {\"Blue Armor Class\",    &deh_blue_armor_class},\n    {\"Max Soulsphere\",      &deh_max_soulsphere},\n    {\"Soulsphere Health\",   &deh_soulsphere_health},\n    {\"Megasphere Health\",   &deh_megasphere_health},\n    {\"God Mode Health\",     &deh_god_mode_health},\n    {\"IDFA Armor\",          &deh_idfa_armor},\n    {\"IDFA Armor Class\",    &deh_idfa_armor_class},\n    {\"IDKFA Armor\",         &deh_idkfa_armor},\n    {\"IDKFA Armor Class\",   &deh_idkfa_armor_class},\n    {\"BFG Cells/Shot\",      &deh_bfg_cells_per_shot},\n};\n\nstatic void *DEH_MiscStart(deh_context_t *context, char *line)\n{\n    return NULL;\n}\n\nstatic void DEH_MiscParseLine(deh_context_t *context, char *line, void *tag)\n{\n    char *variable_name, *value;\n    int ivalue;\n    size_t i;\n\n    if (!DEH_ParseAssignment(line, &variable_name, &value))\n    {\n        // Failed to parse\n\n        DEH_Warning(context, \"Failed to parse assignment\");\n        return;\n    }\n\n    ivalue = atoi(value);\n\n    if (!strcasecmp(variable_name, \"Monsters Infight\"))\n    {\n        // See notes above.\n \n        if (ivalue == 202)\n        {\n            deh_species_infighting = 0;\n        }\n        else if (ivalue == 221)\n        {\n            deh_species_infighting = 1;\n        }\n        else\n        {\n            DEH_Warning(context, \n                        \"Invalid value for 'Monsters Infight': %i\", ivalue);\n        }\n        \n        return;\n    }\n\n    for (i=0; i<arrlen(misc_settings); ++i)\n    {\n        if (!strcasecmp(variable_name, misc_settings[i].deh_name))\n        {\n            *misc_settings[i].value = ivalue;\n            return;\n        }\n    }\n\n    DEH_Warning(context, \"Unknown Misc variable '%s'\", variable_name);\n}\n\nstatic void DEH_MiscSHA1Sum(sha1_context_t *context)\n{\n    unsigned int i;\n\n    for (i=0; i<arrlen(misc_settings); ++i)\n    {\n        SHA1_UpdateInt32(context, *misc_settings[i].value);\n    }\n}\n\ndeh_section_t deh_section_misc =\n{\n    \"Misc\",\n    NULL,\n    DEH_MiscStart,\n    DEH_MiscParseLine,\n    NULL,\n    DEH_MiscSHA1Sum,\n};\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Parses Action Pointer entries in dehacked files\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"doomtype.h\"\n#include \"info.h\"\n\n#include \"deh_defs.h\"\n#include \"deh_io.h\"\n#include \"deh_main.h\"\n\nstatic actionf_t codeptrs[NUMSTATES];\n\nstatic int CodePointerIndex(actionf_t *ptr)\n{\n    int i;\n\n    for (i=0; i<NUMSTATES; ++i)\n    {\n        if (!memcmp(&codeptrs[i], ptr, sizeof(actionf_t)))\n        {\n            return i;\n        }\n    }\n\n    return -1;\n}\n\nstatic void DEH_PointerInit(void)\n{\n    int i;\n    \n    // Initialize list of dehacked pointers\n\n    for (i=0; i<NUMSTATES; ++i)\n        codeptrs[i] = states[i].action;\n\n    // [BH] Initialize extra dehacked states\n    for (; i < NUMSTATES; i++)\n    {\n\tstates[i].sprite = SPR_TNT1;\n\tstates[i].frame = 0;\n\tstates[i].tics = -1;\n\tstates[i].action.acv = (actionf_v) NULL;\n\tstates[i].nextstate = i;\n\tstates[i].misc1 = 0;\n\tstates[i].misc2 = 0;\n//\tstates[i].dehacked = false;\n\tcodeptrs[i] = states[i].action;\n    }\n}\n\nstatic void *DEH_PointerStart(deh_context_t *context, char *line)\n{\n    int frame_number = 0;\n    \n    // FIXME: can the third argument here be something other than \"Frame\"\n    // or are we ok?\n\n    if (sscanf(line, \"Pointer %*i (%*s %i)\", &frame_number) != 1)\n    {\n        DEH_Warning(context, \"Parse error on section start\");\n        return NULL;\n    }\n\n    if (frame_number < 0 || frame_number >= NUMSTATES)\n    {\n        DEH_Warning(context, \"Invalid frame number: %i\", frame_number);\n        return NULL;\n    }\n\n    return &states[frame_number];\n}\n\nstatic void DEH_PointerParseLine(deh_context_t *context, char *line, void *tag)\n{\n    state_t *state;\n    char *variable_name, *value;\n    int ivalue;\n    \n    if (tag == NULL)\n       return;\n\n    state = (state_t *) tag;\n\n    // Parse the assignment\n\n    if (!DEH_ParseAssignment(line, &variable_name, &value))\n    {\n        // Failed to parse\n        DEH_Warning(context, \"Failed to parse assignment\");\n        return;\n    }\n\n    // all values are integers\n\n    ivalue = atoi(value);\n    \n    // set the appropriate field\n\n    if (!strcasecmp(variable_name, \"Codep frame\"))\n    {\n        if (ivalue < 0 || ivalue >= NUMSTATES)\n        {\n            DEH_Warning(context, \"Invalid state '%i'\", ivalue);\n        }\n        else\n        {        \n            state->action = codeptrs[ivalue];\n        }\n    }\n    else\n    {\n        DEH_Warning(context, \"Unknown variable name '%s'\", variable_name);\n    }\n}\n\nstatic void DEH_PointerSHA1Sum(sha1_context_t *context)\n{\n    int i;\n\n    for (i=0; i<NUMSTATES; ++i)\n    {\n        SHA1_UpdateInt32(context, CodePointerIndex(&states[i].action));\n    }\n}\n\ndeh_section_t deh_section_pointer =\n{\n    \"Pointer\",\n    DEH_PointerInit,\n    DEH_PointerStart,\n    DEH_PointerParseLine,\n    NULL,\n    DEH_PointerSHA1Sum,\n};\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Parses \"Sound\" sections in dehacked files\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"doomtype.h\"\n#include \"deh_defs.h\"\n#include \"deh_main.h\"\n#include \"deh_mapping.h\"\n#include \"sounds.h\"\n\nDEH_BEGIN_MAPPING(sound_mapping, sfxinfo_t)\n    DEH_UNSUPPORTED_MAPPING(\"Offset\")\n    DEH_UNSUPPORTED_MAPPING(\"Zero/One\")\n    DEH_MAPPING(\"Value\", priority)\n    DEH_MAPPING(\"Zero 1\", link)\n    DEH_MAPPING(\"Zero 2\", pitch)\n    DEH_MAPPING(\"Zero 3\", volume)\n    DEH_UNSUPPORTED_MAPPING(\"Zero 4\")\n    DEH_MAPPING(\"Neg. One 1\", usefulness)\n    DEH_MAPPING(\"Neg. One 2\", lumpnum)\nDEH_END_MAPPING\n\nstatic void *DEH_SoundStart(deh_context_t *context, char *line)\n{\n    int sound_number = 0;\n    \n    if (sscanf(line, \"Sound %i\", &sound_number) != 1)\n    {\n        DEH_Warning(context, \"Parse error on section start\");\n        return NULL;\n    }\n\n    if (sound_number < 0 || sound_number >= NUMSFX)\n    {\n        DEH_Warning(context, \"Invalid sound number: %i\", sound_number);\n        return NULL;\n    }\n\n    if (sound_number >= DEH_VANILLA_NUMSFX)\n    {\n        DEH_Warning(context, \"Attempt to modify SFX %i.  This will cause \"\n                             \"problems in Vanilla dehacked.\", sound_number); \n    }\n\n    return &S_sfx[sound_number];\n}\n\nstatic void DEH_SoundParseLine(deh_context_t *context, char *line, void *tag)\n{\n    sfxinfo_t *sfx;\n    char *variable_name, *value;\n    int ivalue;\n    \n    if (tag == NULL)\n       return;\n\n    sfx = (sfxinfo_t *) tag;\n\n    // Parse the assignment\n\n    if (!DEH_ParseAssignment(line, &variable_name, &value))\n    {\n        // Failed to parse\n        DEH_Warning(context, \"Failed to parse assignment\");\n        return;\n    }\n    \n    // all values are integers\n\n    ivalue = atoi(value);\n    \n    // Set the field value\n\n    DEH_SetMapping(context, &sound_mapping, sfx, variable_name, ivalue);\n}\n\ndeh_section_t deh_section_sound =\n{\n    \"Sound\",\n    NULL,\n    DEH_SoundStart,\n    DEH_SoundParseLine,\n    NULL,\n    NULL,\n};\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Parses \"Thing\" sections in dehacked files\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"doomtype.h\"\n\n#include \"deh_defs.h\"\n#include \"deh_main.h\"\n#include \"deh_mapping.h\"\n\n#include \"info.h\"\n\nDEH_BEGIN_MAPPING(thing_mapping, mobjinfo_t)\n  DEH_MAPPING(\"ID #\",                doomednum)\n  DEH_MAPPING(\"Initial frame\",       spawnstate)\n  DEH_MAPPING(\"Hit points\",          spawnhealth)\n  DEH_MAPPING(\"First moving frame\",  seestate)\n  DEH_MAPPING(\"Alert sound\",         seesound)\n  DEH_MAPPING(\"Reaction time\",       reactiontime)\n  DEH_MAPPING(\"Attack sound\",        attacksound)\n  DEH_MAPPING(\"Injury frame\",        painstate)\n  DEH_MAPPING(\"Pain chance\",         painchance)\n  DEH_MAPPING(\"Pain sound\",          painsound)\n  DEH_MAPPING(\"Close attack frame\",  meleestate)\n  DEH_MAPPING(\"Far attack frame\",    missilestate)\n  DEH_MAPPING(\"Death frame\",         deathstate)\n  DEH_MAPPING(\"Exploding frame\",     xdeathstate)\n  DEH_MAPPING(\"Death sound\",         deathsound)\n  DEH_MAPPING(\"Speed\",               speed)\n  DEH_MAPPING(\"Width\",               radius)\n  DEH_MAPPING(\"Height\",              height)\n  DEH_MAPPING(\"Mass\",                mass)\n  DEH_MAPPING(\"Missile damage\",      damage)\n  DEH_MAPPING(\"Action sound\",        activesound)\n  DEH_MAPPING(\"Bits\",                flags)\n  DEH_MAPPING(\"Respawn frame\",       raisestate)\nDEH_END_MAPPING\n\nstatic void *DEH_ThingStart(deh_context_t *context, char *line)\n{\n    int thing_number = 0;\n    mobjinfo_t *mobj;\n    \n    if (sscanf(line, \"Thing %i\", &thing_number) != 1)\n    {\n        DEH_Warning(context, \"Parse error on section start\");\n        return NULL;\n    }\n\n    // dehacked files are indexed from 1\n    --thing_number;\n\n    if (thing_number < 0 || thing_number >= NUMMOBJTYPES)\n    {\n        DEH_Warning(context, \"Invalid thing number: %i\", thing_number);\n        return NULL;\n    }\n    \n    mobj = &mobjinfo[thing_number];\n    \n    return mobj;\n}\n\nstatic void DEH_ThingParseLine(deh_context_t *context, char *line, void *tag)\n{\n    mobjinfo_t *mobj;\n    char *variable_name, *value;\n    int ivalue;\n    \n    if (tag == NULL)\n       return;\n\n    mobj = (mobjinfo_t *) tag;\n\n    // Parse the assignment\n\n    if (!DEH_ParseAssignment(line, &variable_name, &value))\n    {\n        // Failed to parse\n\n        DEH_Warning(context, \"Failed to parse assignment\");\n        return;\n    }\n    \n//    printf(\"Set %s to %s for mobj\\n\", variable_name, value);\n\n    // all values are integers\n\n    ivalue = atoi(value);\n    \n    // Set the field value\n\n    DEH_SetMapping(context, &thing_mapping, mobj, variable_name, ivalue);\n}\n\nstatic void DEH_ThingSHA1Sum(sha1_context_t *context)\n{\n    int i;\n\n    for (i=0; i<NUMMOBJTYPES; ++i)\n    {\n        DEH_StructSHA1Sum(context, &thing_mapping, &mobjinfo[i]);\n    }\n}\n\ndeh_section_t deh_section_thing =\n{\n    \"Thing\",\n    NULL,\n    DEH_ThingStart,\n    DEH_ThingParseLine,\n    NULL,\n    DEH_ThingSHA1Sum,\n};\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Parses \"Weapon\" sections in dehacked files\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"doomtype.h\"\n\n#include \"d_items.h\"\n\n#include \"deh_defs.h\"\n#include \"deh_main.h\"\n#include \"deh_mapping.h\"\n\nDEH_BEGIN_MAPPING(weapon_mapping, weaponinfo_t)\n  DEH_MAPPING(\"Ammo type\",        ammo)\n  DEH_MAPPING(\"Deselect frame\",   upstate)\n  DEH_MAPPING(\"Select frame\",     downstate)\n  DEH_MAPPING(\"Bobbing frame\",    readystate)\n  DEH_MAPPING(\"Shooting frame\",   atkstate)\n  DEH_MAPPING(\"Firing frame\",     flashstate)\nDEH_END_MAPPING\n\nstatic void *DEH_WeaponStart(deh_context_t *context, char *line)\n{\n    int weapon_number = 0;\n\n    if (sscanf(line, \"Weapon %i\", &weapon_number) != 1)\n    {\n        DEH_Warning(context, \"Parse error on section start\");\n        return NULL;\n    }\n\n    if (weapon_number < 0 || weapon_number >= NUMWEAPONS)\n    {\n        DEH_Warning(context, \"Invalid weapon number: %i\", weapon_number);\n        return NULL;\n    }\n    \n    return &weaponinfo[weapon_number];\n}\n\nstatic void DEH_WeaponParseLine(deh_context_t *context, char *line, void *tag)\n{\n    char *variable_name, *value;\n    weaponinfo_t *weapon;\n    int ivalue;\n    \n    if (tag == NULL)\n        return;\n\n    weapon = (weaponinfo_t *) tag;\n\n    if (!DEH_ParseAssignment(line, &variable_name, &value))\n    {\n        // Failed to parse\n\n        DEH_Warning(context, \"Failed to parse assignment\");\n        return;\n    }\n\n    ivalue = atoi(value);\n\n    DEH_SetMapping(context, &weapon_mapping, weapon, variable_name, ivalue);\n}\n\nstatic void DEH_WeaponSHA1Sum(sha1_context_t *context)\n{\n    int i;\n\n    for (i=0; i<NUMWEAPONS ;++i)\n    {\n        DEH_StructSHA1Sum(context, &weapon_mapping, &weaponinfo[i]);\n    }\n}\n\ndeh_section_t deh_section_weapon =\n{\n    \"Weapon\",\n    NULL,\n    DEH_WeaponStart,\n    DEH_WeaponParseLine,\n    NULL,\n    DEH_WeaponSHA1Sum,\n};\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tGame completion, final screen animation.\n//\n\n\n#include <stdio.h>\n#include <ctype.h>\n\n// Functions.\n#include \"deh_main.h\"\n#include \"i_system.h\"\n#include \"i_swap.h\"\n#include \"z_zone.h\"\n#include \"i_video.h\"\n#include \"v_video.h\"\n#include \"w_wad.h\"\n#include \"s_sound.h\"\n\n// Data.\n#include \"d_main.h\"\n#include \"dstrings.h\"\n#include \"sounds.h\"\n\n#include \"doomstat.h\"\n#include \"r_state.h\"\n\n#include \"f_finale.h\"\n\ntypedef enum\n{\n    F_STAGE_TEXT,\n    F_STAGE_ARTSCREEN,\n    F_STAGE_CAST,\n} finalestage_t;\n\n// ?\n//#include \"doomstat.h\"\n//#include \"r_local.h\"\n//#include \"f_finale.h\"\n\n// Stage of animation:\nfinalestage_t finalestage;\n\nunsigned int finalecount;\n\n#define\tTEXTSPEED\t3\n#define\tTEXTWAIT\t250\n\ntypedef struct\n{\n    GameMission_t mission;\n    int episode, level;\n    char *background;\n    char *text;\n} textscreen_t;\n\nstatic textscreen_t textscreens[] =\n{\n    { doom,      1, 8,  \"FLOOR4_8\",  E1TEXT},\n    { doom,      2, 8,  \"SFLR6_1\",   E2TEXT},\n    { doom,      3, 8,  \"MFLR8_4\",   E3TEXT},\n    { doom,      4, 8,  \"MFLR8_3\",   E4TEXT},\n\n    { doom2,     1, 6,  \"SLIME16\",   C1TEXT},\n    { doom2,     1, 11, \"RROCK14\",   C2TEXT},\n    { doom2,     1, 20, \"RROCK07\",   C3TEXT},\n    { doom2,     1, 30, \"RROCK17\",   C4TEXT},\n    { doom2,     1, 15, \"RROCK13\",   C5TEXT},\n    { doom2,     1, 31, \"RROCK19\",   C6TEXT},\n\n    { pack_tnt,  1, 6,  \"SLIME16\",   T1TEXT},\n    { pack_tnt,  1, 11, \"RROCK14\",   T2TEXT},\n    { pack_tnt,  1, 20, \"RROCK07\",   T3TEXT},\n    { pack_tnt,  1, 30, \"RROCK17\",   T4TEXT},\n    { pack_tnt,  1, 15, \"RROCK13\",   T5TEXT},\n    { pack_tnt,  1, 31, \"RROCK19\",   T6TEXT},\n\n    { pack_plut, 1, 6,  \"SLIME16\",   P1TEXT},\n    { pack_plut, 1, 11, \"RROCK14\",   P2TEXT},\n    { pack_plut, 1, 20, \"RROCK07\",   P3TEXT},\n    { pack_plut, 1, 30, \"RROCK17\",   P4TEXT},\n    { pack_plut, 1, 15, \"RROCK13\",   P5TEXT},\n    { pack_plut, 1, 31, \"RROCK19\",   P6TEXT},\n\n    { pack_nerve, 1, 8, \"SLIME16\",   N1TEXT},\n    { pack_master, 1, 20, \"SLIME16\",   M1TEXT},\n};\n\nconst char *finaletext;\nconst char *finaleflat;\n\nvoid\tF_StartCast (void);\nvoid\tF_CastTicker (void);\nboolean F_CastResponder (event_t *ev);\nvoid\tF_CastDrawer (void);\n\n//\n// F_StartFinale\n//\nvoid F_StartFinale (void)\n{\n    size_t i;\n\n    gameaction = ga_nothing;\n    gamestate = GS_FINALE;\n    viewactive = false;\n    automapactive = false;\n\n    if (logical_gamemission == doom)\n    {\n        S_ChangeMusic(mus_victor, true);\n    }\n    else\n    {\n        S_ChangeMusic(mus_read_m, true);\n    }\n\n    // Find the right screen and set the text and background\n\n    for (i=0; i<arrlen(textscreens); ++i)\n    {\n        textscreen_t *screen = &textscreens[i];\n\n        // Hack for Chex Quest\n\n        if (gameversion == exe_chex && screen->mission == doom)\n        {\n            screen->level = 5;\n        }\n\n        // [crispy] Hack for Master Levels MAP21: Bad Dream\n        if (gamemission == pack_master && screen->mission == pack_master && gamemap == 21)\n        {\n            screen->level = 21;\n        }\n\n        // [crispy] During demo recording/playback or network games\n        // these two packs behave like any other ordinary PWAD\n        if (//!crispy->singleplayer &&\n            (gamemission == pack_nerve || gamemission == pack_master)\n            && screen->mission == doom2)\n        {\n            screen->mission = gamemission;\n        }\n\n        if (logical_gamemission == screen->mission\n         && (logical_gamemission != doom || gameepisode == screen->episode)\n         && gamemap == screen->level)\n        {\n            finaletext = screen->text;\n            finaleflat = screen->background;\n        }\n    }\n\n    // Do dehacked substitutions of strings\n  \n    finaletext = DEH_String(finaletext);\n    finaleflat = DEH_String(finaleflat);\n    \n    finalestage = F_STAGE_TEXT;\n    finalecount = 0;\n\t\n}\n\n\n\nboolean F_Responder (event_t *event)\n{\n    if (finalestage == F_STAGE_CAST)\n\treturn F_CastResponder (event);\n\t\n    return false;\n}\n\n\n//\n// F_Ticker\n//\nvoid F_Ticker (void)\n{\n    size_t\t\ti;\n    \n    // check for skipping\n    if ( (gamemode == commercial)\n      && ( finalecount > 50) )\n    {\n      // go on to the next level\n      for (i=0 ; i<MAXPLAYERS ; i++)\n\tif (players[i].cmd.buttons)\n\t  break;\n\t\t\t\t\n      if (i < MAXPLAYERS)\n      {\t\n    if (gamemission == pack_nerve && gamemap == 8)\n\t  F_StartCast ();\n\telse\n\tif (gamemission == pack_master && (gamemap == 20 || gamemap == 21))\n\t  F_StartCast ();\n\telse\n\tif (gamemap == 30)\n\t  F_StartCast ();\n\telse\n\t  gameaction = ga_worlddone;\n      }\n    }\n    \n    // advance animation\n    finalecount++;\n\t\n    if (finalestage == F_STAGE_CAST)\n    {\n\tF_CastTicker ();\n\treturn;\n    }\n\t\n    if ( gamemode == commercial)\n\treturn;\n\t\t\n    if (finalestage == F_STAGE_TEXT\n     && finalecount>strlen (finaletext)*TEXTSPEED + TEXTWAIT)\n    {\n\tfinalecount = 0;\n\tfinalestage = F_STAGE_ARTSCREEN;\n\twipegamestate = -1;\t\t// force a wipe\n\tif (gameepisode == 3)\n\t    S_StartMusic (mus_bunny);\n    }\n}\n\n\n\n//\n// F_TextWrite\n//\n\n#include \"hu_stuff.h\"\nextern\tpatch_t *hu_font[HU_FONTSIZE];\n\n\nvoid F_TextWrite (void)\n{\n    byte*\tsrc;\n    pixel_t*\tdest;\n    \n    int\t\tx,y,w;\n    signed int\tcount;\n    const char *ch;\n    int\t\tc;\n    int\t\tcx;\n    int\t\tcy;\n    \n    // erase the entire screen to a tiled background\n    src = W_CacheLumpName ( finaleflat , PU_CACHE);\n    dest = I_VideoBuffer;\n\t\n    for (y=0 ; y<SCREENHEIGHT ; y++)\n    {\n\tfor (x=0 ; x<SCREENWIDTH/64 ; x++)\n\t{\n\t    memcpy (dest, src+((y&63)<<6), 64);\n\t    dest += 64;\n\t}\n\tif (SCREENWIDTH&63)\n\t{\n\t    memcpy (dest, src+((y&63)<<6), SCREENWIDTH&63);\n\t    dest += (SCREENWIDTH&63);\n\t}\n    }\n\n    V_MarkRect (0, 0, SCREENWIDTH, SCREENHEIGHT);\n    \n    // draw some of the text onto the screen\n    cx = 10;\n    cy = 10;\n    ch = finaletext;\n\t\n    count = ((signed int) finalecount - 10) / TEXTSPEED;\n    if (count < 0)\n\tcount = 0;\n    for ( ; count ; count-- )\n    {\n\tc = *ch++;\n\tif (!c)\n\t    break;\n\tif (c == '\\n')\n\t{\n\t    cx = 10;\n\t    cy += 11;\n\t    continue;\n\t}\n\t\t\n\tc = toupper(c) - HU_FONTSTART;\n\tif (c < 0 || c> HU_FONTSIZE)\n\t{\n\t    cx += 4;\n\t    continue;\n\t}\n\t\t\n\tw = SHORT (hu_font[c]->width);\n\tif (cx+w > SCREENWIDTH)\n\t    break;\n\tV_DrawPatch(cx, cy, hu_font[c]);\n\tcx+=w;\n    }\n\t\n}\n\n//\n// Final DOOM 2 animation\n// Casting by id Software.\n//   in order of appearance\n//\ncastinfo_t\tcastorder[] = {\n    {CC_ZOMBIE, MT_POSSESSED},\n    {CC_SHOTGUN, MT_SHOTGUY},\n    {CC_HEAVY, MT_CHAINGUY},\n    {CC_IMP, MT_TROOP},\n    {CC_DEMON, MT_SERGEANT},\n    {CC_LOST, MT_SKULL},\n    {CC_CACO, MT_HEAD},\n    {CC_HELL, MT_KNIGHT},\n    {CC_BARON, MT_BRUISER},\n    {CC_ARACH, MT_BABY},\n    {CC_PAIN, MT_PAIN},\n    {CC_REVEN, MT_UNDEAD},\n    {CC_MANCU, MT_FATSO},\n    {CC_ARCH, MT_VILE},\n    {CC_SPIDER, MT_SPIDER},\n    {CC_CYBER, MT_CYBORG},\n    {CC_HERO, MT_PLAYER},\n\n    {NULL,0}\n};\n\nint\t\tcastnum;\nint\t\tcasttics;\nstate_t*\tcaststate;\nboolean\t\tcastdeath;\nint\t\tcastframes;\nint\t\tcastonmelee;\nboolean\t\tcastattacking;\n\n\n//\n// F_StartCast\n//\nvoid F_StartCast (void)\n{\n    wipegamestate = -1;\t\t// force a screen wipe\n    castnum = 0;\n    caststate = &states[mobjinfo[castorder[castnum].type].seestate];\n    casttics = caststate->tics;\n    castdeath = false;\n    finalestage = F_STAGE_CAST;\n    castframes = 0;\n    castonmelee = 0;\n    castattacking = false;\n    S_ChangeMusic(mus_evil, true);\n}\n\n\n//\n// F_CastTicker\n//\nvoid F_CastTicker (void)\n{\n    int\t\tst;\n    int\t\tsfx;\n\t\n    if (--casttics > 0)\n\treturn;\t\t\t// not time to change state yet\n\t\t\n    if (caststate->tics == -1 || caststate->nextstate == S_NULL)\n    {\n\t// switch from deathstate to next monster\n\tcastnum++;\n\tcastdeath = false;\n\tif (castorder[castnum].name == NULL)\n\t    castnum = 0;\n\tif (mobjinfo[castorder[castnum].type].seesound)\n\t    S_StartSound (NULL, mobjinfo[castorder[castnum].type].seesound);\n\tcaststate = &states[mobjinfo[castorder[castnum].type].seestate];\n\tcastframes = 0;\n    }\n    else\n    {\n\t// just advance to next state in animation\n\tif (caststate == &states[S_PLAY_ATK1])\n\t    goto stopattack;\t// Oh, gross hack!\n\tst = caststate->nextstate;\n\tcaststate = &states[st];\n\tcastframes++;\n\t\n\t// sound hacks....\n\tswitch (st)\n\t{\n\t  case S_PLAY_ATK1:\tsfx = sfx_dshtgn; break;\n\t  case S_POSS_ATK2:\tsfx = sfx_pistol; break;\n\t  case S_SPOS_ATK2:\tsfx = sfx_shotgn; break;\n\t  case S_VILE_ATK2:\tsfx = sfx_vilatk; break;\n\t  case S_SKEL_FIST2:\tsfx = sfx_skeswg; break;\n\t  case S_SKEL_FIST4:\tsfx = sfx_skepch; break;\n\t  case S_SKEL_MISS2:\tsfx = sfx_skeatk; break;\n\t  case S_FATT_ATK8:\n\t  case S_FATT_ATK5:\n\t  case S_FATT_ATK2:\tsfx = sfx_firsht; break;\n\t  case S_CPOS_ATK2:\n\t  case S_CPOS_ATK3:\n\t  case S_CPOS_ATK4:\tsfx = sfx_shotgn; break;\n\t  case S_TROO_ATK3:\tsfx = sfx_claw; break;\n\t  case S_SARG_ATK2:\tsfx = sfx_sgtatk; break;\n\t  case S_BOSS_ATK2:\n\t  case S_BOS2_ATK2:\n\t  case S_HEAD_ATK2:\tsfx = sfx_firsht; break;\n\t  case S_SKULL_ATK2:\tsfx = sfx_sklatk; break;\n\t  case S_SPID_ATK2:\n\t  case S_SPID_ATK3:\tsfx = sfx_shotgn; break;\n\t  case S_BSPI_ATK2:\tsfx = sfx_plasma; break;\n\t  case S_CYBER_ATK2:\n\t  case S_CYBER_ATK4:\n\t  case S_CYBER_ATK6:\tsfx = sfx_rlaunc; break;\n\t  case S_PAIN_ATK3:\tsfx = sfx_sklatk; break;\n\t  default: sfx = 0; break;\n\t}\n\t\t\n\tif (sfx)\n\t    S_StartSound (NULL, sfx);\n    }\n\t\n    if (castframes == 12)\n    {\n\t// go into attack frame\n\tcastattacking = true;\n\tif (castonmelee)\n\t    caststate=&states[mobjinfo[castorder[castnum].type].meleestate];\n\telse\n\t    caststate=&states[mobjinfo[castorder[castnum].type].missilestate];\n\tcastonmelee ^= 1;\n\tif (caststate == &states[S_NULL])\n\t{\n\t    if (castonmelee)\n\t\tcaststate=\n\t\t    &states[mobjinfo[castorder[castnum].type].meleestate];\n\t    else\n\t\tcaststate=\n\t\t    &states[mobjinfo[castorder[castnum].type].missilestate];\n\t}\n    }\n\t\n    if (castattacking)\n    {\n\tif (castframes == 24\n\t    ||\tcaststate == &states[mobjinfo[castorder[castnum].type].seestate] )\n\t{\n\t  stopattack:\n\t    castattacking = false;\n\t    castframes = 0;\n\t    caststate = &states[mobjinfo[castorder[castnum].type].seestate];\n\t}\n    }\n\t\n    casttics = caststate->tics;\n    if (casttics == -1)\n\tcasttics = 15;\n}\n\n\n//\n// F_CastResponder\n//\n\nboolean F_CastResponder (event_t* ev)\n{\n    if (ev->type != ev_keydown)\n\treturn false;\n\t\t\n    if (castdeath)\n\treturn true;\t\t\t// already in dying frames\n\t\t\n    // go into death frame\n    castdeath = true;\n    caststate = &states[mobjinfo[castorder[castnum].type].deathstate];\n    casttics = caststate->tics;\n    castframes = 0;\n    castattacking = false;\n    if (mobjinfo[castorder[castnum].type].deathsound)\n\tS_StartSound (NULL, mobjinfo[castorder[castnum].type].deathsound);\n\t\n    return true;\n}\n\n\nvoid F_CastPrint (const char *text)\n{\n    const char *ch;\n    int\t\tc;\n    int\t\tcx;\n    int\t\tw;\n    int\t\twidth;\n    \n    // find width\n    ch = text;\n    width = 0;\n\t\n    while (ch)\n    {\n\tc = *ch++;\n\tif (!c)\n\t    break;\n\tc = toupper(c) - HU_FONTSTART;\n\tif (c < 0 || c> HU_FONTSIZE)\n\t{\n\t    width += 4;\n\t    continue;\n\t}\n\t\t\n\tw = SHORT (hu_font[c]->width);\n\twidth += w;\n    }\n    \n    // draw it\n    cx = SCREENWIDTH/2-width/2;\n    ch = text;\n    while (ch)\n    {\n\tc = *ch++;\n\tif (!c)\n\t    break;\n\tc = toupper(c) - HU_FONTSTART;\n\tif (c < 0 || c> HU_FONTSIZE)\n\t{\n\t    cx += 4;\n\t    continue;\n\t}\n\t\t\n\tw = SHORT (hu_font[c]->width);\n\tV_DrawPatch(cx, 180, hu_font[c]);\n\tcx+=w;\n    }\n\t\n}\n\n\n//\n// F_CastDrawer\n//\n\nvoid F_CastDrawer (void)\n{\n    spritedef_t*\tsprdef;\n    spriteframe_t*\tsprframe;\n    int\t\t\tlump;\n    boolean\t\tflip;\n    patch_t*\t\tpatch;\n    \n    // erase the entire screen to a background\n    V_DrawPatch (0, 0, W_CacheLumpName (DEH_String(\"BOSSBACK\"), PU_CACHE));\n\n    F_CastPrint (DEH_String(castorder[castnum].name));\n    \n    // draw the current frame in the middle of the screen\n    sprdef = &sprites[caststate->sprite];\n    // [crispy] the TNT1 sprite is not supposed to be rendered anyway\n    if (!sprdef->numframes && caststate->sprite == SPR_TNT1)\n    {\n\treturn;\n    }\n    sprframe = &sprdef->spriteframes[ caststate->frame & FF_FRAMEMASK];\n    lump = sprframe->lump[0];\n    flip = (boolean)sprframe->flip[0];\n\t\t\t\n    patch = W_CacheLumpNum (lump+firstspritelump, PU_CACHE);\n    if (flip)\n\tV_DrawPatchFlipped(SCREENWIDTH/2, 170, patch);\n    else\n\tV_DrawPatch(SCREENWIDTH/2, 170, patch);\n}\n\n\n//\n// F_DrawPatchCol\n//\nvoid\nF_DrawPatchCol\n( int\t\tx,\n  patch_t*\tpatch,\n  int\t\tcol )\n{\n    column_t*\tcolumn;\n    byte*\tsource;\n    pixel_t*\tdest;\n    pixel_t*\tdesttop;\n    int\t\tcount;\n\t\n    column = (column_t *)((byte *)patch + LONG(patch->columnofs[col]));\n    desttop = I_VideoBuffer + x;\n\n    // step through the posts in a column\n    while (column->topdelta != 0xff )\n    {\n\tsource = (byte *)column + 3;\n\tdest = desttop + column->topdelta*SCREENWIDTH;\n\tcount = column->length;\n\t\t\n\twhile (count--)\n\t{\n\t    *dest = *source++;\n\t    dest += SCREENWIDTH;\n\t}\n\tcolumn = (column_t *)(  (byte *)column + column->length + 4 );\n    }\n}\n\n\n//\n// F_BunnyScroll\n//\nvoid F_BunnyScroll (void)\n{\n    signed int  scrolled;\n    int\t\tx;\n    patch_t*\tp1;\n    patch_t*\tp2;\n    char\tname[10];\n    int\t\tstage;\n    static int\tlaststage;\n\t\t\n    p1 = W_CacheLumpName (DEH_String(\"PFUB2\"), PU_LEVEL);\n    p2 = W_CacheLumpName (DEH_String(\"PFUB1\"), PU_LEVEL);\n\n    V_MarkRect (0, 0, SCREENWIDTH, SCREENHEIGHT);\n\t\n    scrolled = (SCREENWIDTH - ((signed int) finalecount-230)/2);\n    if (scrolled > SCREENWIDTH)\n\tscrolled = SCREENWIDTH;\n    if (scrolled < 0)\n\tscrolled = 0;\n\t\t\n    for ( x=0 ; x<SCREENWIDTH ; x++)\n    {\n\tif (x+scrolled < SCREENWIDTH)\n\t    F_DrawPatchCol (x, p1, x+scrolled);\n\telse\n\t    F_DrawPatchCol (x, p2, x+scrolled - SCREENWIDTH);\t\t\n    }\n\t\n    if (finalecount < 1130)\n\treturn;\n    if (finalecount < 1180)\n    {\n        V_DrawPatch((SCREENWIDTH - 13 * 8) / 2,\n                    (SCREENHEIGHT - 8 * 8) / 2, \n                    W_CacheLumpName(DEH_String(\"END0\"), PU_CACHE));\n\tlaststage = 0;\n\treturn;\n    }\n\t\n    stage = (finalecount-1180) / 5;\n    if (stage > 6)\n\tstage = 6;\n    if (stage > laststage)\n    {\n\tS_StartSound (NULL, sfx_pistol);\n\tlaststage = stage;\n    }\n\t\n    DEH_snprintf(name, 10, \"END%i\", stage);\n    V_DrawPatch((SCREENWIDTH - 13 * 8) / 2, \n                (SCREENHEIGHT - 8 * 8) / 2, \n                W_CacheLumpName (name,PU_CACHE));\n}\n\nstatic void F_ArtScreenDrawer(void)\n{\n    const char *lumpname;\n    \n    if (gameepisode == 3)\n    {\n        F_BunnyScroll();\n    }\n    else\n    {\n        switch (gameepisode)\n        {\n            case 1:\n                if (gameversion >= exe_ultimate)\n                {\n                    lumpname = \"CREDIT\";\n                }\n                else\n                {\n                    lumpname = \"HELP2\";\n                }\n                break;\n            case 2:\n                lumpname = \"VICTORY2\";\n                break;\n            case 4:\n                lumpname = \"ENDPIC\";\n                break;\n            default:\n                return;\n        }\n\n        lumpname = DEH_String(lumpname);\n\n        V_DrawPatch (0, 0, W_CacheLumpName(lumpname, PU_CACHE));\n    }\n}\n\n//\n// F_Drawer\n//\nvoid F_Drawer (void)\n{\n    switch (finalestage)\n    {\n        case F_STAGE_CAST:\n            F_CastDrawer();\n            break;\n        case F_STAGE_TEXT:\n            F_TextWrite();\n            break;\n        case F_STAGE_ARTSCREEN:\n            F_ArtScreenDrawer();\n            break;\n    }\n}\n\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//     OPL interface.\n//\n\n#include \"config.h\"\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"SDL.h\"\n\n#include \"opl.h\"\n#include \"opl_internal.h\"\n\nextern opl_driver_t opl_sdl_driver;\nstatic opl_driver_t *drivers[] =\n{\n    &opl_sdl_driver,\n    NULL\n};\n\nstatic opl_driver_t *driver = NULL;\nstatic int init_stage_reg_writes = 1;\n\nunsigned int opl_sample_rate = 22050;\n\n//\n// Init/shutdown code.\n//\n\n// Initialize the specified driver and detect an OPL chip.  Returns\n// true if an OPL is detected.\n\nstatic opl_init_result_t InitDriver(opl_driver_t *_driver,\n                                    unsigned int port_base)\n{\n    // Initialize the driver.\n\n    if (!_driver->init_func(port_base))\n    {\n        return OPL_INIT_NONE;\n    }\n\n    // The driver was initialized okay, so we now have somewhere\n    // to write to.  It doesn't mean there's an OPL chip there,\n    // though.  Perform the detection sequence to make sure.\n    // (it's done twice, like how Doom does it).\n\n    driver = _driver;\n    init_stage_reg_writes = 1;\n\n    OPL_Detect(0);\n    OPL_Detect(1 * OPL_MS + 1);\n\n    init_stage_reg_writes = 0;\n\n    printf(\"OPL_Init: Using driver '%s'.\\n\", driver->name);\n\n    return OPL_INIT_OPL3;\n}\n\n// Find a driver automatically by trying each in the list.\n\nstatic opl_init_result_t AutoSelectDriver(unsigned int port_base)\n{\n    int i;\n    opl_init_result_t result;\n\n    for (i=0; drivers[i] != NULL; ++i)\n    {\n        result = InitDriver(drivers[i], port_base);\n        if (result != OPL_INIT_NONE)\n        {\n            return result;\n        }\n    }\n\n    printf(\"OPL_Init: Failed to find a working driver.\\n\");\n\n    return OPL_INIT_NONE;\n}\n\n// Initialize the OPL library. Return value indicates type of OPL chip\n// detected, if any.\n\nopl_init_result_t OPL_Init(unsigned int port_base)\n{\n    char *driver_name;\n    int i;\n    int result;\n\n    driver_name = getenv(\"OPL_DRIVER\");\n\n    if (driver_name != NULL)\n    {\n        // Search the list until we find the driver with this name.\n\n        for (i=0; drivers[i] != NULL; ++i)\n        {\n            if (!strcmp(driver_name, drivers[i]->name))\n            {\n                result = InitDriver(drivers[i], port_base);\n                if (result)\n                {\n                    return result;\n                }\n                else\n                {\n                    printf(\"OPL_Init: Failed to initialize \"\n                           \"driver: '%s'.\\n\", driver_name);\n                    return OPL_INIT_NONE;\n                }\n            }\n        }\n\n        printf(\"OPL_Init: unknown driver: '%s'.\\n\", driver_name);\n\n        return OPL_INIT_NONE;\n    }\n    else\n    {\n        return AutoSelectDriver(port_base);\n    }\n}\n\n// Shut down the OPL library.\n\nvoid OPL_Shutdown(void)\n{\n    if (driver != NULL)\n    {\n        driver->shutdown_func();\n        driver = NULL;\n    }\n}\n\n// Set the sample rate used for software OPL emulation.\n\nvoid OPL_SetSampleRate(unsigned int rate)\n{\n    opl_sample_rate = rate;\n}\n\nvoid OPL_WritePort(opl_port_t port, unsigned int value)\n{\n    if (driver != NULL)\n    {\n        driver->write_port_func(port, value);\n    }\n}\n\nunsigned int OPL_ReadPort(opl_port_t port)\n{\n    if (driver != NULL)\n    {\n        unsigned int result;\n        result = driver->read_port_func(port);\n        return result;\n    }\n    else\n    {\n        return 0;\n    }\n}\n\n//\n// Higher-level functions, based on the lower-level functions above\n// (register write, etc).\n//\n\nunsigned int OPL_ReadStatus(void)\n{\n    return OPL_ReadPort(OPL_REGISTER_PORT);\n}\n\n// Write an OPL register value\n\nvoid OPL_WriteRegister(int reg, int value)\n{\n    int i;\n\n    if (reg & 0x100)\n    {\n        OPL_WritePort(OPL_REGISTER_PORT_OPL3, reg);\n    }\n    else\n    {\n        OPL_WritePort(OPL_REGISTER_PORT, reg);\n    }\n\n    // For timing, read the register port six times after writing the\n    // register number to cause the appropriate delay\n\n    for (i=0; i<6; ++i)\n    {\n        // An oddity of the Doom OPL code: at startup initialization,\n        // the spacing here is performed by reading from the register\n        // port; after initialization, the data port is read, instead.\n\n        if (init_stage_reg_writes)\n        {\n            OPL_ReadPort(OPL_REGISTER_PORT);\n        }\n        else\n        {\n            OPL_ReadPort(OPL_DATA_PORT);\n        }\n    }\n\n    OPL_WritePort(OPL_DATA_PORT, value);\n\n    // Read the register port 24 times after writing the value to\n    // cause the appropriate delay\n\n    for (i=0; i<24; ++i)\n    {\n        OPL_ReadStatus();\n    }\n}\n\nstatic void OPL_DetectCallback2(void *_data)\n{\n    int result1, result2;\n\n    result1 = 0;\n\n    // Read status\n    result2 = OPL_ReadStatus();\n\n    // Reset both timers:\n    OPL_WriteRegister(OPL_REG_TIMER_CTRL, 0x60);\n\n    // Enable interrupts:\n    OPL_WriteRegister(OPL_REG_TIMER_CTRL, 0x80);\n\n    if ((result1 & 0xe0) == 0x00 && (result2 & 0xe0) == 0xc0)\n    {\n        result1 = OPL_ReadPort(OPL_REGISTER_PORT);\n        result2 = OPL_ReadPort(OPL_REGISTER_PORT_OPL3);\n    }\n}\n\nstatic void OPL_DetectCallback1(void *_data)\n{\n    int result1;\n    int i;\n\n    OPL_WriteRegister(OPL_REG_TIMER_CTRL, 0x60);\n\n    // Enable interrupts:\n    OPL_WriteRegister(OPL_REG_TIMER_CTRL, 0x80);\n\n    // Read status\n    result1 = OPL_ReadStatus();\n\n    // Set timer:\n    OPL_WriteRegister(OPL_REG_TIMER1, 0xff);\n\n    // Start timer 1:\n    OPL_WriteRegister(OPL_REG_TIMER_CTRL, 0x21);\n\n    // Wait for 80 microseconds\n    // This is how Doom does it:\n\n    for (i=0; i<200; ++i)\n    {\n        OPL_ReadStatus();\n    }\n\n    OPL_SetCallback(1 * OPL_MS, OPL_DetectCallback2, &result1);\n}\n\nvoid OPL_Detect(uint64_t us)\n{\n    OPL_SetCallback(us, OPL_DetectCallback1, NULL);\n}\n\n// Initialize registers on startup\n\nvoid OPL_InitRegisters(int opl3)\n{\n    int r;\n\n    // Initialize level registers\n\n    for (r=OPL_REGS_LEVEL; r <= OPL_REGS_LEVEL + OPL_NUM_OPERATORS; ++r)\n    {\n        OPL_WriteRegister(r, 0x3f);\n    }\n\n    // Initialize other registers\n    // These two loops write to registers that actually don't exist,\n    // but this is what Doom does ...\n    // Similarly, the <= is also intenational.\n\n    for (r=OPL_REGS_ATTACK; r <= OPL_REGS_WAVEFORM + OPL_NUM_OPERATORS; ++r)\n    {\n        OPL_WriteRegister(r, 0x00);\n    }\n\n    // More registers ...\n\n    for (r=1; r < OPL_REGS_LEVEL; ++r)\n    {\n        OPL_WriteRegister(r, 0x00);\n    }\n\n    // Re-initialize the low registers:\n\n    // Reset both timers and enable interrupts:\n    OPL_WriteRegister(OPL_REG_TIMER_CTRL,      0x60);\n    OPL_WriteRegister(OPL_REG_TIMER_CTRL,      0x80);\n\n    // \"Allow FM chips to control the waveform of each operator\":\n    OPL_WriteRegister(OPL_REG_WAVEFORM_ENABLE, 0x20);\n\n    if (opl3)\n    {\n        OPL_WriteRegister(OPL_REG_NEW, 0x01);\n\n        // Initialize level registers\n\n        for (r=OPL_REGS_LEVEL; r <= OPL_REGS_LEVEL + OPL_NUM_OPERATORS; ++r)\n        {\n            OPL_WriteRegister(r | 0x100, 0x3f);\n        }\n\n        // Initialize other registers\n        // These two loops write to registers that actually don't exist,\n        // but this is what Doom does ...\n        // Similarly, the <= is also intenational.\n\n        for (r=OPL_REGS_ATTACK; r <= OPL_REGS_WAVEFORM + OPL_NUM_OPERATORS; ++r)\n        {\n            OPL_WriteRegister(r | 0x100, 0x00);\n        }\n\n        // More registers ...\n\n        for (r=1; r < OPL_REGS_LEVEL; ++r)\n        {\n            OPL_WriteRegister(r | 0x100, 0x00);\n        }\n    }\n\n    // Keyboard split point on (?)\n    OPL_WriteRegister(OPL_REG_FM_MODE,         0x40);\n\n    if (opl3)\n    {\n        OPL_WriteRegister(OPL_REG_NEW, 0x01);\n    }\n}\n\n//\n// Timer functions.\n//\n\nvoid OPL_SetCallback(uint64_t us, opl_callback_t callback, void *data)\n{\n    if (driver != NULL)\n    {\n        driver->set_callback_func(us, callback, data);\n    }\n}\n\nvoid OPL_ClearCallbacks(void)\n{\n    if (driver != NULL)\n    {\n        driver->clear_callbacks_func();\n    }\n}\n\nvoid OPL_Lock(void)\n{\n    if (driver != NULL)\n    {\n        driver->lock_func();\n    }\n}\n\nvoid OPL_Unlock(void)\n{\n    if (driver != NULL)\n    {\n        driver->unlock_func();\n    }\n}\n\ntypedef struct\n{\n    int finished;\n\n    SDL_mutex *mutex;\n    SDL_cond *cond;\n} delay_data_t;\n\nstatic void DelayCallback(void *_delay_data)\n{\n    delay_data_t *delay_data = _delay_data;\n\n    delay_data->finished = 1;\n    SDL_CondSignal(delay_data->cond);\n}\n\nvoid OPL_Delay(uint64_t us)\n{\n    delay_data_t delay_data;\n\n    if (driver == NULL)\n    {\n        return;\n    }\n\n    // Create a callback that will signal this thread after the\n    // specified time.\n\n    delay_data.finished = 0;\n    delay_data.mutex = SDL_CreateMutex();\n    delay_data.cond = SDL_CreateCond();\n\n    OPL_SetCallback(us, DelayCallback, &delay_data);\n\n    while (!delay_data.finished)\n    {\n        SDL_CondWait(delay_data.cond, delay_data.mutex);\n    }\n\n    SDL_DestroyMutex(delay_data.mutex);\n    SDL_DestroyCond(delay_data.cond);\n}\n\nvoid OPL_SetPaused(int paused)\n{\n    if (driver != NULL)\n    {\n        driver->set_paused_func(paused);\n    }\n}\n\nvoid OPL_AdjustCallbacks(float value)\n{\n    if (driver != NULL)\n    {\n        driver->adjust_callbacks_func(value);\n    }\n}\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Dehacked \"mapping\" code\n// Allows the fields in structures to be mapped out and accessed by\n// name\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"doomtype.h\"\n#include \"i_system.h\"\n#include \"m_misc.h\"\n\n#include \"deh_mapping.h\"\n\nstatic deh_mapping_entry_t *GetMappingEntryByName(deh_context_t *context,\n                                                  deh_mapping_t *mapping,\n                                                  char *name)\n{\n    int i;\n\n    for (i=0; mapping->entries[i].name != NULL; ++i)\n    {\n        deh_mapping_entry_t *entry = &mapping->entries[i];\n\n        if (!strcasecmp(entry->name, name))\n        {\n            if (entry->location == NULL)\n            {\n                DEH_Warning(context, \"Field '%s' is unsupported\", name);\n                return NULL;\n            }\n\n            return entry;\n        }\n    }\n\n    // Not found.\n\n    DEH_Warning(context, \"Field named '%s' not found\", name);\n\n    return NULL;\n}\n\n//\n// Get the location of the specified field in the specified structure.\n//\n\nstatic void *GetStructField(void *structptr,\n                            deh_mapping_t *mapping,\n                            deh_mapping_entry_t *entry)\n{\n    unsigned int offset;\n\n    offset = (uint8_t *)entry->location - (uint8_t *)mapping->base;\n\n    return (uint8_t *)structptr + offset;\n}\n\n//\n// Set the value of a particular field in a structure by name\n//\n\nboolean DEH_SetMapping(deh_context_t *context, deh_mapping_t *mapping,\n                       void *structptr, char *name, int value)\n{\n    deh_mapping_entry_t *entry;\n    void *location;\n\n    entry = GetMappingEntryByName(context, mapping, name);\n\n    if (entry == NULL)\n    {\n        return false;\n    }\n\n    // Sanity check:\n\n    if (entry->is_string)\n    {\n        DEH_Error(context, \"Tried to set '%s' as integer (BUG)\", name);\n        return false;\n    }\n\n    location = GetStructField(structptr, mapping, entry);\n\n    //       printf(\"Setting %p::%s to %i (%i bytes)\\n\",\n    //               structptr, name, value, entry->size);\n\n    // Set field content based on its type:\n\n    switch (entry->size)\n    {\n        case 1:\n            * ((uint8_t *) location) = value;\n            break;\n        case 2:\n            * ((uint16_t *) location) = value;\n            break;\n        case 4:\n            * ((uint32_t *) location) = value;\n            break;\n        default:\n            DEH_Error(context, \"Unknown field type for '%s' (BUG)\", name);\n            return false;\n    }\n\n    return true;\n}\n\n//\n// Set the value of a string field in a structure by name\n//\n\nboolean DEH_SetStringMapping(deh_context_t *context, deh_mapping_t *mapping,\n                             void *structptr, char *name, char *value)\n{\n    deh_mapping_entry_t *entry;\n    void *location;\n\n    entry = GetMappingEntryByName(context, mapping, name);\n\n    if (entry == NULL)\n    {\n        return false;\n    }\n\n    // Sanity check:\n\n    if (!entry->is_string)\n    {\n        DEH_Error(context, \"Tried to set '%s' as string (BUG)\", name);\n        return false;\n    }\n\n    location = GetStructField(structptr, mapping, entry);\n\n    // Copy value into field:\n\n    M_StringCopy(location, value, entry->size);\n\n    return true;\n}\n\nvoid DEH_StructSHA1Sum(sha1_context_t *context, deh_mapping_t *mapping,\n                       void *structptr)\n{\n    int i;\n\n    // Go through each mapping\n\n    for (i=0; mapping->entries[i].name != NULL; ++i)\n    {\n        deh_mapping_entry_t *entry = &mapping->entries[i];\n        void *location;\n\n        if (entry->location == NULL)\n        {\n            // Unsupported field\n\n            continue;\n        }\n\n        // Add in data for this field\n\n        location = (uint8_t *)structptr + ((uint8_t *)entry->location - (uint8_t *)mapping->base);\n\n        switch (entry->size)\n        {\n            case 1:\n                SHA1_UpdateInt32(context, *((uint8_t *) location));\n                break;\n            case 2:\n                SHA1_UpdateInt32(context, *((uint16_t *) location));\n                break;\n            case 4:\n                SHA1_UpdateInt32(context, *((uint32_t *) location));\n                break;\n            default:\n                I_Error(\"Unknown dehacked mapping field type for '%s' (BUG)\", \n                        entry->name);\n                break;\n        }\n    }\n}\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Parses Text substitution sections in dehacked files\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n\n#include \"doomtype.h\"\n#include \"deh_str.h\"\n#include \"m_misc.h\"\n\n#include \"z_zone.h\"\n\ntypedef struct \n{\n    char *from_text;\n    char *to_text;\n} deh_substitution_t;\n\nstatic deh_substitution_t **hash_table = NULL;\nstatic int hash_table_entries;\nstatic int hash_table_length = -1;\n\n// This is the algorithm used by glib\n\nstatic unsigned int strhash(const char *s)\n{\n    const char *p = s;\n    unsigned int h = *p;\n  \n    if (h)\n    {\n        for (p += 1; *p; p++)\n            h = (h << 5) - h + *p;\n    }\n\n    return h;\n}\n\nstatic deh_substitution_t *SubstitutionForString(const char *s)\n{\n    int entry;\n\n    // Fallback if we have not initialized the hash table yet\n    if (hash_table_length < 0)\n\treturn NULL;\n\n    entry = strhash(s) % hash_table_length;\n\n    while (hash_table[entry] != NULL)\n    {\n        if (!strcmp(hash_table[entry]->from_text, s))\n        {\n            // substitution found!\n            return hash_table[entry];\n        }\n\n        entry = (entry + 1) % hash_table_length;\n    }\n\n    // no substitution found\n    return NULL;\n}\n\n// Look up a string to see if it has been replaced with something else\n// This will be used throughout the program to substitute text\n\nconst char *DEH_String(const char *s)\n{\n    deh_substitution_t *subst;\n\n    subst = SubstitutionForString(s);\n\n    if (subst != NULL)\n    {\n        return subst->to_text;\n    }\n    else\n    {\n        return s;\n    }\n}\n\nstatic void InitHashTable(void)\n{\n    // init hash table\n    \n    hash_table_entries = 0;\n    hash_table_length = 16;\n    hash_table = Z_Malloc(sizeof(deh_substitution_t *) * hash_table_length,\n                          PU_STATIC, NULL);\n    memset(hash_table, 0, sizeof(deh_substitution_t *) * hash_table_length);\n}\n\nstatic void DEH_AddToHashtable(deh_substitution_t *sub);\n\nstatic void IncreaseHashtable(void)\n{\n    deh_substitution_t **old_table;\n    int old_table_length;\n    int i;\n    \n    // save the old table\n\n    old_table = hash_table;\n    old_table_length = hash_table_length;\n    \n    // double the size \n\n    hash_table_length *= 2;\n    hash_table = Z_Malloc(sizeof(deh_substitution_t *) * hash_table_length,\n                          PU_STATIC, NULL);\n    memset(hash_table, 0, sizeof(deh_substitution_t *) * hash_table_length);\n\n    // go through the old table and insert all the old entries\n\n    for (i=0; i<old_table_length; ++i)\n    {\n        if (old_table[i] != NULL)\n        {\n            DEH_AddToHashtable(old_table[i]);\n        }\n    }\n\n    // free the old table\n\n    Z_Free(old_table);\n}\n\nstatic void DEH_AddToHashtable(deh_substitution_t *sub)\n{\n    int entry;\n\n    // if the hash table is more than 60% full, increase its size\n\n    if ((hash_table_entries * 10) / hash_table_length > 6)\n    {\n        IncreaseHashtable();\n    }\n\n    // find where to insert it\n    entry = strhash(sub->from_text) % hash_table_length;\n\n    while (hash_table[entry] != NULL)\n    {\n        entry = (entry + 1) % hash_table_length;\n    }\n\n    hash_table[entry] = sub;\n    ++hash_table_entries;\n}\n\nvoid DEH_AddStringReplacement(const char *from_text, const char *to_text)\n{\n    deh_substitution_t *sub;\n    size_t len;\n\n    // Initialize the hash table if this is the first time\n    if (hash_table_length < 0)\n    {\n        InitHashTable();\n    }\n\n    // Check to see if there is an existing substitution already in place.\n    sub = SubstitutionForString(from_text);\n\n    if (sub != NULL)\n    {\n        Z_Free(sub->to_text);\n\n        len = strlen(to_text) + 1;\n        sub->to_text = Z_Malloc(len, PU_STATIC, NULL);\n        memcpy(sub->to_text, to_text, len);\n    }\n    else\n    {\n        // We need to allocate a new substitution.\n        sub = Z_Malloc(sizeof(*sub), PU_STATIC, 0);\n\n        // We need to create our own duplicates of the provided strings.\n        len = strlen(from_text) + 1;\n        sub->from_text = Z_Malloc(len, PU_STATIC, NULL);\n        memcpy(sub->from_text, from_text, len);\n\n        len = strlen(to_text) + 1;\n        sub->to_text = Z_Malloc(len, PU_STATIC, NULL);\n        memcpy(sub->to_text, to_text, len);\n\n        DEH_AddToHashtable(sub);\n    }\n}\n\ntypedef enum\n{\n    FORMAT_ARG_INVALID,\n    FORMAT_ARG_INT,\n    FORMAT_ARG_FLOAT,\n    FORMAT_ARG_CHAR,\n    FORMAT_ARG_STRING,\n    FORMAT_ARG_PTR,\n    FORMAT_ARG_SAVE_POS\n} format_arg_t;\n\n// Get the type of a format argument.\n// We can mix-and-match different format arguments as long as they\n// are for the same data type.\n\nstatic format_arg_t FormatArgumentType(char c)\n{\n    switch (c)\n    {\n        case 'd': case 'i': case 'o': case 'u': case 'x': case 'X':\n            return FORMAT_ARG_INT;\n\n        case 'e': case 'E': case 'f': case 'F': case 'g': case 'G':\n        case 'a': case 'A':\n            return FORMAT_ARG_FLOAT;\n\n        case 'c': case 'C':\n            return FORMAT_ARG_CHAR;\n\n        case 's': case 'S':\n            return FORMAT_ARG_STRING;\n\n        case 'p':\n            return FORMAT_ARG_PTR;\n\n        case 'n':\n            return FORMAT_ARG_SAVE_POS;\n\n        default:\n            return FORMAT_ARG_INVALID;\n    }\n}\n\n// Given the specified string, get the type of the first format\n// string encountered.\n\nstatic format_arg_t NextFormatArgument(const char **str)\n{\n    format_arg_t argtype;\n\n    // Search for the '%' starting the next string.\n\n    while (**str != '\\0')\n    {\n        if (**str == '%')\n        {\n            ++*str;\n\n            // Don't stop for double-%s.\n\n            if (**str != '%')\n            {\n                break;\n            }\n        }\n\n        ++*str;\n    }\n\n    // Find the type of the format string.\n\n    while (**str != '\\0')\n    {\n        argtype = FormatArgumentType(**str);\n\n        if (argtype != FORMAT_ARG_INVALID)\n        {\n            ++*str;\n\n            return argtype;\n        }\n\n        ++*str;\n    }\n\n    // Stop searching, we have reached the end.\n\n    *str = NULL;\n\n    return FORMAT_ARG_INVALID;\n}\n\n// Check if the specified argument type is a valid replacement for\n// the original.\n\nstatic boolean ValidArgumentReplacement(format_arg_t original,\n                                        format_arg_t replacement)\n{\n    // In general, the original and replacement types should be\n    // identical.  However, there are some cases where the replacement\n    // is valid and the types don't match.\n\n    // Characters can be represented as ints.\n\n    if (original == FORMAT_ARG_CHAR && replacement == FORMAT_ARG_INT)\n    {\n        return true;\n    }\n\n    // Strings are pointers.\n\n    if (original == FORMAT_ARG_STRING && replacement == FORMAT_ARG_PTR)\n    {\n        return true;\n    }\n\n    return original == replacement;\n}\n\n// Return true if the specified string contains no format arguments.\n\nstatic boolean ValidFormatReplacement(const char *original, const char *replacement)\n{\n    const char *rover1;\n    const char *rover2;\n    int argtype1, argtype2;\n\n    // Check each argument in turn and compare types.\n\n    rover1 = original; rover2 = replacement;\n\n    for (;;)\n    {\n        argtype1 = NextFormatArgument(&rover1);\n        argtype2 = NextFormatArgument(&rover2);\n\n        if (argtype2 == FORMAT_ARG_INVALID)\n        {\n            // No more arguments left to read from the replacement string.\n\n            break;\n        }\n        else if (argtype1 == FORMAT_ARG_INVALID)\n        {\n            // Replacement string has more arguments than the original.\n\n            return false;\n        }\n        else if (!ValidArgumentReplacement(argtype1, argtype2))\n        {\n            // Not a valid replacement argument.\n\n            return false;\n        }\n    }\n\n    return true;\n}\n\n// Get replacement format string, checking arguments.\n\nstatic const char *FormatStringReplacement(const char *s)\n{\n    const char *repl;\n\n    repl = DEH_String(s);\n\n    if (!ValidFormatReplacement(s, repl))\n    {\n        printf(\"WARNING: Unsafe dehacked replacement provided for \"\n               \"printf format string: %s\\n\", s);\n\n        return s;\n    }\n\n    return repl;\n}\n\n// printf(), performing a replacement on the format string.\n\nvoid DEH_printf(const char *fmt, ...)\n{\n    va_list args;\n    const char *repl;\n\n    repl = FormatStringReplacement(fmt);\n\n    va_start(args, fmt);\n\n    vprintf(repl, args);\n\n    va_end(args);\n}\n\n// fprintf(), performing a replacement on the format string.\n\nvoid DEH_fprintf(FILE *fstream, const char *fmt, ...)\n{\n    va_list args;\n    const char *repl;\n\n    repl = FormatStringReplacement(fmt);\n\n    va_start(args, fmt);\n\n    vfprintf(fstream, repl, args);\n\n    va_end(args);\n}\n\n// snprintf(), performing a replacement on the format string.\n\nvoid DEH_snprintf(char *buffer, size_t len, const char *fmt, ...)\n{\n    va_list args;\n    const char *repl;\n\n    repl = FormatStringReplacement(fmt);\n\n    va_start(args, fmt);\n\n    M_vsnprintf(buffer, len, repl, args);\n\n    va_end(args);\n}\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Parses Text substitution sections in dehacked files\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"doomtype.h\"\n\n#include \"z_zone.h\"\n\n#include \"deh_defs.h\"\n#include \"deh_io.h\"\n#include \"deh_main.h\"\n\n// [crispy] support INCLUDE NOTEXT directive in BEX files\nboolean bex_notext = false;\n\n// Given a string length, find the maximum length of a \n// string that can replace it.\n\nstatic int TXT_MaxStringLength(int len)\n{\n    // Enough bytes for the string and the NUL terminator\n\n    len += 1;\n\n    // All strings in doom.exe are on 4-byte boundaries, so we may be able\n    // to support a slightly longer string.\n    // Extend up to the next 4-byte boundary\n\n    len += (4 - (len % 4)) % 4;\n            \n    // Less one for the NUL terminator.\n\n    return len - 1;\n}\n\nstatic void *DEH_TextStart(deh_context_t *context, char *line)\n{\n    char *from_text, *to_text;\n    int fromlen, tolen;\n    int i;\n\n    if (sscanf(line, \"Text %i %i\", &fromlen, &tolen) != 2)\n    {\n        DEH_Warning(context, \"Parse error on section start\");\n        return NULL;\n    }\n\n    // Only allow string replacements that are possible in Vanilla Doom.  \n    // Chocolate Doom is unforgiving!\n\n    if (!deh_allow_long_strings && tolen > TXT_MaxStringLength(fromlen))\n    {\n        DEH_Error(context, \"Replacement string is longer than the maximum \"\n                           \"possible in doom.exe\");\n        return NULL;\n    }\n\n    from_text = malloc(fromlen + 1);\n    to_text = malloc(tolen + 1);\n\n    // read in the \"from\" text\n\n    for (i=0; i<fromlen; ++i)\n    {\n        from_text[i] = DEH_GetChar(context);\n    }\n    from_text[fromlen] = '\\0';\n\n    // read in the \"to\" text\n\n    for (i=0; i<tolen; ++i)\n    {\n        to_text[i] = DEH_GetChar(context);\n    }\n    to_text[tolen] = '\\0';\n\n    DEH_AddStringReplacement(from_text, to_text);\n\n    free(from_text);\n    free(to_text);\n\n    return NULL;\n}\n\nstatic void DEH_TextParseLine(deh_context_t *context, char *line, void *tag)\n{\n    // not used\n}\n\ndeh_section_t deh_section_text =\n{\n    \"Text\",\n    NULL,\n    DEH_TextStart,\n    DEH_TextParseLine,\n    NULL,\n    NULL,\n};\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// DESCRIPTION:  the automap code\n//\n\n\n#include <stdio.h>\n\n#include \"deh_main.h\"\n\n#include \"z_zone.h\"\n#include \"doomkeys.h\"\n#include \"doomdef.h\"\n#include \"st_stuff.h\"\n#include \"p_local.h\"\n#include \"w_wad.h\"\n\n#include \"m_cheat.h\"\n#include \"m_controls.h\"\n#include \"m_misc.h\"\n#include \"i_system.h\"\n#include \"i_timer.h\"\n#include \"i_video.h\"\n\n// Needs access to LFB.\n#include \"v_video.h\"\n\n// State.\n#include \"doomstat.h\"\n#include \"r_state.h\"\n\n// Data.\n#include \"dstrings.h\"\n\n#include \"am_map.h\"\n\n\n// For use if I do walls with outsides/insides\n#define REDS\t\t(256-5*16)\n#define REDRANGE\t16\n#define BLUES\t\t(256-4*16+8)\n#define BLUERANGE\t8\n#define GREENS\t\t(7*16)\n#define GREENRANGE\t16\n#define GRAYS\t\t(6*16)\n#define GRAYSRANGE\t16\n#define BROWNS\t\t(4*16)\n#define BROWNRANGE\t16\n#define YELLOWS\t\t(256-32+7)\n#define YELLOWRANGE\t1\n#define BLACK\t\t0\n#define WHITE\t\t(256-47)\n\n// Automap colors\n#define BACKGROUND\tBLACK\n#define YOURCOLORS\tWHITE\n#define YOURRANGE\t0\n#define WALLCOLORS\tREDS\n#define WALLRANGE\tREDRANGE\n#define TSWALLCOLORS\tGRAYS\n#define TSWALLRANGE\tGRAYSRANGE\n#define FDWALLCOLORS\tBROWNS\n#define FDWALLRANGE\tBROWNRANGE\n#define CDWALLCOLORS\tYELLOWS\n#define CDWALLRANGE\tYELLOWRANGE\n#define THINGCOLORS\tGREENS\n#define THINGRANGE\tGREENRANGE\n#define SECRETWALLCOLORS WALLCOLORS\n#define SECRETWALLRANGE WALLRANGE\n#define GRIDCOLORS\t(GRAYS + GRAYSRANGE/2)\n#define GRIDRANGE\t0\n#define XHAIRCOLORS\tGRAYS\n\n// drawing stuff\n\n#define AM_NUMMARKPOINTS 10\n\n// scale on entry\n#define INITSCALEMTOF (.2*FRACUNIT)\n// how much the automap moves window per tic in frame-buffer coordinates\n// moves 140 pixels in 1 second\n#define F_PANINC\t4\n// how much zoom-in per tic\n// goes to 2x in 1 second\n#define M_ZOOMIN        ((int) (1.02*FRACUNIT))\n// how much zoom-out per tic\n// pulls out to 0.5x in 1 second\n#define M_ZOOMOUT       ((int) (FRACUNIT/1.02))\n\n// translates between frame-buffer and map distances\n#define FTOM(x) FixedMul(((x)<<FRACBITS),scale_ftom)\n#define MTOF(x) (FixedMul((x),scale_mtof)>>FRACBITS)\n// translates between frame-buffer and map coordinates\n#define CXMTOF(x)  (f_x + MTOF((x)-m_x))\n#define CYMTOF(y)  (f_y + (f_h - MTOF((y)-m_y)))\n\n// the following is crap\n#define LINE_NEVERSEE ML_DONTDRAW\n\ntypedef struct\n{\n    int x, y;\n} fpoint_t;\n\ntypedef struct\n{\n    fpoint_t a, b;\n} fline_t;\n\ntypedef struct\n{\n    fixed_t\t\tx,y;\n} mpoint_t;\n\ntypedef struct\n{\n    mpoint_t a, b;\n} mline_t;\n\ntypedef struct\n{\n    fixed_t slp, islp;\n} islope_t;\n\n\n\n//\n// The vector graphics for the automap.\n//  A line drawing of the player pointing right,\n//   starting from the middle.\n//\n#define R ((8*PLAYERRADIUS)/7)\nmline_t player_arrow[] = {\n    { { -R+R/8, 0 }, { R, 0 } }, // -----\n    { { R, 0 }, { R-R/2, R/4 } },  // ----->\n    { { R, 0 }, { R-R/2, -R/4 } },\n    { { -R+R/8, 0 }, { -R-R/8, R/4 } }, // >---->\n    { { -R+R/8, 0 }, { -R-R/8, -R/4 } },\n    { { -R+3*R/8, 0 }, { -R+R/8, R/4 } }, // >>--->\n    { { -R+3*R/8, 0 }, { -R+R/8, -R/4 } }\n};\n#undef R\n\n#define R ((8*PLAYERRADIUS)/7)\nmline_t cheat_player_arrow[] = {\n    { { -R+R/8, 0 }, { R, 0 } }, // -----\n    { { R, 0 }, { R-R/2, R/6 } },  // ----->\n    { { R, 0 }, { R-R/2, -R/6 } },\n    { { -R+R/8, 0 }, { -R-R/8, R/6 } }, // >----->\n    { { -R+R/8, 0 }, { -R-R/8, -R/6 } },\n    { { -R+3*R/8, 0 }, { -R+R/8, R/6 } }, // >>----->\n    { { -R+3*R/8, 0 }, { -R+R/8, -R/6 } },\n    { { -R/2, 0 }, { -R/2, -R/6 } }, // >>-d--->\n    { { -R/2, -R/6 }, { -R/2+R/6, -R/6 } },\n    { { -R/2+R/6, -R/6 }, { -R/2+R/6, R/4 } },\n    { { -R/6, 0 }, { -R/6, -R/6 } }, // >>-dd-->\n    { { -R/6, -R/6 }, { 0, -R/6 } },\n    { { 0, -R/6 }, { 0, R/4 } },\n    { { R/6, R/4 }, { R/6, -R/7 } }, // >>-ddt->\n    { { R/6, -R/7 }, { R/6+R/32, -R/7-R/32 } },\n    { { R/6+R/32, -R/7-R/32 }, { R/6+R/10, -R/7 } }\n};\n#undef R\n\n#define R (FRACUNIT)\nmline_t triangle_guy[] = {\n    { { (fixed_t)(-.867*R), (fixed_t)(-.5*R) }, { (fixed_t)(.867*R ), (fixed_t)(-.5*R) } },\n    { { (fixed_t)(.867*R ), (fixed_t)(-.5*R) }, { (fixed_t)(0      ), (fixed_t)(R    ) } },\n    { { (fixed_t)(0      ), (fixed_t)(R    ) }, { (fixed_t)(-.867*R), (fixed_t)(-.5*R) } }\n};\n#undef R\n\n#define R (FRACUNIT)\nmline_t thintriangle_guy[] = {\n    { { (fixed_t)(-.5*R), (fixed_t)(-.7*R) }, { (fixed_t)(R    ), (fixed_t)(0    ) } },\n    { { (fixed_t)(R    ), (fixed_t)(0    ) }, { (fixed_t)(-.5*R), (fixed_t)(.7*R ) } },\n    { { (fixed_t)(-.5*R), (fixed_t)(.7*R ) }, { (fixed_t)(-.5*R), (fixed_t)(-.7*R) } }\n};\n#undef R\n\n\n\n\nstatic int \tcheating = 0;\nstatic int \tgrid = 0;\n\nstatic int \tleveljuststarted = 1; \t// kluge until AM_LevelInit() is called\n\nboolean    \tautomapactive = false;\nstatic int \tfinit_width = SCREENWIDTH;\nstatic int \tfinit_height = SCREENHEIGHT - ST_HEIGHT;\n\n// location of window on screen\nstatic int \tf_x;\nstatic int\tf_y;\n\n// size of window on screen\nstatic int \tf_w;\nstatic int\tf_h;\n\nstatic int \tlightlev; \t\t// used for funky strobing effect\nstatic pixel_t*\tfb; \t\t\t// pseudo-frame buffer\nstatic int \tamclock;\n\nstatic mpoint_t m_paninc; // how far the window pans each tic (map coords)\nstatic fixed_t \tmtof_zoommul; // how far the window zooms in each tic (map coords)\nstatic fixed_t \tftom_zoommul; // how far the window zooms in each tic (fb coords)\n\nstatic fixed_t \tm_x, m_y;   // LL x,y where the window is on the map (map coords)\nstatic fixed_t \tm_x2, m_y2; // UR x,y where the window is on the map (map coords)\n\n//\n// width/height of window on map (map coords)\n//\nstatic fixed_t \tm_w;\nstatic fixed_t\tm_h;\n\n// based on level size\nstatic fixed_t \tmin_x;\nstatic fixed_t\tmin_y; \nstatic fixed_t \tmax_x;\nstatic fixed_t  max_y;\n\nstatic fixed_t \tmax_w; // max_x-min_x,\nstatic fixed_t  max_h; // max_y-min_y\n\n// based on player size\nstatic fixed_t \tmin_w;\nstatic fixed_t  min_h;\n\n\nstatic fixed_t \tmin_scale_mtof; // used to tell when to stop zooming out\nstatic fixed_t \tmax_scale_mtof; // used to tell when to stop zooming in\n\n// old stuff for recovery later\nstatic fixed_t old_m_w, old_m_h;\nstatic fixed_t old_m_x, old_m_y;\n\n// old location used by the Follower routine\nstatic mpoint_t f_oldloc;\n\n// used by MTOF to scale from map-to-frame-buffer coords\nstatic fixed_t scale_mtof = (fixed_t)INITSCALEMTOF;\n// used by FTOM to scale from frame-buffer-to-map coords (=1/scale_mtof)\nstatic fixed_t scale_ftom;\n\nstatic player_t *plr; // the player represented by an arrow\n\nstatic patch_t *marknums[10]; // numbers used for marking by the automap\nstatic mpoint_t markpoints[AM_NUMMARKPOINTS]; // where the points are\nstatic int markpointnum = 0; // next point to be assigned\n\nstatic int followplayer = 1; // specifies whether to follow the player around\n\ncheatseq_t cheat_amap = CHEAT(\"iddt\", 0);\n\nstatic boolean stopped = true;\n\n// Calculates the slope and slope according to the x-axis of a line\n// segment in map coordinates (with the upright y-axis n' all) so\n// that it can be used with the brain-dead drawing stuff.\n\nvoid\nAM_getIslope\n( mline_t*\tml,\n  islope_t*\tis )\n{\n    int dx, dy;\n\n    dy = ml->a.y - ml->b.y;\n    dx = ml->b.x - ml->a.x;\n    if (!dy) is->islp = (dx<0?-INT_MAX:INT_MAX);\n    else is->islp = FixedDiv(dx, dy);\n    if (!dx) is->slp = (dy<0?-INT_MAX:INT_MAX);\n    else is->slp = FixedDiv(dy, dx);\n\n}\n\n//\n//\n//\nvoid AM_activateNewScale(void)\n{\n    m_x += m_w/2;\n    m_y += m_h/2;\n    m_w = FTOM(f_w);\n    m_h = FTOM(f_h);\n    m_x -= m_w/2;\n    m_y -= m_h/2;\n    m_x2 = m_x + m_w;\n    m_y2 = m_y + m_h;\n}\n\n//\n//\n//\nvoid AM_saveScaleAndLoc(void)\n{\n    old_m_x = m_x;\n    old_m_y = m_y;\n    old_m_w = m_w;\n    old_m_h = m_h;\n}\n\n//\n//\n//\nvoid AM_restoreScaleAndLoc(void)\n{\n\n    m_w = old_m_w;\n    m_h = old_m_h;\n    if (!followplayer)\n    {\n\tm_x = old_m_x;\n\tm_y = old_m_y;\n    } else {\n\tm_x = plr->mo->x - m_w/2;\n\tm_y = plr->mo->y - m_h/2;\n    }\n    m_x2 = m_x + m_w;\n    m_y2 = m_y + m_h;\n\n    // Change the scaling multipliers\n    scale_mtof = FixedDiv(f_w<<FRACBITS, m_w);\n    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n}\n\n//\n// adds a marker at the current location\n//\nvoid AM_addMark(void)\n{\n    markpoints[markpointnum].x = m_x + m_w/2;\n    markpoints[markpointnum].y = m_y + m_h/2;\n    markpointnum = (markpointnum + 1) % AM_NUMMARKPOINTS;\n\n}\n\n//\n// Determines bounding box of all vertices,\n// sets global variables controlling zoom range.\n//\nvoid AM_findMinMaxBoundaries(void)\n{\n    int i;\n    fixed_t a;\n    fixed_t b;\n\n    min_x = min_y =  INT_MAX;\n    max_x = max_y = -INT_MAX;\n  \n    for (i=0;i<numvertexes;i++)\n    {\n\tif (vertexes[i].x < min_x)\n\t    min_x = vertexes[i].x;\n\telse if (vertexes[i].x > max_x)\n\t    max_x = vertexes[i].x;\n    \n\tif (vertexes[i].y < min_y)\n\t    min_y = vertexes[i].y;\n\telse if (vertexes[i].y > max_y)\n\t    max_y = vertexes[i].y;\n    }\n  \n    max_w = max_x - min_x;\n    max_h = max_y - min_y;\n\n    min_w = 2*PLAYERRADIUS; // const? never changed?\n    min_h = 2*PLAYERRADIUS;\n\n    a = FixedDiv(f_w<<FRACBITS, max_w);\n    b = FixedDiv(f_h<<FRACBITS, max_h);\n  \n    min_scale_mtof = a < b ? a : b;\n    max_scale_mtof = FixedDiv(f_h<<FRACBITS, 2*PLAYERRADIUS);\n\n}\n\n\n//\n//\n//\nvoid AM_changeWindowLoc(void)\n{\n    if (m_paninc.x || m_paninc.y)\n    {\n\tfollowplayer = 0;\n\tf_oldloc.x = INT_MAX;\n    }\n\n    m_x += m_paninc.x;\n    m_y += m_paninc.y;\n\n    if (m_x + m_w/2 > max_x)\n\tm_x = max_x - m_w/2;\n    else if (m_x + m_w/2 < min_x)\n\tm_x = min_x - m_w/2;\n  \n    if (m_y + m_h/2 > max_y)\n\tm_y = max_y - m_h/2;\n    else if (m_y + m_h/2 < min_y)\n\tm_y = min_y - m_h/2;\n\n    m_x2 = m_x + m_w;\n    m_y2 = m_y + m_h;\n}\n\n\n//\n//\n//\nvoid AM_initVariables(void)\n{\n    int pnum;\n    static event_t st_notify = { ev_keyup, AM_MSGENTERED, 0, 0 };\n\n    automapactive = true;\n    fb = I_VideoBuffer;\n\n    f_oldloc.x = INT_MAX;\n    amclock = 0;\n    lightlev = 0;\n\n    m_paninc.x = m_paninc.y = 0;\n    ftom_zoommul = FRACUNIT;\n    mtof_zoommul = FRACUNIT;\n\n    m_w = FTOM(f_w);\n    m_h = FTOM(f_h);\n\n    // find player to center on initially\n    if (playeringame[consoleplayer])\n    {\n        plr = &players[consoleplayer];\n    }\n    else\n    {\n        plr = &players[0];\n\n\tfor (pnum=0;pnum<MAXPLAYERS;pnum++)\n        {\n\t    if (playeringame[pnum])\n            {\n                plr = &players[pnum];\n\t\tbreak;\n            }\n        }\n    }\n\n    m_x = plr->mo->x - m_w/2;\n    m_y = plr->mo->y - m_h/2;\n    AM_changeWindowLoc();\n\n    // for saving & restoring\n    old_m_x = m_x;\n    old_m_y = m_y;\n    old_m_w = m_w;\n    old_m_h = m_h;\n\n    // inform the status bar of the change\n    ST_Responder(&st_notify);\n\n}\n\n//\n// \n//\nvoid AM_loadPics(void)\n{\n    int i;\n    char namebuf[9];\n  \n    for (i=0;i<10;i++)\n    {\n\tDEH_snprintf(namebuf, 9, \"AMMNUM%d\", i);\n\tmarknums[i] = W_CacheLumpName(namebuf, PU_STATIC);\n    }\n\n}\n\nvoid AM_unloadPics(void)\n{\n    int i;\n    char namebuf[9];\n  \n    for (i=0;i<10;i++)\n    {\n\tDEH_snprintf(namebuf, 9, \"AMMNUM%d\", i);\n\tW_ReleaseLumpName(namebuf);\n    }\n}\n\nvoid AM_clearMarks(void)\n{\n    int i;\n\n    for (i=0;i<AM_NUMMARKPOINTS;i++)\n\tmarkpoints[i].x = -1; // means empty\n    markpointnum = 0;\n}\n\n//\n// should be called at the start of every level\n// right now, i figure it out myself\n//\nvoid AM_LevelInit(void)\n{\n    leveljuststarted = 0;\n\n    f_x = f_y = 0;\n    f_w = finit_width;\n    f_h = finit_height;\n\n    AM_clearMarks();\n\n    AM_findMinMaxBoundaries();\n    scale_mtof = FixedDiv(min_scale_mtof, (int) (0.7*FRACUNIT));\n    if (scale_mtof > max_scale_mtof)\n\tscale_mtof = min_scale_mtof;\n    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n}\n\n\n\n\n//\n//\n//\nvoid AM_Stop (void)\n{\n    static event_t st_notify = { 0, ev_keyup, AM_MSGEXITED, 0 };\n\n    AM_unloadPics();\n    automapactive = false;\n    ST_Responder(&st_notify);\n    stopped = true;\n}\n\n//\n//\n//\nvoid AM_Start (void)\n{\n    static int lastlevel = -1, lastepisode = -1;\n\n    if (!stopped) AM_Stop();\n    stopped = false;\n    if (lastlevel != gamemap || lastepisode != gameepisode)\n    {\n\tAM_LevelInit();\n\tlastlevel = gamemap;\n\tlastepisode = gameepisode;\n    }\n    AM_initVariables();\n    AM_loadPics();\n}\n\n//\n// set the window scale to the maximum size\n//\nvoid AM_minOutWindowScale(void)\n{\n    scale_mtof = min_scale_mtof;\n    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n    AM_activateNewScale();\n}\n\n//\n// set the window scale to the minimum size\n//\nvoid AM_maxOutWindowScale(void)\n{\n    scale_mtof = max_scale_mtof;\n    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n    AM_activateNewScale();\n}\n\n\n//\n// Handle events (user inputs) in automap mode\n//\nboolean\nAM_Responder\n( event_t*\tev )\n{\n\n    int rc;\n    static int bigstate=0;\n    static char buffer[20];\n    int key;\n\n    rc = false;\n\n    if (ev->type == ev_joystick && joybautomap >= 0\n        && (ev->data1 & (1 << joybautomap)) != 0)\n    {\n        joywait = I_GetTime() + 5;\n\n        if (!automapactive)\n        {\n            AM_Start ();\n            viewactive = false;\n        }\n        else\n        {\n            bigstate = 0;\n            viewactive = true;\n            AM_Stop ();\n        }\n\n        return true;\n    }\n\n    if (!automapactive)\n    {\n\tif (ev->type == ev_keydown && ev->data1 == key_map_toggle)\n\t{\n\t    AM_Start ();\n\t    viewactive = false;\n\t    rc = true;\n\t}\n    }\n    else if (ev->type == ev_keydown)\n    {\n\trc = true;\n        key = ev->data1;\n\n        if (key == key_map_east)          // pan right\n        {\n            if (!followplayer) m_paninc.x = FTOM(F_PANINC);\n            else rc = false;\n        }\n        else if (key == key_map_west)     // pan left\n        {\n            if (!followplayer) m_paninc.x = -FTOM(F_PANINC);\n            else rc = false;\n        }\n        else if (key == key_map_north)    // pan up\n        {\n            if (!followplayer) m_paninc.y = FTOM(F_PANINC);\n            else rc = false;\n        }\n        else if (key == key_map_south)    // pan down\n        {\n            if (!followplayer) m_paninc.y = -FTOM(F_PANINC);\n            else rc = false;\n        }\n        else if (key == key_map_zoomout)  // zoom out\n        {\n            mtof_zoommul = M_ZOOMOUT;\n            ftom_zoommul = M_ZOOMIN;\n        }\n        else if (key == key_map_zoomin)   // zoom in\n        {\n            mtof_zoommul = M_ZOOMIN;\n            ftom_zoommul = M_ZOOMOUT;\n        }\n        else if (key == key_map_toggle)\n        {\n            bigstate = 0;\n            viewactive = true;\n            AM_Stop ();\n        }\n        else if (key == key_map_maxzoom)\n        {\n            bigstate = !bigstate;\n            if (bigstate)\n            {\n                AM_saveScaleAndLoc();\n                AM_minOutWindowScale();\n            }\n            else AM_restoreScaleAndLoc();\n        }\n        else if (key == key_map_follow)\n        {\n            followplayer = !followplayer;\n            f_oldloc.x = INT_MAX;\n            if (followplayer)\n                plr->message = DEH_String(AMSTR_FOLLOWON);\n            else\n                plr->message = DEH_String(AMSTR_FOLLOWOFF);\n        }\n        else if (key == key_map_grid)\n        {\n            grid = !grid;\n            if (grid)\n                plr->message = DEH_String(AMSTR_GRIDON);\n            else\n                plr->message = DEH_String(AMSTR_GRIDOFF);\n        }\n        else if (key == key_map_mark)\n        {\n            M_snprintf(buffer, sizeof(buffer), \"%s %d\",\n                       DEH_String(AMSTR_MARKEDSPOT), markpointnum);\n            plr->message = buffer;\n            AM_addMark();\n        }\n        else if (key == key_map_clearmark)\n        {\n            AM_clearMarks();\n            plr->message = DEH_String(AMSTR_MARKSCLEARED);\n        }\n        else\n        {\n            rc = false;\n        }\n\n        if ((!deathmatch || gameversion <= exe_doom_1_8)\n         && cht_CheckCheat(&cheat_amap, ev->data2))\n        {\n            rc = false;\n            cheating = (cheating + 1) % 3;\n        }\n    }\n    else if (ev->type == ev_keyup)\n    {\n        rc = false;\n        key = ev->data1;\n\n        if (key == key_map_east)\n        {\n            if (!followplayer) m_paninc.x = 0;\n        }\n        else if (key == key_map_west)\n        {\n            if (!followplayer) m_paninc.x = 0;\n        }\n        else if (key == key_map_north)\n        {\n            if (!followplayer) m_paninc.y = 0;\n        }\n        else if (key == key_map_south)\n        {\n            if (!followplayer) m_paninc.y = 0;\n        }\n        else if (key == key_map_zoomout || key == key_map_zoomin)\n        {\n            mtof_zoommul = FRACUNIT;\n            ftom_zoommul = FRACUNIT;\n        }\n    }\n\n    return rc;\n\n}\n\n\n//\n// Zooming\n//\nvoid AM_changeWindowScale(void)\n{\n\n    // Change the scaling multipliers\n    scale_mtof = FixedMul(scale_mtof, mtof_zoommul);\n    scale_ftom = FixedDiv(FRACUNIT, scale_mtof);\n\n    if (scale_mtof < min_scale_mtof)\n\tAM_minOutWindowScale();\n    else if (scale_mtof > max_scale_mtof)\n\tAM_maxOutWindowScale();\n    else\n\tAM_activateNewScale();\n}\n\n\n//\n//\n//\nvoid AM_doFollowPlayer(void)\n{\n\n    if (f_oldloc.x != plr->mo->x || f_oldloc.y != plr->mo->y)\n    {\n\tm_x = FTOM(MTOF(plr->mo->x)) - m_w/2;\n\tm_y = FTOM(MTOF(plr->mo->y)) - m_h/2;\n\tm_x2 = m_x + m_w;\n\tm_y2 = m_y + m_h;\n\tf_oldloc.x = plr->mo->x;\n\tf_oldloc.y = plr->mo->y;\n\n\t//  m_x = FTOM(MTOF(plr->mo->x - m_w/2));\n\t//  m_y = FTOM(MTOF(plr->mo->y - m_h/2));\n\t//  m_x = plr->mo->x - m_w/2;\n\t//  m_y = plr->mo->y - m_h/2;\n\n    }\n\n}\n\n//\n//\n//\nvoid AM_updateLightLev(void)\n{\n    static int nexttic = 0;\n    //static int litelevels[] = { 0, 3, 5, 6, 6, 7, 7, 7 };\n    static int litelevels[] = { 0, 4, 7, 10, 12, 14, 15, 15 };\n    static int litelevelscnt = 0;\n   \n    // Change light level\n    if (amclock>nexttic)\n    {\n\tlightlev = litelevels[litelevelscnt++];\n\tif (litelevelscnt == arrlen(litelevels)) litelevelscnt = 0;\n\tnexttic = amclock + 6 - (amclock % 6);\n    }\n\n}\n\n\n//\n// Updates on Game Tick\n//\nvoid AM_Ticker (void)\n{\n\n    if (!automapactive)\n\treturn;\n\n    amclock++;\n\n    if (followplayer)\n\tAM_doFollowPlayer();\n\n    // Change the zoom if necessary\n    if (ftom_zoommul != FRACUNIT)\n\tAM_changeWindowScale();\n\n    // Change x,y location\n    if (m_paninc.x || m_paninc.y)\n\tAM_changeWindowLoc();\n\n    // Update light level\n    // AM_updateLightLev();\n\n}\n\n\n//\n// Clear automap frame buffer.\n//\nvoid AM_clearFB(int color)\n{\n    memset(fb, color, f_w*f_h*sizeof(*fb));\n}\n\n\n//\n// Automap clipping of lines.\n//\n// Based on Cohen-Sutherland clipping algorithm but with a slightly\n// faster reject and precalculated slopes.  If the speed is needed,\n// use a hash algorithm to handle  the common cases.\n//\nboolean\nAM_clipMline\n( mline_t*\tml,\n  fline_t*\tfl )\n{\n    enum\n    {\n\tLEFT\t=1,\n\tRIGHT\t=2,\n\tBOTTOM\t=4,\n\tTOP\t=8\n    };\n    \n    register int\toutcode1 = 0;\n    register int\toutcode2 = 0;\n    register int\toutside;\n    \n    fpoint_t\ttmp;\n    int\t\tdx;\n    int\t\tdy;\n\n    \n#define DOOUTCODE(oc, mx, my) \\\n    (oc) = 0; \\\n    if ((my) < 0) (oc) |= TOP; \\\n    else if ((my) >= f_h) (oc) |= BOTTOM; \\\n    if ((mx) < 0) (oc) |= LEFT; \\\n    else if ((mx) >= f_w) (oc) |= RIGHT;\n\n    \n    // do trivial rejects and outcodes\n    if (ml->a.y > m_y2)\n\toutcode1 = TOP;\n    else if (ml->a.y < m_y)\n\toutcode1 = BOTTOM;\n\n    if (ml->b.y > m_y2)\n\toutcode2 = TOP;\n    else if (ml->b.y < m_y)\n\toutcode2 = BOTTOM;\n    \n    if (outcode1 & outcode2)\n\treturn false; // trivially outside\n\n    if (ml->a.x < m_x)\n\toutcode1 |= LEFT;\n    else if (ml->a.x > m_x2)\n\toutcode1 |= RIGHT;\n    \n    if (ml->b.x < m_x)\n\toutcode2 |= LEFT;\n    else if (ml->b.x > m_x2)\n\toutcode2 |= RIGHT;\n    \n    if (outcode1 & outcode2)\n\treturn false; // trivially outside\n\n    // transform to frame-buffer coordinates.\n    fl->a.x = CXMTOF(ml->a.x);\n    fl->a.y = CYMTOF(ml->a.y);\n    fl->b.x = CXMTOF(ml->b.x);\n    fl->b.y = CYMTOF(ml->b.y);\n\n    DOOUTCODE(outcode1, fl->a.x, fl->a.y);\n    DOOUTCODE(outcode2, fl->b.x, fl->b.y);\n\n    if (outcode1 & outcode2)\n\treturn false;\n\n    while (outcode1 | outcode2)\n    {\n\t// may be partially inside box\n\t// find an outside point\n\tif (outcode1)\n\t    outside = outcode1;\n\telse\n\t    outside = outcode2;\n\t\n\t// clip to each side\n\tif (outside & TOP)\n\t{\n\t    dy = fl->a.y - fl->b.y;\n\t    dx = fl->b.x - fl->a.x;\n\t    tmp.x = fl->a.x + (dx*(fl->a.y))/dy;\n\t    tmp.y = 0;\n\t}\n\telse if (outside & BOTTOM)\n\t{\n\t    dy = fl->a.y - fl->b.y;\n\t    dx = fl->b.x - fl->a.x;\n\t    tmp.x = fl->a.x + (dx*(fl->a.y-f_h))/dy;\n\t    tmp.y = f_h-1;\n\t}\n\telse if (outside & RIGHT)\n\t{\n\t    dy = fl->b.y - fl->a.y;\n\t    dx = fl->b.x - fl->a.x;\n\t    tmp.y = fl->a.y + (dy*(f_w-1 - fl->a.x))/dx;\n\t    tmp.x = f_w-1;\n\t}\n\telse if (outside & LEFT)\n\t{\n\t    dy = fl->b.y - fl->a.y;\n\t    dx = fl->b.x - fl->a.x;\n\t    tmp.y = fl->a.y + (dy*(-fl->a.x))/dx;\n\t    tmp.x = 0;\n\t}\n        else\n        {\n            tmp.x = 0;\n            tmp.y = 0;\n        }\n\n\tif (outside == outcode1)\n\t{\n\t    fl->a = tmp;\n\t    DOOUTCODE(outcode1, fl->a.x, fl->a.y);\n\t}\n\telse\n\t{\n\t    fl->b = tmp;\n\t    DOOUTCODE(outcode2, fl->b.x, fl->b.y);\n\t}\n\t\n\tif (outcode1 & outcode2)\n\t    return false; // trivially outside\n    }\n\n    return true;\n}\n#undef DOOUTCODE\n\n\n//\n// Classic Bresenham w/ whatever optimizations needed for speed\n//\nvoid\nAM_drawFline\n( fline_t*\tfl,\n  int\t\tcolor )\n{\n    register int x;\n    register int y;\n    register int dx;\n    register int dy;\n    register int sx;\n    register int sy;\n    register int ax;\n    register int ay;\n    register int d;\n    \n    static int fuck = 0;\n\n    // For debugging only\n    if (      fl->a.x < 0 || fl->a.x >= f_w\n\t   || fl->a.y < 0 || fl->a.y >= f_h\n\t   || fl->b.x < 0 || fl->b.x >= f_w\n\t   || fl->b.y < 0 || fl->b.y >= f_h)\n    {\n        DEH_fprintf(stderr, \"fuck %d \\r\", fuck++);\n\treturn;\n    }\n\n#define PUTDOT(xx,yy,cc) fb[(yy)*f_w+(xx)]=(cc)\n\n    dx = fl->b.x - fl->a.x;\n    ax = 2 * (dx<0 ? -dx : dx);\n    sx = dx<0 ? -1 : 1;\n\n    dy = fl->b.y - fl->a.y;\n    ay = 2 * (dy<0 ? -dy : dy);\n    sy = dy<0 ? -1 : 1;\n\n    x = fl->a.x;\n    y = fl->a.y;\n\n    if (ax > ay)\n    {\n\td = ay - ax/2;\n\twhile (1)\n\t{\n\t    PUTDOT(x,y,color);\n\t    if (x == fl->b.x) return;\n\t    if (d>=0)\n\t    {\n\t\ty += sy;\n\t\td -= ax;\n\t    }\n\t    x += sx;\n\t    d += ay;\n\t}\n    }\n    else\n    {\n\td = ax - ay/2;\n\twhile (1)\n\t{\n\t    PUTDOT(x, y, color);\n\t    if (y == fl->b.y) return;\n\t    if (d >= 0)\n\t    {\n\t\tx += sx;\n\t\td -= ay;\n\t    }\n\t    y += sy;\n\t    d += ax;\n\t}\n    }\n}\n\n\n//\n// Clip lines, draw visible part sof lines.\n//\nvoid\nAM_drawMline\n( mline_t*\tml,\n  int\t\tcolor )\n{\n    static fline_t fl;\n\n    if (AM_clipMline(ml, &fl))\n\tAM_drawFline(&fl, color); // draws it on frame buffer using fb coords\n}\n\n\n\n//\n// Draws flat (floor/ceiling tile) aligned grid lines.\n//\nvoid AM_drawGrid(int color)\n{\n    fixed_t x, y;\n    fixed_t start, end;\n    mline_t ml;\n\n    // Figure out start of vertical gridlines\n    start = m_x;\n    if ((start-bmaporgx)%(MAPBLOCKUNITS<<FRACBITS))\n\tstart += (MAPBLOCKUNITS<<FRACBITS)\n\t    - ((start-bmaporgx)%(MAPBLOCKUNITS<<FRACBITS));\n    end = m_x + m_w;\n\n    // draw vertical gridlines\n    ml.a.y = m_y;\n    ml.b.y = m_y+m_h;\n    for (x=start; x<end; x+=(MAPBLOCKUNITS<<FRACBITS))\n    {\n\tml.a.x = x;\n\tml.b.x = x;\n\tAM_drawMline(&ml, color);\n    }\n\n    // Figure out start of horizontal gridlines\n    start = m_y;\n    if ((start-bmaporgy)%(MAPBLOCKUNITS<<FRACBITS))\n\tstart += (MAPBLOCKUNITS<<FRACBITS)\n\t    - ((start-bmaporgy)%(MAPBLOCKUNITS<<FRACBITS));\n    end = m_y + m_h;\n\n    // draw horizontal gridlines\n    ml.a.x = m_x;\n    ml.b.x = m_x + m_w;\n    for (y=start; y<end; y+=(MAPBLOCKUNITS<<FRACBITS))\n    {\n\tml.a.y = y;\n\tml.b.y = y;\n\tAM_drawMline(&ml, color);\n    }\n\n}\n\n//\n// Determines visible lines, draws them.\n// This is LineDef based, not LineSeg based.\n//\nvoid AM_drawWalls(void)\n{\n    int i;\n    static mline_t l;\n\n    for (i=0;i<numlines;i++)\n    {\n\tl.a.x = lines[i].v1->x;\n\tl.a.y = lines[i].v1->y;\n\tl.b.x = lines[i].v2->x;\n\tl.b.y = lines[i].v2->y;\n\tif (cheating || (lines[i].flags & ML_MAPPED))\n\t{\n\t    if ((lines[i].flags & LINE_NEVERSEE) && !cheating)\n\t\tcontinue;\n\t    if (!lines[i].backsector)\n\t    {\n\t\tAM_drawMline(&l, WALLCOLORS+lightlev);\n\t    }\n\t    else\n\t    {\n\t\tif (lines[i].special == 39)\n\t\t{ // teleporters\n\t\t    AM_drawMline(&l, WALLCOLORS+WALLRANGE/2);\n\t\t}\n\t\telse if (lines[i].flags & ML_SECRET) // secret door\n\t\t{\n\t\t    if (cheating) AM_drawMline(&l, SECRETWALLCOLORS + lightlev);\n\t\t    else AM_drawMline(&l, WALLCOLORS+lightlev);\n\t\t}\n\t\telse if (lines[i].backsector->floorheight\n\t\t\t   != lines[i].frontsector->floorheight) {\n\t\t    AM_drawMline(&l, FDWALLCOLORS + lightlev); // floor level change\n\t\t}\n\t\telse if (lines[i].backsector->ceilingheight\n\t\t\t   != lines[i].frontsector->ceilingheight) {\n\t\t    AM_drawMline(&l, CDWALLCOLORS+lightlev); // ceiling level change\n\t\t}\n\t\telse if (cheating) {\n\t\t    AM_drawMline(&l, TSWALLCOLORS+lightlev);\n\t\t}\n\t    }\n\t}\n\telse if (plr->powers[pw_allmap])\n\t{\n\t    if (!(lines[i].flags & LINE_NEVERSEE)) AM_drawMline(&l, GRAYS+3);\n\t}\n    }\n}\n\n\n//\n// Rotation in 2D.\n// Used to rotate player arrow line character.\n//\nvoid\nAM_rotate\n( fixed_t*\tx,\n  fixed_t*\ty,\n  angle_t\ta )\n{\n    fixed_t tmpx;\n\n    tmpx =\n\tFixedMul(*x,finecosine[a>>ANGLETOFINESHIFT])\n\t- FixedMul(*y,finesine[a>>ANGLETOFINESHIFT]);\n    \n    *y   =\n\tFixedMul(*x,finesine[a>>ANGLETOFINESHIFT])\n\t+ FixedMul(*y,finecosine[a>>ANGLETOFINESHIFT]);\n\n    *x = tmpx;\n}\n\nvoid\nAM_drawLineCharacter\n( mline_t*\tlineguy,\n  int\t\tlineguylines,\n  fixed_t\tscale,\n  angle_t\tangle,\n  int\t\tcolor,\n  fixed_t\tx,\n  fixed_t\ty )\n{\n    int\t\ti;\n    mline_t\tl;\n\n    for (i=0;i<lineguylines;i++)\n    {\n\tl.a.x = lineguy[i].a.x;\n\tl.a.y = lineguy[i].a.y;\n\n\tif (scale)\n\t{\n\t    l.a.x = FixedMul(scale, l.a.x);\n\t    l.a.y = FixedMul(scale, l.a.y);\n\t}\n\n\tif (angle)\n\t    AM_rotate(&l.a.x, &l.a.y, angle);\n\n\tl.a.x += x;\n\tl.a.y += y;\n\n\tl.b.x = lineguy[i].b.x;\n\tl.b.y = lineguy[i].b.y;\n\n\tif (scale)\n\t{\n\t    l.b.x = FixedMul(scale, l.b.x);\n\t    l.b.y = FixedMul(scale, l.b.y);\n\t}\n\n\tif (angle)\n\t    AM_rotate(&l.b.x, &l.b.y, angle);\n\t\n\tl.b.x += x;\n\tl.b.y += y;\n\n\tAM_drawMline(&l, color);\n    }\n}\n\nvoid AM_drawPlayers(void)\n{\n    int\t\ti;\n    player_t*\tp;\n    static int \ttheir_colors[] = { GREENS, GRAYS, BROWNS, REDS };\n    int\t\ttheir_color = -1;\n    int\t\tcolor;\n\n    if (!netgame)\n    {\n\tif (cheating)\n\t    AM_drawLineCharacter\n\t\t(cheat_player_arrow, arrlen(cheat_player_arrow), 0,\n\t\t plr->mo->angle, WHITE, plr->mo->x, plr->mo->y);\n\telse\n\t    AM_drawLineCharacter\n\t\t(player_arrow, arrlen(player_arrow), 0, plr->mo->angle,\n\t\t WHITE, plr->mo->x, plr->mo->y);\n\treturn;\n    }\n\n    for (i=0;i<MAXPLAYERS;i++)\n    {\n\ttheir_color++;\n\tp = &players[i];\n\n\tif ( (deathmatch && !singledemo) && p != plr)\n\t    continue;\n\n\tif (!playeringame[i])\n\t    continue;\n\n\tif (p->powers[pw_invisibility])\n\t    color = 246; // *close* to black\n\telse\n\t    color = their_colors[their_color];\n\t\n\tAM_drawLineCharacter\n\t    (player_arrow, arrlen(player_arrow), 0, p->mo->angle,\n\t     color, p->mo->x, p->mo->y);\n    }\n\n}\n\nvoid\nAM_drawThings\n( int\tcolors,\n  int \tcolorrange)\n{\n    int\t\ti;\n    mobj_t*\tt;\n\n    for (i=0;i<numsectors;i++)\n    {\n\tt = sectors[i].thinglist;\n\twhile (t)\n\t{\n\t    AM_drawLineCharacter\n\t\t(thintriangle_guy, arrlen(thintriangle_guy),\n\t\t 16<<FRACBITS, t->angle, colors+lightlev, t->x, t->y);\n\t    t = t->snext;\n\t}\n    }\n}\n\nvoid AM_drawMarks(void)\n{\n    int i, fx, fy, w, h;\n\n    for (i=0;i<AM_NUMMARKPOINTS;i++)\n    {\n\tif (markpoints[i].x != -1)\n\t{\n\t    //      w = SHORT(marknums[i]->width);\n\t    //      h = SHORT(marknums[i]->height);\n\t    w = 5; // because something's wrong with the wad, i guess\n\t    h = 6; // because something's wrong with the wad, i guess\n\t    fx = CXMTOF(markpoints[i].x);\n\t    fy = CYMTOF(markpoints[i].y);\n\t    if (fx >= f_x && fx <= f_w - w && fy >= f_y && fy <= f_h - h)\n\t\tV_DrawPatch(fx, fy, marknums[i]);\n\t}\n    }\n\n}\n\nvoid AM_drawCrosshair(int color)\n{\n    fb[(f_w*(f_h+1))/2] = color; // single point for now\n\n}\n\nvoid AM_Drawer (void)\n{\n    if (!automapactive) return;\n\n    AM_clearFB(BACKGROUND);\n    if (grid)\n\tAM_drawGrid(GRIDCOLORS);\n    AM_drawWalls();\n    AM_drawPlayers();\n    if (cheating==2)\n\tAM_drawThings(THINGCOLORS, THINGRANGE);\n    AM_drawCrosshair(XHAIRCOLORS);\n\n    AM_drawMarks();\n\n    V_MarkRect(f_x, f_y, f_w, f_h);\n\n}\n","/* Emacs style mode select   -*- C++ -*-\n *-----------------------------------------------------------------------------\n *\n *\n *  PrBoom: a Doom port merged with LxDoom and LSDLDoom\n *  based on BOOM, a modified and improved DOOM engine\n *  Copyright (C) 1999 by\n *  id Software, Chi Hoang, Lee Killough, Jim Flynn, Rand Phares, Ty Halderman\n *  Copyright (C) 1999-2000 by\n *  Jess Haas, Nicolas Kalkhof, Colin Phipps, Florian Schulze\n *  Copyright 2005, 2006 by\n *  Florian Schulze, Colin Phipps, Neil Stevens, Andrey Budko\n *\n *  This program is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU General Public License\n *  as published by the Free Software Foundation; either version 2\n *  of the License, or (at your option) any later version.\n *\n *  This program is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this program; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n *  02111-1307, USA.\n *\n * DESCRIPTION:\n *  Generalized linedef type handlers\n *  Floors, Ceilings, Doors, Locked Doors, Lifts, Stairs, Crushers\n *\n *-----------------------------------------------------------------------------*/\n\n#include \"doomstat.h\" //jff 6/19/98 for demo_compatibility\n#include \"r_state.h\"\n#include \"r_main.h\"\n#include \"p_local.h\"\n#include \"p_spec.h\"\n#include \"p_tick.h\"\n#include \"m_random.h\"\n#include \"s_sound.h\"\n#include \"sounds.h\"\n#include \"z_zone.h\"\n\n//////////////////////////////////////////////////////////\n//\n// Generalized Linedef Type handlers\n//\n//////////////////////////////////////////////////////////\n\n//\n// EV_DoGenFloor()\n//\n// Handle generalized floor types\n//\n// Passed the line activating the generalized floor function\n// Returns true if a thinker is created\n//\n// jff 02/04/98 Added this routine (and file) to handle generalized\n// floor movers using bit fields in the line special type.\n//\nint EV_DoGenFloor\n( line_t*       line )\n{\n  int                   secnum;\n  int                   rtn;\n  boolean               manual;\n  sector_t*             sec;\n  floormove_t*          floor;\n  unsigned              value = (unsigned)line->special - GenFloorBase;\n\n  // parse the bit fields in the line's special type\n\n  int Crsh = (value & FloorCrush) >> FloorCrushShift;\n  int ChgT = (value & FloorChange) >> FloorChangeShift;\n  int Targ = (value & FloorTarget) >> FloorTargetShift;\n  int Dirn = (value & FloorDirection) >> FloorDirectionShift;\n  int ChgM = (value & FloorModel) >> FloorModelShift;\n  int Sped = (value & FloorSpeed) >> FloorSpeedShift;\n\n  rtn = 0;\n\n  // check if a manual trigger, if so do just the sector on the backside\n  manual = false;\n  // if (Trig==PushOnce || Trig==PushMany)\n  // {\n  //   if (!(sec = line->backsector))\n  //     return rtn;\n  //   secnum = sec->iSectorID;\n  //   manual = true;\n  //   goto manual_floor;\n  // }\n\n  secnum = -1;\n  // if not manual do all sectors tagged the same as the line\n  while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n  {\n    sec = &sectors[secnum];\n\n    // Do not start another function if floor already moving\n    if (P_SectorActive(floor_special,sec))\n    {\n      if (!manual)\n        continue;\n      else\n        return rtn;\n    }\n\n    // new floor thinker\n    rtn = 1;\n    floor = Z_Malloc (sizeof(*floor), PU_LEVSPEC, 0);\n    memset(floor, 0, sizeof(*floor));\n    P_AddThinker (&floor->thinker);\n    sec->floordata = floor;\n    floor->thinker.function.acp1 = (actionf_p1) T_MoveFloor;\n    floor->crush = Crsh;\n    floor->direction = Dirn? 1 : -1;\n    floor->sector = sec;\n    floor->texture = sec->floorpic;\n    floor->newspecial = sec->special;\n    //jff 3/14/98 transfer old special field too\n    floor->oldspecial = sec->oldspecial;\n    floor->type = genFloor;\n\n    // set the speed of motion\n    switch (Sped)\n    {\n      case SpeedSlow:\n        floor->speed = FLOORSPEED;\n        break;\n      case SpeedNormal:\n        floor->speed = FLOORSPEED*2;\n        break;\n      case SpeedFast:\n        floor->speed = FLOORSPEED*4;\n        break;\n      case SpeedTurbo:\n        floor->speed = FLOORSPEED*8;\n        break;\n      default:\n        break;\n    }\n\n    // set the destination height\n    switch(Targ)\n    {\n      case FtoHnF:\n        floor->floordestheight = P_FindHighestFloorSurrounding(sec);\n        break;\n      case FtoLnF:\n        floor->floordestheight = P_FindLowestFloorSurrounding(sec);\n        break;\n      case FtoNnF:\n        floor->floordestheight = Dirn?\n          P_FindNextHighestFloor(sec,sec->floorheight) :\n          P_FindNextLowestFloor(sec,sec->floorheight);\n        break;\n      case FtoLnC:\n        floor->floordestheight = P_FindLowestCeilingSurrounding(sec);\n        break;\n      case FtoC:\n        floor->floordestheight = sec->ceilingheight;\n        break;\n      case FbyST:\n        floor->floordestheight = (floor->sector->floorheight>>FRACBITS) +\n          floor->direction * (P_FindShortestTextureAround(secnum)>>FRACBITS);\n        if (floor->floordestheight>32000)  //jff 3/13/98 prevent overflow\n          floor->floordestheight=32000;    // wraparound in floor height\n        if (floor->floordestheight<-32000)\n          floor->floordestheight=-32000;\n        floor->floordestheight<<=FRACBITS;\n        break;\n      case Fby24:\n        floor->floordestheight = floor->sector->floorheight +\n          floor->direction * 24*FRACUNIT;\n        break;\n      case Fby32:\n        floor->floordestheight = floor->sector->floorheight +\n          floor->direction * 32*FRACUNIT;\n        break;\n      default:\n        break;\n    }\n\n    // set texture/type change properties\n    if (ChgT)   // if a texture change is indicated\n    {\n      if (ChgM) // if a numeric model change\n      {\n        sector_t *sec;\n\n        //jff 5/23/98 find model with ceiling at target height if target\n        //is a ceiling type\n        sec = (Targ==FtoLnC || Targ==FtoC)?\n          P_FindModelCeilingSector(floor->floordestheight,secnum) :\n          P_FindModelFloorSector(floor->floordestheight,secnum);\n        if (sec)\n        {\n          floor->texture = sec->floorpic;\n          switch(ChgT)\n          {\n            case FChgZero:  // zero type\n              floor->newspecial = 0;\n              //jff 3/14/98 change old field too\n              floor->oldspecial = 0;\n              floor->type = genFloorChg0;\n              break;\n            case FChgTyp:   // copy type\n              floor->newspecial = sec->special;\n              //jff 3/14/98 change old field too\n              floor->oldspecial = sec->oldspecial;\n              floor->type = genFloorChgT;\n              break;\n            case FChgTxt:   // leave type be\n              floor->type = genFloorChg;\n              break;\n            default:\n              break;\n          }\n        }\n      }\n      else     // else if a trigger model change\n      {\n        floor->texture = line->frontsector->floorpic;\n        switch (ChgT)\n        {\n          case FChgZero:    // zero type\n            floor->newspecial = 0;\n            //jff 3/14/98 change old field too\n            floor->oldspecial = 0;\n            floor->type = genFloorChg0;\n            break;\n          case FChgTyp:     // copy type\n            floor->newspecial = line->frontsector->special;\n            //jff 3/14/98 change old field too\n            floor->oldspecial = line->frontsector->oldspecial;\n            floor->type = genFloorChgT;\n            break;\n          case FChgTxt:     // leave type be\n            floor->type = genFloorChg;\n          default:\n            break;\n        }\n      }\n    }\n    if (manual) return rtn;\n  }\n  return rtn;\n}\n\n\n//\n// EV_DoGenCeiling()\n//\n// Handle generalized ceiling types\n//\n// Passed the linedef activating the ceiling function\n// Returns true if a thinker created\n//\n// jff 02/04/98 Added this routine (and file) to handle generalized\n// floor movers using bit fields in the line special type.\n//\nint EV_DoGenCeiling\n( line_t*       line )\n{\n  int                   secnum;\n  int                   rtn;\n  boolean               manual;\n  fixed_t               targheight;\n  sector_t*             sec;\n  ceiling_t*            ceiling;\n  unsigned              value = (unsigned)line->special - GenCeilingBase;\n\n  // parse the bit fields in the line's special type\n\n  int Crsh = (value & CeilingCrush) >> CeilingCrushShift;\n  int ChgT = (value & CeilingChange) >> CeilingChangeShift;\n  int Targ = (value & CeilingTarget) >> CeilingTargetShift;\n  int Dirn = (value & CeilingDirection) >> CeilingDirectionShift;\n  int ChgM = (value & CeilingModel) >> CeilingModelShift;\n  int Sped = (value & CeilingSpeed) >> CeilingSpeedShift;\n\n  rtn = 0;\n\n  // check if a manual trigger, if so do just the sector on the backside\n  manual = false;\n  // if (Trig==PushOnce || Trig==PushMany)\n  // {\n  //   if (!(sec = line->backsector))\n  //     return rtn;\n  //   secnum = sec->iSectorID;\n  //   manual = true;\n  //   goto manual_ceiling;\n  // }\n\n  secnum = -1;\n  // if not manual do all sectors tagged the same as the line\n  while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n  {\n    sec = &sectors[secnum];\n\n    // Do not start another function if ceiling already moving\n    if (P_SectorActive(ceiling_special,sec)) //jff 2/22/98\n    {\n      if (!manual)\n        continue;\n      else\n        return rtn;\n    }\n\n    // new ceiling thinker\n    rtn = 1;\n    ceiling = Z_Malloc (sizeof(*ceiling), PU_LEVSPEC, 0);\n    memset(ceiling, 0, sizeof(*ceiling));\n    P_AddThinker (&ceiling->thinker);\n    sec->ceilingdata = ceiling; //jff 2/22/98\n    ceiling->thinker.function.acp1 = (actionf_p1) T_MoveCeiling;\n    ceiling->crush = Crsh;\n    ceiling->direction = Dirn? 1 : -1;\n    ceiling->sector = sec;\n    ceiling->texture = sec->ceilingpic;\n    ceiling->newspecial = sec->special;\n    //jff 3/14/98 change old field too\n    ceiling->oldspecial = sec->oldspecial;\n    ceiling->tag = sec->tag;\n    ceiling->type = genCeiling;\n\n    // set speed of motion\n    switch (Sped)\n    {\n      case SpeedSlow:\n        ceiling->speed = CEILSPEED;\n        break;\n      case SpeedNormal:\n        ceiling->speed = CEILSPEED*2;\n        break;\n      case SpeedFast:\n        ceiling->speed = CEILSPEED*4;\n        break;\n      case SpeedTurbo:\n        ceiling->speed = CEILSPEED*8;\n        break;\n      default:\n        break;\n    }\n\n    // set destination target height\n    targheight = sec->ceilingheight;\n    switch(Targ)\n    {\n      case CtoHnC:\n        targheight = P_FindHighestCeilingSurrounding(sec);\n        break;\n      case CtoLnC:\n        targheight = P_FindLowestCeilingSurrounding(sec);\n        break;\n      case CtoNnC:\n        targheight = Dirn?\n          P_FindNextHighestCeiling(sec,sec->ceilingheight) :\n          P_FindNextLowestCeiling(sec,sec->ceilingheight);\n        break;\n      case CtoHnF:\n        targheight = P_FindHighestFloorSurrounding(sec);\n        break;\n      case CtoF:\n        targheight = sec->floorheight;\n        break;\n      case CbyST:\n        targheight = (ceiling->sector->ceilingheight>>FRACBITS) +\n          ceiling->direction * (P_FindShortestUpperAround(secnum)>>FRACBITS);\n        if (targheight>32000)  //jff 3/13/98 prevent overflow\n          targheight=32000;    // wraparound in ceiling height\n        if (targheight<-32000)\n          targheight=-32000;\n        targheight<<=FRACBITS;\n        break;\n      case Cby24:\n        targheight = ceiling->sector->ceilingheight +\n          ceiling->direction * 24*FRACUNIT;\n        break;\n      case Cby32:\n        targheight = ceiling->sector->ceilingheight +\n          ceiling->direction * 32*FRACUNIT;\n        break;\n      default:\n        break;\n    }\n    if (Dirn) ceiling->topheight = targheight;\n    else ceiling->bottomheight = targheight;\n\n    // set texture/type change properties\n    if (ChgT)     // if a texture change is indicated\n    {\n      if (ChgM)   // if a numeric model change\n      {\n        sector_t *sec;\n\n        //jff 5/23/98 find model with floor at target height if target\n        //is a floor type\n        sec = (Targ==CtoHnF || Targ==CtoF)?\n          P_FindModelFloorSector(targheight,secnum) :\n          P_FindModelCeilingSector(targheight,secnum);\n        if (sec)\n        {\n          ceiling->texture = sec->ceilingpic;\n          switch (ChgT)\n          {\n            case CChgZero:  // type is zeroed\n              ceiling->newspecial = 0;\n              //jff 3/14/98 change old field too\n              ceiling->oldspecial = 0;\n              ceiling->type = genCeilingChg0;\n              break;\n            case CChgTyp:   // type is copied\n              ceiling->newspecial = sec->special;\n              //jff 3/14/98 change old field too\n              ceiling->oldspecial = sec->oldspecial;\n              ceiling->type = genCeilingChgT;\n              break;\n            case CChgTxt:   // type is left alone\n              ceiling->type = genCeilingChg;\n              break;\n            default:\n              break;\n          }\n        }\n      }\n      else        // else if a trigger model change\n      {\n        ceiling->texture = line->frontsector->ceilingpic;\n        switch (ChgT)\n        {\n          case CChgZero:    // type is zeroed\n            ceiling->newspecial = 0;\n            //jff 3/14/98 change old field too\n            ceiling->oldspecial = 0;\n            ceiling->type = genCeilingChg0;\n            break;\n          case CChgTyp:     // type is copied\n            ceiling->newspecial = line->frontsector->special;\n            //jff 3/14/98 change old field too\n            ceiling->oldspecial = line->frontsector->oldspecial;\n            ceiling->type = genCeilingChgT;\n            break;\n          case CChgTxt:     // type is left alone\n            ceiling->type = genCeilingChg;\n            break;\n          default:\n            break;\n        }\n      }\n    }\n    P_AddActiveCeiling(ceiling);  // add this ceiling to the active list\n    if (manual) return rtn;\n  }\n  return rtn;\n}\n\n//\n// EV_DoGenLift()\n//\n// Handle generalized lift types\n//\n// Passed the linedef activating the lift\n// Returns true if a thinker is created\n//\nint EV_DoGenLift\n( line_t*       line )\n{\n  plat_t*         plat;\n  int             secnum;\n  int             rtn;\n  boolean         manual;\n  sector_t*       sec;\n  unsigned        value = (unsigned)line->special - GenLiftBase;\n\n  // parse the bit fields in the line's special type\n\n  int Targ = (value & LiftTarget) >> LiftTargetShift;\n  int Dely = (value & LiftDelay) >> LiftDelayShift;\n  int Sped = (value & LiftSpeed) >> LiftSpeedShift;\n\n  secnum = -1;\n  rtn = 0;\n\n  // Activate all <type> plats that are in_stasis\n\n  if (Targ==LnF2HnF)\n    P_ActivateInStasis(line->tag);\n\n  // check if a manual trigger, if so do just the sector on the backside\n  manual = false;\n  // if (Trig==PushOnce || Trig==PushMany)\n  // {\n  //   if (!(sec = line->backsector))\n  //     return rtn;\n  //   secnum = sec->iSectorID;\n  //   manual = true;\n  //   goto manual_lift;\n  // }\n\n  // if not manual do all sectors tagged the same as the line\n  while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n  {\n    sec = &sectors[secnum];\n\n    // Do not start another function if floor already moving\n    if (P_SectorActive(floor_special,sec))\n    {\n      if (!manual)\n        continue;\n      else\n        return rtn;\n    }\n\n    // Setup the plat thinker\n    rtn = 1;\n    plat = Z_Malloc( sizeof(*plat), PU_LEVSPEC, 0);\n    memset(plat, 0, sizeof(*plat));\n    P_AddThinker(&plat->thinker);\n\n    plat->sector = sec;\n    plat->sector->floordata = plat;\n    plat->thinker.function.acp1 = (actionf_p1) T_PlatRaise;\n    plat->crush = false;\n    plat->tag = line->tag;\n\n    plat->type = genLift;\n    plat->high = sec->floorheight;\n    plat->status = down;\n\n    // setup the target destination height\n    switch(Targ)\n    {\n      case F2LnF:\n        plat->low = P_FindLowestFloorSurrounding(sec);\n        if (plat->low > sec->floorheight)\n          plat->low = sec->floorheight;\n        break;\n      case F2NnF:\n        plat->low = P_FindNextLowestFloor(sec,sec->floorheight);\n        break;\n      case F2LnC:\n        plat->low = P_FindLowestCeilingSurrounding(sec);\n        if (plat->low > sec->floorheight)\n          plat->low = sec->floorheight;\n        break;\n      case LnF2HnF:\n        plat->type = genPerpetual;\n        plat->low = P_FindLowestFloorSurrounding(sec);\n        if (plat->low > sec->floorheight)\n          plat->low = sec->floorheight;\n        plat->high = P_FindHighestFloorSurrounding(sec);\n        if (plat->high < sec->floorheight)\n          plat->high = sec->floorheight;\n        plat->status = P_Random()&1;\n        break;\n      default:\n        break;\n    }\n\n    // setup the speed of motion\n    switch(Sped)\n    {\n      case SpeedSlow:\n        plat->speed = PLATSPEED * 2;\n        break;\n      case SpeedNormal:\n        plat->speed = PLATSPEED * 4;\n        break;\n      case SpeedFast:\n        plat->speed = PLATSPEED * 8;\n        break;\n      case SpeedTurbo:\n        plat->speed = PLATSPEED * 16;\n        break;\n      default:\n        break;\n    }\n\n    // setup the delay time before the floor returns\n    switch(Dely)\n    {\n      case 0:\n        plat->wait = 1*35;\n        break;\n      case 1:\n        plat->wait = PLATWAIT*35;\n        break;\n      case 2:\n        plat->wait = 5*35;\n        break;\n      case 3:\n        plat->wait = 10*35;\n        break;\n    }\n\n    S_StartSound((mobj_t *)&sec->soundorg,sfx_pstart);\n    P_AddActivePlat(plat); // add this plat to the list of active plats\n\n    if (manual)\n      return rtn;\n  }\n  return rtn;\n}\n\n//\n// EV_DoGenStairs()\n//\n// Handle generalized stair building\n//\n// Passed the linedef activating the stairs\n// Returns true if a thinker is created\n//\nint EV_DoGenStairs\n( line_t*       line )\n{\n  int                   secnum;\n  int                   osecnum; //jff 3/4/98 preserve loop index\n  int                   height;\n  int                   i;\n  int                   newsecnum;\n  int                   texture;\n  int                   ok;\n  int                   rtn;\n  boolean               manual;\n\n  sector_t*             sec;\n  sector_t*             tsec;\n\n  floormove_t*  floor;\n\n  fixed_t               stairsize;\n  fixed_t               speed;\n\n  unsigned              value = (unsigned)line->special - GenStairsBase;\n\n  // parse the bit fields in the line's special type\n\n  int Igno = (value & StairIgnore) >> StairIgnoreShift;\n  int Dirn = (value & StairDirection) >> StairDirectionShift;\n  int Step = (value & StairStep) >> StairStepShift;\n  int Sped = (value & StairSpeed) >> StairSpeedShift;\n\n  rtn = 0;\n\n  // if (ProcessNoTagLines(line, &sec, &secnum)) {if (zerotag_manual) {manual = true; goto manual_stair;} else {return rtn;}};//e6y\n  // check if a manual trigger, if so do just the sector on the backside\n  manual = false;\n  // if (Trig==PushOnce || Trig==PushMany)\n  // {\n  //   if (!(sec = line->backsector))\n  //     return rtn;\n  //   secnum = sec->iSectorID;\n  //   manual = true;\n  //   goto manual_stair;\n  // }\n\n  secnum = -1;\n  // if not manual do all sectors tagged the same as the line\n  while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n  {\n    sec = &sectors[secnum];\n\n    //Do not start another function if floor already moving\n    //jff 2/26/98 add special lockout condition to wait for entire\n    //staircase to build before retriggering\n    if (P_SectorActive(floor_special,sec) || sec->stairlock)\n    {\n      if (!manual)\n        continue;\n      else\n        return rtn;\n    }\n\n    // new floor thinker\n    rtn = 1;\n    floor = Z_Malloc (sizeof(*floor), PU_LEVSPEC, 0);\n    memset(floor, 0, sizeof(*floor));\n    P_AddThinker (&floor->thinker);\n    sec->floordata = floor;\n    floor->thinker.function.acp1 = (actionf_p1) T_MoveFloor;\n    floor->direction = Dirn? 1 : -1;\n    floor->sector = sec;\n\n    // setup speed of stair building\n    switch(Sped)\n      {\n      default:\n      case SpeedSlow:\n        floor->speed = FLOORSPEED/4;\n        break;\n      case SpeedNormal:\n        floor->speed = FLOORSPEED/2;\n        break;\n      case SpeedFast:\n        floor->speed = FLOORSPEED*2;\n        break;\n      case SpeedTurbo:\n        floor->speed = FLOORSPEED*4;\n        break;\n      }\n\n    // setup stepsize for stairs\n    switch(Step)\n    {\n      default:\n      case 0:\n        stairsize = 4*FRACUNIT;\n        break;\n      case 1:\n        stairsize = 8*FRACUNIT;\n        break;\n      case 2:\n        stairsize = 16*FRACUNIT;\n        break;\n      case 3:\n        stairsize = 24*FRACUNIT;\n        break;\n    }\n\n    speed = floor->speed;\n    height = sec->floorheight + floor->direction * stairsize;\n    floor->floordestheight = height;\n    texture = sec->floorpic;\n    floor->crush = false;\n    floor->type = genBuildStair; // jff 3/31/98 do not leave uninited\n\n    sec->stairlock = -2;         // jff 2/26/98 set up lock on current sector\n    sec->nextsec = -1;\n    sec->prevsec = -1;\n\n    osecnum = secnum;            //jff 3/4/98 preserve loop index\n    // Find next sector to raise\n    // 1.     Find 2-sided line with same sector side[0]\n    // 2.     Other side is the next sector to raise\n    do\n    {\n      ok = 0;\n      for (i = 0;i < sec->linecount;i++)\n      {\n        if ( !((sec->lines[i])->backsector) )\n          continue;\n\n        tsec = (sec->lines[i])->frontsector;\n        newsecnum = tsec - sectors;\n\n        if (secnum != newsecnum)\n          continue;\n\n        tsec = (sec->lines[i])->backsector;\n        newsecnum = tsec - sectors;\n\n        if (!Igno && tsec->floorpic != texture)\n          continue;\n\n        /* jff 6/19/98 prevent double stepsize */\n        // if (compatibility_level < boom_202_compatibility)\n        //   height += floor->direction * stairsize;\n\n        //jff 2/26/98 special lockout condition for retriggering\n        if (P_SectorActive(floor_special,tsec) || tsec->stairlock)\n          continue;\n\n        /* jff 6/19/98 increase height AFTER continue */\n        // if (compatibility_level >= boom_202_compatibility)\n        height += floor->direction * stairsize;\n\n        // jff 2/26/98\n        // link the stair chain in both directions\n        // lock the stair sector until building complete\n        sec->nextsec = newsecnum; // link step to next\n        tsec->prevsec = secnum;   // link next back\n        tsec->nextsec = -1;       // set next forward link as end\n        tsec->stairlock = -2;     // lock the step\n\n        sec = tsec;\n        secnum = newsecnum;\n        floor = Z_Malloc (sizeof(*floor), PU_LEVSPEC, 0);\n\n        memset(floor, 0, sizeof(*floor));\n        P_AddThinker (&floor->thinker);\n\n        sec->floordata = floor;\n        floor->thinker.function.acp1 = (actionf_p1) T_MoveFloor;\n        floor->direction = Dirn? 1 : -1;\n        floor->sector = sec;\n        floor->speed = speed;\n        floor->floordestheight = height;\n        floor->crush = false;\n        floor->type = genBuildStair; // jff 3/31/98 do not leave uninited\n\n        ok = 1;\n        break;\n      }\n    } while(ok);\n      if (manual)\n        return rtn;\n      secnum = osecnum; //jff 3/4/98 restore old loop index\n  }\n  // retriggerable generalized stairs build up or down alternately\n  if (rtn)\n    line->special ^= StairDirection; // alternate dir on succ activations\n  return rtn;\n}\n\n//\n// EV_DoGenCrusher()\n//\n// Handle generalized crusher types\n//\n// Passed the linedef activating the crusher\n// Returns true if a thinker created\n//\nint EV_DoGenCrusher\n( line_t*       line )\n{\n  int                   secnum;\n  int                   rtn;\n  boolean               manual;\n  sector_t*             sec;\n  ceiling_t*            ceiling;\n  unsigned              value = (unsigned)line->special - GenCrusherBase;\n\n  // parse the bit fields in the line's special type\n\n  int Slnt = (value & CrusherSilent) >> CrusherSilentShift;\n  int Sped = (value & CrusherSpeed) >> CrusherSpeedShift;\n\n  //jff 2/22/98  Reactivate in-stasis ceilings...for certain types.\n  //jff 4/5/98 return if activated\n  rtn = P_ActivateInStasisCeiling(line);\n\n  // check if a manual trigger, if so do just the sector on the backside\n  manual = false;\n  // if (Trig==PushOnce || Trig==PushMany)\n  // {\n  //   if (!(sec = line->backsector))\n  //     return rtn;\n  //   secnum = sec->iSectorID;\n  //   manual = true;\n  //   goto manual_crusher;\n  // }\n\n  secnum = -1;\n  // if not manual do all sectors tagged the same as the line\n  while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n  {\n    sec = &sectors[secnum];\n\n    // Do not start another function if ceiling already moving\n    if (P_SectorActive(ceiling_special,sec)) //jff 2/22/98\n    {\n      if (!manual)\n        continue;\n      else\n        return rtn;\n    }\n\n    // new ceiling thinker\n    rtn = 1;\n    ceiling = Z_Malloc (sizeof(*ceiling), PU_LEVSPEC, 0);\n    memset(ceiling, 0, sizeof(*ceiling));\n    P_AddThinker (&ceiling->thinker);\n    sec->ceilingdata = ceiling; //jff 2/22/98\n    ceiling->thinker.function.acp1 = (actionf_p1) T_MoveCeiling;\n    ceiling->crush = true;\n    ceiling->direction = -1;\n    ceiling->sector = sec;\n    ceiling->texture = sec->ceilingpic;\n    ceiling->newspecial = sec->special;\n    ceiling->tag = sec->tag;\n    ceiling->type = Slnt? genSilentCrusher : genCrusher;\n    ceiling->topheight = sec->ceilingheight;\n    ceiling->bottomheight = sec->floorheight + (8*FRACUNIT);\n\n    // setup ceiling motion speed\n    switch (Sped)\n    {\n      case SpeedSlow:\n        ceiling->speed = CEILSPEED;\n        break;\n      case SpeedNormal:\n        ceiling->speed = CEILSPEED*2;\n        break;\n      case SpeedFast:\n        ceiling->speed = CEILSPEED*4;\n        break;\n      case SpeedTurbo:\n        ceiling->speed = CEILSPEED*8;\n        break;\n      default:\n        break;\n    }\n    ceiling->oldspeed=ceiling->speed;\n\n    P_AddActiveCeiling(ceiling);  // add to list of active ceilings\n    if (manual) return rtn;\n  }\n  return rtn;\n}\n\n//\n// EV_DoGenLockedDoor()\n//\n// Handle generalized locked door types\n//\n// Passed the linedef activating the generalized locked door\n// Returns true if a thinker created\n//\nint EV_DoGenLockedDoor\n( line_t* line )\n{\n  int   secnum,rtn;\n  sector_t* sec;\n  vldoor_t* door;\n  boolean manual;\n  unsigned  value = (unsigned)line->special - GenLockedBase;\n\n  // parse the bit fields in the line's special type\n\n  int Kind = (value & LockedKind) >> LockedKindShift;\n  int Sped = (value & LockedSpeed) >> LockedSpeedShift;\n\n  rtn = 0;\n\n  // check if a manual trigger, if so do just the sector on the backside\n  manual = false;\n  // if (Trig==PushOnce || Trig==PushMany)\n  // {\n  //   if (!(sec = line->backsector))\n  //     return rtn;\n  //   secnum = sec->iSectorID;\n  //   manual = true;\n  //   goto manual_locked;\n  // }\n\n  secnum = -1;\n  rtn = 0;\n\n  // if not manual do all sectors tagged the same as the line\n  while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n  {\n    sec = &sectors[secnum];\n\n    // Do not start another function if ceiling already moving\n    if (P_SectorActive(ceiling_special,sec)) //jff 2/22/98\n    {\n      if (!manual)\n        continue;\n      else\n        return rtn;\n    }\n\n    // new door thinker\n    rtn = 1;\n    door = Z_Malloc (sizeof(*door), PU_LEVSPEC, 0);\n    memset(door, 0, sizeof(*door));\n    P_AddThinker (&door->thinker);\n    sec->ceilingdata = door; //jff 2/22/98\n\n    door->thinker.function.acp1 = (actionf_p1) T_VerticalDoor;\n    door->sector = sec;\n    door->topwait = VDOORWAIT;\n    door->line = line;\n    door->topheight = P_FindLowestCeilingSurrounding(sec);\n    door->topheight -= 4*FRACUNIT;\n    door->direction = 1;\n\n    /* killough 10/98: implement gradual lighting */\n    door->lighttag = // !comp[comp_doorlight] &&\n      (line->special&6) == 6 &&\n      line->special > GenLockedBase ? line->tag : 0;\n\n    // setup speed of door motion\n    switch(Sped)\n    {\n      default:\n      case SpeedSlow:\n        door->type = Kind? genOpen : genRaise;\n        door->speed = VDOORSPEED;\n        break;\n      case SpeedNormal:\n        door->type = Kind? genOpen : genRaise;\n        door->speed = VDOORSPEED*2;\n        break;\n      case SpeedFast:\n        door->type = Kind? genBlazeOpen : genBlazeRaise;\n        door->speed = VDOORSPEED*4;\n        break;\n      case SpeedTurbo:\n        door->type = Kind? genBlazeOpen : genBlazeRaise;\n        door->speed = VDOORSPEED*8;\n\n        break;\n    }\n\n    // killough 4/15/98: fix generalized door opening sounds\n    // (previously they always had the blazing door close sound)\n\n    S_StartSound((mobj_t *)&door->sector->soundorg,   // killough 4/15/98\n                 door->speed >= VDOORSPEED*4 ? sfx_bdopn : sfx_doropn);\n\n    if (manual)\n      return rtn;\n  }\n  return rtn;\n}\n\n//\n// EV_DoGenDoor()\n//\n// Handle generalized door types\n//\n// Passed the linedef activating the generalized door\n// Returns true if a thinker created\n//\nint EV_DoGenDoor\n( line_t* line )\n{\n  int   secnum,rtn;\n  sector_t* sec;\n  boolean   manual;\n  vldoor_t* door;\n  unsigned  value = (unsigned)line->special - GenDoorBase;\n\n  // parse the bit fields in the line's special type\n\n  int Dely = (value & DoorDelay) >> DoorDelayShift;\n  int Kind = (value & DoorKind) >> DoorKindShift;\n  int Sped = (value & DoorSpeed) >> DoorSpeedShift;\n\n  rtn = 0;\n\n  // check if a manual trigger, if so do just the sector on the backside\n  manual = false;\n  // if (Trig==PushOnce || Trig==PushMany)\n  // {\n  //   if (!(sec = line->backsector))\n  //     return rtn;\n  //   secnum = sec->iSectorID;\n  //   manual = true;\n  //   goto manual_door;\n  // }\n\n\n  secnum = -1;\n  rtn = 0;\n\n  // if not manual do all sectors tagged the same as the line\n  while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n  {\n    sec = &sectors[secnum];\n\n    // Do not start another function if ceiling already moving\n    if (P_SectorActive(ceiling_special,sec)) //jff 2/22/98\n    {\n      if (!manual)\n        continue;\n      else\n        return rtn;\n    }\n\n    // new door thinker\n    rtn = 1;\n    door = Z_Malloc (sizeof(*door), PU_LEVSPEC, 0);\n    memset(door, 0, sizeof(*door));\n    P_AddThinker (&door->thinker);\n    sec->ceilingdata = door; //jff 2/22/98\n\n    door->thinker.function.acp1 = (actionf_p1) T_VerticalDoor;\n    door->sector = sec;\n    // setup delay for door remaining open/closed\n    switch(Dely)\n    {\n      default:\n      case 0:\n        door->topwait = 35;\n        break;\n      case 1:\n        door->topwait = VDOORWAIT;\n        break;\n      case 2:\n        door->topwait = 2*VDOORWAIT;\n        break;\n      case 3:\n        door->topwait = 7*VDOORWAIT;\n        break;\n    }\n\n    // setup speed of door motion\n    switch(Sped)\n    {\n      default:\n      case SpeedSlow:\n        door->speed = VDOORSPEED;\n        break;\n      case SpeedNormal:\n        door->speed = VDOORSPEED*2;\n        break;\n      case SpeedFast:\n        door->speed = VDOORSPEED*4;\n        break;\n      case SpeedTurbo:\n        door->speed = VDOORSPEED*8;\n        break;\n    }\n    door->line = line; // jff 1/31/98 remember line that triggered us\n\n    /* killough 10/98: implement gradual lighting */\n    door->lighttag = // !comp[comp_doorlight] &&\n      (line->special&6) == 6 &&\n      line->special > GenLockedBase ? line->tag : 0;\n\n    // set kind of door, whether it opens then close, opens, closes etc.\n    // assign target heights accordingly\n    switch(Kind)\n    {\n      case OdCDoor:\n        door->direction = 1;\n        door->topheight = P_FindLowestCeilingSurrounding(sec);\n        door->topheight -= 4*FRACUNIT;\n        if (door->topheight != sec->ceilingheight)\n          S_StartSound((mobj_t *)&door->sector->soundorg,Sped>=SpeedFast ? sfx_bdopn : sfx_doropn);\n        door->type = Sped>=SpeedFast? genBlazeRaise : genRaise;\n        break;\n      case ODoor:\n        door->direction = 1;\n        door->topheight = P_FindLowestCeilingSurrounding(sec);\n        door->topheight -= 4*FRACUNIT;\n        if (door->topheight != sec->ceilingheight)\n          S_StartSound((mobj_t *)&door->sector->soundorg,Sped>=SpeedFast ? sfx_bdopn : sfx_doropn);\n        door->type = Sped>=SpeedFast? genBlazeOpen : genOpen;\n        break;\n      case CdODoor:\n        door->topheight = sec->ceilingheight;\n        door->direction = -1;\n        S_StartSound((mobj_t *)&door->sector->soundorg,Sped>=SpeedFast ? sfx_bdcls : sfx_dorcls);\n        door->type = Sped>=SpeedFast? genBlazeCdO : genCdO;\n        break;\n      case CDoor:\n        door->topheight = P_FindLowestCeilingSurrounding(sec);\n        door->topheight -= 4*FRACUNIT;\n        door->direction = -1;\n        S_StartSound((mobj_t *)&door->sector->soundorg,Sped>=SpeedFast ? sfx_bdcls : sfx_dorcls);\n        door->type = Sped>=SpeedFast? genBlazeClose : genClose;\n        break;\n      default:\n        break;\n    }\n    if (manual)\n      return rtn;\n  }\n  return rtn;\n}\n"," /*\n\n Copyright(C) 2005-2014 Simon Howard\n\n This program is free software; you can redistribute it and/or\n modify it under the terms of the GNU General Public License\n as published by the Free Software Foundation; either version 2\n of the License, or (at your option) any later version.\n\n This program is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n\n --\n\n Functions for presenting the information captured from the statistics\n buffer to a file.\n\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"d_player.h\"\n#include \"d_mode.h\"\n#include \"m_argv.h\"\n\n#include \"statdump.h\"\n\n/* Par times for E1M1-E1M9. */\nstatic const int doom1_par_times[] =\n{\n    30, 75, 120, 90, 165, 180, 180, 30, 165,\n};\n\n/* Par times for MAP01-MAP09. */\nstatic const int doom2_par_times[] =\n{\n    30, 90, 120, 120, 90, 150, 120, 120, 270,\n};\n\n/* Player colors. */\nstatic const char *player_colors[] =\n{\n    \"Green\", \"Indigo\", \"Brown\", \"Red\"\n};\n\n// Array of end-of-level statistics that have been captured.\n\n#define MAX_CAPTURES 32\nstatic wbstartstruct_t captured_stats[MAX_CAPTURES];\nstatic int num_captured_stats = 0;\n\nstatic GameMission_t discovered_gamemission = none;\n\n/* Try to work out whether this is a Doom 1 or Doom 2 game, by looking\n * at the episode and map, and the par times.  This is used to decide\n * how to format the level name.  Unfortunately, in some cases it is\n * impossible to determine whether this is Doom 1 or Doom 2. */\n\nstatic void DiscoverGamemode(wbstartstruct_t *stats, int num_stats)\n{\n    int partime;\n    int level;\n    int i;\n\n    if (discovered_gamemission != none)\n    {\n        return;\n    }\n\n    for (i=0; i<num_stats; ++i)\n    {\n        level = stats[i].last;\n\n        /* If episode 2, 3 or 4, this is Doom 1. */\n\n        if (stats[i].epsd > 0)\n        {\n            discovered_gamemission = doom;\n            return;\n        }\n\n        /* This is episode 1.  If this is level 10 or higher,\n           it must be Doom 2. */\n\n        if (level >= 9)\n        {\n            discovered_gamemission = doom2;\n            return;\n        }\n\n        /* Try to work out if this is Doom 1 or Doom 2 by looking\n           at the par time. */\n\n        partime = stats[i].partime;\n\n        if (partime == doom1_par_times[level] * TICRATE\n         && partime != doom2_par_times[level] * TICRATE)\n        {\n            discovered_gamemission = doom;\n            return;\n        }\n\n        if (partime != doom1_par_times[level] * TICRATE\n         && partime == doom2_par_times[level] * TICRATE)\n        {\n            discovered_gamemission = doom2;\n            return;\n        }\n    }\n}\n\n/* Returns the number of players active in the given stats buffer. */\n\nstatic int GetNumPlayers(wbstartstruct_t *stats)\n{\n    int i;\n    int num_players = 0;\n\n    for (i=0; i<MAXPLAYERS; ++i)\n    {\n        if (stats->plyr[i].in)\n        {\n            ++num_players;\n        }\n    }\n\n    return num_players;\n}\n\nstatic void PrintBanner(FILE *stream)\n{\n    fprintf(stream, \"===========================================\\n\");\n}\n\nstatic void PrintPercentage(FILE *stream, int amount, int total)\n{\n    if (total == 0)\n    {\n        fprintf(stream, \"0\");\n    }\n    else\n    {\n        fprintf(stream, \"%i / %i\", amount, total);\n\n        // statdump.exe is a 16-bit program, so very occasionally an\n        // integer overflow can occur when doing this calculation with\n        // a large value. Therefore, cast to short to give the same\n        // output.\n\n        fprintf(stream, \" (%i%%)\", (short) (amount * 100) / total);\n    }\n}\n\n/* Display statistics for a single player. */\n\nstatic void PrintPlayerStats(FILE *stream, wbstartstruct_t *stats,\n        int player_num)\n{\n    wbplayerstruct_t *player = &stats->plyr[player_num];\n\n    fprintf(stream, \"Player %i (%s):\\n\", player_num + 1,\n            player_colors[player_num]);\n\n    /* Kills percentage */\n\n    fprintf(stream, \"\\tKills: \");\n    PrintPercentage(stream, player->skills, stats->maxkills);\n    fprintf(stream, \"\\n\");\n\n    /* Items percentage */\n\n    fprintf(stream, \"\\tItems: \");\n    PrintPercentage(stream, player->sitems, stats->maxitems);\n    fprintf(stream, \"\\n\");\n\n    /* Secrets percentage */\n\n    fprintf(stream, \"\\tSecrets: \");\n    PrintPercentage(stream, player->ssecret, stats->maxsecret);\n    fprintf(stream, \"\\n\");\n}\n\n/* Frags table for multiplayer games. */\n\nstatic void PrintFragsTable(FILE *stream, wbstartstruct_t *stats)\n{\n    int x, y;\n\n    fprintf(stream, \"Frags:\\n\");\n\n    /* Print header */\n\n    fprintf(stream, \"\\t\\t\");\n\n    for (x=0; x<MAXPLAYERS; ++x)\n    {\n\n        if (!stats->plyr[x].in)\n        {\n            continue;\n        }\n\n        fprintf(stream, \"%s\\t\", player_colors[x]);\n    }\n\n    fprintf(stream, \"\\n\");\n\n    fprintf(stream, \"\\t\\t-------------------------------- VICTIMS\\n\");\n\n    /* Print table */\n\n    for (y=0; y<MAXPLAYERS; ++y)\n    {\n        if (!stats->plyr[y].in)\n        {\n            continue;\n        }\n\n        fprintf(stream, \"\\t%s\\t|\", player_colors[y]);\n\n        for (x=0; x<MAXPLAYERS; ++x)\n        {\n            if (!stats->plyr[x].in)\n            {\n                continue;\n            }\n\n            fprintf(stream, \"%i\\t\", stats->plyr[y].frags[x]);\n        }\n\n        fprintf(stream, \"\\n\");\n    }\n\n    fprintf(stream, \"\\t\\t|\\n\");\n    fprintf(stream, \"\\t     KILLERS\\n\");\n}\n\n/* Displays the level name: MAPxy or ExMy, depending on game mode. */\n\nstatic void PrintLevelName(FILE *stream, int episode, int level)\n{\n    PrintBanner(stream);\n\n    switch (discovered_gamemission)\n    {\n\n        case doom:\n            fprintf(stream, \"E%iM%i\\n\", episode + 1, level + 1);\n            break;\n        case doom2:\n            fprintf(stream, \"MAP%02i\\n\", level + 1);\n            break;\n        default:\n        case none:\n            fprintf(stream, \"E%iM%i / MAP%02i\\n\", \n                    episode + 1, level + 1, level + 1);\n            break;\n    }\n\n    PrintBanner(stream);\n}\n\n/* Print details of a statistics buffer to the given file. */\n\nstatic void PrintStats(FILE *stream, wbstartstruct_t *stats)\n{\n    int leveltime, partime;\n    int i;\n\n    PrintLevelName(stream, stats->epsd, stats->last);\n    fprintf(stream, \"\\n\");\n\n    leveltime = stats->plyr[0].stime / TICRATE;\n    partime = stats->partime / TICRATE;\n    fprintf(stream, \"Time: %i:%02i\", leveltime / 60, leveltime % 60);\n    fprintf(stream, \" (par: %i:%02i)\\n\", partime / 60, partime % 60);\n    fprintf(stream, \"\\n\");\n\n    for (i=0; i<MAXPLAYERS; ++i)\n    {\n        if (stats->plyr[i].in)\n        {\n            PrintPlayerStats(stream, stats, i);\n        }\n    }\n\n    if (GetNumPlayers(stats) >= 2)\n    {\n        PrintFragsTable(stream, stats);\n    }\n\n    fprintf(stream, \"\\n\");\n}\n\nvoid StatCopy(wbstartstruct_t *stats)\n{\n    if (M_ParmExists(\"-statdump\") && num_captured_stats < MAX_CAPTURES)\n    {\n        memcpy(&captured_stats[num_captured_stats], stats,\n               sizeof(wbstartstruct_t));\n        ++num_captured_stats;\n    }\n}\n\nvoid StatDump(void)\n{\n    FILE *dumpfile;\n    int i;\n\n    //!\n    // @category compat\n    // @arg <filename>\n    //\n    // Dump statistics information to the specified file on the levels\n    // that were played. The output from this option matches the output\n    // from statdump.exe (see ctrlapi.zip in the /idgames archive).\n    //\n\n    i = M_CheckParmWithArgs(\"-statdump\", 1);\n\n    if (i > 0)\n    {\n        printf(\"Statistics captured for %i level(s)\\n\", num_captured_stats);\n\n        // We actually know what the real gamemission is, but this has\n        // to match the output from statdump.exe.\n\n        DiscoverGamemode(captured_stats, num_captured_stats);\n\n        // Allow \"-\" as output file, for stdout.\n\n        if (strcmp(myargv[i + 1], \"-\") != 0)\n        {\n            dumpfile = fopen(myargv[i + 1], \"w\");\n        }\n        else\n        {\n            dumpfile = NULL;\n        }\n\n        for (i = 0; i < num_captured_stats; ++i)\n        {\n            PrintStats(dumpfile, &captured_stats[i]);\n        }\n\n        if (dumpfile != NULL)\n        {\n            fclose(dumpfile);\n        }\n    }\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tImplements special effects:\n//\tTexture animation, height or lighting changes\n//\t according to adjacent sectors, respective\n//\t utility functions, etc.\n//\tLine Tag handling. Line and Sector triggers.\n//\n\n\n#include <stdlib.h>\n\n#include \"doomdef.h\"\n#include \"doomstat.h\"\n\n#include \"deh_main.h\"\n#include \"i_system.h\"\n#include \"i_swap.h\" // [crispy] LONG()\n#include \"z_zone.h\"\n#include \"m_argv.h\"\n#include \"m_misc.h\"\n#include \"m_random.h\"\n#include \"w_wad.h\"\n\n#include \"r_local.h\"\n#include \"p_local.h\"\n\n#include \"g_game.h\"\n\n#include \"s_sound.h\"\n\n// State.\n#include \"r_state.h\"\n\n// Data.\n#include \"sounds.h\"\n\n#include \"d_englsh.h\"\n\n#define HUSTR_SECRETFOUND\t\"A secret is revealed!\"\n\n//\n//      source animation definition\n//\n// [crispy] change istexture type from int to char and\n// add PACKEDATTR for reading ANIMATED lumps from memory\ntypedef PACKED_STRUCT (\n{\n    signed char\tistexture;\t// if false, it is a flat\n    char\tendname[9];\n    char\tstartname[9];\n    int\t\tspeed;\n}) animdef_t;\n\n\n\n#define MAXANIMS                32\n\n// [crispy] remove MAXANIMS limit\nextern anim_t*\tanims;\nextern anim_t*\tlastanim;\n\n//\n// P_InitPicAnims\n//\n\n// Floor/ceiling animation sequences,\n//  defined by first and last frame,\n//  i.e. the flat (64x64 tile) name to\n//  be used.\n// The full animation sequence is given\n//  using all the flats between the start\n//  and end entry, in the order found in\n//  the WAD file.\n//\n// [crispy] add support for ANIMATED lumps\nanimdef_t\t\tanimdefs_vanilla[] =\n{\n    {false,\t\"NUKAGE3\",\t\"NUKAGE1\",\t8},\n    {false,\t\"FWATER4\",\t\"FWATER1\",\t8},\n    {false,\t\"SWATER4\",\t\"SWATER1\", \t8},\n    {false,\t\"LAVA4\",\t\"LAVA1\",\t8},\n    {false,\t\"BLOOD3\",\t\"BLOOD1\",\t8},\n\n    // DOOM II flat animations.\n    {false,\t\"RROCK08\",\t\"RROCK05\",\t8},\t\t\n    {false,\t\"SLIME04\",\t\"SLIME01\",\t8},\n    {false,\t\"SLIME08\",\t\"SLIME05\",\t8},\n    {false,\t\"SLIME12\",\t\"SLIME09\",\t8},\n\n    {true,\t\"BLODGR4\",\t\"BLODGR1\",\t8},\n    {true,\t\"SLADRIP3\",\t\"SLADRIP1\",\t8},\n\n    {true,\t\"BLODRIP4\",\t\"BLODRIP1\",\t8},\n    {true,\t\"FIREWALL\",\t\"FIREWALA\",\t8},\n    {true,\t\"GSTFONT3\",\t\"GSTFONT1\",\t8},\n    {true,\t\"FIRELAVA\",\t\"FIRELAV3\",\t8},\n    {true,\t\"FIREMAG3\",\t\"FIREMAG1\",\t8},\n    {true,\t\"FIREBLU2\",\t\"FIREBLU1\",\t8},\n    {true,\t\"ROCKRED3\",\t\"ROCKRED1\",\t8},\n\n    {true,\t\"BFALL4\",\t\"BFALL1\",\t8},\n    {true,\t\"SFALL4\",\t\"SFALL1\",\t8},\n    {true,\t\"WFALL4\",\t\"WFALL1\",\t8},\n    {true,\t\"DBRAIN4\",\t\"DBRAIN1\",\t8},\n\t\n    {-1,        \"\",             \"\",             0},\n};\n\n// [crispy] remove MAXANIMS limit\nanim_t*\t\tanims;\nanim_t*\t\tlastanim;\nstatic size_t\tmaxanims;\n\n\n//\n//      Animating line specials\n//\n#define MAXLINEANIMS            64*256\n\nextern  short\tnumlinespecials;\nextern  line_t*\tlinespeciallist[MAXLINEANIMS];\n\n\n\nvoid P_InitPicAnims (void)\n{\n    int\t\ti;\n\n    // [crispy] add support for ANIMATED lumps\n    animdef_t *animdefs;\n    const boolean from_lump = (W_CheckNumForName(\"ANIMATED\") != -1);\n\n    if (from_lump)\n    {\n\tanimdefs = W_CacheLumpName(\"ANIMATED\", PU_STATIC);\n    }\n    else\n    {\n\tanimdefs = animdefs_vanilla;\n    }\n    \n    //\tInit animation\n    lastanim = anims;\n    for (i=0 ; animdefs[i].istexture != -1 ; i++)\n    {\n        const char *startname, *endname;\n\n\t// [crispy] remove MAXANIMS limit\n\tif (lastanim >= anims + maxanims)\n\t{\n\t    size_t newmax = maxanims ? 2 * maxanims : MAXANIMS;\n\t    anims = I_Realloc(anims, newmax * sizeof(*anims));\n\t    lastanim = anims + maxanims;\n\t    maxanims = newmax;\n\t}\n\n        startname = DEH_String(animdefs[i].startname);\n        endname = DEH_String(animdefs[i].endname);\n\n\tif (animdefs[i].istexture)\n\t{\n\t    // different episode ?\n\t    if (R_CheckTextureNumForName(startname) == -1)\n\t\tcontinue;\t\n\n\t    lastanim->picnum = R_TextureNumForName(endname);\n\t    lastanim->basepic = R_TextureNumForName(startname);\n\t}\n\telse\n\t{\n\t    if (W_CheckNumForName(startname) == -1)\n\t\tcontinue;\n\n\t    lastanim->picnum = R_FlatNumForName(endname);\n\t    lastanim->basepic = R_FlatNumForName(startname);\n\t}\n\n\tlastanim->istexture = animdefs[i].istexture;\n\tlastanim->numpics = lastanim->picnum - lastanim->basepic + 1;\n\n\tif (lastanim->numpics < 2)\n\t    I_Error (\"P_InitPicAnims: bad cycle from %s to %s\",\n\t\t     startname, endname);\n\t\n\tlastanim->speed = from_lump ? LONG(animdefs[i].speed) : animdefs[i].speed;\n\tlastanim++;\n    }\n\t\n    if (from_lump)\n    {\n\tZ_ChangeTag(animdefs, PU_CACHE);\n    }\n}\n\n\n\n//\n// UTILITIES\n//\n\n\n\n//\n// getSide()\n// Will return a side_t*\n//  given the number of the current sector,\n//  the line number, and the side (0/1) that you want.\n//\nside_t*\ngetSide\n( int\t\tcurrentSector,\n  int\t\tline,\n  int\t\tside )\n{\n    return &sides[ (sectors[currentSector].lines[line])->sidenum[side] ];\n}\n\n\n//\n// getSector()\n// Will return a sector_t*\n//  given the number of the current sector,\n//  the line number and the side (0/1) that you want.\n//\nsector_t*\ngetSector\n( int\t\tcurrentSector,\n  int\t\tline,\n  int\t\tside )\n{\n    return sides[ (sectors[currentSector].lines[line])->sidenum[side] ].sector;\n}\n\n\n//\n// twoSided()\n// Given the sector number and the line number,\n//  it will tell you whether the line is two-sided or not.\n//\nint\ntwoSided\n( int\tsector,\n  int\tline )\n{\n    return (sectors[sector].lines[line])->flags & ML_TWOSIDED;\n}\n\n\n\n\n//\n// getNextSector()\n// Return sector_t * of sector next to current.\n// NULL if not two-sided line\n//\nsector_t*\ngetNextSector\n( line_t*\tline,\n  sector_t*\tsec )\n{\n    if (!(line->flags & ML_TWOSIDED))\n\treturn NULL;\n\t\t\n    if (line->frontsector == sec)\n\treturn line->backsector;\n\t\n    return line->frontsector;\n}\n\n\n\n//\n// P_FindLowestFloorSurrounding()\n// FIND LOWEST FLOOR HEIGHT IN SURROUNDING SECTORS\n//\nfixed_t\tP_FindLowestFloorSurrounding(sector_t* sec)\n{\n    int\t\t\ti;\n    line_t*\t\tcheck;\n    sector_t*\t\tother;\n    fixed_t\t\tfloor = sec->floorheight;\n\t\n    for (i=0 ;i < sec->linecount ; i++)\n    {\n\tcheck = sec->lines[i];\n\tother = getNextSector(check,sec);\n\n\tif (!other)\n\t    continue;\n\t\n\tif (other->floorheight < floor)\n\t    floor = other->floorheight;\n    }\n    return floor;\n}\n\n\n\n//\n// P_FindHighestFloorSurrounding()\n// FIND HIGHEST FLOOR HEIGHT IN SURROUNDING SECTORS\n//\nfixed_t\tP_FindHighestFloorSurrounding(sector_t *sec)\n{\n    int\t\t\ti;\n    line_t*\t\tcheck;\n    sector_t*\t\tother;\n    fixed_t\t\tfloor = -500*FRACUNIT;\n\t\n    for (i=0 ;i < sec->linecount ; i++)\n    {\n\tcheck = sec->lines[i];\n\tother = getNextSector(check,sec);\n\t\n\tif (!other)\n\t    continue;\n\t\n\tif (other->floorheight > floor)\n\t    floor = other->floorheight;\n    }\n    return floor;\n}\n\n\n\n//\n// P_FindNextHighestFloor\n// FIND NEXT HIGHEST FLOOR IN SURROUNDING SECTORS\n// Note: this should be doable w/o a fixed array.\n\n// Thanks to entryway for the Vanilla overflow emulation.\n\n// 20 adjoining sectors max!\n#define MAX_ADJOINING_SECTORS     20\n\nfixed_t\nP_FindNextHighestFloor\n( sector_t* sec,\n  int       currentheight )\n{\n    int         i;\n    int         h;\n    int         min;\n    line_t*     check;\n    sector_t*   other;\n    fixed_t     height = currentheight;\n    static fixed_t *heightlist = NULL;\n    static int heightlist_size = 0;\n\n    // [crispy] remove MAX_ADJOINING_SECTORS Vanilla limit\n    // from prboom-plus/src/p_spec.c:404-411\n    if (sec->linecount > heightlist_size)\n    {\n\tdo\n\t{\n\t    heightlist_size = heightlist_size ? 2 * heightlist_size : MAX_ADJOINING_SECTORS;\n\t} while (sec->linecount > heightlist_size);\n\theightlist = I_Realloc(heightlist, heightlist_size * sizeof(*heightlist));\n    }\n\n    for (i=0, h=0; i < sec->linecount; i++)\n    {\n        check = sec->lines[i];\n        other = getNextSector(check,sec);\n\n        if (!other)\n            continue;\n        \n        if (other->floorheight > height)\n        {\n            // Emulation of memory (stack) overflow\n            if (h == MAX_ADJOINING_SECTORS + 1)\n            {\n                height = other->floorheight;\n            }\n            else if (h == MAX_ADJOINING_SECTORS + 2)\n            {\n                // Fatal overflow: game crashes at 22 sectors\n                fprintf(stderr, \"Sector with more than 22 adjoining sectors. \"\n                        \"Vanilla will crash here\\n\");\n            }\n\n            heightlist[h++] = other->floorheight;\n        }\n    }\n    \n    // Find lowest height in list\n    if (!h)\n    {\n        return currentheight;\n    }\n        \n    min = heightlist[0];\n    \n    // Range checking? \n    for (i = 1; i < h; i++)\n    {\n        if (heightlist[i] < min)\n        {\n            min = heightlist[i];\n        }\n    }\n\n    return min;\n}\n\n//\n// FIND LOWEST CEILING IN THE SURROUNDING SECTORS\n//\nfixed_t\nP_FindLowestCeilingSurrounding(sector_t* sec)\n{\n    int\t\t\ti;\n    line_t*\t\tcheck;\n    sector_t*\t\tother;\n    fixed_t\t\theight = INT_MAX;\n\t\n    for (i=0 ;i < sec->linecount ; i++)\n    {\n\tcheck = sec->lines[i];\n\tother = getNextSector(check,sec);\n\n\tif (!other)\n\t    continue;\n\n\tif (other->ceilingheight < height)\n\t    height = other->ceilingheight;\n    }\n    return height;\n}\n\n\n//\n// FIND HIGHEST CEILING IN THE SURROUNDING SECTORS\n//\nfixed_t\tP_FindHighestCeilingSurrounding(sector_t* sec)\n{\n    int\t\ti;\n    line_t*\tcheck;\n    sector_t*\tother;\n    fixed_t\theight = 0;\n\t\n    for (i=0 ;i < sec->linecount ; i++)\n    {\n\tcheck = sec->lines[i];\n\tother = getNextSector(check,sec);\n\n\tif (!other)\n\t    continue;\n\n\tif (other->ceilingheight > height)\n\t    height = other->ceilingheight;\n    }\n    return height;\n}\n\n\n\n//\n// RETURN NEXT SECTOR # THAT LINE TAG REFERS TO\n//\nint\nP_FindSectorFromLineTag\n( line_t*\tline,\n  int\t\tstart )\n{\n    int\ti;\n\t\n    // [crispy] linedefs without tags apply locally\n    if (!line->tag)\n    {\n    for (i=start+1;i<numsectors;i++)\n\tif (&sectors[i] == line->backsector)\n\t{\n\t    // const long linedef = line - lines;\n\t    // fprintf(stderr, \"P_FindSectorFromLineTag: Linedef %ld without tag applied to sector %d\\n\", linedef, i);\n\t    return i;\n\t}\n    }\n    else\n    for (i=start+1;i<numsectors;i++)\n\tif (sectors[i].tag == line->tag)\n\t    return i;\n    \n    return -1;\n}\n\n\n\n\n//\n// Find minimum light from an adjacent sector\n//\nint\nP_FindMinSurroundingLight\n( sector_t*\tsector,\n  int\t\tmax )\n{\n    int\t\ti;\n    int\t\tmin;\n    line_t*\tline;\n    sector_t*\tcheck;\n\t\n    min = max;\n    for (i=0 ; i < sector->linecount ; i++)\n    {\n\tline = sector->lines[i];\n\tcheck = getNextSector(line,sector);\n\n\tif (!check)\n\t    continue;\n\n\tif (check->lightlevel < min)\n\t    min = check->lightlevel;\n    }\n    return min;\n}\n\n\n\n//\n// EVENTS\n// Events are operations triggered by using, crossing,\n// or shooting special lines, or by timed thinkers.\n//\n\n//\n// P_CrossSpecialLine - TRIGGER\n// Called every time a thing origin is about\n//  to cross a line with a non 0 special.\n//\nvoid\nP_CrossSpecialLine\n( int\t\tlinenum,\n  int\t\tside,\n  mobj_t*\tthing )\n{\n    return P_CrossSpecialLinePtr(&lines[linenum], side, thing);\n}\n\n// [crispy] more MBF code pointers\nvoid\nP_CrossSpecialLinePtr\n( line_t*\tline,\n  int\t\tside,\n  mobj_t*\tthing )\n{\n//  line_t*\tline;\n    int\t\tok;\n\n//  line = &lines[linenum];\n    \n    //\tTriggers that other things can activate\n    if (!thing->player)\n    {\n\t// Things that should NOT trigger specials...\n\tswitch(thing->type)\n\t{\n\t  case MT_ROCKET:\n\t  case MT_PLASMA:\n\t  case MT_BFG:\n\t  case MT_TROOPSHOT:\n\t  case MT_HEADSHOT:\n\t  case MT_BRUISERSHOT:\n\t    return;\n\t    break;\n\t    \n\t  default: break;\n\t}\n\t}\n\n\t// pointer to line function is NULL by default, set non-null if\n    // line special is walkover generalized linedef type\n    int (*linefunc)(line_t *line)=NULL;\n\n    // check each range of generalized linedefs\n    if ((unsigned)line->special >= GenEnd)\n    {\n      // Out of range for GenFloors\n    }\n    else if ((unsigned)line->special >= GenFloorBase)\n    {\n      if (!thing->player)\n        if ((line->special & FloorChange) || !(line->special & FloorModel))\n          return; // FloorModel is \"Allow Monsters\" if FloorChange is 0\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return;                         // generalized types require tag\n      linefunc = EV_DoGenFloor;\n    }\n    else if ((unsigned)line->special >= GenCeilingBase)\n    {\n      if (!thing->player)\n        if ((line->special & CeilingChange) || !(line->special & CeilingModel))\n          return;   // CeilingModel is \"Allow Monsters\" if CeilingChange is 0\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return;                         // generalized types require tag\n      linefunc = EV_DoGenCeiling;\n    }\n    else if ((unsigned)line->special >= GenDoorBase)\n    {\n      if (!thing->player)\n      {\n        if (!(line->special & DoorMonster))\n          return;   // monsters disallowed from this door\n        if (line->flags & ML_SECRET) // they can't open secret doors either\n          return;\n      }\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 3/2/98 all non-manual\n        return;                         // generalized types require tag\n      linefunc = EV_DoGenDoor;\n    }\n    else if ((unsigned)line->special >= GenLockedBase)\n    {\n      if (!thing->player)\n        return;   // monsters disallowed from unlocking doors\n      if (!P_CanUnlockGenDoor(line,thing->player))\n        return;\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return;                         // generalized types require tag\n\n      linefunc = EV_DoGenLockedDoor;\n    }\n    else if ((unsigned)line->special >= GenLiftBase)\n    {\n      if (!thing->player)\n        if (!(line->special & LiftMonster))\n          return; // monsters disallowed\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return;                         // generalized types require tag\n      linefunc = EV_DoGenLift;\n    }\n    else if ((unsigned)line->special >= GenStairsBase)\n    {\n      if (!thing->player)\n        if (!(line->special & StairMonster))\n          return; // monsters disallowed\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return;                         // generalized types require tag\n      linefunc = EV_DoGenStairs;\n    }\n    else if ((unsigned)line->special >= GenCrusherBase)\n    {\n      if (!thing->player)\n        if (!(line->special & CrusherMonster))\n          return; // monsters disallowed\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return;                         // generalized types require tag\n      linefunc = EV_DoGenCrusher;\n    }\n\n    if (linefunc) // if it was a valid generalized type\n      switch((line->special & TriggerType) >> TriggerTypeShift)\n      {\n        case WalkOnce:\n          if (linefunc(line))\n            line->special = 0;    // clear special if a walk once type\n          return;\n        case WalkMany:\n          linefunc(line);\n          return;\n        default:                  // if not a walk type, do nothing here\n          return;\n      }\n\t\t\n\tif (!thing->player)\n    {\n\tok = 0;\n\tswitch(line->special)\n\t{\n\t  case 39:\t// TELEPORT TRIGGER\n\t  case 97:\t// TELEPORT RETRIGGER\n\t  case 125:\t// TELEPORT MONSTERONLY TRIGGER\n\t  case 126:\t// TELEPORT MONSTERONLY RETRIGGER\n\t  case 4:\t// RAISE DOOR\n\t  case 10:\t// PLAT DOWN-WAIT-UP-STAY TRIGGER\n\t  case 88:\t// PLAT DOWN-WAIT-UP-STAY RETRIGGER\n\t\t//jff 3/5/98 add ability of monsters etc. to use teleporters\n      case 208:     //silent thing teleporters\n      case 207:\n      case 243:     //silent line-line teleporter\n      case 244:     //jff 3/6/98 make fit within DCK's 256 linedef types\n      case 262:     //jff 4/14/98 add monster only\n      case 263:     //jff 4/14/98 silent thing,line,line rev types\n      case 264:     //jff 4/14/98 plus player/monster silent line\n      case 265:     //            reversed types\n      case 266:\n      case 267:\n      case 268:\n      case 269:\n\t    ok = 1;\n\t  \tbreak;\n\t}\n\tif (!ok)\n\t    return;\n    }\n\n    \n    // Note: could use some const's here.\n    switch (line->special)\n    {\n\t// TRIGGERS.\n\t// All from here to RETRIGGERS.\n      case 2:\n\t// Open Door\n\tEV_DoDoor(line,openDoor);\n\tline->special = 0;\n\tbreak;\n\n      case 3:\n\t// Close Door\n\tEV_DoDoor(line,closeDoor);\n\tline->special = 0;\n\tbreak;\n\n      case 4:\n\t// Raise Door\n\tEV_DoDoor(line,normal);\n\tline->special = 0;\n\tbreak;\n\t\n      case 5:\n\t// Raise Floor\n\tEV_DoFloor(line,raiseFloor);\n\tline->special = 0;\n\tbreak;\n\t\n      case 6:\n\t// Fast Ceiling Crush & Raise\n\tEV_DoCeiling(line,fastCrushAndRaise);\n\tline->special = 0;\n\tbreak;\n\t\n      case 8:\n\t// Build Stairs\n\tEV_BuildStairs(line,build8);\n\tline->special = 0;\n\tbreak;\n\t\n      case 10:\n\t// PlatDownWaitUp\n\tEV_DoPlat(line,downWaitUpStay,0);\n\tline->special = 0;\n\tbreak;\n\t\n      case 12:\n\t// Light Turn On - brightest near\n\tEV_LightTurnOn(line,0);\n\tline->special = 0;\n\tbreak;\n\t\n      case 13:\n\t// Light Turn On 255\n\tEV_LightTurnOn(line,255);\n\tline->special = 0;\n\tbreak;\n\t\n      case 16:\n\t// Close Door 30\n\tEV_DoDoor(line,close30ThenOpen);\n\tline->special = 0;\n\tbreak;\n\t\n      case 17:\n\t// Start Light Strobing\n\tEV_StartLightStrobing(line);\n\tline->special = 0;\n\tbreak;\n\t\n      case 19:\n\t// Lower Floor\n\tEV_DoFloor(line,lowerFloor);\n\tline->special = 0;\n\tbreak;\n\t\n      case 22:\n\t// Raise floor to nearest height and change texture\n\tEV_DoPlat(line,raiseToNearestAndChange,0);\n\tline->special = 0;\n\tbreak;\n\t\n      case 25:\n\t// Ceiling Crush and Raise\n\tEV_DoCeiling(line,crushAndRaise);\n\tline->special = 0;\n\tbreak;\n\t\n      case 30:\n\t// Raise floor to shortest texture height\n\t//  on either side of lines.\n\tEV_DoFloor(line,raiseToTexture);\n\tline->special = 0;\n\tbreak;\n\t\n      case 35:\n\t// Lights Very Dark\n\tEV_LightTurnOn(line,35);\n\tline->special = 0;\n\tbreak;\n\t\n      case 36:\n\t// Lower Floor (TURBO)\n\tEV_DoFloor(line,turboLower);\n\tline->special = 0;\n\tbreak;\n\t\n      case 37:\n\t// LowerAndChange\n\tEV_DoFloor(line,lowerAndChange);\n\tline->special = 0;\n\tbreak;\n\t\n      case 38:\n\t// Lower Floor To Lowest\n\tEV_DoFloor( line, lowerFloorToLowest );\n\tline->special = 0;\n\tbreak;\n\t\n      case 39:\n\t// TELEPORT!\n\tEV_Teleport( line, side, thing );\n\tline->special = 0;\n\tbreak;\n\n      case 40:\n\t// RaiseCeilingLowerFloor\n\tEV_DoCeiling( line, raiseToHighest );\n\tEV_DoFloor( line, lowerFloorToLowest );\n\tline->special = 0;\n\tbreak;\n\t\n      case 44:\n\t// Ceiling Crush\n\tEV_DoCeiling( line, lowerAndCrush );\n\tline->special = 0;\n\tbreak;\n\t\n      case 52:\n\t// EXIT!\n\tG_ExitLevel ();\n\tbreak;\n\t\n      case 53:\n\t// Perpetual Platform Raise\n\tEV_DoPlat(line,perpetualRaise,0);\n\tline->special = 0;\n\tbreak;\n\t\n      case 54:\n\t// Platform Stop\n\tEV_StopPlat(line);\n\tline->special = 0;\n\tbreak;\n\n      case 56:\n\t// Raise Floor Crush\n\tEV_DoFloor(line,raiseFloorCrush);\n\tline->special = 0;\n\tbreak;\n\n      case 57:\n\t// Ceiling Crush Stop\n\tEV_CeilingCrushStop(line);\n\tline->special = 0;\n\tbreak;\n\t\n      case 58:\n\t// Raise Floor 24\n\tEV_DoFloor(line,raiseFloor24);\n\tline->special = 0;\n\tbreak;\n\n      case 59:\n\t// Raise Floor 24 And Change\n\tEV_DoFloor(line,raiseFloor24AndChange);\n\tline->special = 0;\n\tbreak;\n\n\t  case 100:\n\t// Build Stairs Turbo 16\n\tEV_BuildStairs(line,turbo16);\n\tline->special = 0;\n\tbreak;\n\t\n      case 104:\n\t// Turn lights off in sector(tag)\n\tEV_TurnTagLightsOff(line);\n\tline->special = 0;\n\tbreak;\n\t\n      case 108:\n\t// Blazing Door Raise (faster than TURBO!)\n\tEV_DoDoor (line,blazeRaise);\n\tline->special = 0;\n\tbreak;\n\t\n      case 109:\n\t// Blazing Door Open (faster than TURBO!)\n\tEV_DoDoor (line,blazeOpen);\n\tline->special = 0;\n\tbreak;\n\t\n      case 110:\n\t// Blazing Door Close (faster than TURBO!)\n\tEV_DoDoor (line,blazeClose);\n\tline->special = 0;\n\tbreak;\n\n      case 119:\n\t// Raise floor to nearest surr. floor\n\tEV_DoFloor(line,raiseFloorToNearest);\n\tline->special = 0;\n\tbreak;\n\t\n      case 121:\n\t// Blazing PlatDownWaitUpStay\n\tEV_DoPlat(line,blazeDWUS,0);\n\tline->special = 0;\n\tbreak;\n\t\n      case 124:\n\t// Secret EXIT\n\tG_SecretExitLevel ();\n\tbreak;\n\t\t\n      case 125:\n\t// TELEPORT MonsterONLY\n\tif (!thing->player)\n\t{\n\t    EV_Teleport( line, side, thing );\n\t    line->special = 0;\n\t}\n\tbreak;\n\t\n      case 130:\n\t// Raise Floor Turbo\n\tEV_DoFloor(line,raiseFloorTurbo);\n\tline->special = 0;\n\tbreak;\n\t\n      case 141:\n\t// Silent Ceiling Crush & Raise\n\tEV_DoCeiling(line,silentCrushAndRaise);\n\tline->special = 0;\n\tbreak;\n\t\n\t// RETRIGGERS.  All from here till end.\n      case 72:\n\t// Ceiling Crush\n\tEV_DoCeiling( line, lowerAndCrush );\n\tbreak;\n\n      case 73:\n\t// Ceiling Crush and Raise\n\tEV_DoCeiling(line,crushAndRaise);\n\tbreak;\n\n      case 74:\n\t// Ceiling Crush Stop\n\tEV_CeilingCrushStop(line);\n\tbreak;\n\t\n      case 75:\n\t// Close Door\n\tEV_DoDoor(line,closeDoor);\n\tbreak;\n\t\n      case 76:\n\t// Close Door 30\n\tEV_DoDoor(line,close30ThenOpen);\n\tbreak;\n\t\n      case 77:\n\t// Fast Ceiling Crush & Raise\n\tEV_DoCeiling(line,fastCrushAndRaise);\n\tbreak;\n\t\n      case 79:\n\t// Lights Very Dark\n\tEV_LightTurnOn(line,35);\n\tbreak;\n\t\n      case 80:\n\t// Light Turn On - brightest near\n\tEV_LightTurnOn(line,0);\n\tbreak;\n\t\n      case 81:\n\t// Light Turn On 255\n\tEV_LightTurnOn(line,255);\n\tbreak;\n\t\n      case 82:\n\t// Lower Floor To Lowest\n\tEV_DoFloor( line, lowerFloorToLowest );\n\tbreak;\n\t\n      case 83:\n\t// Lower Floor\n\tEV_DoFloor(line,lowerFloor);\n\tbreak;\n\n      case 84:\n\t// LowerAndChange\n\tEV_DoFloor(line,lowerAndChange);\n\tbreak;\n\n      case 86:\n\t// Open Door\n\tEV_DoDoor(line,openDoor);\n\tbreak;\n\t\n      case 87:\n\t// Perpetual Platform Raise\n\tEV_DoPlat(line,perpetualRaise,0);\n\tbreak;\n\t\n      case 88:\n\t// PlatDownWaitUp\n\tEV_DoPlat(line,downWaitUpStay,0);\n\tbreak;\n\t\n      case 89:\n\t// Platform Stop\n\tEV_StopPlat(line);\n\tbreak;\n\t\n      case 90:\n\t// Raise Door\n\tEV_DoDoor(line,normal);\n\tbreak;\n\t\n      case 91:\n\t// Raise Floor\n\tEV_DoFloor(line,raiseFloor);\n\tbreak;\n\t\n      case 92:\n\t// Raise Floor 24\n\tEV_DoFloor(line,raiseFloor24);\n\tbreak;\n\t\n      case 93:\n\t// Raise Floor 24 And Change\n\tEV_DoFloor(line,raiseFloor24AndChange);\n\tbreak;\n\t\n      case 94:\n\t// Raise Floor Crush\n\tEV_DoFloor(line,raiseFloorCrush);\n\tbreak;\n\t\n      case 95:\n\t// Raise floor to nearest height\n\t// and change texture.\n\tEV_DoPlat(line,raiseToNearestAndChange,0);\n\tbreak;\n\t\n      case 96:\n\t// Raise floor to shortest texture height\n\t// on either side of lines.\n\tEV_DoFloor(line,raiseToTexture);\n\tbreak;\n\t\n      case 97:\n\t// TELEPORT!\n\tEV_Teleport( line, side, thing );\n\tbreak;\n\t\n      case 98:\n\t// Lower Floor (TURBO)\n\tEV_DoFloor(line,turboLower);\n\tbreak;\n\n      case 105:\n\t// Blazing Door Raise (faster than TURBO!)\n\tEV_DoDoor (line,blazeRaise);\n\tbreak;\n\t\n      case 106:\n\t// Blazing Door Open (faster than TURBO!)\n\tEV_DoDoor (line,blazeOpen);\n\tbreak;\n\n      case 107:\n\t// Blazing Door Close (faster than TURBO!)\n\tEV_DoDoor (line,blazeClose);\n\tbreak;\n\n      case 120:\n\t// Blazing PlatDownWaitUpStay.\n\tEV_DoPlat(line,blazeDWUS,0);\n\tbreak;\n\t\n      case 126:\n\t// TELEPORT MonsterONLY.\n\tif (!thing->player)\n\t    EV_Teleport( line, side, thing );\n\tbreak;\n\t\n      case 128:\n\t// Raise To Nearest Floor\n\tEV_DoFloor(line,raiseFloorToNearest);\n\tbreak;\n\t\n      case 129:\n\t// Raise Floor Turbo\n\tEV_DoFloor(line,raiseFloorTurbo);\n\tbreak;\n\n\t\t// Extended walk triggers\n\n      // jff 1/29/98 added new linedef types to fill all functions out so that\n      // all have varieties SR, S1, WR, W1\n\n      // killough 1/31/98: \"factor out\" compatibility test, by\n      // adding inner switch qualified by compatibility flag.\n      // relax test to demo_compatibility\n\n      // killough 2/16/98: Fix problems with W1 types being cleared too early\n\n\t  // Extended walk once triggers\n\n          case 142:\n            // Raise Floor 512\n            // 142 W1  EV_DoFloor(raiseFloor512)\n            if (EV_DoFloor(line,raiseFloor512))\n              line->special = 0;\n            break;\n\n          case 143:\n            // Raise Floor 24 and change\n            // 143 W1  EV_DoPlat(raiseAndChange,24)\n            if (EV_DoPlat(line,raiseAndChange,24))\n              line->special = 0;\n            break;\n\n          case 144:\n            // Raise Floor 32 and change\n            // 144 W1  EV_DoPlat(raiseAndChange,32)\n            if (EV_DoPlat(line,raiseAndChange,32))\n              line->special = 0;\n            break;\n\n          case 145:\n            // Lower Ceiling to Floor\n            // 145 W1  EV_DoCeiling(lowerToFloor)\n            if (EV_DoCeiling( line, lowerToFloor ))\n              line->special = 0;\n            break;\n\n          case 146:\n            // Lower Pillar, Raise Donut\n            // 146 W1  EV_DoDonut()\n            if (EV_DoDonut(line))\n              line->special = 0;\n            break;\n\n          case 199:\n            // Lower ceiling to lowest surrounding ceiling\n            // 199 W1 EV_DoCeiling(lowerToLowest)\n            if (EV_DoCeiling(line,lowerToLowest))\n              line->special = 0;\n            break;\n\n          case 200:\n            // Lower ceiling to highest surrounding floor\n            // 200 W1 EV_DoCeiling(lowerToMaxFloor)\n            if (EV_DoCeiling(line,lowerToMaxFloor))\n              line->special = 0;\n            break;\n\n          case 207:\n            // killough 2/16/98: W1 silent teleporter (normal kind)\n            if (EV_SilentTeleport(line, side, thing))\n              line->special = 0;\n            break;\n\n            //jff 3/16/98 renumber 215->153\n          case 153: //jff 3/15/98 create texture change no motion type\n            // Texture/Type Change Only (Trig)\n            // 153 W1 Change Texture/Type Only\n            if (EV_DoChange(line,trigChangeOnly))\n              line->special = 0;\n            break;\n\n          case 239: //jff 3/15/98 create texture change no motion type\n            // Texture/Type Change Only (Numeric)\n            // 239 W1 Change Texture/Type Only\n            if (EV_DoChange(line,numChangeOnly))\n              line->special = 0;\n            break;\n\n          case 219:\n            // Lower floor to next lower neighbor\n            // 219 W1 Lower Floor Next Lower Neighbor\n            if (EV_DoFloor(line,lowerFloorToNearest))\n              line->special = 0;\n            break;\n\n          case 227:\n            // Raise elevator next floor\n            // 227 W1 Raise Elevator next floor\n            if (EV_DoElevator(line,elevateUp))\n              line->special = 0;\n            break;\n\n          case 231:\n            // Lower elevator next floor\n            // 231 W1 Lower Elevator next floor\n            if (EV_DoElevator(line,elevateDown))\n              line->special = 0;\n            break;\n\n          case 235:\n            // Elevator to current floor\n            // 235 W1 Elevator to current floor\n            if (EV_DoElevator(line,elevateCurrent))\n              line->special = 0;\n            break;\n\n          case 243: //jff 3/6/98 make fit within DCK's 256 linedef types\n            // killough 2/16/98: W1 silent teleporter (linedef-linedef kind)\n            if (EV_SilentLineTeleport(line, side, thing, false))\n              line->special = 0;\n            break;\n\n          case 262: //jff 4/14/98 add silent line-line reversed\n            if (EV_SilentLineTeleport(line, side, thing, true))\n              line->special = 0;\n            break;\n\n          case 264: //jff 4/14/98 add monster-only silent line-line reversed\n            if (!thing->player &&\n                EV_SilentLineTeleport(line, side, thing, true))\n              line->special = 0;\n            break;\n\n          case 266: //jff 4/14/98 add monster-only silent line-line\n            if (!thing->player &&\n                EV_SilentLineTeleport(line, side, thing, false))\n              line->special = 0;\n            break;\n\n          case 268: //jff 4/14/98 add monster-only silent\n            if (!thing->player && EV_SilentTeleport(line, side, thing))\n              line->special = 0;\n            break;\n\n          //jff 1/29/98 end of added W1 linedef types\n\n          // Extended walk many retriggerable\n\n          //jff 1/29/98 added new linedef types to fill all functions\n          //out so that all have varieties SR, S1, WR, W1\n\n          case 147:\n            // Raise Floor 512\n            // 147 WR  EV_DoFloor(raiseFloor512)\n            EV_DoFloor(line,raiseFloor512);\n            break;\n\n          case 148:\n            // Raise Floor 24 and Change\n            // 148 WR  EV_DoPlat(raiseAndChange,24)\n            EV_DoPlat(line,raiseAndChange,24);\n            break;\n\n          case 149:\n            // Raise Floor 32 and Change\n            // 149 WR  EV_DoPlat(raiseAndChange,32)\n            EV_DoPlat(line,raiseAndChange,32);\n            break;\n\n          case 150:\n            // Start slow silent crusher\n            // 150 WR  EV_DoCeiling(silentCrushAndRaise)\n            EV_DoCeiling(line,silentCrushAndRaise);\n            break;\n\n          case 151:\n            // RaiseCeilingLowerFloor\n            // 151 WR  EV_DoCeiling(raiseToHighest),\n            //         EV_DoFloor(lowerFloortoLowest)\n            EV_DoCeiling( line, raiseToHighest );\n            EV_DoFloor( line, lowerFloorToLowest );\n            break;\n\n          case 152:\n            // Lower Ceiling to Floor\n            // 152 WR  EV_DoCeiling(lowerToFloor)\n            EV_DoCeiling( line, lowerToFloor );\n            break;\n\n            //jff 3/16/98 renumber 153->256\n          case 256:\n            // Build stairs, step 8\n            // 256 WR EV_BuildStairs(build8)\n            EV_BuildStairs(line,build8);\n            break;\n\n            //jff 3/16/98 renumber 154->257\n          case 257:\n            // Build stairs, step 16\n            // 257 WR EV_BuildStairs(turbo16)\n            EV_BuildStairs(line,turbo16);\n            break;\n\n          case 155:\n            // Lower Pillar, Raise Donut\n            // 155 WR  EV_DoDonut()\n            EV_DoDonut(line);\n            break;\n\n          case 156:\n            // Start lights strobing\n            // 156 WR Lights EV_StartLightStrobing()\n            EV_StartLightStrobing(line);\n            break;\n\n          case 157:\n            // Lights to dimmest near\n            // 157 WR Lights EV_TurnTagLightsOff()\n            EV_TurnTagLightsOff(line);\n            break;\n\n          case 201:\n            // Lower ceiling to lowest surrounding ceiling\n            // 201 WR EV_DoCeiling(lowerToLowest)\n            EV_DoCeiling(line,lowerToLowest);\n            break;\n\n          case 202:\n            // Lower ceiling to highest surrounding floor\n            // 202 WR EV_DoCeiling(lowerToMaxFloor)\n            EV_DoCeiling(line,lowerToMaxFloor);\n            break;\n\n          case 208:\n            // killough 2/16/98: WR silent teleporter (normal kind)\n            EV_SilentTeleport(line, side, thing);\n            break;\n\n          case 212: //jff 3/14/98 create instant toggle floor type\n            // Toggle floor between C and F instantly\n            // 212 WR Instant Toggle Floor\n            EV_DoPlat(line,toggleUpDn,0);\n            break;\n\n          //jff 3/16/98 renumber 216->154\n          case 154: //jff 3/15/98 create texture change no motion type\n            // Texture/Type Change Only (Trigger)\n            // 154 WR Change Texture/Type Only\n            EV_DoChange(line,trigChangeOnly);\n            break;\n\n          case 240: //jff 3/15/98 create texture change no motion type\n            // Texture/Type Change Only (Numeric)\n            // 240 WR Change Texture/Type Only\n            EV_DoChange(line,numChangeOnly);\n            break;\n\n          case 220:\n            // Lower floor to next lower neighbor\n            // 220 WR Lower Floor Next Lower Neighbor\n            EV_DoFloor(line,lowerFloorToNearest);\n            break;\n\n          case 228:\n            // Raise elevator next floor\n            // 228 WR Raise Elevator next floor\n            EV_DoElevator(line,elevateUp);\n            break;\n\n          case 232:\n            // Lower elevator next floor\n            // 232 WR Lower Elevator next floor\n            EV_DoElevator(line,elevateDown);\n            break;\n\n          case 236:\n            // Elevator to current floor\n            // 236 WR Elevator to current floor\n            EV_DoElevator(line,elevateCurrent);\n            break;\n\n          case 244: //jff 3/6/98 make fit within DCK's 256 linedef types\n            // killough 2/16/98: WR silent teleporter (linedef-linedef kind)\n            EV_SilentLineTeleport(line, side, thing, false);\n            break;\n\n          case 263: //jff 4/14/98 add silent line-line reversed\n            EV_SilentLineTeleport(line, side, thing, true);\n            break;\n\n          case 265: //jff 4/14/98 add monster-only silent line-line reversed\n            if (!thing->player)\n              EV_SilentLineTeleport(line, side, thing, true);\n            break;\n\n          case 267: //jff 4/14/98 add monster-only silent line-line\n            if (!thing->player)\n              EV_SilentLineTeleport(line, side, thing, false);\n            break;\n\n          case 269: //jff 4/14/98 add monster-only silent\n            if (!thing->player)\n              EV_SilentTeleport(line, side, thing);\n            break;\n\n            //jff 1/29/98 end of added WR linedef types\n    }\n}\n\n\n\n//\n// P_ShootSpecialLine - IMPACT SPECIALS\n// Called when a thing shoots a special line.\n//\nvoid\nP_ShootSpecialLine\n( mobj_t*\tthing,\n  line_t*\tline )\n{\n\n\t// pointer to line function is NULL by default, set non-null if\n    // line special is walkover generalized linedef type\n    int (*linefunc)(line_t *line)=NULL;\n\n    // check each range of generalized linedefs\n    if ((unsigned)line->special >= GenEnd)\n    {\n      // Out of range for GenFloors\n    }\n    else if ((unsigned)line->special >= GenFloorBase)\n    {\n      if (!thing->player)\n        if ((line->special & FloorChange) || !(line->special & FloorModel))\n          return; // FloorModel is \"Allow Monsters\" if FloorChange is 0\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return;                         // generalized types require tag\n      linefunc = EV_DoGenFloor;\n    }\n    else if ((unsigned)line->special >= GenCeilingBase)\n    {\n      if (!thing->player)\n        if ((line->special & CeilingChange) || !(line->special & CeilingModel))\n          return;   // CeilingModel is \"Allow Monsters\" if CeilingChange is 0\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return;                         // generalized types require tag\n      linefunc = EV_DoGenCeiling;\n    }\n    else if ((unsigned)line->special >= GenDoorBase)\n    {\n      if (!thing->player)\n      {\n        if (!(line->special & DoorMonster))\n          return;   // monsters disallowed from this door\n        if (line->flags & ML_SECRET) // they can't open secret doors either\n          return;\n      }\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 3/2/98 all non-manual\n        return;                         // generalized types require tag\n      linefunc = EV_DoGenDoor;\n    }\n    else if ((unsigned)line->special >= GenLockedBase)\n    {\n      if (!thing->player)\n        return;   // monsters disallowed from unlocking doors\n      if (!P_CanUnlockGenDoor(line,thing->player))\n        return;\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return;                         // generalized types require tag\n\n      linefunc = EV_DoGenLockedDoor;\n    }\n    else if ((unsigned)line->special >= GenLiftBase)\n    {\n      if (!thing->player)\n        if (!(line->special & LiftMonster))\n          return; // monsters disallowed\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return;                         // generalized types require tag\n      linefunc = EV_DoGenLift;\n    }\n    else if ((unsigned)line->special >= GenStairsBase)\n    {\n      if (!thing->player)\n        if (!(line->special & StairMonster))\n          return; // monsters disallowed\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return;                         // generalized types require tag\n      linefunc = EV_DoGenStairs;\n    }\n    else if ((unsigned)line->special >= GenCrusherBase)\n    {\n      if (!thing->player)\n        if (!(line->special & CrusherMonster))\n          return; // monsters disallowed\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return;                         // generalized types require tag\n      linefunc = EV_DoGenCrusher;\n    }\n\n    if (linefunc)\n      switch((line->special & TriggerType) >> TriggerTypeShift)\n      {\n        case GunOnce:\n          if (linefunc(line))\n            P_ChangeSwitchTexture(line,0);\n          return;\n        case GunMany:\n          if (linefunc(line))\n            P_ChangeSwitchTexture(line,1);\n          return;\n        default:  // if not a gun type, do nothing here\n          return;\n      }\n\n    int\t\tok;\n    \n    //\tImpacts that other things can activate.\n    if (!thing->player)\n    {\n\tok = 0;\n\tswitch(line->special)\n\t{\n\t  case 46:\n\t    // OPEN DOOR IMPACT\n\t    ok = 1;\n\t    break;\n\t}\n\tif (!ok)\n\t    return;\n    }\n\n    switch(line->special)\n    {\n      case 24:\n\t// RAISE FLOOR\n\tEV_DoFloor(line,raiseFloor);\n\tP_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 46:\n\t// OPEN DOOR\n\tEV_DoDoor(line,openDoor);\n\tP_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 47:\n\t// RAISE FLOOR NEAR AND CHANGE\n\tEV_DoPlat(line,raiseToNearestAndChange,0);\n\tP_ChangeSwitchTexture(line,0);\n\tbreak;\n\n\t//jff 1/30/98 added new gun linedefs here\n    // killough 1/31/98: added demo_compatibility check, added inner switch\n\n\tcase 197:\n\t// Exit to next level\n\t// killough 10/98: prevent zombies from exiting levels\n\tif(thing->player && thing->player->health<=0)\n\t\tbreak;\n\tP_ChangeSwitchTexture(line,0);\n\tG_ExitLevel();\n\tbreak;\n\n\tcase 198:\n\t// Exit to secret level\n\t// killough 10/98: prevent zombies from exiting levels\n\tif(thing->player && thing->player->health<=0)\n\t\tbreak;\n\tP_ChangeSwitchTexture(line,0);\n\tG_SecretExitLevel();\n\tbreak;\n\t//jff end addition of new gun linedefs\n    }\n}\n\n\n\n//\n// P_PlayerInSpecialSector\n// Called every tic frame\n//  that the player origin is in a special sector\n//\nvoid P_PlayerInSpecialSector (player_t* player)\n{\n    sector_t*\tsector;\n    extern int showMessages;\n    static sector_t*\terror;\n\t\n    sector = player->mo->subsector->sector;\n\n    // Falling, not all the way down yet?\n    if (player->mo->z != sector->floorheight)\n\treturn;\t\n\n    // Has hitten ground.\n    switch (sector->special)\n    {\n      case 5:\n\t// HELLSLIME DAMAGE\n\t// [crispy] no nukage damage with NOCLIP cheat\n\tif (!player->powers[pw_ironfeet] && !(player->mo->flags & MF_NOCLIP))\n\t    if (!(leveltime&0x1f))\n\t\tP_DamageMobj (player->mo, NULL, NULL, 10);\n\tbreak;\n\t\n      case 7:\n\t// NUKAGE DAMAGE\n\t// [crispy] no nukage damage with NOCLIP cheat\n\tif (!player->powers[pw_ironfeet] && !(player->mo->flags & MF_NOCLIP))\n\t    if (!(leveltime&0x1f))\n\t\tP_DamageMobj (player->mo, NULL, NULL, 5);\n\tbreak;\n\t\n      case 16:\n\t// SUPER HELLSLIME DAMAGE\n      case 4:\n\t// STROBE HURT\n\t// [crispy] no nukage damage with NOCLIP cheat\n\tif ((!player->powers[pw_ironfeet]\n\t    || (P_Random()<5) ) && !(player->mo->flags & MF_NOCLIP))\n\t{\n\t    if (!(leveltime&0x1f))\n\t\tP_DamageMobj (player->mo, NULL, NULL, 20);\n\t}\n\tbreak;\n\t\t\t\n      case 9:\n\t// SECRET SECTOR\n\tplayer->secretcount++;\n\tsector->special = 0;\n\tbreak;\n\t\t\t\n      case 11:\n\t// EXIT SUPER DAMAGE! (for E1M8 finale)\n\tplayer->cheats &= ~CF_GODMODE;\n\n\tif (!(leveltime&0x1f))\n\t    P_DamageMobj (player->mo, NULL, NULL, 20);\n\n\tif (player->health <= 10)\n\t    G_ExitLevel();\n\tbreak;\n\t\t\t\n      default:\n\t// [crispy] ignore unknown special sectors\n\tif (error != sector)\n\t{\n\terror = sector;\n\tfprintf (stderr, \"P_PlayerInSpecialSector: \"\n\t\t \"unknown special %i\\n\",\n\t\t sector->special);\n\t}\n\tbreak;\n    };\n}\n\n\n\n\n//\n// P_UpdateSpecials\n// Animate planes, scroll walls, etc.\n//\nboolean\t\tlevelTimer;\nint\t\tlevelTimeCount;\n\nvoid P_UpdateSpecials (void)\n{\n    anim_t*\tanim;\n    int\t\tpic;\n    int\t\ti;\n    line_t*\tline;\n\n    \n    //\tLEVEL TIMER\n    if (levelTimer == true)\n    {\n\tlevelTimeCount--;\n\tif (!levelTimeCount)\n\t    G_ExitLevel();\n    }\n    \n    //\tANIMATE FLATS AND TEXTURES GLOBALLY\n    for (anim = anims ; anim < lastanim ; anim++)\n    {\n\tfor (i=anim->basepic ; i<anim->basepic+anim->numpics ; i++)\n\t{\n\t    pic = anim->basepic + ( (leveltime/anim->speed + i)%anim->numpics );\n\t    if (anim->istexture)\n\t\ttexturetranslation[i] = pic;\n\t    else\n\t    {\n\t\t// [crispy] add support for SMMU swirling flats\n\t\tif (anim->speed > 65535 || anim->numpics == 1)\n\t\t{\n\t\t    flattranslation[i] = -1;\n\t\t}\n\t\telse\n\t\tflattranslation[i] = pic;\n\t    }\n\t}\n    }\n\n    \n    //\tANIMATE LINE SPECIALS\n    for (i = 0; i < numlinespecials; i++)\n    {\n\tline = linespeciallist[i];\n\tswitch(line->special)\n\t{\n\t  case 48:\n\t    // EFFECT FIRSTCOL SCROLL +\n\t    // [crispy] smooth texture scrolling\n\t    sides[line->sidenum[0]].basetextureoffset += FRACUNIT;\n\t    sides[line->sidenum[0]].textureoffset =\n\t    sides[line->sidenum[0]].basetextureoffset;\n\t    break;\n\t  case 85:\n\t    // [JN] (Boom) Scroll Texture Right\n\t    // [crispy] smooth texture scrolling\n\t    sides[line->sidenum[0]].basetextureoffset -= FRACUNIT;\n\t    sides[line->sidenum[0]].textureoffset =\n\t    sides[line->sidenum[0]].basetextureoffset;\n\t    break;\n\t  case 255:\n\t  \t// killough 3/2/98: scroll according to sidedef offsets\n\t    sides[line->sidenum[0]].textureoffset -= sides[line->sidenum[0]].basetextureoffset;\n\t\tsides[line->sidenum[0]].rowoffset +=  sides[line->sidenum[0]].baserowoffset;\n\t    break;\n    case 252:\n    case 253:\n    {\n      mobj_t* thing;\n      fixed_t dx = line->dx >> SCROLL_SHIFT;  // direction and speed of scrolling\n      fixed_t dy = line->dy >> SCROLL_SHIFT;\n      dx = FixedMul(dx,CARRYFACTOR);\n      dy = FixedMul(dy,CARRYFACTOR);\n      int s;\n      for (s = -1; (s = P_FindSectorFromLineTag(line,s)) >= 0;)\n      {\n      sector_t* sec = &sectors[s];\n      fixed_t height = sec->floorheight;\n      fixed_t waterheight = sec->heightsec != -1 &&\n        sectors[sec->heightsec].floorheight > height ?\n        sectors[sec->heightsec].floorheight : INT_MIN;\n\n      // Handle all things in sector.\n      for (thing = sec->thinglist ; thing ; thing = thing->snext)\n        if (!((thing->flags & MF_NOCLIP) &&\n            (!(thing->flags & MF_NOGRAVITY || thing->z > height) ||\n             thing->z < waterheight)))\n        {\n          // Move objects only if on floor or underwater,\n          // non-floating, and clipped.\n          thing->momx += dx;\n          thing->momy += dy;\n        }\n      }\n    }\n      break;\n\t}\n    }\n\n    \n    //\tDO BUTTONS\n    for (i = 0; i < maxbuttons; i++)\n\tif (buttonlist[i].btimer)\n\t{\n\t    buttonlist[i].btimer--;\n\t    if (!buttonlist[i].btimer)\n\t    {\n\t\tswitch(buttonlist[i].where)\n\t\t{\n\t\t  case top:\n\t\t    sides[buttonlist[i].line->sidenum[0]].toptexture =\n\t\t\tbuttonlist[i].btexture;\n\t\t    break;\n\t\t    \n\t\t  case middle:\n\t\t    sides[buttonlist[i].line->sidenum[0]].midtexture =\n\t\t\tbuttonlist[i].btexture;\n\t\t    break;\n\t\t    \n\t\t  case bottom:\n\t\t    sides[buttonlist[i].line->sidenum[0]].bottomtexture =\n\t\t\tbuttonlist[i].btexture;\n\t\t    break;\n\t\t}\n\t\t// [crispy] & [JN] Logically proper sound behavior.\n\t\t// Do not play second \"sfx_swtchn\" on two-sided linedefs that attached to special sectors,\n\t\t// and always play second sound on single-sided linedefs.\n\t\t// if (!buttonlist[i].line->backsector /*|| !buttonlist[i].line->backsector->specialdata*/)\n\t\t// {\n\t\t// \tS_StartSoundOnce(buttonlist[i].soundorg,sfx_swtchn);\n\t\t// }\n\n\t\tS_StartSoundOnce(&buttonlist[i].soundorg,sfx_swtchn);\n\t\tmemset(&buttonlist[i],0,sizeof(button_t));\n\t    }\n\t}\n\n    // [crispy] draw fuzz effect independent of rendering frame rate\n    // R_SetFuzzPosTic();\n}\n\n// [crispy] smooth texture scrolling\nvoid R_InterpolateTextureOffsets (void)\n{\n\t// if (crispy->uncapped && leveltime > oldleveltime)\n\t// {\n\t// \tint i;\n\n\t// \tfor (i = 0; i < numlinespecials; i++)\n\t// \t{\n\t// \t\tconst line_t *const line = linespeciallist[i];\n\t// \t\tside_t *const side = &sides[line->sidenum[0]];\n\n\t// \t\tif (line->special == 48)\n\t// \t\t{\n\t// \t\t\tside->textureoffset = side->basetextureoffset + fractionaltic;\n\t// \t\t}\n\t// \t\telse\n\t// \t\tif (line->special == 85)\n\t// \t\t{\n\t// \t\t\tside->textureoffset = side->basetextureoffset - fractionaltic;\n\t// \t\t}\n\t// \t}\n\t// }\n}\n\n//\n// Donut overrun emulation\n//\n// Derived from the code from PrBoom+.  Thanks go to Andrey Budko (entryway)\n// as usual :-)\n//\n\n#define DONUT_FLOORHEIGHT_DEFAULT 0x00000000\n#define DONUT_FLOORPIC_DEFAULT 0x16\n\nstatic void DonutOverrun(fixed_t *s3_floorheight, short *s3_floorpic,\n                         line_t *line, sector_t *pillar_sector)\n{\n    static int first = 1;\n    static int tmp_s3_floorheight;\n    static int tmp_s3_floorpic;\n\n    extern int numflats;\n\n    if (first)\n    {\n        int p;\n\n        // This is the first time we have had an overrun.\n        first = 0;\n\n        // Default values\n        tmp_s3_floorheight = DONUT_FLOORHEIGHT_DEFAULT;\n        tmp_s3_floorpic = DONUT_FLOORPIC_DEFAULT;\n\n        //!\n        // @category compat\n        // @arg <x> <y>\n        //\n        // Use the specified magic values when emulating behavior caused\n        // by memory overruns from improperly constructed donuts.\n        // In Vanilla Doom this can differ depending on the operating\n        // system.  The default (if this option is not specified) is to\n        // emulate the behavior when running under Windows 98.\n\n        p = M_CheckParmWithArgs(\"-donut\", 2);\n\n        if (p > 0)\n        {\n            // Dump of needed memory: (fixed_t)0000:0000 and (short)0000:0008\n            //\n            // C:\\>debug\n            // -d 0:0\n            //\n            // DOS 6.22:\n            // 0000:0000    (57 92 19 00) F4 06 70 00-(16 00)\n            // DOS 7.1:\n            // 0000:0000    (9E 0F C9 00) 65 04 70 00-(16 00)\n            // Win98:\n            // 0000:0000    (00 00 00 00) 65 04 70 00-(16 00)\n            // DOSBox under XP:\n            // 0000:0000    (00 00 00 F1) ?? ?? ?? 00-(07 00)\n\n            M_StrToInt(myargv[p + 1], &tmp_s3_floorheight);\n            M_StrToInt(myargv[p + 2], &tmp_s3_floorpic);\n\n            if (tmp_s3_floorpic >= numflats)\n            {\n                fprintf(stderr,\n                        \"DonutOverrun: The second parameter for \\\"-donut\\\" \"\n                        \"switch should be greater than 0 and less than number \"\n                        \"of flats (%d). Using default value (%d) instead. \\n\",\n                        numflats, DONUT_FLOORPIC_DEFAULT);\n                tmp_s3_floorpic = DONUT_FLOORPIC_DEFAULT;\n            }\n        }\n    }\n\n    /*\n    fprintf(stderr,\n            \"Linedef: %d; Sector: %d; \"\n            \"New floor height: %d; New floor pic: %d\\n\",\n            line->iLineID, pillar_sector->iSectorID,\n            tmp_s3_floorheight >> 16, tmp_s3_floorpic);\n     */\n\n    *s3_floorheight = (fixed_t) tmp_s3_floorheight;\n    *s3_floorpic = (short) tmp_s3_floorpic;\n}\n\n\n//\n// Special Stuff that can not be categorized\n//\nint EV_DoDonut(line_t*\tline)\n{\n    sector_t*\t\ts1;\n    sector_t*\t\ts2;\n    sector_t*\t\ts3;\n    int\t\t\tsecnum;\n    int\t\t\trtn;\n    int\t\t\ti;\n    floormove_t*\tfloor;\n    fixed_t s3_floorheight;\n    short s3_floorpic;\n\n    secnum = -1;\n    rtn = 0;\n    while ((secnum = P_FindSectorFromLineTag(line,secnum)) >= 0)\n    {\n\ts1 = &sectors[secnum];\n\n\t// ALREADY MOVING?  IF SO, KEEP GOING...\n\tif (s1->floordata)\n\t    continue;\n\n\trtn = 1;\n\ts2 = getNextSector(s1->lines[0],s1);\n\n        // Vanilla Doom does not check if the linedef is one sided.  The\n        // game does not crash, but reads invalid memory and causes the\n        // sector floor to move \"down\" to some unknown height.\n        // DOSbox prints a warning about an invalid memory access.\n        //\n        // I'm not sure exactly what invalid memory is being read.  This\n        // isn't something that should be done, anyway.\n        // Just print a warning and return.\n\n        if (s2 == NULL)\n        {\n            fprintf(stderr,\n                    \"EV_DoDonut: linedef had no second sidedef! \"\n                    \"Unexpected behavior may occur in Vanilla Doom. \\n\");\n\t    break;\n        }\n\n\tfor (i = 0; i < s2->linecount; i++)\n\t{\n\t    s3 = s2->lines[i]->backsector;\n\n\t    if (s3 == s1)\n\t\tcontinue;\n\n            if (s3 == NULL)\n            {\n                // e6y\n                // s3 is NULL, so\n                // s3->floorheight is an int at 0000:0000\n                // s3->floorpic is a short at 0000:0008\n                // Trying to emulate\n\n                fprintf(stderr,\n                        \"EV_DoDonut: WARNING: emulating buffer overrun due to \"\n                        \"NULL back sector. \"\n                        \"Unexpected behavior may occur in Vanilla Doom.\\n\");\n\n                DonutOverrun(&s3_floorheight, &s3_floorpic, line, s1);\n            }\n            else\n            {\n                s3_floorheight = s3->floorheight;\n                s3_floorpic = s3->floorpic;\n            }\n\n\t    //\tSpawn rising slime\n\t    floor = Z_Malloc (sizeof(*floor), PU_LEVSPEC, 0);\n\t    P_AddThinker (&floor->thinker);\n\t    s2->floordata = floor;\n\t    floor->thinker.function.acp1 = (actionf_p1) T_MoveFloor;\n\t    floor->type = donutRaise;\n\t    floor->crush = false;\n\t    floor->direction = 1;\n\t    floor->sector = s2;\n\t    floor->speed = FLOORSPEED / 2;\n\t    floor->texture = s3_floorpic;\n\t    floor->newspecial = 0;\n\t    floor->floordestheight = s3_floorheight;\n\t    \n\t    //\tSpawn lowering donut-hole\n\t    floor = Z_Malloc (sizeof(*floor), PU_LEVSPEC, 0);\n\t    P_AddThinker (&floor->thinker);\n\t    s1->floordata = floor;\n\t    floor->thinker.function.acp1 = (actionf_p1) T_MoveFloor;\n\t    floor->type = lowerFloor;\n\t    floor->crush = false;\n\t    floor->direction = -1;\n\t    floor->sector = s1;\n\t    floor->speed = FLOORSPEED / 2;\n\t    floor->floordestheight = s3_floorheight;\n\t    break;\n\t}\n    }\n    return rtn;\n}\n\n// Hash the sector tags across the sectors and linedefs.\nstatic void P_InitTagLists(void)\n{\n  register int i;\n\n  for (i=numsectors; --i>=0; )        // Initially make all slots empty.\n    sectors[i].firsttag = -1;\n  for (i=numsectors; --i>=0; )        // Proceed from last to first sector\n    {                                 // so that lower sectors appear first\n      int j = (unsigned) sectors[i].tag % (unsigned) numsectors; // Hash func\n      sectors[i].nexttag = sectors[j].firsttag;   // Prepend sector to chain\n      sectors[j].firsttag = i;\n    }\n\n  // killough 4/17/98: same thing, only for linedefs\n\n  for (i=numlines; --i>=0; )        // Initially make all slots empty.\n    lines[i].firsttag = -1;\n  for (i=numlines; --i>=0; )        // Proceed from last to first linedef\n    {                               // so that lower linedefs appear first\n      int j = (unsigned) lines[i].tag % (unsigned) numlines; // Hash func\n      lines[i].nexttag = lines[j].firsttag;   // Prepend linedef to chain\n      lines[j].firsttag = i;\n    }\n}\n\n//\n// SPECIAL SPAWNING\n//\n\n//\n// P_SpawnSpecials\n// After the map has been loaded, scan for specials\n//  that spawn thinkers\n//\nshort\t\tnumlinespecials;\nline_t*\t\tlinespeciallist[MAXLINEANIMS];\n\n\n// Parses command line parameters.\nvoid P_SpawnSpecials (void)\n{\n    sector_t*\tsector;\n    int\t\ti;\n\n    // See if -TIMER was specified.\n\n    if (timelimit > 0 && deathmatch)\n    {\n        levelTimer = true;\n        levelTimeCount = timelimit * 60 * TICRATE;\n    }\n    else\n    {\n\tlevelTimer = false;\n    }\n\n    //\tInit special SECTORs.\n    sector = sectors;\n    for (i=0 ; i<numsectors ; i++, sector++)\n    {\n\tif (!sector->special)\n\t    continue;\n\t\n\tswitch (sector->special)\n\t{\n\t  case 1:\n\t    // FLICKERING LIGHTS\n\t    P_SpawnLightFlash (sector);\n\t    break;\n\n\t  case 2:\n\t    // STROBE FAST\n\t    P_SpawnStrobeFlash(sector,FASTDARK,0);\n\t    break;\n\t    \n\t  case 3:\n\t    // STROBE SLOW\n\t    P_SpawnStrobeFlash(sector,SLOWDARK,0);\n\t    break;\n\t    \n\t  case 4:\n\t    // STROBE FAST/DEATH SLIME\n\t    P_SpawnStrobeFlash(sector,FASTDARK,0);\n\t    sector->special = 4;\n\t    break;\n\t    \n\t  case 8:\n\t    // GLOWING LIGHT\n\t    P_SpawnGlowingLight(sector);\n\t    break;\n\t  case 9:\n\t    // SECRET SECTOR\n\t    totalsecret++;\n\t    break;\n\t    \n\t  case 10:\n\t    // DOOR CLOSE IN 30 SECONDS\n\t    P_SpawnDoorCloseIn30 (sector);\n\t    break;\n\t    \n\t  case 12:\n\t    // SYNC STROBE SLOW\n\t    P_SpawnStrobeFlash (sector, SLOWDARK, 1);\n\t    break;\n\n\t  case 13:\n\t    // SYNC STROBE FAST\n\t    P_SpawnStrobeFlash (sector, FASTDARK, 1);\n\t    break;\n\n\t  case 14:\n\t    // DOOR RAISE IN 5 MINUTES\n\t    P_SpawnDoorRaiseIn5Mins (sector, i);\n\t    break;\n\t    \n\t  case 17:\n\t    P_SpawnFireFlicker(sector);\n\t    break;\n\t}\n    }\n\n\t// P_InitTagLists() must be called before P_FindSectorFromLineTag()\n  \t// or P_FindLineFromLineTag() can be called.\n\n  \tP_InitTagLists();   // killough 1/30/98: Create xref tables for tags\n    \n    //\tInit line EFFECTs\n    numlinespecials = 0;\n    for (i = 0;i < numlines; i++)\n    {\n\tswitch(lines[i].special)\n\t{\n\t  case 48:\n\t  case 85:  // [crispy] [JN] (Boom) Scroll Texture Right\n\t  case 255: // killough 3/2/98: scroll according to sidedef offsets\n    case 252: // carry things\n    case 253: // and scroll floor\n            if (numlinespecials >= MAXLINEANIMS)\n            {\n                I_Error(\"Too many scrolling wall linedefs! \"\n                        \"(Vanilla limit is 64)\");\n            }\n\t    // EFFECT FIRSTCOL SCROLL+\n\t    linespeciallist[numlinespecials] = &lines[i];\n\t    numlinespecials++;\n\t    break;\n\n    // killough 3/7/98:\n    // support for drawn heights coming from different sector\n    case 242:\n    {\n      sector_t* sec = sides[lines[i].sidenum[0]].sector;\n      int s;\n      for (s = -1; (s = P_FindSectorFromLineTag(&lines[i],s)) >= 0;)\n        sectors[s].heightsec = sec->id;\n    }\n      break;\n\n    case 213:\n    {\n      sector_t* sec = sides[lines[i].sidenum[0]].sector;\n      int s;\n      for (s = -1; (s = P_FindSectorFromLineTag(&lines[i],s)) >= 0;)\n        sectors[s].floorlightsec = sec->id;\n    }\n      break;\n\n    case 261:\n    {\n      sector_t* sec = sides[lines[i].sidenum[0]].sector;\n      int s;\n      for (s = -1; (s = P_FindSectorFromLineTag(&lines[i],s)) >= 0;)\n        sectors[s].ceilinglightsec = sec->id;\n    }\n      break;\n\n\t  // [crispy] add support for MBF sky tranfers\n\t  case 271:\n\t  case 272:\n\t    {\n\t\tint secnum;\n\n\t\tfor (secnum = 0; secnum < numsectors; secnum++)\n\t\t{\n\t\t    if (sectors[secnum].tag == lines[i].tag)\n\t\t    {\n\t\t\tsectors[secnum].sky = i | PL_SKYFLAT;\n\t\t    }\n\t\t}\n\t    }\n\t    break;\n\t}\n    }\n\n    \n    //\tInit other misc stuff\n    for (i = 0;i < MAXCEILINGS;i++)\n\tactiveceilings[i] = NULL;\n\n    for (i = 0;i < MAXPLATS;i++)\n\tactiveplats[i] = NULL;\n    \n    for (i = 0;i < maxbuttons;i++)\n\tmemset(&buttonlist[i],0,sizeof(button_t));\n\n    // UNUSED: no horizonal sliders.\n    //\tP_InitSlidingDoorFrames();\n}\n\n//\n// P_SectorActive()\n//\n// Passed a linedef special class (floor, ceiling, lighting) and a sector\n// returns whether the sector is already busy with a linedef special of the\n// same class. If old demo compatibility true, all linedef special classes\n// are the same.\n//\n// jff 2/23/98 added to prevent old demos from\n//  succeeding in starting multiple specials on one sector\n//\nboolean P_SectorActive(special_e t, const sector_t *sec)\n{\n    switch (t) // return whether thinker of same type is active\n    {\n      case floor_special:\n        return sec->floordata != NULL;\n      case ceiling_special:\n        return sec->ceilingdata != NULL;\n      case lighting_special:\n        return sec->lightingdata != NULL;\n    }\n  return true; // don't know which special, must be active, shouldn't be here\n}\n\n//\n// P_FindNextLowestFloor()\n//\n// Passed a sector and a floor height, returns the fixed point value\n// of the largest floor height in a surrounding sector smaller than\n// the floor height passed. If no such height exists the floorheight\n// passed is returned.\n//\n// jff 02/03/98 Twiddled Lee's P_FindNextHighestFloor to make this\n//\nfixed_t P_FindNextLowestFloor(sector_t *sec, int currentheight)\n{\n  sector_t *other;\n  int i;\n\n  for (i=0 ;i < sec->linecount ; i++)\n    if ((other = getNextSector(sec->lines[i],sec)) &&\n         other->floorheight < currentheight)\n    {\n      int height = other->floorheight;\n      while (++i < sec->linecount)\n        if ((other = getNextSector(sec->lines[i],sec)) &&\n            other->floorheight > height &&\n            other->floorheight < currentheight)\n          height = other->floorheight;\n      return height;\n    }\n  return currentheight;\n}\n\n//\n// P_FindShortestTextureAround()\n//\n// Passed a sector number, returns the shortest lower texture on a\n// linedef bounding the sector.\n//\n// Note: If no lower texture exists 32000*FRACUNIT is returned.\n//       but if compatibility then INT_MAX is returned\n//\n// jff 02/03/98 Add routine to find shortest lower texture\n//\nfixed_t P_FindShortestTextureAround(int secnum)\n{\n  int minsize = INT_MAX;\n  side_t*     side;\n  int i;\n  sector_t *sec = &sectors[secnum];\n\n\tminsize = 32000<<FRACBITS; //jff 3/13/98 prevent overflow in height calcs\n\n  for (i = 0; i < sec->linecount; i++)\n  {\n    if (twoSided(secnum, i))\n    {\n      side = getSide(secnum,i,0);\n      if (side->bottomtexture > 0)  //jff 8/14/98 texture 0 is a placeholder\n        if (textureheight[side->bottomtexture] < minsize)\n          minsize = textureheight[side->bottomtexture];\n      side = getSide(secnum,i,1);\n      if (side->bottomtexture > 0)  //jff 8/14/98 texture 0 is a placeholder\n        if (textureheight[side->bottomtexture] < minsize)\n          minsize = textureheight[side->bottomtexture];\n    }\n  }\n  return minsize;\n}\n\n//\n// P_FindShortestUpperAround()\n//\n// Passed a sector number, returns the shortest upper texture on a\n// linedef bounding the sector.\n//\n// Note: If no upper texture exists 32000*FRACUNIT is returned.\n//       but if compatibility then INT_MAX is returned\n//\n// jff 03/20/98 Add routine to find shortest upper texture\n//\nfixed_t P_FindShortestUpperAround(int secnum)\n{\n  int minsize = INT_MAX;\n  side_t*     side;\n  int i;\n  sector_t *sec = &sectors[secnum];\n\n  \n  minsize = 32000<<FRACBITS; //jff 3/13/98 prevent overflow\n                               // in height calcs\n  for (i = 0; i < sec->linecount; i++)\n  {\n    if (twoSided(secnum, i))\n    {\n      side = getSide(secnum,i,0);\n      if (side->toptexture > 0)     //jff 8/14/98 texture 0 is a placeholder\n        if (textureheight[side->toptexture] < minsize)\n          minsize = textureheight[side->toptexture];\n      side = getSide(secnum,i,1);\n      if (side->toptexture > 0)     //jff 8/14/98 texture 0 is a placeholder\n        if (textureheight[side->toptexture] < minsize)\n          minsize = textureheight[side->toptexture];\n    }\n  }\n  return minsize;\n}\n\n//\n// P_FindModelCeilingSector()\n//\n// Passed a ceiling height and a sector number, return a pointer to a\n// a sector with that ceiling height across the lowest numbered two sided\n// line surrounding the sector.\n//\n// Note: If no sector at that height bounds the sector passed, return NULL\n//\n// jff 02/03/98 Add routine to find numeric model ceiling\n//  around a sector specified by sector number\n//  used only from generalized ceiling types\n// jff 3/14/98 change first parameter to plain height to allow call\n//  from routine not using ceiling_t\n//\nsector_t *P_FindModelCeilingSector(fixed_t ceildestheight,int secnum)\n{\n  int i;\n  sector_t *sec=NULL;\n  int linecount;\n\n  sec = &sectors[secnum]; //jff 3/2/98 woops! better do this\n  //jff 5/23/98 don't disturb sec->linecount while searching\n  // but allow early exit in old demos\n  linecount = sec->linecount;\n  for (i = 0; i < (/*demo_compatibility &&*/ sec->linecount<linecount?\n                   sec->linecount : linecount); i++)\n  {\n    if ( twoSided(secnum, i) )\n    {\n      if (getSide(secnum,i,0)->sector - sectors == secnum)\n          sec = getSector(secnum,i,1);\n      else\n          sec = getSector(secnum,i,0);\n\n      if (sec->ceilingheight == ceildestheight)\n        return sec;\n    }\n  }\n  return NULL;\n}\n\n//\n// P_FindModelFloorSector()\n//\n// Passed a floor height and a sector number, return a pointer to a\n// a sector with that floor height across the lowest numbered two sided\n// line surrounding the sector.\n//\n// Note: If no sector at that height bounds the sector passed, return NULL\n//\n// jff 02/03/98 Add routine to find numeric model floor\n//  around a sector specified by sector number\n// jff 3/14/98 change first parameter to plain height to allow call\n//  from routine not using floormove_t\n//\nsector_t *P_FindModelFloorSector(fixed_t floordestheight,int secnum)\n{\n  int i;\n  sector_t *sec=NULL;\n  int linecount;\n\n  sec = &sectors[secnum]; //jff 3/2/98 woops! better do this\n  //jff 5/23/98 don't disturb sec->linecount while searching\n  // but allow early exit in old demos\n  linecount = sec->linecount;\n  for (i = 0; i < (/*demo_compatibility &&*/ sec->linecount<linecount?\n                   sec->linecount : linecount); i++)\n  {\n    if ( twoSided(secnum, i) )\n    {\n      if (getSide(secnum,i,0)->sector - sectors == secnum)\n          sec = getSector(secnum,i,1);\n      else\n          sec = getSector(secnum,i,0);\n\n      if (sec->floorheight == floordestheight)\n        return sec;\n    }\n  }\n  return NULL;\n}\n\n//\n// P_FindNextLowestCeiling()\n//\n// Passed a sector and a ceiling height, returns the fixed point value\n// of the largest ceiling height in a surrounding sector smaller than\n// the ceiling height passed. If no such height exists the ceiling height\n// passed is returned.\n//\n// jff 02/03/98 Twiddled Lee's P_FindNextHighestFloor to make this\n//\nfixed_t P_FindNextLowestCeiling(sector_t *sec, int currentheight)\n{\n  sector_t *other;\n  int i;\n\n  for (i=0 ;i < sec->linecount ; i++)\n    if ((other = getNextSector(sec->lines[i],sec)) &&\n        other->ceilingheight < currentheight)\n    {\n      int height = other->ceilingheight;\n      while (++i < sec->linecount)\n        if ((other = getNextSector(sec->lines[i],sec)) &&\n            other->ceilingheight > height &&\n            other->ceilingheight < currentheight)\n          height = other->ceilingheight;\n      return height;\n    }\n  return currentheight;\n}\n\n//\n// P_FindNextHighestCeiling()\n//\n// Passed a sector and a ceiling height, returns the fixed point value\n// of the smallest ceiling height in a surrounding sector larger than\n// the ceiling height passed. If no such height exists the ceiling height\n// passed is returned.\n//\n// jff 02/03/98 Twiddled Lee's P_FindNextHighestFloor to make this\n//\nfixed_t P_FindNextHighestCeiling(sector_t *sec, int currentheight)\n{\n  sector_t *other;\n  int i;\n\n  for (i=0 ;i < sec->linecount ; i++)\n    if ((other = getNextSector(sec->lines[i],sec)) &&\n         other->ceilingheight > currentheight)\n    {\n      int height = other->ceilingheight;\n      while (++i < sec->linecount)\n        if ((other = getNextSector(sec->lines[i],sec)) &&\n            other->ceilingheight < height &&\n            other->ceilingheight > currentheight)\n          height = other->ceilingheight;\n      return height;\n    }\n  return currentheight;\n}\n\n//\n// P_CanUnlockGenDoor()\n//\n// Passed a generalized locked door linedef and a player, returns whether\n// the player has the keys necessary to unlock that door.\n//\n// Note: The linedef passed MUST be a generalized locked door type\n//       or results are undefined.\n//\n// jff 02/05/98 routine added to test for unlockability of\n//  generalized locked doors\n//\nboolean P_CanUnlockGenDoor\n( line_t* line,\n  player_t* player)\n{\n  // does this line special distinguish between skulls and keys?\n  int skulliscard = (line->special & LockedNKeys)>>LockedNKeysShift;\n\n  // determine for each case of lock type if player's keys are adequate\n  switch((line->special & LockedKey)>>LockedKeyShift)\n  {\n    case AnyKey:\n      if\n      (\n        !player->cards[it_redcard] &&\n        !player->cards[it_redskull] &&\n        !player->cards[it_bluecard] &&\n        !player->cards[it_blueskull] &&\n        !player->cards[it_yellowcard] &&\n        !player->cards[it_yellowskull]\n      )\n      {\n        player->message = DEH_String(PD_ANY);; // Ty 03/27/98 - externalized\n        S_StartSound(player->mo,sfx_oof);             // killough 3/20/98\n        return false;\n      }\n      break;\n    case RCard:\n      if\n      (\n        !player->cards[it_redcard] &&\n        (!skulliscard || !player->cards[it_redskull])\n      )\n      {\n        player->message = DEH_String(PD_REDK);; // Ty 03/27/98 - externalized\n        S_StartSound(player->mo,sfx_oof);             // killough 3/20/98\n        return false;\n      }\n      break;\n    case BCard:\n      if\n      (\n        !player->cards[it_bluecard] &&\n        (!skulliscard || !player->cards[it_blueskull])\n      )\n      {\n        player->message = DEH_String(PD_BLUEK); // Ty 03/27/98 - externalized\n        S_StartSound(player->mo,sfx_oof);             // killough 3/20/98\n        return false;\n      }\n      break;\n    case YCard:\n      if\n      (\n        !player->cards[it_yellowcard] &&\n        (!skulliscard || !player->cards[it_yellowskull])\n      )\n      {\n        player->message = DEH_String(PD_YELLOWK); // Ty 03/27/98 - externalized\n        S_StartSound(player->mo,sfx_oof);             // killough 3/20/98\n        return false;\n      }\n      break;\n    case RSkull:\n      if\n      (\n        !player->cards[it_redskull] &&\n        (!skulliscard || !player->cards[it_redcard])\n      )\n      {\n        player->message = DEH_String(PD_REDK); // Ty 03/27/98 - externalized\n        S_StartSound(player->mo,sfx_oof);             // killough 3/20/98\n        return false;\n      }\n      break;\n    case BSkull:\n      if\n      (\n        !player->cards[it_blueskull] &&\n        (!skulliscard || !player->cards[it_bluecard])\n      )\n      {\n        player->message = DEH_String(PD_BLUEK); // Ty 03/27/98 - externalized\n        S_StartSound(player->mo,sfx_oof);             // killough 3/20/98\n        return false;\n      }\n      break;\n    case YSkull:\n      if\n      (\n        !player->cards[it_yellowskull] &&\n        (!skulliscard || !player->cards[it_yellowcard])\n      )\n      {\n        player->message = DEH_String(PD_YELLOWK); // Ty 03/27/98 - externalized\n        S_StartSound(player->mo,sfx_oof);             // killough 3/20/98\n        return false;\n      }\n      break;\n    case AllKeys:\n      if\n      (\n        !skulliscard &&\n        (\n          !player->cards[it_redcard] ||\n          !player->cards[it_redskull] ||\n          !player->cards[it_bluecard] ||\n          !player->cards[it_blueskull] ||\n          !player->cards[it_yellowcard] ||\n          !player->cards[it_yellowskull]\n        )\n      )\n      {\n        player->message = DEH_String(PD_ALL6); // Ty 03/27/98 - externalized\n        S_StartSound(player->mo,sfx_oof);             // killough 3/20/98\n        return false;\n      }\n      if\n      (\n        skulliscard &&\n        (\n          (!player->cards[it_redcard] &&\n            !player->cards[it_redskull]) ||\n          (!player->cards[it_bluecard] &&\n            !player->cards[it_blueskull]) ||\n          (!player->cards[it_yellowcard] &&\n            !player->cards[it_yellowskull])\n        )\n      )\n      {\n        player->message = DEH_String(PD_ALL3); // Ty 03/27/98 - externalized\n        S_StartSound(player->mo,sfx_oof);             // killough 3/20/98\n        return false;\n      }\n      break;\n  }\n  return true;\n}\n\n// killough 4/16/98: Same thing, only for linedefs\n\nint P_FindLineFromLineTag(line_t *line, int start)\n{\n  start = start >= 0 ? lines[start].nexttag :\n    lines[(unsigned) line->tag % (unsigned) numlines].firsttag;\n  while (start >= 0 && lines[start].tag != line->tag)\n    start = lines[start].nexttag;\n  return start;\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// DESCRIPTION:\n//\tSwitches, buttons. Two-state animation. Exits.\n//\n\n#include <stdio.h>\n\n#include \"i_system.h\"\n#include \"deh_main.h\"\n#include \"doomdef.h\"\n#include \"p_local.h\"\n#include \"i_swap.h\" // [crispy] SHORT()\n#include \"w_wad.h\" // [crispy] W_CheckNumForName()\n#include \"z_zone.h\" // [crispy] Z_ChangeTag()\n\n#include \"g_game.h\"\n\n#include \"s_sound.h\"\n\n// Data.\n#include \"sounds.h\"\n\n// State.\n#include \"doomstat.h\"\n#include \"r_state.h\"\n\n\n//\n// CHANGE THE TEXTURE OF A WALL SWITCH TO ITS OPPOSITE\n//\n// [crispy] add support for SWITCHES lumps\nswitchlist_t alphSwitchList_vanilla[] =\n{\n    // Doom shareware episode 1 switches\n    {\"SW1BRCOM\",\t\"SW2BRCOM\",\t1},\n    {\"SW1BRN1\",\t\"SW2BRN1\",\t1},\n    {\"SW1BRN2\",\t\"SW2BRN2\",\t1},\n    {\"SW1BRNGN\",\t\"SW2BRNGN\",\t1},\n    {\"SW1BROWN\",\t\"SW2BROWN\",\t1},\n    {\"SW1COMM\",\t\"SW2COMM\",\t1},\n    {\"SW1COMP\",\t\"SW2COMP\",\t1},\n    {\"SW1DIRT\",\t\"SW2DIRT\",\t1},\n    {\"SW1EXIT\",\t\"SW2EXIT\",\t1},\n    {\"SW1GRAY\",\t\"SW2GRAY\",\t1},\n    {\"SW1GRAY1\",\t\"SW2GRAY1\",\t1},\n    {\"SW1METAL\",\t\"SW2METAL\",\t1},\n    {\"SW1PIPE\",\t\"SW2PIPE\",\t1},\n    {\"SW1SLAD\",\t\"SW2SLAD\",\t1},\n    {\"SW1STARG\",\t\"SW2STARG\",\t1},\n    {\"SW1STON1\",\t\"SW2STON1\",\t1},\n    {\"SW1STON2\",\t\"SW2STON2\",\t1},\n    {\"SW1STONE\",\t\"SW2STONE\",\t1},\n    {\"SW1STRTN\",\t\"SW2STRTN\",\t1},\n\n    // Doom registered episodes 2&3 switches\n    {\"SW1BLUE\",\t\"SW2BLUE\",\t2},\n    {\"SW1CMT\",\t\t\"SW2CMT\",\t2},\n    {\"SW1GARG\",\t\"SW2GARG\",\t2},\n    {\"SW1GSTON\",\t\"SW2GSTON\",\t2},\n    {\"SW1HOT\",\t\t\"SW2HOT\",\t2},\n    {\"SW1LION\",\t\"SW2LION\",\t2},\n    {\"SW1SATYR\",\t\"SW2SATYR\",\t2},\n    {\"SW1SKIN\",\t\"SW2SKIN\",\t2},\n    {\"SW1VINE\",\t\"SW2VINE\",\t2},\n    {\"SW1WOOD\",\t\"SW2WOOD\",\t2},\n\n    // Doom II switches\n    {\"SW1PANEL\",\t\"SW2PANEL\",\t3},\n    {\"SW1ROCK\",\t\"SW2ROCK\",\t3},\n    {\"SW1MET2\",\t\"SW2MET2\",\t3},\n    {\"SW1WDMET\",\t\"SW2WDMET\",\t3},\n    {\"SW1BRIK\",\t\"SW2BRIK\",\t3},\n    {\"SW1MOD1\",\t\"SW2MOD1\",\t3},\n    {\"SW1ZIM\",\t\t\"SW2ZIM\",\t3},\n    {\"SW1STON6\",\t\"SW2STON6\",\t3},\n    {\"SW1TEK\",\t\t\"SW2TEK\",\t3},\n    {\"SW1MARB\",\t\"SW2MARB\",\t3},\n    {\"SW1SKULL\",\t\"SW2SKULL\",\t3},\n\n    // [crispy] SWITCHES lumps are supposed to end like this\n    {\"\\0\",\t\t\"\\0\",\t\t0}\n};\n\n// [crispy] remove MAXSWITCHES limit\nint\t\t*switchlist;\nint\t\tnumswitches;\nstatic size_t\tmaxswitches;\nbutton_t        *buttonlist; // [crispy] remove MAXBUTTONS limit\nint\t\tmaxbuttons; // [crispy] remove MAXBUTTONS limit\n\n//\n// P_InitSwitchList\n// Only called at game initialization.\n//\nvoid P_InitSwitchList(void)\n{\n    int i, slindex, episode;\n\n    // [crispy] add support for SWITCHES lumps\n    switchlist_t *alphSwitchList;\n    boolean from_lump;\n\n    if ((from_lump = (W_CheckNumForName(\"SWITCHES\") != -1)))\n    {\n\talphSwitchList = W_CacheLumpName(\"SWITCHES\", PU_STATIC);\n    }\n    else\n    {\n\talphSwitchList = alphSwitchList_vanilla;\n    }\n\n    // Note that this is called \"episode\" here but it's actually something\n    // quite different. As we progress from Shareware->Registered->Doom II\n    // we support more switch textures.\n    switch (gamemode)\n    {\n        case registered:\n        case retail:\n            episode = 2;\n            break;\n        case commercial:\n            episode = 3;\n            break;\n        default:\n            episode = 1;\n            break;\n    }\n\n    slindex = 0;\n\n    for (i = 0; alphSwitchList[i].episode; i++)\n    {\n\tconst short alphSwitchList_episode = from_lump ?\n\t    SHORT(alphSwitchList[i].episode) :\n\t    alphSwitchList[i].episode;\n\n\t// [crispy] remove MAXSWITCHES limit\n\tif (slindex + 1 >= maxswitches)\n\t{\n\t    size_t newmax = maxswitches ? 2 * maxswitches : MAXSWITCHES;\n\t    switchlist = I_Realloc(switchlist, newmax * sizeof(*switchlist));\n\t    maxswitches = newmax;\n\t}\n\n\tif (alphSwitchList_episode <= episode)\n\t{\n\t    switchlist[slindex++] =\n                R_TextureNumForName(DEH_String(alphSwitchList[i].name1));\n\t    switchlist[slindex++] =\n                R_TextureNumForName(DEH_String(alphSwitchList[i].name2));\n\t}\n    }\n\n    numswitches = slindex / 2;\n    switchlist[slindex] = -1;\n\n    // [crispy] add support for SWITCHES lumps\n    if (from_lump)\n    {\n\tZ_ChangeTag(alphSwitchList, PU_CACHE);\n    }\n\n    // [crispy] pre-allocate some memory for the buttonlist[] array\n    buttonlist = I_Realloc(NULL, sizeof(*buttonlist) * (maxbuttons = MAXBUTTONS));\n    memset(buttonlist, 0, sizeof(*buttonlist) * maxbuttons);\n}\n\n\n//\n// Start a button counting down till it turns off.\n//\nvoid\nP_StartButton\n( line_t*\tline,\n  bwhere_e\tw,\n  int\t\ttexture,\n  int\t\ttime )\n{\n    int\t\ti;\n    \n    // See if button is already pressed\n    for (i = 0;i < maxbuttons;i++)\n    {\n\tif (buttonlist[i].btimer\n\t    && buttonlist[i].line == line)\n\t{\n\t    \n\t  // [crispy] register up to three buttons at once for lines with more than one switch texture\n\t  if (buttonlist[i].where == w)\n\t  {\n\t    return;\n\t  }\n\t}\n    }\n    \n\n    \n    for (i = 0;i < maxbuttons;i++)\n    {\n\tif (!buttonlist[i].btimer)\n\t{\n\t    buttonlist[i].line = line;\n\t    buttonlist[i].where = w;\n\t    buttonlist[i].btexture = texture;\n\t    buttonlist[i].btimer = time;\n\t    buttonlist[i].soundorg = &line->soundorg; // [crispy] corrected sound source\n\t    return;\n\t}\n    }\n    \n    // [crispy] remove MAXBUTTONS limit\n    {\n\tmaxbuttons = 2 * maxbuttons;\n\tbuttonlist = I_Realloc(buttonlist, sizeof(*buttonlist) * maxbuttons);\n\tmemset(buttonlist + maxbuttons/2, 0, sizeof(*buttonlist) * maxbuttons/2);\n\treturn P_StartButton(line, w, texture, time);\n    }\n\n    I_Error(\"P_StartButton: no button slots left!\");\n}\n\n\n\n\n\n//\n// Function that changes wall texture.\n// Tell it if switch is ok to use again (1=yes, it's a button).\n//\nvoid\nP_ChangeSwitchTexture\n( line_t*\tline,\n  int \t\tuseAgain )\n{\n    int     texTop;\n    int     texMid;\n    int     texBot;\n    int     i;\n    int     sound;\n\t\n    if (!useAgain)\n\tline->special = 0;\n\n    texTop = sides[line->sidenum[0]].toptexture;\n    texMid = sides[line->sidenum[0]].midtexture;\n    texBot = sides[line->sidenum[0]].bottomtexture;\n\t\n    sound = sfx_swtchn;\n\n    // EXIT SWITCH?\n    if (line->special == 11)                \n\tsound = sfx_swtchx;\n\t\n    for (i = 0;i < numswitches*2;i++)\n    {\n\tif (switchlist[i] == texTop)\n\t{\n\t    S_StartSoundOnce(&line->soundorg,sound); // [crispy] corrected sound source\n\t    sides[line->sidenum[0]].toptexture = switchlist[i^1];\n\n\t    if (useAgain)\n\t\tP_StartButton(line,top,switchlist[i],BUTTONTIME);\n\n//\t    return;\n\t}\n\t// [crispy] register up to three buttons at once for lines with more than one switch texture\n//\telse\n\t{\n\t    if (switchlist[i] == texMid)\n\t    {\n\t\tS_StartSoundOnce(&line->soundorg,sound); // [crispy] corrected sound source\n\t\tsides[line->sidenum[0]].midtexture = switchlist[i^1];\n\n\t\tif (useAgain)\n\t\t    P_StartButton(line, middle,switchlist[i],BUTTONTIME);\n\n//\t\treturn;\n\t    }\n\t    // [crispy] register up to three buttons at once for lines with more than one switch texture\n//\t    else\n\t    {\n\t\tif (switchlist[i] == texBot)\n\t\t{\n\t\t    S_StartSoundOnce(&line->soundorg,sound); // [crispy] corrected sound source\n\t\t    sides[line->sidenum[0]].bottomtexture = switchlist[i^1];\n\n\t\t    if (useAgain)\n\t\t\tP_StartButton(line, bottom,switchlist[i],BUTTONTIME);\n\n//\t\t    return;\n\t\t}\n\t    }\n\t}\n    }\n}\n\n\n\n\n\n\n//\n// P_UseSpecialLine\n// Called when a thing uses a special line.\n// Only the front sides of lines are usable.\n//\nboolean\nP_UseSpecialLine\n( mobj_t*\tthing,\n  line_t*\tline,\n  int\t\tside )\n{               \n\n    // Err...\n    // Use the back sides of VERY SPECIAL lines...\n    if (side)\n    {\n\tswitch(line->special)\n\t{\n\t  case 124:\n\t    // Sliding door open&close\n\t    // UNUSED?\n\t    break;\n\n\t  default:\n\t    return false;\n\t    break;\n\t}\n    }\n\n\t// pointer to line function is NULL by default, set non-null if\n    // line special is push or switch generalized linedef type\n    int (*linefunc)(line_t *line)=NULL;\n\n    // check each range of generalized linedefs\n    if ((unsigned)line->special >= GenEnd)\n    {\n      // Out of range for GenFloors\n    }\n    else if ((unsigned)line->special >= GenFloorBase)\n    {\n      if (!thing->player)\n        if ((line->special & FloorChange) || !(line->special & FloorModel))\n          return false; // FloorModel is \"Allow Monsters\" if FloorChange is 0\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return false;                         // generalized types require tag\n      linefunc = EV_DoGenFloor;\n    }\n    else if ((unsigned)line->special >= GenCeilingBase)\n    {\n      if (!thing->player)\n        if ((line->special & CeilingChange) || !(line->special & CeilingModel))\n          return false;   // CeilingModel is \"Allow Monsters\" if CeilingChange is 0\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return false;                         // generalized types require tag\n      linefunc = EV_DoGenCeiling;\n    }\n    else if ((unsigned)line->special >= GenDoorBase)\n    {\n      if (!thing->player)\n      {\n        if (!(line->special & DoorMonster))\n          return false;   // monsters disallowed from this door\n        if (line->flags & ML_SECRET) // they can't open secret doors either\n          return false;\n      }\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 3/2/98 all non-manual\n        return false;                         // generalized types require tag\n      linefunc = EV_DoGenDoor;\n    }\n    else if ((unsigned)line->special >= GenLockedBase)\n    {\n      if (!thing->player)\n        return false;   // monsters disallowed from unlocking doors\n      if (!P_CanUnlockGenDoor(line,thing->player))\n        return false;\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return false;                         // generalized types require tag\n\n      linefunc = EV_DoGenLockedDoor;\n    }\n    else if ((unsigned)line->special >= GenLiftBase)\n    {\n      if (!thing->player)\n        if (!(line->special & LiftMonster))\n          return false; // monsters disallowed\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return false;                         // generalized types require tag\n      linefunc = EV_DoGenLift;\n    }\n    else if ((unsigned)line->special >= GenStairsBase)\n    {\n      if (!thing->player)\n        if (!(line->special & StairMonster))\n          return false; // monsters disallowed\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return false;                         // generalized types require tag\n      linefunc = EV_DoGenStairs;\n    }\n    else if ((unsigned)line->special >= GenCrusherBase)\n    {\n      if (!thing->player)\n        if (!(line->special & CrusherMonster))\n          return false; // monsters disallowed\n      if (/*!comperr(comperr_zerotag) &&*/ !line->tag && ((line->special&6)!=6)) //e6y //jff 2/27/98 all non-manual\n        return false;                         // generalized types require tag\n      linefunc = EV_DoGenCrusher;\n    }\n\n    if (linefunc)\n      switch((line->special & TriggerType) >> TriggerTypeShift)\n      {\n        case PushOnce:\n          if (!side)\n            if (linefunc(line))\n              line->special = 0;\n          return true;\n        case PushMany:\n          if (!side)\n            linefunc(line);\n          return true;\n        case SwitchOnce:\n          if (linefunc(line))\n            P_ChangeSwitchTexture(line,0);\n          return true;\n        case SwitchMany:\n          if (linefunc(line))\n            P_ChangeSwitchTexture(line,1);\n          return true;\n        default:  // if not a switch/push type, do nothing here\n          return false;\n      }\n    \n    // Switches that other things can activate.\n    if (!thing->player)\n    {\n\t// never open secret doors\n\tif (line->flags & ML_SECRET)\n\t    return false;\n\t\n\tswitch(line->special)\n\t{\n\t  case 1: \t// MANUAL DOOR RAISE\n\t  case 32:\t// MANUAL BLUE\n\t  case 33:\t// MANUAL RED\n\t  case 34:\t// MANUAL YELLOW\n\t    break;\n\t    \n\t  default:\n\t    return false;\n\t    break;\n\t}\n    }\n\n    \n    // do something  \n    switch (line->special)\n    {\n\t// MANUALS\n      case 1:\t\t// Vertical Door\n      case 26:\t\t// Blue Door/Locked\n      case 27:\t\t// Yellow Door /Locked\n      case 28:\t\t// Red Door /Locked\n\n      case 31:\t\t// Manual door open\n      case 32:\t\t// Blue locked door open\n      case 33:\t\t// Red locked door open\n      case 34:\t\t// Yellow locked door open\n\n      case 117:\t\t// Blazing door raise\n      case 118:\t\t// Blazing door open\n\tEV_VerticalDoor (line, thing);\n\tbreak;\n\t\n\t//UNUSED - Door Slide Open&Close\n\t// case 124:\n\t// EV_SlidingDoor (line, thing);\n\t// break;\n\n\t// SWITCHES\n      case 7:\n\t// Build Stairs\n\tif (EV_BuildStairs(line,build8))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\n      case 9:\n\t// Change Donut\n\tif (EV_DoDonut(line))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 11:\n\t// Exit level\n\tP_ChangeSwitchTexture(line,0);\n\tG_ExitLevel ();\n\tbreak;\n\t\n      case 14:\n\t// Raise Floor 32 and change texture\n\tif (EV_DoPlat(line,raiseAndChange,32))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 15:\n\t// Raise Floor 24 and change texture\n\tif (EV_DoPlat(line,raiseAndChange,24))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 18:\n\t// Raise Floor to next highest floor\n\tif (EV_DoFloor(line, raiseFloorToNearest))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 20:\n\t// Raise Plat next highest floor and change texture\n\tif (EV_DoPlat(line,raiseToNearestAndChange,0))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 21:\n\t// PlatDownWaitUpStay\n\tif (EV_DoPlat(line,downWaitUpStay,0))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 23:\n\t// Lower Floor to Lowest\n\tif (EV_DoFloor(line,lowerFloorToLowest))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 29:\n\t// Raise Door\n\tif (EV_DoDoor(line,normal))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 41:\n\t// Lower Ceiling to Floor\n\tif (EV_DoCeiling(line,lowerToFloor))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 71:\n\t// Turbo Lower Floor\n\tif (EV_DoFloor(line,turboLower))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 49:\n\t// Ceiling Crush And Raise\n\tif (EV_DoCeiling(line,crushAndRaise))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 50:\n\t// Close Door\n\tif (EV_DoDoor(line,closeDoor))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 51:\n\t// Secret EXIT\n\tP_ChangeSwitchTexture(line,0);\n\tG_SecretExitLevel ();\n\tbreak;\n\t\n      case 55:\n\t// Raise Floor Crush\n\tif (EV_DoFloor(line,raiseFloorCrush))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 101:\n\t// Raise Floor\n\tif (EV_DoFloor(line,raiseFloor))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 102:\n\t// Lower Floor to Surrounding floor height\n\tif (EV_DoFloor(line,lowerFloor))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 103:\n\t// Open Door\n\tif (EV_DoDoor(line,openDoor))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 111:\n\t// Blazing Door Raise (faster than TURBO!)\n\tif (EV_DoDoor (line,blazeRaise))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 112:\n\t// Blazing Door Open (faster than TURBO!)\n\tif (EV_DoDoor (line,blazeOpen))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 113:\n\t// Blazing Door Close (faster than TURBO!)\n\tif (EV_DoDoor (line,blazeClose))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 122:\n\t// Blazing PlatDownWaitUpStay\n\tif (EV_DoPlat(line,blazeDWUS,0))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 127:\n\t// Build Stairs Turbo 16\n\tif (EV_BuildStairs(line,turbo16))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 131:\n\t// Raise Floor Turbo\n\tif (EV_DoFloor(line,raiseFloorTurbo))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 133:\n\t// BlzOpenDoor BLUE\n      case 135:\n\t// BlzOpenDoor RED\n      case 137:\n\t// BlzOpenDoor YELLOW\n\tif (EV_DoLockedDoor (line,blazeOpen,thing))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n      case 140:\n\t// Raise Floor 512\n\tif (EV_DoFloor(line,raiseFloor512))\n\t    P_ChangeSwitchTexture(line,0);\n\tbreak;\n\t\n\t// BUTTONS\n      case 42:\n\t// Close Door\n\tif (EV_DoDoor(line,closeDoor))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 43:\n\t// Lower Ceiling to Floor\n\tif (EV_DoCeiling(line,lowerToFloor))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 45:\n\t// Lower Floor to Surrounding floor height\n\tif (EV_DoFloor(line,lowerFloor))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 60:\n\t// Lower Floor to Lowest\n\tif (EV_DoFloor(line,lowerFloorToLowest))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 61:\n\t// Open Door\n\tif (EV_DoDoor(line,openDoor))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 62:\n\t// PlatDownWaitUpStay\n\tif (EV_DoPlat(line,downWaitUpStay,1))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 63:\n\t// Raise Door\n\tif (EV_DoDoor(line,normal))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 64:\n\t// Raise Floor to ceiling\n\tif (EV_DoFloor(line,raiseFloor))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 66:\n\t// Raise Floor 24 and change texture\n\tif (EV_DoPlat(line,raiseAndChange,24))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 67:\n\t// Raise Floor 32 and change texture\n\tif (EV_DoPlat(line,raiseAndChange,32))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 65:\n\t// Raise Floor Crush\n\tif (EV_DoFloor(line,raiseFloorCrush))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 68:\n\t// Raise Plat to next highest floor and change texture\n\tif (EV_DoPlat(line,raiseToNearestAndChange,0))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 69:\n\t// Raise Floor to next highest floor\n\tif (EV_DoFloor(line, raiseFloorToNearest))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 70:\n\t// Turbo Lower Floor\n\tif (EV_DoFloor(line,turboLower))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 114:\n\t// Blazing Door Raise (faster than TURBO!)\n\tif (EV_DoDoor (line,blazeRaise))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 115:\n\t// Blazing Door Open (faster than TURBO!)\n\tif (EV_DoDoor (line,blazeOpen))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 116:\n\t// Blazing Door Close (faster than TURBO!)\n\tif (EV_DoDoor (line,blazeClose))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 123:\n\t// Blazing PlatDownWaitUpStay\n\tif (EV_DoPlat(line,blazeDWUS,0))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 132:\n\t// Raise Floor Turbo\n\tif (EV_DoFloor(line,raiseFloorTurbo))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 99:\n\t// BlzOpenDoor BLUE\n      case 134:\n\t// BlzOpenDoor RED\n      case 136:\n\t// BlzOpenDoor YELLOW\n\tif (EV_DoLockedDoor (line,blazeOpen,thing))\n\t    P_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 138:\n\t// Light Turn On\n\tEV_LightTurnOn(line,255);\n\tP_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\n      case 139:\n\t// Light Turn Off\n\tEV_LightTurnOn(line,35);\n\tP_ChangeSwitchTexture(line,1);\n\tbreak;\n\t\t\t\n    }\n\t\n    return true;\n}\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//       SDL Joystick code.\n//\n\n\n#include \"SDL.h\"\n#include \"SDL_joystick.h\"\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#include <emscripten.h>\n\n#include \"doomtype.h\"\n#include \"d_event.h\"\n#include \"i_joystick.h\"\n#include \"i_system.h\"\n\n#include \"m_config.h\"\n#include \"m_misc.h\"\n\n// When an axis is within the dead zone, it is set to zero.\n// This is 5% of the full range:\n\n#define DEAD_ZONE (32768 / 3)\n\nstatic SDL_Joystick *joystick = NULL;\n\n// Configuration variables:\n\n// Standard default.cfg Joystick enable/disable\n\nstatic int usejoystick = 1;\n\n// SDL GUID and index of the joystick to use.\nstatic char *joystick_guid = \"\";\nstatic int joystick_index = -1;\n\n// Which joystick axis to use for horizontal movement, and whether to\n// invert the direction:\n\nstatic int joystick_x_axis = 2;\nstatic int joystick_x_invert = 0;\n\n// Which joystick axis to use for vertical movement, and whether to\n// invert the direction:\n\nstatic int joystick_y_axis = 1;\nstatic int joystick_y_invert = 0;\n\n// Which joystick axis to use for strafing?\n\nstatic int joystick_strafe_axis = 0;\nstatic int joystick_strafe_invert = 0;\n\n// Which joystick axis to use for looking?\n\nstatic int joystick_look_axis = -1;\nstatic int joystick_look_invert = 0;\n\n// Virtual to physical button joystick button mapping. By default this\n// is a straight mapping.\nstatic int joystick_physical_buttons[NUM_VIRTUAL_BUTTONS] = {\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n};\n\nEMSCRIPTEN_KEEPALIVE\nvoid I_ShutdownJoystick(void)\n{\n    if (joystick != NULL)\n    {\n        SDL_JoystickClose(joystick);\n        joystick = NULL;\n        SDL_QuitSubSystem(SDL_INIT_JOYSTICK);\n    }\n}\n\nstatic boolean IsValidAxis(int axis)\n{\n    int num_axes;\n\n    if (axis < 0)\n    {\n        return true;\n    }\n\n    if (IS_BUTTON_AXIS(axis))\n    {\n        return true;\n    }\n\n    if (IS_HAT_AXIS(axis))\n    {\n        return HAT_AXIS_HAT(axis) < SDL_JoystickNumHats(joystick);\n    }\n\n    num_axes = SDL_JoystickNumAxes(joystick);\n\n    return axis < num_axes;\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid I_InitJoystick(void)\n{\n    int index;\n\n    if (SDL_Init(SDL_INIT_JOYSTICK) < 0)\n    {\n        printf(\"I_InitJoystick: SDL_INIT_JOYSTICK failed\\n\");\n        return;\n    }\n\n    index = 0;\n\n    // Open the joystick\n\n    joystick = SDL_JoystickOpen(index);\n\n    if (joystick == NULL)\n    {\n        printf(\"I_InitJoystick: Failed to open joystick #%i\\n\", index);\n        SDL_QuitSubSystem(SDL_INIT_JOYSTICK);\n        return;\n    }\n\n    if (!IsValidAxis(joystick_x_axis)\n     || !IsValidAxis(joystick_y_axis)\n     || !IsValidAxis(joystick_strafe_axis)\n     || !IsValidAxis(joystick_look_axis))\n    {\n        printf(\"I_InitJoystick: Invalid joystick axis for configured joystick \"\n               \"(run joystick setup again)\\n\");\n\n        SDL_JoystickClose(joystick);\n        joystick = NULL;\n        SDL_QuitSubSystem(SDL_INIT_JOYSTICK);\n    }\n\n    SDL_JoystickEventState(SDL_ENABLE);\n\n    // Initialized okay!\n\n    printf(\"I_InitJoystick: %s\\n\", SDL_JoystickName(joystick));\n\n    I_AtExit(I_ShutdownJoystick, true);\n}\n\nstatic boolean IsAxisButton(int physbutton)\n{\n    if (IS_BUTTON_AXIS(joystick_x_axis))\n    {\n        if (physbutton == BUTTON_AXIS_NEG(joystick_x_axis)\n         || physbutton == BUTTON_AXIS_POS(joystick_x_axis))\n        {\n            return true;\n        }\n    }\n    if (IS_BUTTON_AXIS(joystick_y_axis))\n    {\n        if (physbutton == BUTTON_AXIS_NEG(joystick_y_axis)\n         || physbutton == BUTTON_AXIS_POS(joystick_y_axis))\n        {\n            return true;\n        }\n    }\n    if (IS_BUTTON_AXIS(joystick_strafe_axis))\n    {\n        if (physbutton == BUTTON_AXIS_NEG(joystick_strafe_axis)\n         || physbutton == BUTTON_AXIS_POS(joystick_strafe_axis))\n        {\n            return true;\n        }\n    }\n    if (IS_BUTTON_AXIS(joystick_look_axis))\n    {\n        if (physbutton == BUTTON_AXIS_NEG(joystick_look_axis)\n         || physbutton == BUTTON_AXIS_POS(joystick_look_axis))\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Get the state of the given virtual button.\n\nstatic int ReadButtonState(int vbutton)\n{\n    int physbutton;\n\n    // Map from virtual button to physical (SDL) button.\n    if (vbutton < NUM_VIRTUAL_BUTTONS)\n    {\n        physbutton = joystick_physical_buttons[vbutton];\n    }\n    else\n    {\n        physbutton = vbutton;\n    }\n\n    // Never read axis buttons as buttons.\n    if (IsAxisButton(physbutton))\n    {\n        return 0;\n    }\n\n    return SDL_JoystickGetButton(joystick, physbutton);\n}\n\n// Get a bitmask of all currently-pressed buttons\n\nstatic int GetButtonsState(void)\n{\n    int i;\n    int result;\n\n    result = 0;\n\n    for (i = 0; i < 20; ++i)\n    {\n        if (ReadButtonState(i))\n        {\n            result |= 1 << i;\n        }\n    }\n\n    return result;\n}\n\n// Read the state of an axis, inverting if necessary.\n\nstatic int GetAxisState(int axis, int invert)\n{\n    int result;\n\n    // Axis -1 means disabled.\n\n    if (axis < 0)\n    {\n        return 0;\n    }\n\n    // Is this a button axis, or a hat axis?\n    // If so, we need to handle it specially.\n\n    result = 0;\n\n    if (IS_BUTTON_AXIS(axis))\n    {\n        if (SDL_JoystickGetButton(joystick, BUTTON_AXIS_NEG(axis)))\n        {\n            result -= 32767;\n        }\n        if (SDL_JoystickGetButton(joystick, BUTTON_AXIS_POS(axis)))\n        {\n            result += 32767;\n        }\n    }\n    else if (IS_HAT_AXIS(axis))\n    {\n        int direction = HAT_AXIS_DIRECTION(axis);\n        int hatval = SDL_JoystickGetHat(joystick, HAT_AXIS_HAT(axis));\n\n        if (direction == HAT_AXIS_HORIZONTAL)\n        {\n            if ((hatval & SDL_HAT_LEFT) != 0)\n            {\n                result -= 32767;\n            }\n            else if ((hatval & SDL_HAT_RIGHT) != 0)\n            {\n                result += 32767;\n            }\n        }\n        else if (direction == HAT_AXIS_VERTICAL)\n        {\n            if ((hatval & SDL_HAT_UP) != 0)\n            {\n                result -= 32767;\n            }\n            else if ((hatval & SDL_HAT_DOWN) != 0)\n            {\n                result += 32767;\n            }\n        }\n    }\n    else\n    {\n        result = SDL_JoystickGetAxis(joystick, axis);\n\n        if (result < DEAD_ZONE && result > -DEAD_ZONE)\n        {\n            result = 0;\n        }\n    }\n\n    if (invert)\n    {\n        result = -result;\n    }\n\n    return result;\n}\n\nvoid I_UpdateJoystick(void)\n{\n    if (joystick != NULL)\n    {\n        event_t ev;\n\n        ev.type = ev_joystick;\n        ev.data1 = GetButtonsState();\n        ev.data2 = GetAxisState(joystick_x_axis, joystick_x_invert);\n        ev.data3 = GetAxisState(joystick_y_axis, joystick_y_invert);\n        ev.data4 = GetAxisState(joystick_strafe_axis, joystick_strafe_invert);\n        ev.data5 = GetAxisState(joystick_look_axis, joystick_look_invert);\n\n        D_PostEvent(&ev);\n    }\n}\n\nvoid I_BindJoystickVariables(void)\n{\n    int i;\n\n    M_BindIntVariable(\"use_joystick\",          &usejoystick);\n    M_BindStringVariable(\"joystick_guid\",      &joystick_guid);\n    M_BindIntVariable(\"joystick_index\",        &joystick_index);\n    M_BindIntVariable(\"joystick_x_axis\",       &joystick_x_axis);\n    M_BindIntVariable(\"joystick_y_axis\",       &joystick_y_axis);\n    M_BindIntVariable(\"joystick_strafe_axis\",  &joystick_strafe_axis);\n    M_BindIntVariable(\"joystick_x_invert\",     &joystick_x_invert);\n    M_BindIntVariable(\"joystick_y_invert\",     &joystick_y_invert);\n    M_BindIntVariable(\"joystick_strafe_invert\",&joystick_strafe_invert);\n    M_BindIntVariable(\"joystick_look_axis\",    &joystick_look_axis);\n    M_BindIntVariable(\"joystick_look_invert\",  &joystick_look_invert);\n\n    for (i = 0; i < NUM_VIRTUAL_BUTTONS; ++i)\n    {\n        char name[32];\n        M_snprintf(name, sizeof(name), \"joystick_physical_button%i\", i);\n        M_BindIntVariable(name, &joystick_physical_buttons[i]);\n    }\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 1993-2008 Raven Software\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n\n#include <stdio.h>\n\n#include \"doomtype.h\"\n#include \"doomkeys.h\"\n\n#include \"m_config.h\"\n#include \"m_misc.h\"\n\n//\n// Keyboard controls\n//\n\nint key_right = KEY_RIGHTARROW;\nint key_left = KEY_LEFTARROW;\n\nint key_up = KEY_UPARROW;\nint key_down = KEY_DOWNARROW; \nint key_strafeleft = ',';\nint key_straferight = '.';\nint key_fire = KEY_RCTRL;\nint key_use = ' ';\nint key_strafe = KEY_RALT;\nint key_speed = KEY_RSHIFT; \n\n// \n// Heretic keyboard controls\n//\n \nint key_flyup = KEY_PGUP;\nint key_flydown = KEY_INS;\nint key_flycenter = KEY_HOME;\n\nint key_lookup = KEY_PGDN;\nint key_lookdown = KEY_DEL;\nint key_lookcenter = KEY_END;\n\nint key_invleft = '[';\nint key_invright = ']';\nint key_useartifact = KEY_ENTER;\n\n//\n// Hexen key controls\n//\n\nint key_jump = '/';\n\nint key_arti_all             = KEY_BACKSPACE;\nint key_arti_health          = '\\\\';\nint key_arti_poisonbag       = '0';\nint key_arti_blastradius     = '9';\nint key_arti_teleport        = '8';\nint key_arti_teleportother   = '7';\nint key_arti_egg             = '6';\nint key_arti_invulnerability = '5';\n\n//\n// Strife key controls\n//\n// haleyjd 09/01/10\n//\n\n// Note: Strife also uses key_invleft, key_invright, key_jump, key_lookup, and\n// key_lookdown, but with different default values.\n\nint key_usehealth = 'h';\nint key_invquery  = 'q';\nint key_mission   = 'w';\nint key_invpop    = 'z';\nint key_invkey    = 'k';\nint key_invhome   = KEY_HOME;\nint key_invend    = KEY_END;\nint key_invuse    = KEY_ENTER;\nint key_invdrop   = KEY_BACKSPACE;\n\n\n//\n// Mouse controls\n//\n\nint mousebfire = 0;\nint mousebstrafe = 1;\nint mousebforward = 2;\n\nint mousebjump = -1;\n\nint mousebstrafeleft = -1;\nint mousebstraferight = -1;\nint mousebbackward = -1;\nint mousebuse = -1;\n\nint mousebprevweapon = -1;\nint mousebnextweapon = -1;\n\n\nint key_message_refresh = KEY_ENTER;\nint key_pause = KEY_PAUSE;\nint key_demo_quit = 'q';\nint key_spy = KEY_F12;\n\n// Multiplayer chat keys:\n\nint key_multi_msg = 't';\nint key_multi_msgplayer[8];\n\n// Weapon selection keys:\n\nint key_weapon1 = '1';\nint key_weapon2 = '2';\nint key_weapon3 = '3';\nint key_weapon4 = '4';\nint key_weapon5 = '5';\nint key_weapon6 = '6';\nint key_weapon7 = '7';\nint key_weapon8 = '8';\nint key_prevweapon = '9';\nint key_nextweapon = '0';\n\n// Map control keys:\n\nint key_map_north     = KEY_UPARROW;\nint key_map_south     = KEY_DOWNARROW;\nint key_map_east      = KEY_RIGHTARROW;\nint key_map_west      = KEY_LEFTARROW;\nint key_map_zoomin    = '=';\nint key_map_zoomout   = '-';\nint key_map_toggle    = KEY_TAB;\nint key_map_maxzoom   = '0';\nint key_map_follow    = 'f';\nint key_map_grid      = 'g';\nint key_map_mark      = 'm';\nint key_map_clearmark = 'c';\n\n// menu keys:\n\nint key_menu_activate  = KEY_ESCAPE;\nint key_menu_up        = KEY_UPARROW;\nint key_menu_down      = KEY_DOWNARROW;\nint key_menu_left      = KEY_LEFTARROW;\nint key_menu_right     = KEY_RIGHTARROW;\nint key_menu_back      = KEY_BACKSPACE;\nint key_menu_forward   = KEY_ENTER;\nint key_menu_confirm   = 'y';\nint key_menu_abort     = 'n';\n\nint key_menu_help      = KEY_F1;\nint key_menu_save      = KEY_F2;\nint key_menu_load      = KEY_F3;\nint key_menu_volume    = KEY_F4;\nint key_menu_detail    = KEY_F5;\nint key_menu_qsave     = KEY_F6;\nint key_menu_endgame   = KEY_F7;\nint key_menu_messages  = KEY_F8;\nint key_menu_qload     = KEY_F9;\nint key_menu_quit      = KEY_F10;\nint key_menu_gamma     = KEY_F11;\n\nint key_menu_incscreen = KEY_EQUALS;\nint key_menu_decscreen = KEY_MINUS;\nint key_menu_screenshot = 0;\n\n//\n// Joystick controls\n//\n\nint joybfire = 7;\nint joybstrafe = -1;\nint joybuse = 0;\nint joybspeed = 6;\n\nint joybstrafeleft = -1;\nint joybstraferight = -1;\n\nint joybjump = 2;\n\nint joybprevweapon = 4;\nint joybnextweapon = 5;\n\nint joybmenu = 9;\nint joybautomap = 8;\n\n// Control whether if a mouse button is double clicked, it acts like \n// \"use\" has been pressed\n\nint dclick_use = 1;\n \n// \n// Bind all of the common controls used by Doom and all other games.\n//\n\nvoid M_BindBaseControls(void)\n{\n    M_BindIntVariable(\"key_right\",          &key_right);\n    M_BindIntVariable(\"key_left\",           &key_left);\n    M_BindIntVariable(\"key_up\",             &key_up);\n    M_BindIntVariable(\"key_down\",           &key_down);\n    M_BindIntVariable(\"key_strafeleft\",     &key_strafeleft);\n    M_BindIntVariable(\"key_straferight\",    &key_straferight);\n    M_BindIntVariable(\"key_fire\",           &key_fire);\n    M_BindIntVariable(\"key_use\",            &key_use);\n    M_BindIntVariable(\"key_strafe\",         &key_strafe);\n    M_BindIntVariable(\"key_speed\",          &key_speed);\n\n    M_BindIntVariable(\"mouseb_fire\",        &mousebfire);\n    M_BindIntVariable(\"mouseb_strafe\",      &mousebstrafe);\n    M_BindIntVariable(\"mouseb_forward\",     &mousebforward);\n\n    M_BindIntVariable(\"joyb_fire\",          &joybfire);\n    M_BindIntVariable(\"joyb_strafe\",        &joybstrafe);\n    M_BindIntVariable(\"joyb_use\",           &joybuse);\n    M_BindIntVariable(\"joyb_speed\",         &joybspeed);\n\n    M_BindIntVariable(\"joyb_menu_activate\", &joybmenu);\n    M_BindIntVariable(\"joyb_toggle_automap\", &joybautomap);\n\n    // Extra controls that are not in the Vanilla versions:\n\n    M_BindIntVariable(\"joyb_strafeleft\",     &joybstrafeleft);\n    M_BindIntVariable(\"joyb_straferight\",    &joybstraferight);\n    M_BindIntVariable(\"mouseb_strafeleft\",   &mousebstrafeleft);\n    M_BindIntVariable(\"mouseb_straferight\",  &mousebstraferight);\n    M_BindIntVariable(\"mouseb_use\",          &mousebuse);\n    M_BindIntVariable(\"mouseb_backward\",     &mousebbackward);\n    M_BindIntVariable(\"dclick_use\",          &dclick_use);\n    M_BindIntVariable(\"key_pause\",           &key_pause);\n    M_BindIntVariable(\"key_message_refresh\", &key_message_refresh);\n}\n\nvoid M_BindHereticControls(void)\n{\n    M_BindIntVariable(\"key_flyup\",          &key_flyup);\n    M_BindIntVariable(\"key_flydown\",        &key_flydown);\n    M_BindIntVariable(\"key_flycenter\",      &key_flycenter);\n\n    M_BindIntVariable(\"key_lookup\",         &key_lookup);\n    M_BindIntVariable(\"key_lookdown\",       &key_lookdown);\n    M_BindIntVariable(\"key_lookcenter\",     &key_lookcenter);\n\n    M_BindIntVariable(\"key_invleft\",        &key_invleft);\n    M_BindIntVariable(\"key_invright\",       &key_invright);\n    M_BindIntVariable(\"key_useartifact\",    &key_useartifact);\n}\n\nvoid M_BindHexenControls(void)\n{\n    M_BindIntVariable(\"key_jump\",           &key_jump);\n    M_BindIntVariable(\"mouseb_jump\",        &mousebjump);\n    M_BindIntVariable(\"joyb_jump\",          &joybjump);\n\n    M_BindIntVariable(\"key_arti_all\",             &key_arti_all);\n    M_BindIntVariable(\"key_arti_health\",          &key_arti_health);\n    M_BindIntVariable(\"key_arti_poisonbag\",       &key_arti_poisonbag);\n    M_BindIntVariable(\"key_arti_blastradius\",     &key_arti_blastradius);\n    M_BindIntVariable(\"key_arti_teleport\",        &key_arti_teleport);\n    M_BindIntVariable(\"key_arti_teleportother\",   &key_arti_teleportother);\n    M_BindIntVariable(\"key_arti_egg\",             &key_arti_egg);\n    M_BindIntVariable(\"key_arti_invulnerability\", &key_arti_invulnerability);\n}\n\nvoid M_BindStrifeControls(void)\n{\n    // These are shared with all games, but have different defaults:\n    key_message_refresh = '/';\n\n    // These keys are shared with Heretic/Hexen but have different defaults:\n    key_jump     = 'a';\n    key_lookup   = KEY_PGUP;\n    key_lookdown = KEY_PGDN;\n    key_invleft  = KEY_INS;\n    key_invright = KEY_DEL;\n\n    M_BindIntVariable(\"key_jump\",           &key_jump);\n    M_BindIntVariable(\"key_lookUp\",         &key_lookup);\n    M_BindIntVariable(\"key_lookDown\",       &key_lookdown);\n    M_BindIntVariable(\"key_invLeft\",        &key_invleft);\n    M_BindIntVariable(\"key_invRight\",       &key_invright);\n\n    // Custom Strife-only Keys:\n    M_BindIntVariable(\"key_useHealth\",      &key_usehealth);\n    M_BindIntVariable(\"key_invquery\",       &key_invquery);\n    M_BindIntVariable(\"key_mission\",        &key_mission);\n    M_BindIntVariable(\"key_invPop\",         &key_invpop);\n    M_BindIntVariable(\"key_invKey\",         &key_invkey);\n    M_BindIntVariable(\"key_invHome\",        &key_invhome);\n    M_BindIntVariable(\"key_invEnd\",         &key_invend);\n    M_BindIntVariable(\"key_invUse\",         &key_invuse);\n    M_BindIntVariable(\"key_invDrop\",        &key_invdrop);\n\n    // Strife also supports jump on mouse and joystick, and in the exact same\n    // manner as Hexen!\n    M_BindIntVariable(\"mouseb_jump\",        &mousebjump);\n    M_BindIntVariable(\"joyb_jump\",          &joybjump);\n}\n\nvoid M_BindWeaponControls(void)\n{\n    M_BindIntVariable(\"key_weapon1\",        &key_weapon1);\n    M_BindIntVariable(\"key_weapon2\",        &key_weapon2);\n    M_BindIntVariable(\"key_weapon3\",        &key_weapon3);\n    M_BindIntVariable(\"key_weapon4\",        &key_weapon4);\n    M_BindIntVariable(\"key_weapon5\",        &key_weapon5);\n    M_BindIntVariable(\"key_weapon6\",        &key_weapon6);\n    M_BindIntVariable(\"key_weapon7\",        &key_weapon7);\n    M_BindIntVariable(\"key_weapon8\",        &key_weapon8);\n\n    M_BindIntVariable(\"key_prevweapon\",     &key_prevweapon);\n    M_BindIntVariable(\"key_nextweapon\",     &key_nextweapon);\n\n    M_BindIntVariable(\"joyb_prevweapon\",    &joybprevweapon);\n    M_BindIntVariable(\"joyb_nextweapon\",    &joybnextweapon);\n\n    M_BindIntVariable(\"mouseb_prevweapon\",  &mousebprevweapon);\n    M_BindIntVariable(\"mouseb_nextweapon\",  &mousebnextweapon);\n}\n\nvoid M_BindMapControls(void)\n{\n    M_BindIntVariable(\"key_map_north\",      &key_map_north);\n    M_BindIntVariable(\"key_map_south\",      &key_map_south);\n    M_BindIntVariable(\"key_map_east\",       &key_map_east);\n    M_BindIntVariable(\"key_map_west\",       &key_map_west);\n    M_BindIntVariable(\"key_map_zoomin\",     &key_map_zoomin);\n    M_BindIntVariable(\"key_map_zoomout\",    &key_map_zoomout);\n    M_BindIntVariable(\"key_map_toggle\",     &key_map_toggle);\n    M_BindIntVariable(\"key_map_maxzoom\",    &key_map_maxzoom);\n    M_BindIntVariable(\"key_map_follow\",     &key_map_follow);\n    M_BindIntVariable(\"key_map_grid\",       &key_map_grid);\n    M_BindIntVariable(\"key_map_mark\",       &key_map_mark);\n    M_BindIntVariable(\"key_map_clearmark\",  &key_map_clearmark);\n}\n\nvoid M_BindMenuControls(void)\n{\n    M_BindIntVariable(\"key_menu_activate\",  &key_menu_activate);\n    M_BindIntVariable(\"key_menu_up\",        &key_menu_up);\n    M_BindIntVariable(\"key_menu_down\",      &key_menu_down);\n    M_BindIntVariable(\"key_menu_left\",      &key_menu_left);\n    M_BindIntVariable(\"key_menu_right\",     &key_menu_right);\n    M_BindIntVariable(\"key_menu_back\",      &key_menu_back);\n    M_BindIntVariable(\"key_menu_forward\",   &key_menu_forward);\n    M_BindIntVariable(\"key_menu_confirm\",   &key_menu_confirm);\n    M_BindIntVariable(\"key_menu_abort\",     &key_menu_abort);\n\n    M_BindIntVariable(\"key_menu_help\",      &key_menu_help);\n    M_BindIntVariable(\"key_menu_save\",      &key_menu_save);\n    M_BindIntVariable(\"key_menu_load\",      &key_menu_load);\n    M_BindIntVariable(\"key_menu_volume\",    &key_menu_volume);\n    M_BindIntVariable(\"key_menu_detail\",    &key_menu_detail);\n    M_BindIntVariable(\"key_menu_qsave\",     &key_menu_qsave);\n    M_BindIntVariable(\"key_menu_endgame\",   &key_menu_endgame);\n    M_BindIntVariable(\"key_menu_messages\",  &key_menu_messages);\n    M_BindIntVariable(\"key_menu_qload\",     &key_menu_qload);\n    M_BindIntVariable(\"key_menu_quit\",      &key_menu_quit);\n    M_BindIntVariable(\"key_menu_gamma\",     &key_menu_gamma);\n\n    M_BindIntVariable(\"key_menu_incscreen\", &key_menu_incscreen);\n    M_BindIntVariable(\"key_menu_decscreen\", &key_menu_decscreen);\n    M_BindIntVariable(\"key_menu_screenshot\",&key_menu_screenshot);\n    M_BindIntVariable(\"key_demo_quit\",      &key_demo_quit);\n    M_BindIntVariable(\"key_spy\",            &key_spy);\n}\n\nvoid M_BindChatControls(unsigned int num_players)\n{\n    char name[32];  // haleyjd: 20 not large enough - Thank you, come again!\n    unsigned int i; // haleyjd: signedness conflict\n\n    M_BindIntVariable(\"key_multi_msg\",     &key_multi_msg);\n\n    for (i=0; i<num_players; ++i)\n    {\n        M_snprintf(name, sizeof(name), \"key_multi_msgplayer%i\", i + 1);\n        M_BindIntVariable(name, &key_multi_msgplayer[i]);\n    }\n}\n\n//\n// Apply custom patches to the default values depending on the\n// platform we are running on.\n//\n\nvoid M_ApplyPlatformDefaults(void)\n{\n    // no-op. Add your platform-specific patches here.\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tFixed point implementation.\n//\n\n\n\n#include \"stdlib.h\"\n\n#include \"doomtype.h\"\n#include \"i_system.h\"\n\n#include \"m_fixed.h\"\n\n\n\n\n// Fixme. __USE_C_FIXED__ or something.\n\nfixed_t\nFixedMul\n( fixed_t\ta,\n  fixed_t\tb )\n{\n    return ((int64_t) a * (int64_t) b) >> FRACBITS;\n}\n\n\n\n//\n// FixedDiv, C version.\n//\n\nfixed_t FixedDiv(fixed_t a, fixed_t b)\n{\n    if ((abs(a) >> 14) >= abs(b))\n    {\n\treturn (a^b) < 0 ? INT_MIN : INT_MAX;\n    }\n    else\n    {\n\tint64_t result;\n\n\tresult = ((int64_t) a << FRACBITS) / b;\n\n\treturn (fixed_t) result;\n    }\n}\n\n/* CPhipps -\n * FixedMod - returns a % b, guaranteeing 0<=a<b\n * (notice that the C standard for % does not guarantee this)\n */\n\nfixed_t FixedMod(fixed_t a, fixed_t b)\n{\n  if (b & (b-1)) {\n    fixed_t r = a % b;\n    return ((r<0) ? r+b : r);\n  } else\n    return (a & (b-1));\n}\n\nfixed_t Scale(fixed_t a, fixed_t b, fixed_t c)\n{\n\treturn (fixed_t)(((int64_t)a*b)/c);\n}","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 1993-2008 Raven Software\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//      Miscellaneous.\n//\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include \"doomtype.h\"\n\n#include \"deh_str.h\"\n\n#include \"i_swap.h\"\n#include \"i_system.h\"\n#include \"i_video.h\"\n#include \"m_misc.h\"\n#include \"v_video.h\"\n#include \"w_wad.h\"\n#include \"z_zone.h\"\n\n//\n// Create a directory\n//\n\nvoid M_MakeDirectory(const char *path)\n{\n#ifdef _WIN32\n    mkdir(path);\n#else\n    mkdir(path, 0755);\n#endif\n}\n\n// Check if a file exists\n\nboolean M_FileExists(const char *filename)\n{\n    FILE *fstream;\n\n    fstream = fopen(filename, \"r\");\n\n    if (fstream != NULL)\n    {\n        fclose(fstream);\n        return true;\n    }\n    else\n    {\n        // If we can't open because the file is a directory, the \n        // \"file\" exists at least!\n\n        return errno == EISDIR;\n    }\n}\n\n// Check if a file exists by probing for common case variation of its filename.\n// Returns a newly allocated string that the caller is responsible for freeing.\n\nchar *M_FileCaseExists(const char *path)\n{\n    char *path_dup, *filename, *ext;\n\n    path_dup = M_StringDuplicate(path);\n\n    // 0: actual path\n    if (M_FileExists(path_dup))\n    {\n        return path_dup;\n    }\n\n    filename = strrchr(path_dup, DIR_SEPARATOR);\n    if (filename != NULL)\n    {\n        filename++;\n    }\n    else\n    {\n        filename = path_dup;\n    }\n\n    // 1: lowercase filename, e.g. doom2.wad\n    M_ForceLowercase(filename);\n\n    if (M_FileExists(path_dup))\n    {\n        return path_dup;\n    }\n\n    // 2: uppercase filename, e.g. DOOM2.WAD\n    M_ForceUppercase(filename);\n\n    if (M_FileExists(path_dup))\n    {\n        return path_dup;\n    }\n\n    // 3. uppercase basename with lowercase extension, e.g. DOOM2.wad\n    ext = strrchr(path_dup, '.');\n    if (ext != NULL && ext > filename)\n    {\n        M_ForceLowercase(ext + 1);\n\n        if (M_FileExists(path_dup))\n        {\n            return path_dup;\n        }\n    }\n\n    // 4. lowercase filename with uppercase first letter, e.g. Doom2.wad\n    if (strlen(filename) > 1)\n    {\n        M_ForceLowercase(filename + 1);\n\n        if (M_FileExists(path_dup))\n        {\n            return path_dup;\n        }\n    }\n\n    // 5. no luck\n    free(path_dup);\n    return NULL;\n}\n\n//\n// Determine the length of an open file.\n//\n\nlong M_FileLength(FILE *handle)\n{ \n    long savedpos;\n    long length;\n\n    // save the current position in the file\n    savedpos = ftell(handle);\n    \n    // jump to the end and find the length\n    fseek(handle, 0, SEEK_END);\n    length = ftell(handle);\n\n    // go back to the old location\n    fseek(handle, savedpos, SEEK_SET);\n\n    return length;\n}\n\n//\n// M_WriteFile\n//\n\nboolean M_WriteFile(const char *name, void *source, int length)\n{\n    FILE *handle;\n    int\tcount;\n\t\n    handle = fopen(name, \"wb\");\n\n    if (handle == NULL)\n\treturn false;\n\n    count = fwrite(source, 1, length, handle);\n    fclose(handle);\n\t\n    if (count < length)\n\treturn false;\n\t\t\n    return true;\n}\n\n\n//\n// M_ReadFile\n//\n\nint M_ReadFile(const char *name, byte **buffer)\n{\n    FILE *handle;\n    int\tcount, length;\n    byte *buf;\n\t\n    handle = fopen(name, \"rb\");\n    if (handle == NULL)\n\tI_Error (\"Couldn't read file %s\", name);\n\n    // find the size of the file by seeking to the end and\n    // reading the current position\n\n    length = M_FileLength(handle);\n    \n    buf = Z_Malloc (length + 1, PU_STATIC, NULL);\n    count = fread(buf, 1, length, handle);\n    fclose (handle);\n\t\n    if (count < length)\n\tI_Error (\"Couldn't read file %s\", name);\n\t\t\n    buf[length] = '\\0';\n    *buffer = buf;\n    return length;\n}\n\n// Returns the path to a temporary file of the given name, stored\n// inside the system temporary directory.\n//\n// The returned value must be freed with Z_Free after use.\n\nchar *M_TempFile(const char *s)\n{\n    const char *tempdir;\n\n#ifdef _WIN32\n\n    // Check the TEMP environment variable to find the location.\n\n    tempdir = getenv(\"TEMP\");\n\n    if (tempdir == NULL)\n    {\n        tempdir = \".\";\n    }\n#else\n    // In Unix, just use /tmp.\n\n    tempdir = \"/tmp\";\n#endif\n\n    return M_StringJoin(tempdir, DIR_SEPARATOR_S, s, NULL);\n}\n\nboolean M_StrToInt(const char *str, int *result)\n{\n    return sscanf(str, \" 0x%x\", result) == 1\n        || sscanf(str, \" 0X%x\", result) == 1\n        || sscanf(str, \" 0%o\", result) == 1\n        || sscanf(str, \" %d\", result) == 1;\n}\n\n// Returns the directory portion of the given path, without the trailing\n// slash separator character. If no directory is described in the path,\n// the string \".\" is returned. In either case, the result is newly allocated\n// and must be freed by the caller after use.\nchar *M_DirName(const char *path)\n{\n    char *p, *result;\n\n    p = strrchr(path, DIR_SEPARATOR);\n    if (p == NULL)\n    {\n        return M_StringDuplicate(\".\");\n    }\n    else\n    {\n        result = M_StringDuplicate(path);\n        result[p - path] = '\\0';\n        return result;\n    }\n}\n\n// Returns the base filename described by the given path (without the\n// directory name). The result points inside path and nothing new is\n// allocated.\nconst char *M_BaseName(const char *path)\n{\n    const char *p;\n\n    p = strrchr(path, DIR_SEPARATOR);\n    if (p == NULL)\n    {\n        return path;\n    }\n    else\n    {\n        return p + 1;\n    }\n}\n\nvoid M_ExtractFileBase(const char *path, char *dest)\n{\n    const char *src;\n    const char *filename;\n    int length;\n\n    src = path + strlen(path) - 1;\n\n    // back up until a \\ or the start\n    while (src != path && *(src - 1) != DIR_SEPARATOR)\n    {\n\tsrc--;\n    }\n\n    filename = src;\n\n    // Copy up to eight characters\n    // Note: Vanilla Doom exits with an error if a filename is specified\n    // with a base of more than eight characters.  To remove the 8.3\n    // filename limit, instead we simply truncate the name.\n\n    length = 0;\n    memset(dest, 0, 8);\n\n    while (*src != '\\0' && *src != '.')\n    {\n        if (length >= 8)\n        {\n            printf(\"Warning: Truncated '%s' lump name to '%.8s'.\\n\",\n                   filename, dest);\n            break;\n        }\n\n\tdest[length++] = toupper((int)*src++);\n    }\n}\n\n//---------------------------------------------------------------------------\n//\n// PROC M_ForceUppercase\n//\n// Change string to uppercase.\n//\n//---------------------------------------------------------------------------\n\nvoid M_ForceUppercase(char *text)\n{\n    char *p;\n\n    for (p = text; *p != '\\0'; ++p)\n    {\n        *p = toupper(*p);\n    }\n}\n\n//---------------------------------------------------------------------------\n//\n// PROC M_ForceLowercase\n//\n// Change string to lowercase.\n//\n//---------------------------------------------------------------------------\n\nvoid M_ForceLowercase(char *text)\n{\n    char *p;\n\n    for (p = text; *p != '\\0'; ++p)\n    {\n        *p = tolower(*p);\n    }\n}\n\n//\n// M_StrCaseStr\n//\n// Case-insensitive version of strstr()\n//\n\nconst char *M_StrCaseStr(const char *haystack, const char *needle)\n{\n    unsigned int haystack_len;\n    unsigned int needle_len;\n    unsigned int len;\n    unsigned int i;\n\n    haystack_len = strlen(haystack);\n    needle_len = strlen(needle);\n\n    if (haystack_len < needle_len)\n    {\n        return NULL;\n    }\n\n    len = haystack_len - needle_len;\n\n    for (i = 0; i <= len; ++i)\n    {\n        if (!strncasecmp(haystack + i, needle, needle_len))\n        {\n            return haystack + i;\n        }\n    }\n\n    return NULL;\n}\n\n//\n// Safe version of strdup() that checks the string was successfully\n// allocated.\n//\n\nchar *M_StringDuplicate(const char *orig)\n{\n    char *result;\n\n    result = strdup(orig);\n\n    if (result == NULL)\n    {\n        I_Error(\"Failed to duplicate string\\n\");\n    }\n\n    return result;\n}\n\n//\n// String replace function.\n//\n\nchar *M_StringReplace(const char *haystack, const char *needle,\n                      const char *replacement)\n{\n    char *result, *dst;\n    const char *p;\n    size_t needle_len = strlen(needle);\n    size_t result_len, dst_len;\n\n    // Iterate through occurrences of 'needle' and calculate the size of\n    // the new string.\n    result_len = strlen(haystack) + 1;\n    p = haystack;\n\n    for (;;)\n    {\n        p = strstr(p, needle);\n        if (p == NULL)\n        {\n            break;\n        }\n\n        p += needle_len;\n        result_len += strlen(replacement) - needle_len;\n    }\n\n    // Construct new string.\n\n    result = malloc(result_len);\n    if (result == NULL)\n    {\n        I_Error(\"M_StringReplace: Failed to allocate new string\");\n        return NULL;\n    }\n\n    dst = result; dst_len = result_len;\n    p = haystack;\n\n    while (*p != '\\0')\n    {\n        if (!strncmp(p, needle, needle_len))\n        {\n            M_StringCopy(dst, replacement, dst_len);\n            p += needle_len;\n            dst += strlen(replacement);\n            dst_len -= strlen(replacement);\n        }\n        else\n        {\n            *dst = *p;\n            ++dst; --dst_len;\n            ++p;\n        }\n    }\n\n    *dst = '\\0';\n\n    return result;\n}\n\n// Safe string copy function that works like OpenBSD's strlcpy().\n// Returns true if the string was not truncated.\n\nboolean M_StringCopy(char *dest, const char *src, size_t dest_size)\n{\n    size_t len;\n\n    if (dest_size >= 1)\n    {\n        dest[dest_size - 1] = '\\0';\n        strncpy(dest, src, dest_size - 1);\n    }\n    else\n    {\n        return false;\n    }\n\n    len = strlen(dest);\n    return src[len] == '\\0';\n}\n\n// Safe string concat function that works like OpenBSD's strlcat().\n// Returns true if string not truncated.\n\nboolean M_StringConcat(char *dest, const char *src, size_t dest_size)\n{\n    size_t offset;\n\n    offset = strlen(dest);\n    if (offset > dest_size)\n    {\n        offset = dest_size;\n    }\n\n    return M_StringCopy(dest + offset, src, dest_size - offset);\n}\n\n// Returns true if 's' begins with the specified prefix.\n\nboolean M_StringStartsWith(const char *s, const char *prefix)\n{\n    return strlen(s) > strlen(prefix)\n        && strncmp(s, prefix, strlen(prefix)) == 0;\n}\n\n// Returns true if 's' ends with the specified suffix.\n\nboolean M_StringEndsWith(const char *s, const char *suffix)\n{\n    return strlen(s) >= strlen(suffix)\n        && strcmp(s + strlen(s) - strlen(suffix), suffix) == 0;\n}\n\n// Return a newly-malloced string with all the strings given as arguments\n// concatenated together.\n\nchar *M_StringJoin(const char *s, ...)\n{\n    char *result;\n    const char *v;\n    va_list args;\n    size_t result_len;\n\n    result_len = strlen(s) + 1;\n\n    va_start(args, s);\n    for (;;)\n    {\n        v = va_arg(args, const char *);\n        if (v == NULL)\n        {\n            break;\n        }\n\n        result_len += strlen(v);\n    }\n    va_end(args);\n\n    result = malloc(result_len);\n\n    if (result == NULL)\n    {\n        I_Error(\"M_StringJoin: Failed to allocate new string.\");\n        return NULL;\n    }\n\n    M_StringCopy(result, s, result_len);\n\n    va_start(args, s);\n    for (;;)\n    {\n        v = va_arg(args, const char *);\n        if (v == NULL)\n        {\n            break;\n        }\n\n        M_StringConcat(result, v, result_len);\n    }\n    va_end(args);\n\n    return result;\n}\n\n// On Windows, vsnprintf() is _vsnprintf().\n#ifdef _WIN32\n#if _MSC_VER < 1400 /* not needed for Visual Studio 2008 */\n#define vsnprintf _vsnprintf\n#endif\n#endif\n\n// Safe, portable vsnprintf().\nint M_vsnprintf(char *buf, size_t buf_len, const char *s, va_list args)\n{\n    int result;\n\n    if (buf_len < 1)\n    {\n        return 0;\n    }\n\n    // Windows (and other OSes?) has a vsnprintf() that doesn't always\n    // append a trailing \\0. So we must do it, and write into a buffer\n    // that is one byte shorter; otherwise this function is unsafe.\n    result = vsnprintf(buf, buf_len, s, args);\n\n    // If truncated, change the final char in the buffer to a \\0.\n    // A negative result indicates a truncated buffer on Windows.\n    if (result < 0 || result >= buf_len)\n    {\n        buf[buf_len - 1] = '\\0';\n        result = buf_len - 1;\n    }\n\n    return result;\n}\n\n// Safe, portable snprintf().\nint M_snprintf(char *buf, size_t buf_len, const char *s, ...)\n{\n    va_list args;\n    int result;\n    va_start(args, s);\n    result = M_vsnprintf(buf, buf_len, s, args);\n    va_end(args);\n    return result;\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tDOOM main program (D_DoomMain) and game loop (D_DoomLoop),\n//\tplus functions to determine game mode (shareware, registered),\n//\tparse command line parameters, configure game parameters (turbo),\n//\tand call the startup functions.\n//\n\n\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"config.h\"\n#include \"deh_main.h\"\n#include \"doomdef.h\"\n#include \"doomstat.h\"\n\n#include \"dstrings.h\"\n#include \"sounds.h\"\n\n#include \"d_iwad.h\"\n\n#include \"z_zone.h\"\n#include \"w_main.h\"\n#include \"w_wad.h\"\n#include \"s_sound.h\"\n#include \"v_diskicon.h\"\n#include \"v_video.h\"\n\n#include \"f_finale.h\"\n#include \"f_wipe.h\"\n\n#include \"m_argv.h\"\n#include \"m_config.h\"\n#include \"m_controls.h\"\n#include \"m_misc.h\"\n#include \"m_menu.h\"\n#include \"p_saveg.h\"\n\n#include \"i_endoom.h\"\n#include \"i_input.h\"\n#include \"i_joystick.h\"\n#include \"i_system.h\"\n#include \"i_timer.h\"\n#include \"i_video.h\"\n\n#include \"g_game.h\"\n\n#include \"hu_stuff.h\"\n#include \"wi_stuff.h\"\n#include \"st_stuff.h\"\n#include \"am_map.h\"\n\n#include \"p_setup.h\"\n#include \"r_local.h\"\n#include \"statdump.h\"\n\n\n#include \"d_main.h\"\n#include \"i_gif.h\"\n\n#include <emscripten.h>\n\n// Inspect mode\nboolean inspectmode = false;\nboolean firstScreen = true;\n\n// Crispy\nboolean havee1m10 = false;\nboolean havemap33 = false;\n\n//\n// D-DoomLoop()\n// Not a globally visible function,\n//  just included for source reference,\n//  called by D_DoomMain, never exits.\n// Manages timing and IO,\n//  calls all ?_Responder, ?_Ticker, and ?_Drawer,\n//  calls I_GetTime, I_StartFrame, and I_StartTic\n//\nvoid D_DoomLoop (void);\n\n// Location where savegames are stored\n\nchar *          savegamedir;\n\n// location of IWAD and WAD files\n\nchar *          iwadfile;\n\nboolean\t\tdevparm;\t// started game with -devparm\nboolean         nomonsters;\t// checkparm of -nomonsters\nboolean         respawnparm;\t// checkparm of -respawn\nboolean         fastparm;\t// checkparm of -fast\n\nextern  boolean\tinhelpscreens;\n\nskill_t\t\tstartskill;\nint             startepisode;\nint\t\tstartmap;\nboolean\t\tautostart;\nint             startloadgame;\n\nboolean\t\tadvancedemo;\nticcmd_t *netcmds;\nstatic void RunTic(ticcmd_t *cmds, boolean *ingame)\n{\n    netcmds = cmds;\n\n    // check that there are players in the game.  if not, we cannot\n    // run a tic.\n\n    if (advancedemo)\n        D_DoAdvanceDemo ();\n\n    G_Ticker ();\n}\n\n// Store demo, do not accept any inputs\nboolean         storedemo;\n\n//\n// D_ProcessEvents\n// Send all the events of the given timestamp down the responder chain\n//\nvoid D_ProcessEvents (void)\n{\n    event_t*\tev;\n\t\n    // IF STORE DEMO, DO NOT ACCEPT INPUT\n    if (storedemo)\n        return;\n\t\n    while ((ev = D_PopEvent()) != NULL)\n    {\n\tif (M_Responder (ev))\n\t    continue;               // menu ate the event\n\tG_Responder (ev);\n    }\n}\n\n// Doom loop interface\nstatic loop_interface_t doom_loop_interface = {\n    D_ProcessEvents,\n    G_BuildTiccmd,\n    RunTic,\n    M_Ticker\n};\n\n// Load game settings from the specified structure and\n// set global variables.\n\nstatic void LoadGameSettings(net_gamesettings_t *settings)\n{\n    unsigned int i;\n\n    deathmatch = settings->deathmatch;\n    startepisode = settings->episode;\n    startmap = settings->map;\n    startskill = settings->skill;\n    startloadgame = settings->loadgame;\n    lowres_turn = settings->lowres_turn;\n    nomonsters = settings->nomonsters;\n    fastparm = settings->fast_monsters;\n    respawnparm = settings->respawn_monsters;\n    timelimit = settings->timelimit;\n    consoleplayer = settings->consoleplayer;\n\n    if (lowres_turn)\n    {\n        printf(\"NOTE: Turning resolution is reduced; this is probably \"\n               \"because there is a client recording a Vanilla demo.\\n\");\n    }\n\n    for (i = 0; i < MAXPLAYERS; ++i)\n    {\n        playeringame[i] = i < settings->num_players;\n    }\n}\n\n// Save the game settings from global variables to the specified\n// game settings structure.\n\nstatic void SaveGameSettings(net_gamesettings_t *settings)\n{\n    // Fill in game settings structure with appropriate parameters\n    // for the new game\n\n    settings->deathmatch = deathmatch;\n    settings->episode = startepisode;\n    settings->map = startmap;\n    settings->skill = startskill;\n    settings->loadgame = startloadgame;\n    settings->gameversion = gameversion;\n    settings->nomonsters = nomonsters;\n    settings->fast_monsters = fastparm;\n    settings->respawn_monsters = respawnparm;\n    settings->timelimit = timelimit;\n\n    settings->lowres_turn = (M_ParmExists(\"-record\")\n                         && !M_ParmExists(\"-longtics\"))\n                          || M_ParmExists(\"-shorttics\");\n}\n\n// If true, the main game loop has started.\nboolean         main_loop_started = false;\n\nchar\t\twadfile[1024];\t\t// primary wad file\nchar\t\tmapdir[1024];           // directory of development maps\n\nint             show_endoom = 1;\nint             show_diskicon = 1;\n\nchar            *nervewadfile = NULL;\n\n//\n// D_Display\n//  draw current display, possibly wiping it from the previous\n//\n\n// wipegamestate can be set to -1 to force a wipe on the next draw\ngamestate_t     wipegamestate = GS_DEMOSCREEN;\nextern  boolean setsizeneeded;\nextern  int             showMessages;\nvoid R_ExecuteSetViewSize (void);\n\nint wipestart;\nint nowtime;\nint tics;\nboolean done;\nvoid D_Display (void)\n{\n    static  boolean\t\tviewactivestate = false;\n    static  boolean\t\tmenuactivestate = false;\n    static  boolean\t\tinhelpscreensstate = false;\n    static  boolean\t\tfullscreen = false;\n    static  gamestate_t\t\toldgamestate = -1;\n    static  int\t\t\tborderdrawcount;\n    int\t\t\t\ty;\n    boolean\t\t\twipe;\n    boolean\t\t\tredrawsbar;\n\n    if (wipestart > 0)\n    {\n        nowtime = I_GetTime ();\n\t    tics = nowtime - wipestart;\n        if (tics <= 0) return;\n\n        wipestart = nowtime;\n        done = wipe_ScreenWipe(wipe_Melt\n\t\t\t       , 0, 0, SCREENWIDTH, SCREENHEIGHT, tics);\n        I_UpdateNoBlit ();\n        M_Drawer ();                            // menu is drawn even on top of wipes\n        I_FinishUpdate ();                      // page flip or blit buffer\n\n        if (done)\n        {\n            wipestart = 0;\n        }\n        else return;\n    }\n\n    if (nodrawers)\n\treturn;                    // for comparative timing / profiling\n\t\t\n    redrawsbar = false;\n    \n    // change the view size if needed\n    if (setsizeneeded)\n    {\n\tR_ExecuteSetViewSize ();\n\toldgamestate = -1;                      // force background redraw\n\tborderdrawcount = 3;\n    }\n\n    // save the current screen if about to wipe\n    if (gamestate != wipegamestate)\n    {\n\twipe = true;\n\twipe_StartScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);\n    }\n    else\n\twipe = false;\n\n    if (gamestate == GS_LEVEL && gametic)\n\tHU_Erase();\n    \n    // do buffered drawing\n    switch (gamestate)\n    {\n      case GS_LEVEL:\n\tif (!gametic)\n\t    break;\n\tif (automapactive)\n\t    AM_Drawer ();\n\tif (wipe || (viewheight != SCREENHEIGHT && fullscreen))\n\t    redrawsbar = true;\n\tif (inhelpscreensstate && !inhelpscreens)\n\t    redrawsbar = true;              // just put away the help screen\n\tST_Drawer (viewheight == SCREENHEIGHT, redrawsbar );\n\tfullscreen = viewheight == SCREENHEIGHT;\n\tbreak;\n\n      case GS_INTERMISSION:\n\tWI_Drawer ();\n\tbreak;\n\n      case GS_FINALE:\n\tF_Drawer ();\n\tbreak;\n\n      case GS_DEMOSCREEN:\n\tD_PageDrawer ();\n\tbreak;\n    }\n    \n    // draw buffered stuff to screen\n    I_UpdateNoBlit ();\n    \n    // draw the view directly\n    if (gamestate == GS_LEVEL && !automapactive && gametic)\n\tR_RenderPlayerView (&players[displayplayer]);\n\n    if (gamestate == GS_LEVEL && gametic)\n\tHU_Drawer ();\n    \n    // clean up border stuff\n    if (gamestate != oldgamestate && gamestate != GS_LEVEL)\n\tI_SetPalette (W_CacheLumpName (DEH_String(\"PLAYPAL\"),PU_CACHE));\n\n    // see if the border needs to be initially drawn\n    if (gamestate == GS_LEVEL && oldgamestate != GS_LEVEL)\n    {\n\tviewactivestate = false;        // view was not active\n\tR_FillBackScreen ();    // draw the pattern into the back screen\n    }\n\n    // see if the border needs to be updated to the screen\n    if (gamestate == GS_LEVEL && !automapactive && scaledviewwidth != SCREENWIDTH)\n    {\n\tif (menuactive || menuactivestate || !viewactivestate)\n\t    borderdrawcount = 3;\n\tif (borderdrawcount)\n\t{\n\t    R_DrawViewBorder ();    // erase old menu stuff\n\t    borderdrawcount--;\n\t}\n\n    }\n\n    if (testcontrols)\n    {\n        // Box showing current mouse speed\n\n        V_DrawMouseSpeedBox(testcontrols_mousespeed);\n    }\n\n    menuactivestate = menuactive;\n    viewactivestate = viewactive;\n    inhelpscreensstate = inhelpscreens;\n    oldgamestate = wipegamestate = gamestate;\n    \n    // draw pause pic\n    if (paused)\n    {\n\tif (automapactive)\n\t    y = 4;\n\telse\n\t    y = viewwindowy+4;\n\tV_DrawPatchDirect(viewwindowx + (scaledviewwidth - 68) / 2, y,\n                          W_CacheLumpName (DEH_String(\"M_PAUSE\"), PU_CACHE));\n    }\n\n\n    // menus go directly to the screen\n    M_Drawer ();          // menu is drawn even on top of everything\n    NetUpdate ();         // send out any new accumulation\n\n\n    // normal update\n    if (!wipe)\n    {\n\tI_FinishUpdate ();              // page flip or blit buffer\n\treturn;\n    }\n    \n    if (!inspectmode)\n    {\n    // wipe update\n    wipe_EndScreen(0, 0, SCREENWIDTH, SCREENHEIGHT);\n\n    wipestart = I_GetTime () - 1;\n    }\n}\n\nstatic void EnableLoadingDisk(void)\n{\n    const char *disk_lump_name;\n\n    if (show_diskicon)\n    {\n        if (M_CheckParm(\"-cdrom\") > 0)\n        {\n            disk_lump_name = DEH_String(\"STCDROM\");\n        }\n        else\n        {\n            disk_lump_name = DEH_String(\"STDISK\");\n        }\n\n        V_EnableLoadingDisk(disk_lump_name,\n                            SCREENWIDTH - LOADING_DISK_W,\n                            SCREENHEIGHT - LOADING_DISK_H);\n    }\n}\n\n//\n// Add configuration file variable bindings.\n//\n\nvoid D_BindVariables(void)\n{\n    int i;\n\n    M_ApplyPlatformDefaults();\n\n    I_BindInputVariables();\n    I_BindVideoVariables();\n    I_BindJoystickVariables();\n    I_BindSoundVariables();\n\n    M_BindBaseControls();\n    M_BindWeaponControls();\n    M_BindMapControls();\n    M_BindMenuControls();\n    M_BindChatControls(MAXPLAYERS);\n\n    key_multi_msgplayer[0] = HUSTR_KEYGREEN;\n    key_multi_msgplayer[1] = HUSTR_KEYINDIGO;\n    key_multi_msgplayer[2] = HUSTR_KEYBROWN;\n    key_multi_msgplayer[3] = HUSTR_KEYRED;\n\n    M_BindIntVariable(\"mouse_sensitivity\",      &mouseSensitivity);\n    M_BindIntVariable(\"sfx_volume\",             &sfxVolume);\n    M_BindIntVariable(\"music_volume\",           &musicVolume);\n    M_BindIntVariable(\"show_messages\",          &showMessages);\n    M_BindIntVariable(\"screenblocks\",           &screenblocks);\n    M_BindIntVariable(\"detaillevel\",            &detailLevel);\n    M_BindIntVariable(\"snd_channels\",           &snd_channels);\n    M_BindIntVariable(\"vanilla_savegame_limit\", &vanilla_savegame_limit);\n    M_BindIntVariable(\"vanilla_demo_limit\",     &vanilla_demo_limit);\n    M_BindIntVariable(\"show_endoom\",            &show_endoom);\n    M_BindIntVariable(\"show_diskicon\",          &show_diskicon);\n\n    // Multiplayer chat macros\n\n    for (i=0; i<10; ++i)\n    {\n        char buf[12];\n\n        M_snprintf(buf, sizeof(buf), \"chatmacro%i\", i);\n        M_BindStringVariable(buf, &chat_macros[i]);\n    }\n}\n\n//\n// D_GrabMouseCallback\n//\n// Called to determine whether to grab the mouse pointer\n//\n\nboolean D_GrabMouseCallback(void)\n{\n    // when menu is active or game is paused, release the mouse \n \n    if (menuactive || paused)\n        return false;\n\n    // only grab mouse when playing levels (but not demos)\n\n    return (gamestate == GS_LEVEL) && !demoplayback && !advancedemo;\n}\n\nvoid D_DoomLoopIter()\n{\n    if (wipestart > 0)\n    {\n        D_Display();\n        return;\n    }\n\n    I_StartFrame ();\n\n    TryRunTics (); // will run at least one tic\n\n    S_UpdateSounds (players[consoleplayer].mo);// move positional sounds\n\n    // Update display, next frame, with current state.\n    if (screenvisible)\n    {\n        D_Display ();\n        if (inspectmode && firstScreen)\n        {\n            firstScreen = false;\n            G_ScreenShot();\n        }\n    }\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid D_SetLoopIter()\n{\n    emscripten_set_main_loop(D_DoomLoopIter, 0, 0);\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid D_CancelLoopIter()\n{\n    emscripten_cancel_main_loop();\n}\n\nEMSCRIPTEN_KEEPALIVE\nchar* G_GetGameDescription()\n{\n    return gamedescription;\n}\n\nEMSCRIPTEN_KEEPALIVE\nint G_GetEpisodeCount()\n{\n    int epi = 4;\n\n    if (gamemode == commercial)\n        epi = 1;\n    // Versions of doom.exe before the Ultimate Doom release only had\n    // three episodes; if we're emulating one of those then don't try\n    // to show episode four. If we are, then do show episode four\n    // (should crash if missing).\n    else if (gameversion < exe_ultimate)\n        epi--;\n    // chex.exe shows only one episode.\n    else if (gameversion == exe_chex)\n        epi = 1;\n\n    return epi;\n}\n\nEMSCRIPTEN_KEEPALIVE\nvoid G_SetInspectMode()\n{\n    inspectmode = true;\n}\n\n//\n//  D_DoomLoop\n//\nvoid D_DoomLoop (void)\n{\n    if (gamevariant == bfgedition &&\n        (demorecording || (gameaction == ga_playdemo) || netgame))\n    {\n        printf(\" WARNING: You are playing using one of the Doom Classic\\n\"\n               \" IWAD files shipped with the Doom 3: BFG Edition. These are\\n\"\n               \" known to be incompatible with the regular IWAD files and\\n\"\n               \" may cause demos and network games to get out of sync.\\n\");\n    }\n\n    main_loop_started = true;\n\n    I_SetWindowTitle(gamedescription);\n    I_GraphicsCheckCommandLine();\n    I_SetGrabMouseCallback(D_GrabMouseCallback);\n    I_InitGraphics();\n    EnableLoadingDisk();\n\n    TryRunTics();\n\n    V_RestoreBuffer();\n    R_ExecuteSetViewSize();\n\n    D_StartGameLoop();\n\n    if (testcontrols)\n    {\n        wipegamestate = gamestate;\n    }\n}\n\n\n\n//\n//  DEMO LOOP\n//\nint             demosequence;\nint             pagetic;\nconst char                    *pagename;\n\n\n//\n// D_PageTicker\n// Handles timing for warped projection\n//\nvoid D_PageTicker (void)\n{\n    if (--pagetic < 0)\n\tD_AdvanceDemo ();\n}\n\n\n\n//\n// D_PageDrawer\n//\nvoid D_PageDrawer (void)\n{\n    V_DrawPatch (0, 0, W_CacheLumpName(pagename, PU_CACHE));\n}\n\n\n//\n// D_AdvanceDemo\n// Called after each demo or intro demosequence finishes\n//\nvoid D_AdvanceDemo (void)\n{\n    advancedemo = true;\n}\n\n\n//\n// This cycles through the demo sequences.\n// FIXME - version dependend demo numbers?\n//\nvoid D_DoAdvanceDemo (void)\n{\n    players[consoleplayer].playerstate = PST_LIVE;  // not reborn\n    advancedemo = false;\n    usergame = false;               // no save / end game here\n    paused = false;\n    gameaction = ga_nothing;\n\n    // The Ultimate Doom executable changed the demo sequence to add\n    // a DEMO4 demo.  Final Doom was based on Ultimate, so also\n    // includes this change; however, the Final Doom IWADs do not\n    // include a DEMO4 lump, so the game bombs out with an error\n    // when it reaches this point in the demo sequence.\n\n    // However! There is an alternate version of Final Doom that\n    // includes a fixed executable.\n\n    if (gameversion == exe_ultimate || gameversion == exe_final)\n      demosequence = (demosequence+1)%7;\n    else\n      demosequence = (demosequence+1)%6;\n    \n    switch (demosequence)\n    {\n      case 0:\n\tif ( gamemode == commercial )\n\t    pagetic = TICRATE * 11;\n\telse\n\t    pagetic = 170;\n\tgamestate = GS_DEMOSCREEN;\n\tpagename = DEH_String(\"TITLEPIC\");\n\tif ( gamemode == commercial )\n\t  S_StartMusic(mus_dm2ttl);\n\telse\n\t  S_StartMusic (mus_intro);\n\tbreak;\n      case 1:\n\tG_DeferedPlayDemo(DEH_String(\"demo1\"));\n\tbreak;\n      case 2:\n\tpagetic = 200;\n\tgamestate = GS_DEMOSCREEN;\n\tpagename = DEH_String(\"CREDIT\");\n\tbreak;\n      case 3:\n\tG_DeferedPlayDemo(DEH_String(\"demo2\"));\n\tbreak;\n      case 4:\n\tgamestate = GS_DEMOSCREEN;\n\tif ( gamemode == commercial)\n\t{\n\t    pagetic = TICRATE * 11;\n\t    pagename = DEH_String(\"TITLEPIC\");\n\t    S_StartMusic(mus_dm2ttl);\n\t}\n\telse\n\t{\n\t    pagetic = 200;\n\n\t    if (gameversion >= exe_ultimate)\n\t      pagename = DEH_String(\"CREDIT\");\n\t    else\n\t      pagename = DEH_String(\"HELP2\");\n\t}\n\tbreak;\n      case 5:\n\tG_DeferedPlayDemo(DEH_String(\"demo3\"));\n\tbreak;\n        // THE DEFINITIVE DOOM Special Edition demo\n      case 6:\n\tG_DeferedPlayDemo(DEH_String(\"demo4\"));\n\tbreak;\n    }\n\n    // The Doom 3: BFG Edition version of doom2.wad does not have a\n    // TITLETPIC lump. Use INTERPIC instead as a workaround.\n    if (gamevariant == bfgedition && !strcasecmp(pagename, \"TITLEPIC\")\n        && W_CheckNumForName(\"titlepic\") < 0)\n    {\n        pagename = DEH_String(\"INTERPIC\");\n    }\n}\n\n\n\n//\n// D_StartTitle\n//\nvoid D_StartTitle (void)\n{\n    gameaction = ga_nothing;\n    demosequence = -1;\n    D_AdvanceDemo ();\n}\n\n// Strings for dehacked replacements of the startup banner\n//\n// These are from the original source: some of them are perhaps\n// not used in any dehacked patches\n\nstatic char *banners[] =\n{\n    // doom2.wad\n    \"                         \"\n    \"DOOM 2: Hell on Earth v%i.%i\"\n    \"                           \",\n    // doom2.wad v1.666\n    \"                         \"\n    \"DOOM 2: Hell on Earth v%i.%i66\"\n    \"                          \",\n    // doom1.wad\n    \"                            \"\n    \"DOOM Shareware Startup v%i.%i\"\n    \"                           \",\n    // doom.wad\n    \"                            \"\n    \"DOOM Registered Startup v%i.%i\"\n    \"                           \",\n    // Registered DOOM uses this\n    \"                          \"\n    \"DOOM System Startup v%i.%i\"\n    \"                          \",\n    // Doom v1.666\n    \"                          \"\n    \"DOOM System Startup v%i.%i66\"\n    \"                          \"\n    // doom.wad (Ultimate DOOM)\n    \"                         \"\n    \"The Ultimate DOOM Startup v%i.%i\"\n    \"                        \",\n    // tnt.wad\n    \"                     \"\n    \"DOOM 2: TNT - Evilution v%i.%i\"\n    \"                           \",\n    // plutonia.wad\n    \"                   \"\n    \"DOOM 2: Plutonia Experiment v%i.%i\"\n    \"                           \",\n};\n\n//\n// Get game name: if the startup banner has been replaced, use that.\n// Otherwise, use the name given\n// \n\nstatic char *GetGameName(char *gamename)\n{\n    size_t i;\n    const char *deh_sub;\n    \n    for (i=0; i<arrlen(banners); ++i)\n    {\n        // Has the banner been replaced?\n\n        deh_sub = DEH_String(banners[i]);\n        \n        if (deh_sub != banners[i])\n        {\n            size_t gamename_size;\n            int version;\n\n            // Has been replaced.\n            // We need to expand via printf to include the Doom version number\n            // We also need to cut off spaces to get the basic name\n\n            gamename_size = strlen(deh_sub) + 10;\n            gamename = Z_Malloc(gamename_size, PU_STATIC, 0);\n            version = G_VanillaVersionCode();\n            M_snprintf(gamename, gamename_size, deh_sub,\n                       version / 100, version % 100);\n\n            while (gamename[0] != '\\0' && isspace(gamename[0]))\n            {\n                memmove(gamename, gamename + 1, gamename_size - 1);\n            }\n\n            while (gamename[0] != '\\0' && isspace(gamename[strlen(gamename)-1]))\n            {\n                gamename[strlen(gamename) - 1] = '\\0';\n            }\n\n            return gamename;\n        }\n    }\n\n    return gamename;\n}\n\nstatic void SetMissionForPackName(char *pack_name)\n{\n    int i;\n    static const struct\n    {\n        char *name;\n        int mission;\n    } packs[] = {\n        { \"doom2\",    doom2 },\n        { \"tnt\",      pack_tnt },\n        { \"plutonia\", pack_plut },\n    };\n\n    for (i = 0; i < arrlen(packs); ++i)\n    {\n        if (!strcasecmp(pack_name, packs[i].name))\n        {\n            gamemission = packs[i].mission;\n            return;\n        }\n    }\n\n    printf(\"Valid mission packs are:\\n\");\n\n    for (i = 0; i < arrlen(packs); ++i)\n    {\n        printf(\"\\t%s\\n\", packs[i].name);\n    }\n\n    I_Error(\"Unknown mission pack name: %s\", pack_name);\n}\n\n//\n// Find out what version of Doom is playing.\n//\n\nvoid D_IdentifyVersion(void)\n{\n    // gamemission is set up by the D_FindIWAD function.  But if \n    // we specify '-iwad', we have to identify using \n    // IdentifyIWADByName.  However, if the iwad does not match\n    // any known IWAD name, we may have a dilemma.  Try to \n    // identify by its contents.\n\n    if (gamemission == none)\n    {\n        unsigned int i;\n\n        for (i=0; i<numlumps; ++i)\n        {\n            if (!strncasecmp(lumpinfo[i]->name, \"MAP01\", 8))\n            {\n                gamemission = doom2;\n                break;\n            } \n            else if (!strncasecmp(lumpinfo[i]->name, \"E1M1\", 8))\n            {\n                gamemission = doom;\n                break;\n            }\n        }\n\n        if (gamemission == none)\n        {\n            // Still no idea.  I don't think this is going to work.\n\n            I_Error(\"Unknown or invalid IWAD file.\");\n        }\n    }\n\n    // Make sure gamemode is set up correctly\n\n    if (logical_gamemission == doom)\n    {\n        // Doom 1.  But which version?\n\n        if (W_CheckNumForName(\"E4M1\") > 0)\n        {\n            // Ultimate Doom\n\n            gamemode = retail;\n        } \n        else if (W_CheckNumForName(\"E3M1\") > 0)\n        {\n            gamemode = registered;\n        }\n        else\n        {\n            gamemode = shareware;\n        }\n    }\n    else\n    {\n        int p;\n\n        // Doom 2 of some kind.\n        gamemode = commercial;\n\n        // We can manually override the gamemission that we got from the\n        // IWAD detection code. This allows us to eg. play Plutonia 2\n        // with Freedoom and get the right level names.\n\n        //!\n        // @category compat\n        // @arg <pack>\n        //\n        // Explicitly specify a Doom II \"mission pack\" to run as, instead of\n        // detecting it based on the filename. Valid values are: \"doom2\",\n        // \"tnt\" and \"plutonia\".\n        //\n        p = M_CheckParmWithArgs(\"-pack\", 1);\n        if (p > 0)\n        {\n            SetMissionForPackName(myargv[p + 1]);\n        }\n    }\n}\n\n// Set the gamedescription string\n\nvoid D_SetGameDescription(void)\n{\n    gamedescription = \"Unknown\";\n\n    if (logical_gamemission == doom)\n    {\n        // Doom 1.  But which version?\n\n        if (gamevariant == freedoom)\n        {\n            gamedescription = GetGameName(\"Freedoom: Phase 1\");\n        }\n        else if (gamemode == retail)\n        {\n            // Ultimate Doom\n\n            gamedescription = GetGameName(\"The Ultimate DOOM\");\n        }\n        else if (gamemode == registered)\n        {\n            gamedescription = GetGameName(\"DOOM Registered\");\n        }\n        else if (gamemode == shareware)\n        {\n            gamedescription = GetGameName(\"DOOM Shareware\");\n        }\n    }\n    else\n    {\n        // Doom 2 of some kind.  But which mission?\n\n        if (gamevariant == freedm)\n        {\n            gamedescription = GetGameName(\"FreeDM\");\n        }\n        else if (gamevariant == freedoom)\n        {\n            gamedescription = GetGameName(\"Freedoom: Phase 2\");\n        }\n        else if (logical_gamemission == doom2)\n        {\n            gamedescription = GetGameName(\"DOOM 2: Hell on Earth\");\n        }\n        else if (logical_gamemission == pack_plut)\n        {\n            gamedescription = GetGameName(\"DOOM 2: Plutonia Experiment\"); \n        }\n        else if (logical_gamemission == pack_tnt)\n        {\n            gamedescription = GetGameName(\"DOOM 2: TNT - Evilution\");\n        }\n        else if (logical_gamemission == pack_nerve)\n        {\n            gamedescription = GetGameName(\"DOOM 2: No Rest For The Living\");\n        }\n        else if (logical_gamemission == pack_master)\n        {\n            gamedescription = GetGameName(\"Master Levels for DOOM 2\");\n        }\n    }\n}\n\n//      print title for every printed line\nchar            title[128];\n\nstatic boolean D_AddFile(char *filename)\n{\n    wad_file_t *handle;\n\n    printf(\" adding %s\\n\", filename);\n    handle = W_AddFile(filename);\n\n    return handle != NULL;\n}\n\n// Copyright message banners\n// Some dehacked mods replace these.  These are only displayed if they are \n// replaced by dehacked.\n\nstatic char *copyright_banners[] =\n{\n    \"===========================================================================\\n\"\n    \"ATTENTION:  This version of DOOM has been modified.  If you would like to\\n\"\n    \"get a copy of the original game, call 1-800-IDGAMES or see the readme file.\\n\"\n    \"        You will not receive technical support for modified games.\\n\"\n    \"                      press enter to continue\\n\"\n    \"===========================================================================\\n\",\n\n    \"===========================================================================\\n\"\n    \"                 Commercial product - do not distribute!\\n\"\n    \"         Please report software piracy to the SPA: 1-800-388-PIR8\\n\"\n    \"===========================================================================\\n\",\n\n    \"===========================================================================\\n\"\n    \"                                Shareware!\\n\"\n    \"===========================================================================\\n\"\n};\n\n// Prints a message only if it has been modified by dehacked.\n\nvoid PrintDehackedBanners(void)\n{\n    size_t i;\n\n    for (i=0; i<arrlen(copyright_banners); ++i)\n    {\n        const char *deh_s;\n\n        deh_s = DEH_String(copyright_banners[i]);\n\n        if (deh_s != copyright_banners[i])\n        {\n            printf(\"%s\", deh_s);\n\n            // Make sure the modified banner always ends in a newline character.\n            // If it doesn't, add a newline.  This fixes av.wad.\n\n            if (deh_s[strlen(deh_s) - 1] != '\\n')\n            {\n                printf(\"\\n\");\n            }\n        }\n    }\n}\n\nstatic struct \n{\n    char *description;\n    char *cmdline;\n    GameVersion_t version;\n} gameversions[] = {\n    {\"Doom 1.666\",           \"1.666\",      exe_doom_1_666},\n    {\"Doom 1.7/1.7a\",        \"1.7\",        exe_doom_1_7},\n    {\"Doom 1.8\",             \"1.8\",        exe_doom_1_8},\n    {\"Doom 1.9\",             \"1.9\",        exe_doom_1_9},\n    {\"Hacx\",                 \"hacx\",       exe_hacx},\n    {\"Ultimate Doom\",        \"ultimate\",   exe_ultimate},\n    {\"Final Doom\",           \"final\",      exe_final},\n    {\"Final Doom (alt)\",     \"final2\",     exe_final2},\n    {\"Chex Quest\",           \"chex\",       exe_chex},\n    { NULL,                  NULL,         0},\n};\n\n// Initialize the game version\n\nstatic void InitGameVersion(void)\n{\n    byte *demolump;\n    char demolumpname[6];\n    int demoversion;\n    int p;\n    int i;\n    boolean status;\n\n    //! \n    // @arg <version>\n    // @category compat\n    //\n    // Emulate a specific version of Doom.  Valid values are \"1.666\",\n    // \"1.7\", \"1.8\", \"1.9\", \"ultimate\", \"final\", \"final2\", \"hacx\" and\n    // \"chex\".\n    //\n\n    p = M_CheckParmWithArgs(\"-gameversion\", 1);\n\n    if (p)\n    {\n        for (i=0; gameversions[i].description != NULL; ++i)\n        {\n            if (!strcmp(myargv[p+1], gameversions[i].cmdline))\n            {\n                gameversion = gameversions[i].version;\n                break;\n            }\n        }\n        \n        if (gameversions[i].description == NULL) \n        {\n            printf(\"Supported game versions:\\n\");\n\n            for (i=0; gameversions[i].description != NULL; ++i)\n            {\n                printf(\"\\t%s (%s)\\n\", gameversions[i].cmdline,\n                        gameversions[i].description);\n            }\n            \n            I_Error(\"Unknown game version '%s'\", myargv[p+1]);\n        }\n    }\n    else\n    {\n        // Determine automatically\n\n        if (gamemission == pack_chex)\n        {\n            // chex.exe - identified by iwad filename\n\n            gameversion = exe_chex;\n        }\n        else if (gamemission == pack_hacx)\n        {\n            // hacx.exe: identified by iwad filename\n\n            gameversion = exe_hacx;\n        }\n        else if (gamemode == shareware || gamemode == registered\n              || (gamemode == commercial && gamemission == doom2))\n        {\n            // original\n            gameversion = exe_doom_1_9;\n\n            // Detect version from demo lump\n            for (i = 1; i <= 3; ++i)\n            {\n                M_snprintf(demolumpname, 6, \"demo%i\", i);\n                if (W_CheckNumForName(demolumpname) > 0)\n                {\n                    demolump = W_CacheLumpName(demolumpname, PU_STATIC);\n                    demoversion = demolump[0];\n                    W_ReleaseLumpName(demolumpname);\n                    status = true;\n                    switch (demoversion)\n                    {\n                        case 106:\n                            gameversion = exe_doom_1_666;\n                            break;\n                        case 107:\n                            gameversion = exe_doom_1_7;\n                            break;\n                        case 108:\n                            gameversion = exe_doom_1_8;\n                            break;\n                        case 109:\n                            gameversion = exe_doom_1_9;\n                            break;\n                        default:\n                            status = false;\n                            break;\n                    }\n                    if (status)\n                    {\n                        break;\n                    }\n                }\n            }\n        }\n        else if (gamemode == retail)\n        {\n            gameversion = exe_ultimate;\n        }\n        else if (gamemode == commercial)\n        {\n            // Final Doom: tnt or plutonia\n            // Defaults to emulating the first Final Doom executable,\n            // which has the crash in the demo loop; however, having\n            // this as the default should mean that it plays back\n            // most demos correctly.\n\n            gameversion = exe_final;\n        }\n    }\n    \n    // The original exe does not support retail - 4th episode not supported\n\n    if (gameversion < exe_ultimate && gamemode == retail)\n    {\n        gamemode = registered;\n    }\n\n    // EXEs prior to the Final Doom exes do not support Final Doom.\n\n    if (gameversion < exe_final && gamemode == commercial\n     && (gamemission == pack_tnt || gamemission == pack_plut))\n    {\n        gamemission = doom2;\n    }\n}\n\nvoid PrintGameVersion(void)\n{\n    int i;\n\n    for (i=0; gameversions[i].description != NULL; ++i)\n    {\n        if (gameversions[i].version == gameversion)\n        {\n            printf(\"Emulating the behavior of the \"\n                   \"'%s' executable.\\n\", gameversions[i].description);\n            break;\n        }\n    }\n}\n\n// Function called at exit to display the ENDOOM screen\n\nstatic void D_Endoom(void)\n{\n    byte *endoom;\n\n    // Don't show ENDOOM if we have it disabled, or we're running\n    // in screensaver or control test mode. Only show it once the\n    // game has actually started.\n\n    if (!show_endoom || !main_loop_started\n     || screensaver_mode || M_CheckParm(\"-testcontrols\") > 0)\n    {\n        return;\n    }\n\n    endoom = W_CacheLumpName(DEH_String(\"ENDOOM\"), PU_STATIC);\n\n    I_Endoom(endoom);\n}\n\n// Load dehacked patches needed for certain IWADs.\nstatic void LoadIwadDeh(void)\n{\n    // The Freedoom IWADs have DEHACKED lumps that must be loaded.\n    if (gamevariant == freedoom || gamevariant == freedm)\n    {\n        // Old versions of Freedoom (before 2014-09) did not have technically\n        // valid DEHACKED lumps, so ignore errors and just continue if this\n        // is an old IWAD.\n        DEH_LoadLumpByName(\"DEHACKED\", false, true);\n    }\n\n    // If this is the HACX IWAD, we need to load the DEHACKED lump.\n    if (gameversion == exe_hacx)\n    {\n        if (!DEH_LoadLumpByName(\"DEHACKED\", true, false))\n        {\n            I_Error(\"DEHACKED lump not found.  Please check that this is the \"\n                    \"Hacx v1.2 IWAD.\");\n        }\n    }\n\n    // Chex Quest needs a separate Dehacked patch which must be downloaded\n    // and installed next to the IWAD.\n    if (gameversion == exe_chex)\n    {\n        char *chex_deh = NULL;\n        char *sep;\n\n        // Look for chex.deh in the same directory as the IWAD file.\n        sep = strrchr(iwadfile, DIR_SEPARATOR);\n\n        if (sep != NULL)\n        {\n            size_t chex_deh_len = strlen(iwadfile) + 9;\n            chex_deh = malloc(chex_deh_len);\n            M_StringCopy(chex_deh, iwadfile, chex_deh_len);\n            chex_deh[sep - iwadfile + 1] = '\\0';\n            M_StringConcat(chex_deh, \"chex.deh\", chex_deh_len);\n        }\n        else\n        {\n            chex_deh = M_StringDuplicate(\"chex.deh\");\n        }\n\n        // If the dehacked patch isn't found, try searching the WAD\n        // search path instead.  We might find it...\n        if (!M_FileExists(chex_deh))\n        {\n            free(chex_deh);\n            chex_deh = D_FindWADByName(\"chex.deh\");\n        }\n\n        // Still not found?\n        if (chex_deh == NULL)\n        {\n            I_Error(\"Unable to find Chex Quest dehacked file (chex.deh).\\n\"\n                    \"The dehacked file is required in order to emulate\\n\"\n                    \"chex.exe correctly.  It can be found in your nearest\\n\"\n                    \"/idgames repository mirror at:\\n\\n\"\n                    \"   utils/exe_edit/patches/chexdeh.zip\");\n        }\n\n        if (!DEH_LoadFile(chex_deh))\n        {\n            I_Error(\"Failed to load chex.deh needed for emulating chex.exe.\");\n        }\n    }\n}\n\n// [crispy] support loading NERVE.WAD alongside DOOM2.WAD\nstatic void LoadNerveWad(void)\n{\n    int i, j, k;\n\n    if (gamemission != doom2)\n        return;\n\n    if ((i = W_GetNumForName(\"map01\")) != -1 &&\n        (j = W_GetNumForName(\"map09\")) != -1 &&\n        !strcasecmp(W_WadNameForLump(lumpinfo[i]), \"nerve.wad\") &&\n        !strcasecmp(W_WadNameForLump(lumpinfo[j]), \"nerve.wad\"))\n    {\n\tgamemission = pack_nerve;\n\tDEH_AddStringReplacement (\"TITLEPIC\", \"INTERPIC\");\n    }\n    else\n    // [crispy] The \"New Game -> Which Expansion\" menu is only shown if the\n    // menu graphics lumps are available and (a) if they are from the IWAD\n    // and that is the BFG Edition DOOM2.WAD or (b) if they are from a PWAD.\n    if ((i = W_CheckNumForName(\"M_EPI1\")) != -1 &&\n        (j = W_CheckNumForName(\"M_EPI2\")) != -1 &&\n        (k = W_CheckNumForName(\"M_EPISOD\")) != -1 &&\n        (gamevariant == bfgedition ||\n        (!W_IsIWADLump(lumpinfo[i]) &&\n         !W_IsIWADLump(lumpinfo[j]) &&\n         !W_IsIWADLump(lumpinfo[k]))))\n    {\n        if (strrchr(iwadfile, DIR_SEPARATOR) != NULL)\n        {\n            char *dir;\n            dir = M_DirName(iwadfile);\n            nervewadfile = M_StringJoin(dir, DIR_SEPARATOR_S, \"nerve.wad\", NULL);\n            free(dir);\n        }\n        else\n        {\n            nervewadfile = M_StringDuplicate(\"nerve.wad\");\n        }\n\n        if (!M_FileExists(nervewadfile))\n        {\n            free(nervewadfile);\n            nervewadfile = D_FindWADByName(\"nerve.wad\");\n        }\n\n        if (nervewadfile == NULL)\n        {\n            return;\n        }\n\n        D_AddFile(nervewadfile);\n\n        // [crispy] rename level name patch lumps out of the way\n        for (i = 0; i < 9; i++)\n        {\n            char lumpname[9];\n\n            M_snprintf (lumpname, 9, \"CWILV%2.2d\", i);\n            lumpinfo[W_GetNumForName(lumpname)]->name[0] = 'N';\n        }\n    }\n}\n\n// [crispy] support loading MASTERLEVELS.WAD alongside DOOM2.WAD\nstatic void LoadMasterlevelsWad(void)\n{\n    int i, j;\n\n    if (gamemission != doom2)\n        return;\n\n    if ((i = W_GetNumForName(\"map01\")) != -1 &&\n        (j = W_GetNumForName(\"map21\")) != -1 &&\n        !strcasecmp(W_WadNameForLump(lumpinfo[i]), \"masterlevels.wad\") &&\n        !strcasecmp(W_WadNameForLump(lumpinfo[j]), \"masterlevels.wad\"))\n    {\n\tgamemission = pack_master;\n    }\n}\n\nstatic void G_CheckDemoStatusAtExit (void)\n{\n    G_CheckDemoStatus();\n}\n\n//\n// D_DoomMain\n//\nvoid D_DoomMain (void)\n{\n    int p;\n    char file[256];\n    char demolumpname[9];\n    int numiwadlumps;\n\n    // print banner\n\n    I_PrintBanner(PACKAGE_STRING);\n\n    printf(\"D_MAIN: init emscripten main loop.\\n\");\n    D_SetLoopIter();\n    I_AtExit(D_CancelLoopIter, true);\n    I_AtExit(D_Endoom, false);\n\n    DEH_printf(\"Z_Init: Init zone memory allocation daemon. \\n\");\n    Z_Init ();\n\n    //!\n    // @category game\n    // @vanilla\n    //\n    // Disable monsters.\n    //\n\t\n    nomonsters = M_CheckParm (\"-nomonsters\");\n\n    //!\n    // @category game\n    // @vanilla\n    //\n    // Monsters respawn after being killed.\n    //\n\n    respawnparm = M_CheckParm (\"-respawn\");\n\n    //!\n    // @category game\n    // @vanilla\n    //\n    // Monsters move faster.\n    //\n\n    fastparm = M_CheckParm (\"-fast\");\n\n    //!\n    // @vanilla\n    //\n    // Developer mode. F1 saves a screenshot in the current working\n    // directory.\n    //\n\n    devparm = M_CheckParm (\"-devparm\");\n\n    I_DisplayFPSDots(devparm);\n\n    //!\n    // @category net\n    // @vanilla\n    //\n    // Start a deathmatch game.\n    //\n\n    if (M_CheckParm (\"-deathmatch\"))\n\tdeathmatch = 1;\n\n    //!\n    // @category net\n    // @vanilla\n    //\n    // Start a deathmatch 2.0 game.  Weapons do not stay in place and\n    // all items respawn after 30 seconds.\n    //\n\n    if (M_CheckParm (\"-altdeath\"))\n\tdeathmatch = 2;\n\n    if (devparm)\n\tDEH_printf(D_DEVSTR);\n    \n    // Auto-detect the configuration dir.\n    M_SetConfigDir(NULL);\n\n    //!\n    // @category game\n    // @arg <x>\n    // @vanilla\n    //\n    // Turbo mode.  The player's speed is multiplied by x%.  If unspecified,\n    // x defaults to 200.  Values are rounded up to 10 and down to 400.\n    //\n\n    if ( (p=M_CheckParm (\"-turbo\")) )\n    {\n\tint     scale = 200;\n\textern int forwardmove[2];\n\textern int sidemove[2];\n\t\n\tif (p<myargc-1)\n\t    scale = atoi (myargv[p+1]);\n\tif (scale < 10)\n\t    scale = 10;\n\tif (scale > 400)\n\t    scale = 400;\n        DEH_printf(\"turbo scale: %i%%\\n\", scale);\n\tforwardmove[0] = forwardmove[0]*scale/100;\n\tforwardmove[1] = forwardmove[1]*scale/100;\n\tsidemove[0] = sidemove[0]*scale/100;\n\tsidemove[1] = sidemove[1]*scale/100;\n    }\n    \n    // init subsystems\n    DEH_printf(\"V_Init: allocate screens.\\n\");\n    V_Init ();\n\n    // Load configuration files before initialising other subsystems.\n    DEH_printf(\"M_LoadDefaults: Load system defaults.\\n\");\n    M_SetConfigFilenames(\"default.cfg\", PROGRAM_PREFIX \"doom.cfg\");\n    D_BindVariables();\n    M_LoadDefaults();\n\n    // Save configuration at exit.\n    I_AtExit(M_SaveDefaults, false);\n\n    // Find main IWAD file and load it.\n    iwadfile = D_FindIWAD(IWAD_MASK_DOOM, &gamemission);\n\n    // None found?\n\n    if (iwadfile == NULL)\n    {\n        I_Error(\"Game mode indeterminate.  No IWAD file was found.  Try\\n\"\n                \"specifying one with the '-iwad' command line parameter.\\n\");\n    }\n\n    modifiedgame = false;\n\n    DEH_printf(\"W_Init: Init WADfiles.\\n\");\n    D_AddFile(iwadfile);\n    numiwadlumps = numlumps;\n\n    W_CheckCorrectIWAD(doom);\n\n    // Now that we've loaded the IWAD, we can figure out what gamemission\n    // we're playing and which version of Vanilla Doom we need to emulate.\n    D_IdentifyVersion();\n    InitGameVersion();\n\n    // Check which IWAD variant we are using.\n\n    if (W_CheckNumForName(\"FREEDOOM\") >= 0)\n    {\n        if (W_CheckNumForName(\"FREEDM\") >= 0)\n        {\n            gamevariant = freedm;\n        }\n        else\n        {\n            gamevariant = freedoom;\n        }\n    }\n    else if (W_CheckNumForName(\"DMENUPIC\") >= 0)\n    {\n        gamevariant = bfgedition;\n    }\n\n    //!\n    // @category mod\n    //\n    // Disable automatic loading of Dehacked patches for certain\n    // IWAD files.\n    //\n    if (!M_ParmExists(\"-nodeh\"))\n    {\n        // Some IWADs have dehacked patches that need to be loaded for\n        // them to be played properly.\n        LoadIwadDeh();\n    }\n\n    // Doom 3: BFG Edition includes modified versions of the classic\n    // IWADs which can be identified by an additional DMENUPIC lump.\n    // Furthermore, the M_GDHIGH lumps have been modified in a way that\n    // makes them incompatible to Vanilla Doom and the modified version\n    // of doom2.wad is missing the TITLEPIC lump.\n    // We specifically check for DMENUPIC here, before PWADs have been\n    // loaded which could probably include a lump of that name.\n\n    if (gamevariant == bfgedition)\n    {\n        printf(\"BFG Edition: Using workarounds as needed.\\n\");\n\n        // BFG Edition changes the names of the secret levels to\n        // censor the Wolfenstein references. It also has an extra\n        // secret level (MAP33). In Vanilla Doom (meaning the DOS\n        // version), MAP33 overflows into the Plutonia level names\n        // array, so HUSTR_33 is actually PHUSTR_1.\n        DEH_AddStringReplacement(HUSTR_31, \"level 31: idkfa\");\n        DEH_AddStringReplacement(HUSTR_32, \"level 32: keen\");\n        DEH_AddStringReplacement(PHUSTR_1, \"level 33: betray\");\n\n        // The BFG edition doesn't have the \"low detail\" menu option (fair\n        // enough). But bizarrely, it reuses the M_GDHIGH patch as a label\n        // for the options menu (says \"Fullscreen:\"). Why the perpetrators\n        // couldn't just add a new graphic lump and had to reuse this one,\n        // I don't know.\n        //\n        // The end result is that M_GDHIGH is too wide and causes the game\n        // to crash. As a workaround to get a minimum level of support for\n        // the BFG edition IWADs, use the \"ON\"/\"OFF\" graphics instead.\n        DEH_AddStringReplacement(\"M_GDHIGH\", \"M_MSGON\");\n        DEH_AddStringReplacement(\"M_GDLOW\", \"M_MSGOFF\");\n\n        // The BFG edition's \"Screen Size:\" graphic has also been changed\n        // to say \"Gamepad:\". Fortunately, it (along with the original\n        // Doom IWADs) has an unused graphic that says \"Display\". So we\n        // can swap this in instead, and it kind of makes sense.\n        DEH_AddStringReplacement(\"M_SCRNSZ\", \"M_DISP\");\n    }\n\n    // Load Dehacked patches specified on the command line with -deh.\n    // Note that there's a very careful and deliberate ordering to how\n    // Dehacked patches are loaded. The order we use is:\n    //  1. IWAD dehacked patches.\n    //  2. Command line dehacked patches specified with -deh.\n    //  3. PWAD dehacked patches in DEHACKED lumps.\n    DEH_ParseCommandLine();\n\n    // Load PWAD files.\n    modifiedgame = W_ParseCommandLine();\n\n    //!\n    // @arg <demo>\n    // @category demo\n    // @vanilla\n    //\n    // Play back the demo named demo.lmp.\n    //\n\n    p = M_CheckParmWithArgs (\"-playdemo\", 1);\n\n    if (!p)\n    {\n        //!\n        // @arg <demo>\n        // @category demo\n        // @vanilla\n        //\n        // Play back the demo named demo.lmp, determining the framerate\n        // of the screen.\n        //\n\tp = M_CheckParmWithArgs(\"-timedemo\", 1);\n\n    }\n\n    if (p)\n    {\n        char *uc_filename = strdup(myargv[p + 1]);\n        M_ForceUppercase(uc_filename);\n\n        // With Vanilla you have to specify the file without extension,\n        // but make that optional.\n        if (M_StringEndsWith(uc_filename, \".LMP\"))\n        {\n            M_StringCopy(file, myargv[p + 1], sizeof(file));\n        }\n        else\n        {\n            DEH_snprintf(file, sizeof(file), \"%s.lmp\", myargv[p+1]);\n        }\n\n        free(uc_filename);\n\n        if (D_AddFile(file))\n        {\n            M_StringCopy(demolumpname, lumpinfo[numlumps - 1]->name,\n                         sizeof(demolumpname));\n        }\n        else\n        {\n            // If file failed to load, still continue trying to play\n            // the demo in the same way as Vanilla Doom.  This makes\n            // tricks like \"-playdemo demo1\" possible.\n\n            M_StringCopy(demolumpname, myargv[p + 1], sizeof(demolumpname));\n        }\n\n        printf(\"Playing demo %s.\\n\", file);\n    }\n\n    I_AtExit(G_CheckDemoStatusAtExit, true);\n\n    // Generate the WAD hash table.  Speed things up a bit.\n    W_GenerateHashTable();\n\n    // [crispy] allow overriding of special-casing\n    if (!M_ParmExists(\"-nodeh\"))\n    {\n\tLoadMasterlevelsWad();\n\tLoadNerveWad();\n    }\n\n    // Load DEHACKED lumps from WAD files - but only if we give the right\n    // command line parameter.\n\n    //!\n    // @category mod\n    //\n    // Load Dehacked patches from DEHACKED lumps contained in one of the\n    // loaded PWAD files.\n    //\n    if (M_ParmExists(\"-dehlump\"))\n    {\n        int i, loaded = 0;\n\n        for (i = numiwadlumps; i < numlumps; ++i)\n        {\n            if (!strncmp(lumpinfo[i]->name, \"DEHACKED\", 8))\n            {\n                DEH_LoadLump(i, false, false);\n                loaded++;\n            }\n        }\n\n        printf(\"  loaded %i DEHACKED lumps from PWAD files.\\n\", loaded);\n    }\n\n    // Set the gamedescription string. This is only possible now that\n    // we've finished loading Dehacked patches.\n    D_SetGameDescription();\n\n    savegamedir = M_GetSaveGameDir(D_SaveGameIWADName(gamemission));\n\n    // Check for -file in shareware\n    if (modifiedgame && (gamevariant != freedoom))\n    {\n\t// These are the lumps that will be checked in IWAD,\n\t// if any one is not present, execution will be aborted.\n\tchar name[23][8]=\n\t{\n\t    \"e2m1\",\"e2m2\",\"e2m3\",\"e2m4\",\"e2m5\",\"e2m6\",\"e2m7\",\"e2m8\",\"e2m9\",\n\t    \"e3m1\",\"e3m3\",\"e3m3\",\"e3m4\",\"e3m5\",\"e3m6\",\"e3m7\",\"e3m8\",\"e3m9\",\n\t    \"dphoof\",\"bfgga0\",\"heada1\",\"cybra1\",\"spida1d1\"\n\t};\n\tint i;\n\t\n\tif ( gamemode == shareware)\n\t    I_Error(DEH_String(\"\\nYou cannot -file with the shareware \"\n\t\t\t       \"version. Register!\"));\n\n\t// Check for fake IWAD with right name,\n\t// but w/o all the lumps of the registered version. \n\tif (gamemode == registered)\n\t    for (i = 0;i < 23; i++)\n\t\tif (W_CheckNumForName(name[i])<0)\n\t\t    I_Error(DEH_String(\"\\nThis is not the registered version.\"));\n    }\n\n    if (W_CheckNumForName(\"SS_START\") >= 0\n     || W_CheckNumForName(\"FF_END\") >= 0)\n    {\n        I_PrintDivider();\n        printf(\" WARNING: The loaded WAD file contains modified sprites or\\n\"\n               \" floor textures.  You may want to use the '-merge' command\\n\"\n               \" line option instead of '-file'.\\n\");\n    }\n\n    I_PrintStartupBanner(gamedescription);\n    PrintDehackedBanners();\n\n    // Freedoom's IWADs are Boom-compatible, which means they usually\n    // don't work in Vanilla (though FreeDM is okay). Show a warning\n    // message and give a link to the website.\n    if (gamevariant == freedoom)\n    {\n        printf(\" WARNING: You are playing using one of the Freedoom IWAD\\n\"\n               \" files, which might not work in this port. See this page\\n\"\n               \" for more information on how to play using Freedoom:\\n\"\n               \"   https://www.chocolate-doom.org/wiki/index.php/Freedoom\\n\");\n        I_PrintDivider();\n    }\n\n    DEH_printf(\"I_Init: Setting up machine state.\\n\");\n    I_CheckIsScreensaver();\n    I_InitTimer();\n    I_InitJoystick();\n    I_InitSound(true);\n    I_InitMusic();\n\n    // [crispy] check for presence of E1M10\n    havee1m10 = (gamemode == retail) &&\n        (W_CheckNumForName(\"e1m10\") != -1) &&\n        (W_CheckNumForName(\"sewers\") != -1);\n\n    // [crispy] check for presence of MAP33\n    havemap33 = (gamemode == commercial) &&\n        (W_CheckNumForName(\"map33\") != -1) &&\n        (W_CheckNumForName(\"cwilv32\") != -1);\n\n    // [crispy] change level name for MAP33 if not already changed\n    if (havemap33 && !strcmp(PHUSTR_1, DEH_String(PHUSTR_1)))\n    {\n        DEH_AddStringReplacement(PHUSTR_1, \"level 33: betray\");\n    }\n\n    printf (\"NET_Init: Init network subsystem.\\n\");\n\n    // get skill / episode / map from parms\n    startskill = sk_medium;\n    startepisode = 1;\n    startmap = 1;\n    autostart = false;\n\n    //!\n    // @category game\n    // @arg <skill>\n    // @vanilla\n    //\n    // Set the game skill, 1-5 (1: easiest, 5: hardest).  A skill of\n    // 0 disables all monsters.\n    //\n\n    p = M_CheckParmWithArgs(\"-skill\", 1);\n\n    if (p)\n    {\n\tstartskill = myargv[p+1][0]-'1';\n\tautostart = true;\n    }\n\n    //!\n    // @category game\n    // @arg <n>\n    // @vanilla\n    //\n    // Start playing on episode n (1-4)\n    //\n\n    p = M_CheckParmWithArgs(\"-episode\", 1);\n\n    if (p)\n    {\n\tstartepisode = myargv[p+1][0]-'0';\n\tstartmap = 1;\n\tautostart = true;\n    }\n\t\n    timelimit = 0;\n\n    //! \n    // @arg <n>\n    // @category net\n    // @vanilla\n    //\n    // For multiplayer games: exit each level after n minutes.\n    //\n\n    p = M_CheckParmWithArgs(\"-timer\", 1);\n\n    if (p)\n    {\n\ttimelimit = atoi(myargv[p+1]);\n    }\n\n    //!\n    // @category net\n    // @vanilla\n    //\n    // Austin Virtual Gaming: end levels after 20 minutes.\n    //\n\n    p = M_CheckParm (\"-avg\");\n\n    if (p)\n    {\n\ttimelimit = 20;\n    }\n\n    //!\n    // @category game\n    // @arg [<x> <y> | <xy>]\n    // @vanilla\n    //\n    // Start a game immediately, warping to ExMy (Doom 1) or MAPxy\n    // (Doom 2)\n    //\n\n    p = M_CheckParmWithArgs(\"-warp\", 1);\n\n    if (p)\n    {\n        if (gamemode == commercial)\n            startmap = atoi (myargv[p+1]);\n        else\n        {\n            startepisode = myargv[p+1][0]-'0';\n\n            if (p + 2 < myargc)\n            {\n                startmap = myargv[p+2][0]-'0';\n            }\n            else\n            {\n                startmap = 1;\n            }\n        }\n        autostart = true;\n    }\n\n    // Undocumented:\n    // Invoked by setup to test the controls.\n\n    p = M_CheckParm(\"-testcontrols\");\n\n    if (p > 0)\n    {\n        startepisode = 1;\n        startmap = 1;\n        autostart = true;\n        testcontrols = true;\n    }\n\n    // Check for load game parameter\n    // We do this here and save the slot number, so that the network code\n    // can override it or send the load slot to other players.\n\n    //!\n    // @category game\n    // @arg <s>\n    // @vanilla\n    //\n    // Load the game in slot s.\n    //\n\n    p = M_CheckParmWithArgs(\"-loadgame\", 1);\n    \n    if (p)\n    {\n        startloadgame = atoi(myargv[p+1]);\n    }\n    else\n    {\n        // Not loading a game\n        startloadgame = -1;\n    }\n\n    DEH_printf(\"M_Init: Init miscellaneous info.\\n\");\n    M_Init ();\n\n    DEH_printf(\"R_Init: Init DOOM refresh daemon - \");\n    printf(\"[...........]\");\n    R_Init ();\n\n    DEH_printf(\"\\nP_Init: Init Playloop state.\\n\");\n    P_Init ();\n\n    DEH_printf(\"S_Init: Setting up sound.\\n\");\n    S_Init (sfxVolume * 8, musicVolume * 8);\n\n    DEH_printf(\"D_CheckNetGame: Checking network game status.\\n\");\n\n    // D_StartNetGame\n    D_RegisterLoopCallbacks(&doom_loop_interface);\n\n    net_gamesettings_t settings;\n    SaveGameSettings(&settings);\n    D_StartNetGame(&settings, NULL);\n    LoadGameSettings(&settings);\n\n    PrintGameVersion();\n\n    DEH_printf(\"HU_Init: Setting up heads up display.\\n\");\n    HU_Init ();\n\n    DEH_printf(\"ST_Init: Init status bar.\\n\");\n    ST_Init ();\n\n    // If Doom II without a MAP01 lump, this is a store demo.\n    // Moved this here so that MAP01 isn't constantly looked up\n    // in the main loop.\n\n    if (gamemode == commercial && W_CheckNumForName(\"map01\") < 0)\n        storedemo = true;\n\n    if (M_CheckParmWithArgs(\"-statdump\", 1))\n    {\n        I_AtExit(StatDump, true);\n        DEH_printf(\"External statistics registered.\\n\");\n    }\n\n    //!\n    // @arg <x>\n    // @category demo\n    // @vanilla\n    //\n    // Record a demo named x.lmp.\n    //\n\n    p = M_CheckParmWithArgs(\"-record\", 1);\n\n    if (p)\n    {\n\tG_RecordDemo (myargv[p+1]);\n\tautostart = true;\n    }\n\n    p = M_CheckParmWithArgs(\"-playdemo\", 1);\n    if (p)\n    {\n\tsingledemo = true;              // quit after one demo\n\tG_DeferedPlayDemo (demolumpname);\n\treturn D_DoomLoop ();  // never returns\n    }\n\t\n    p = M_CheckParmWithArgs(\"-timedemo\", 1);\n    if (p)\n    {\n\tG_TimeDemo (demolumpname);\n\treturn D_DoomLoop ();  // never returns\n    }\n\t\n    if (startloadgame >= 0)\n    {\n        M_StringCopy(file, P_SaveGameFile(startloadgame), sizeof(file));\n\tG_LoadGame(file);\n    }\n\t\n    if (gameaction != ga_loadgame )\n    {\n\tif (autostart || netgame)\n\t    G_InitNew (startskill, startepisode, startmap);\n\telse\n\t    D_StartTitle ();                // start up intro loop\n    }\n\n    D_DoomLoop ();  // never returns\n}\n\n","/*\n  SDL_mixer:  An audio mixer library based on the SDL library\n  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n/* $Id$ */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"SDL.h\"\n\n#include \"SDL_mixer.h\"\n#include \"mixer.h\"\n#include \"music.h\"\n#include \"load_aiff.h\"\n#include \"load_voc.h\"\n\n#define __MIX_INTERNAL_EFFECT__\n#include \"effects_internal.h\"\n\n/* Magic numbers for various audio file formats */\n#define RIFF        0x46464952      /* \"RIFF\" */\n#define WAVE        0x45564157      /* \"WAVE\" */\n#define FORM        0x4d524f46      /* \"FORM\" */\n#define CREA        0x61657243      /* \"Crea\" */\n\nstatic int audio_opened = 0;\nstatic SDL_AudioSpec mixer;\nstatic SDL_AudioDeviceID audio_device;\n\ntypedef struct _Mix_effectinfo\n{\n    Mix_EffectFunc_t callback;\n    Mix_EffectDone_t done_callback;\n    void *udata;\n    struct _Mix_effectinfo *next;\n} effect_info;\n\nstatic struct _Mix_Channel {\n    Mix_Chunk *chunk;\n    int playing;\n    int paused;\n    Uint8 *samples;\n    int volume;\n    int looping;\n    int tag;\n    Uint32 expire;\n    Uint32 start_time;\n    Mix_Fading fading;\n    int fade_volume;\n    int fade_volume_reset;\n    Uint32 fade_length;\n    Uint32 ticks_fade;\n    effect_info *effects;\n} *mix_channel = NULL;\n\nstatic effect_info *posteffects = NULL;\n\nstatic int num_channels;\nstatic int reserved_channels = 0;\n\n\n/* Support for hooking into the mixer callback system */\nstatic void (SDLCALL *mix_postmix)(void *udata, Uint8 *stream, int len) = NULL;\nstatic void *mix_postmix_data = NULL;\n\n/* rcg07062001 callback to alert when channels are done playing. */\nstatic void (SDLCALL *channel_done_callback)(int channel) = NULL;\n\n/* Support for user defined music functions */\nstatic void (SDLCALL *mix_music)(void *udata, Uint8 *stream, int len) = music_mixer;\nstatic void *music_data = NULL;\n\n/* rcg06042009 report available decoders at runtime. */\nstatic const char **chunk_decoders = NULL;\nstatic int num_decoders = 0;\n\n\nint Mix_GetNumChunkDecoders(void)\n{\n    return(num_decoders);\n}\n\nconst char *Mix_GetChunkDecoder(int index)\n{\n    if ((index < 0) || (index >= num_decoders)) {\n        return NULL;\n    }\n    return(chunk_decoders[index]);\n}\n\nSDL_bool Mix_HasChunkDecoder(const char *name)\n{\n    int index;\n    for (index = 0; index < num_decoders; ++index) {\n        if (SDL_strcasecmp(name, chunk_decoders[index]) == 0) {\n            return SDL_TRUE;\n        }\n    }\n    return SDL_FALSE;\n}\n\nstatic void add_chunk_decoder(const char *decoder)\n{\n    void *ptr = SDL_realloc((void *)chunk_decoders, (num_decoders + 1) * sizeof (const char *));\n    if (ptr == NULL) {\n        return;  /* oh well, go on without it. */\n    }\n    chunk_decoders = (const char **) ptr;\n    chunk_decoders[num_decoders++] = decoder;\n}\n\n/* rcg06192001 get linked library's version. */\nconst SDL_version *Mix_Linked_Version(void)\n{\n    static SDL_version linked_version;\n    SDL_MIXER_VERSION(&linked_version);\n    return(&linked_version);\n}\n\nint Mix_Init(int flags)\n{\n    int result = 0;\n\n    load_music();\n\n    if (flags & MIX_INIT_FLAC) {\n        if (has_music(MUS_FLAC)) {\n            result |= MIX_INIT_FLAC;\n        } else {\n            Mix_SetError(\"FLAC support not available\");\n        }\n    }\n    if (flags & MIX_INIT_MOD) {\n        if (has_music(MUS_MOD)) {\n            result |= MIX_INIT_MOD;\n        } else {\n            Mix_SetError(\"MOD support not available\");\n        }\n    }\n    if (flags & MIX_INIT_MP3) {\n        if (has_music(MUS_MP3)) {\n            result |= MIX_INIT_MP3;\n        } else {\n            Mix_SetError(\"MP3 support not available\");\n        }\n    }\n    if (flags & MIX_INIT_OGG) {\n        if (has_music(MUS_OGG)) {\n            result |= MIX_INIT_OGG;\n        } else {\n            Mix_SetError(\"OGG support not available\");\n        }\n    }\n    if (flags & MIX_INIT_MID) {\n        if (has_music(MUS_MID)) {\n            result |= MIX_INIT_MID;\n        } else {\n            Mix_SetError(\"MIDI support not available\");\n        }\n    }\n    return (result);\n}\n\nvoid Mix_Quit()\n{\n    unload_music();\n}\n\nstatic int _Mix_remove_all_effects(int channel, effect_info **e);\n\n/*\n * rcg06122001 Cleanup effect callbacks.\n *  MAKE SURE Mix_LockAudio() is called before this (or you're in the\n *   audio callback).\n */\nstatic void _Mix_channel_done_playing(int channel)\n{\n    if (channel_done_callback) {\n        channel_done_callback(channel);\n    }\n\n    /*\n     * Call internal function directly, to avoid locking audio from\n     *   inside audio callback.\n     */\n    _Mix_remove_all_effects(channel, &mix_channel[channel].effects);\n}\n\n\nstatic void *Mix_DoEffects(int chan, void *snd, int len)\n{\n    int posteffect = (chan == MIX_CHANNEL_POST);\n    effect_info *e = ((posteffect) ? posteffects : mix_channel[chan].effects);\n    void *buf = snd;\n\n    if (e != NULL) {    /* are there any registered effects? */\n        /* if this is the postmix, we can just overwrite the original. */\n        if (!posteffect) {\n            buf = SDL_malloc(len);\n            if (buf == NULL) {\n                return(snd);\n            }\n            SDL_memcpy(buf, snd, len);\n        }\n\n        for (; e != NULL; e = e->next) {\n            if (e->callback != NULL) {\n                e->callback(chan, buf, len, e->udata);\n            }\n        }\n    }\n\n    /* be sure to SDL_free() the return value if != snd ... */\n    return(buf);\n}\n\n\n/* Mixing function */\nstatic void SDLCALL\nmix_channels(void *udata, Uint8 *stream, int len)\n{\n    Uint8 *mix_input;\n    int i, mixable, volume = MIX_MAX_VOLUME;\n    Uint32 sdl_ticks;\n\n#if SDL_VERSION_ATLEAST(1, 3, 0)\n    /* Need to initialize the stream in SDL 1.3+ */\n    SDL_memset(stream, mixer.silence, len);\n#endif\n\n    /* Mix the music (must be done before the channels are added) */\n    mix_music(music_data, stream, len);\n\n    /* Mix any playing channels... */\n    sdl_ticks = SDL_GetTicks();\n    for (i=0; i<num_channels; ++i) {\n        if (!mix_channel[i].paused) {\n            if (mix_channel[i].expire > 0 && mix_channel[i].expire < sdl_ticks) {\n                /* Expiration delay for that channel is reached */\n                mix_channel[i].playing = 0;\n                mix_channel[i].looping = 0;\n                mix_channel[i].fading = MIX_NO_FADING;\n                mix_channel[i].expire = 0;\n                _Mix_channel_done_playing(i);\n            } else if (mix_channel[i].fading != MIX_NO_FADING) {\n                Uint32 ticks = sdl_ticks - mix_channel[i].ticks_fade;\n                if (ticks >= mix_channel[i].fade_length) {\n                    Mix_Volume(i, mix_channel[i].fade_volume_reset); /* Restore the volume */\n                    if(mix_channel[i].fading == MIX_FADING_OUT) {\n                        mix_channel[i].playing = 0;\n                        mix_channel[i].looping = 0;\n                        mix_channel[i].expire = 0;\n                        _Mix_channel_done_playing(i);\n                    }\n                    mix_channel[i].fading = MIX_NO_FADING;\n                } else {\n                    if (mix_channel[i].fading == MIX_FADING_OUT) {\n                        Mix_Volume(i, (mix_channel[i].fade_volume * (mix_channel[i].fade_length-ticks))\n                                   / mix_channel[i].fade_length);\n                    } else {\n                        Mix_Volume(i, (mix_channel[i].fade_volume * ticks) / mix_channel[i].fade_length);\n                    }\n                }\n            }\n            if (mix_channel[i].playing > 0) {\n                int index = 0;\n                int remaining = len;\n                while (mix_channel[i].playing > 0 && index < len) {\n                    remaining = len - index;\n                    volume = (mix_channel[i].volume*mix_channel[i].chunk->volume) / MIX_MAX_VOLUME;\n                    mixable = mix_channel[i].playing;\n                    if (mixable > remaining) {\n                        mixable = remaining;\n                    }\n\n                    mix_input = Mix_DoEffects(i, mix_channel[i].samples, mixable);\n                    SDL_MixAudioFormat(stream+index,mix_input,mixer.format,mixable,volume);\n                    if (mix_input != mix_channel[i].samples)\n                        SDL_free(mix_input);\n\n                    mix_channel[i].samples += mixable;\n                    mix_channel[i].playing -= mixable;\n                    index += mixable;\n\n                    /* rcg06072001 Alert app if channel is done playing. */\n                    if (!mix_channel[i].playing && !mix_channel[i].looping) {\n                        _Mix_channel_done_playing(i);\n                    }\n                }\n\n                /* If looping the sample and we are at its end, make sure\n                   we will still return a full buffer */\n                while (mix_channel[i].looping && index < len) {\n                    int alen = mix_channel[i].chunk->alen;\n                    remaining = len - index;\n                    if (remaining > alen) {\n                        remaining = alen;\n                    }\n\n                    mix_input = Mix_DoEffects(i, mix_channel[i].chunk->abuf, remaining);\n                    SDL_MixAudioFormat(stream+index, mix_input, mixer.format, remaining, volume);\n                    if (mix_input != mix_channel[i].chunk->abuf)\n                        SDL_free(mix_input);\n\n                    if (mix_channel[i].looping > 0) {\n                        --mix_channel[i].looping;\n                    }\n                    mix_channel[i].samples = mix_channel[i].chunk->abuf + remaining;\n                    mix_channel[i].playing = mix_channel[i].chunk->alen - remaining;\n                    index += remaining;\n                }\n                if (! mix_channel[i].playing && mix_channel[i].looping) {\n                    if (mix_channel[i].looping > 0) {\n                        --mix_channel[i].looping;\n                    }\n                    mix_channel[i].samples = mix_channel[i].chunk->abuf;\n                    mix_channel[i].playing = mix_channel[i].chunk->alen;\n                }\n            }\n        }\n    }\n\n    /* rcg06122001 run posteffects... */\n    Mix_DoEffects(MIX_CHANNEL_POST, stream, len);\n\n    if (mix_postmix) {\n        mix_postmix(mix_postmix_data, stream, len);\n    }\n}\n\n#if 0\nstatic void PrintFormat(char *title, SDL_AudioSpec *fmt)\n{\n    printf(\"%s: %d bit %s audio (%s) at %u Hz\\n\", title, (fmt->format&0xFF),\n            (fmt->format&0x8000) ? \"signed\" : \"unsigned\",\n            (fmt->channels > 2) ? \"surround\" :\n            (fmt->channels > 1) ? \"stereo\" : \"mono\", fmt->freq);\n}\n#endif\n\n/* Open the mixer with a certain desired audio format */\nint Mix_OpenAudioDevice(int frequency, Uint16 format, int nchannels, int chunksize,\n                        const char* device, int allowed_changes)\n{\n    int i;\n    SDL_AudioSpec desired;\n\n    /* This used to call SDL_OpenAudio(), which initializes the audio\n       subsystem if necessary. Since SDL_OpenAudioDevice() doesn't,\n       we have to handle this case here. */\n    if (!SDL_WasInit(SDL_INIT_AUDIO)) {\n        if (SDL_InitSubSystem(SDL_INIT_AUDIO) < 0) {\n            return -1;\n        }\n    }\n\n    /* If the mixer is already opened, increment open count */\n    if (audio_opened) {\n        if (format == mixer.format && nchannels == mixer.channels) {\n            ++audio_opened;\n            return(0);\n        }\n        while (audio_opened) {\n            Mix_CloseAudio();\n        }\n    }\n\n    /* Set the desired format and frequency */\n    desired.freq = frequency;\n    desired.format = format;\n    desired.channels = nchannels;\n    desired.samples = chunksize;\n    desired.callback = mix_channels;\n    desired.userdata = NULL;\n\n    /* Accept nearly any audio format */\n    if ((audio_device = SDL_OpenAudioDevice(device, 0, &desired, &mixer, allowed_changes)) == 0) {\n        return(-1);\n    }\n#if 0\n    PrintFormat(\"Audio device\", &mixer);\n#endif\n\n    /* Initialize the music players */\n    load_music();\n    if (open_music(&mixer) < 0) {\n        SDL_CloseAudioDevice(audio_device);\n        return(-1);\n    }\n\n    num_channels = MIX_CHANNELS;\n    mix_channel = (struct _Mix_Channel *) SDL_malloc(num_channels * sizeof(struct _Mix_Channel));\n\n    /* Clear out the audio channels */\n    for (i=0; i<num_channels; ++i) {\n        mix_channel[i].chunk = NULL;\n        mix_channel[i].playing = 0;\n        mix_channel[i].looping = 0;\n        mix_channel[i].volume = SDL_MIX_MAXVOLUME;\n        mix_channel[i].fade_volume = SDL_MIX_MAXVOLUME;\n        mix_channel[i].fade_volume_reset = SDL_MIX_MAXVOLUME;\n        mix_channel[i].fading = MIX_NO_FADING;\n        mix_channel[i].tag = -1;\n        mix_channel[i].expire = 0;\n        mix_channel[i].effects = NULL;\n        mix_channel[i].paused = 0;\n    }\n    Mix_VolumeMusic(SDL_MIX_MAXVOLUME);\n\n    _Mix_InitEffects();\n\n    add_chunk_decoder(\"WAVE\");\n    add_chunk_decoder(\"AIFF\");\n    add_chunk_decoder(\"VOC\");\n    if (has_music(MUS_MOD)) {\n        add_chunk_decoder(\"MOD\");\n    }\n    if (has_music(MUS_MID)) {\n        add_chunk_decoder(\"MID\");\n    }\n    if (has_music(MUS_OGG)) {\n        add_chunk_decoder(\"OGG\");\n    }\n    if (has_music(MUS_MP3)) {\n        add_chunk_decoder(\"MP3\");\n    }\n    if (has_music(MUS_FLAC)) {\n        add_chunk_decoder(\"FLAC\");\n    }\n\n    audio_opened = 1;\n    SDL_PauseAudioDevice(audio_device, 0);\n    return(0);\n}\n\n/* Open the mixer with a certain desired audio format */\nint Mix_OpenAudio(int frequency, Uint16 format, int nchannels, int chunksize)\n{\n    return Mix_OpenAudioDevice(frequency, format, nchannels, chunksize, NULL,\n                                SDL_AUDIO_ALLOW_FREQUENCY_CHANGE |\n                                SDL_AUDIO_ALLOW_CHANNELS_CHANGE);\n}\n\n/* Dynamically change the number of channels managed by the mixer.\n   If decreasing the number of channels, the upper channels are\n   stopped.\n */\nint Mix_AllocateChannels(int numchans)\n{\n    if (numchans<0 || numchans==num_channels)\n        return(num_channels);\n\n    if (numchans < num_channels) {\n        /* Stop the affected channels */\n        int i;\n        for(i=numchans; i < num_channels; i++) {\n            Mix_UnregisterAllEffects(i);\n            Mix_HaltChannel(i);\n        }\n    }\n    Mix_LockAudio();\n    mix_channel = (struct _Mix_Channel *) SDL_realloc(mix_channel, numchans * sizeof(struct _Mix_Channel));\n    if (numchans > num_channels) {\n        /* Initialize the new channels */\n        int i;\n        for(i=num_channels; i < numchans; i++) {\n            mix_channel[i].chunk = NULL;\n            mix_channel[i].playing = 0;\n            mix_channel[i].looping = 0;\n            mix_channel[i].volume = MIX_MAX_VOLUME;\n            mix_channel[i].fade_volume = MIX_MAX_VOLUME;\n            mix_channel[i].fade_volume_reset = MIX_MAX_VOLUME;\n            mix_channel[i].fading = MIX_NO_FADING;\n            mix_channel[i].tag = -1;\n            mix_channel[i].expire = 0;\n            mix_channel[i].effects = NULL;\n            mix_channel[i].paused = 0;\n        }\n    }\n    num_channels = numchans;\n    Mix_UnlockAudio();\n    return(num_channels);\n}\n\n/* Return the actual mixer parameters */\nint Mix_QuerySpec(int *frequency, Uint16 *format, int *channels)\n{\n    if (audio_opened) {\n        if (frequency) {\n            *frequency = mixer.freq;\n        }\n        if (format) {\n            *format = mixer.format;\n        }\n        if (channels) {\n            *channels = mixer.channels;\n        }\n    }\n    return(audio_opened);\n}\n\ntypedef struct _MusicFragment\n{\n    Uint8 *data;\n    int size;\n    struct _MusicFragment *next;\n} MusicFragment;\n\nstatic SDL_AudioSpec *Mix_LoadMusic_RW(Mix_MusicType music_type, SDL_RWops *src, int freesrc, SDL_AudioSpec *spec, Uint8 **audio_buf, Uint32 *audio_len)\n{\n    int i;\n    Mix_MusicInterface *interface = NULL;\n    void *music = NULL;\n    Sint64 start;\n    SDL_bool playing;\n    MusicFragment *first = NULL, *last = NULL, *fragment = NULL;\n    int count = 0;\n    int fragment_size;\n\n    *spec = mixer;\n\n    /* Use fragments sized on full audio frame boundaries - this'll do */\n    fragment_size = spec->size;\n\n    start = SDL_RWtell(src);\n    for (i = 0; i < get_num_music_interfaces(); ++i) {\n        interface = get_music_interface(i);\n        if (interface->type != music_type) {\n            continue;\n        }\n        if (!interface->CreateFromRW || !interface->GetAudio) {\n            continue;\n        }\n\n        /* These music interfaces are not safe to use while music is playing */\n        if (interface->api == MIX_MUSIC_CMD ||\n             interface->api == MIX_MUSIC_MIKMOD ||\n             interface->api == MIX_MUSIC_NATIVEMIDI) {\n            continue;\n        }\n\n        music = interface->CreateFromRW(src, freesrc);\n        if (music) {\n            /* The interface owns the data source now */\n            freesrc = SDL_FALSE;\n            break;\n        }\n\n        /* Reset the stream for the next decoder */\n        SDL_RWseek(src, start, RW_SEEK_SET);\n    }\n\n    if (!music) {\n        if (freesrc) {\n            SDL_RWclose(src);\n        }\n        Mix_SetError(\"Unrecognized audio format\");\n        return NULL;\n    }\n\n    Mix_LockAudio();\n\n    if (interface->Play) {\n        interface->Play(music, 1);\n    }\n    playing = SDL_TRUE;\n\n    while (playing) {\n        int left;\n\n        fragment = (MusicFragment *)SDL_malloc(sizeof(*fragment));\n        if (!fragment) {\n            /* Uh oh, out of memory, let's return what we have */\n            break;\n        }\n        fragment->data = (Uint8 *)SDL_malloc(fragment_size);\n        if (!fragment->data) {\n            /* Uh oh, out of memory, let's return what we have */\n            SDL_free(fragment);\n            break;\n        }\n        fragment->next = NULL;\n\n        left = interface->GetAudio(music, fragment->data, fragment_size);\n        if (left > 0) {\n            playing = SDL_FALSE;\n        } else if (interface->IsPlaying) {\n            playing = interface->IsPlaying(music);\n        }\n        fragment->size = (fragment_size - left);\n\n        if (!first) {\n            first = fragment;\n        }\n        if (last) {\n            last->next = fragment;\n        }\n        last = fragment;\n        ++count;\n    }\n\n    if (interface->Stop) {\n        interface->Stop(music);\n    }\n\n    if (music) {\n        interface->Delete(music);\n    }\n\n    Mix_UnlockAudio();\n\n    if (count > 0) {\n        *audio_len = (count - 1) * fragment_size + fragment->size;\n        *audio_buf = (Uint8 *)SDL_malloc(*audio_len);\n        if (*audio_buf) {\n            Uint8 *dst = *audio_buf;\n            for (fragment = first; fragment; fragment = fragment->next) {\n                SDL_memcpy(dst, fragment->data, fragment->size);\n                dst += fragment->size;\n            }\n        } else {\n            SDL_OutOfMemory();\n            spec = NULL;\n        }\n    } else {\n        Mix_SetError(\"No audio data\");\n        spec = NULL;\n    }\n\n    while (first) {\n        fragment = first;\n        first = first->next;\n        SDL_free(fragment->data);\n        SDL_free(fragment);\n    }\n\n    if (freesrc) {\n        SDL_RWclose(src);\n    }\n    return spec;\n}\n\n/* Load a wave file */\nMix_Chunk *Mix_LoadWAV_RW(SDL_RWops *src, int freesrc)\n{\n    Uint8 magic[4];\n    Mix_Chunk *chunk;\n    SDL_AudioSpec wavespec, *loaded;\n    SDL_AudioCVT wavecvt;\n    int samplesize;\n\n    /* rcg06012001 Make sure src is valid */\n    if (!src) {\n        SDL_SetError(\"Mix_LoadWAV_RW with NULL src\");\n        return(NULL);\n    }\n\n    /* Make sure audio has been opened */\n    if (!audio_opened) {\n        SDL_SetError(\"Audio device hasn't been opened\");\n        if (freesrc) {\n            SDL_RWclose(src);\n        }\n        return(NULL);\n    }\n\n    /* Allocate the chunk memory */\n    chunk = (Mix_Chunk *)SDL_malloc(sizeof(Mix_Chunk));\n    if (chunk == NULL) {\n        SDL_SetError(\"Out of memory\");\n        if (freesrc) {\n            SDL_RWclose(src);\n        }\n        return(NULL);\n    }\n\n    /* Find out what kind of audio file this is */\n    if (SDL_RWread(src, magic, 1, 4) != 4) {\n        if (freesrc) {\n            SDL_RWclose(src);\n        }\n        Mix_SetError(\"Couldn't read first 4 bytes of audio data\");\n        return NULL;\n    }\n    /* Seek backwards for compatibility with older loaders */\n    SDL_RWseek(src, -4, RW_SEEK_CUR);\n\n    if (SDL_memcmp(magic, \"WAVE\", 4) == 0 || SDL_memcmp(magic, \"RIFF\", 4) == 0) {\n        loaded = SDL_LoadWAV_RW(src, freesrc, &wavespec, (Uint8 **)&chunk->abuf, &chunk->alen);\n    } else if (SDL_memcmp(magic, \"FORM\", 4) == 0) {\n        loaded = Mix_LoadAIFF_RW(src, freesrc, &wavespec, (Uint8 **)&chunk->abuf, &chunk->alen);\n    } else if (SDL_memcmp(magic, \"CREA\", 4) == 0) {\n        loaded = Mix_LoadVOC_RW(src, freesrc, &wavespec, (Uint8 **)&chunk->abuf, &chunk->alen);\n    } else {\n        Mix_MusicType music_type = detect_music_type_from_magic(magic);\n        loaded = Mix_LoadMusic_RW(music_type, src, freesrc, &wavespec, (Uint8 **)&chunk->abuf, &chunk->alen);\n    }\n    if (!loaded) {\n        /* The individual loaders have closed src if needed */\n        SDL_free(chunk);\n        return(NULL);\n    }\n\n#if 0\n    PrintFormat(\"Audio device\", &mixer);\n    PrintFormat(\"-- Wave file\", &wavespec);\n#endif\n\n    /* Build the audio converter and create conversion buffers */\n    if (wavespec.format != mixer.format ||\n         wavespec.channels != mixer.channels ||\n         wavespec.freq != mixer.freq) {\n        if (SDL_BuildAudioCVT(&wavecvt,\n                wavespec.format, wavespec.channels, wavespec.freq,\n                mixer.format, mixer.channels, mixer.freq) < 0) {\n            SDL_free(chunk->abuf);\n            SDL_free(chunk);\n            return(NULL);\n        }\n        samplesize = ((wavespec.format & 0xFF)/8)*wavespec.channels;\n        wavecvt.len = chunk->alen & ~(samplesize-1);\n        wavecvt.buf = (Uint8 *)SDL_calloc(1, wavecvt.len*wavecvt.len_mult);\n        if (wavecvt.buf == NULL) {\n            SDL_SetError(\"Out of memory\");\n            SDL_free(chunk->abuf);\n            SDL_free(chunk);\n            return(NULL);\n        }\n        SDL_memcpy(wavecvt.buf, chunk->abuf, wavecvt.len);\n        SDL_free(chunk->abuf);\n\n        /* Run the audio converter */\n        if (SDL_ConvertAudio(&wavecvt) < 0) {\n            SDL_free(wavecvt.buf);\n            SDL_free(chunk);\n            return(NULL);\n        }\n\n        chunk->abuf = wavecvt.buf;\n        chunk->alen = wavecvt.len_cvt;\n    }\n\n    chunk->allocated = 1;\n    chunk->volume = MIX_MAX_VOLUME;\n\n    return(chunk);\n}\n\n/* Load a wave file of the mixer format from a memory buffer */\nMix_Chunk *Mix_QuickLoad_WAV(Uint8 *mem)\n{\n    Mix_Chunk *chunk;\n    Uint8 magic[4];\n\n    /* Make sure audio has been opened */\n    if (! audio_opened) {\n        SDL_SetError(\"Audio device hasn't been opened\");\n        return(NULL);\n    }\n\n    /* Allocate the chunk memory */\n    chunk = (Mix_Chunk *)SDL_calloc(1,sizeof(Mix_Chunk));\n    if (chunk == NULL) {\n        SDL_SetError(\"Out of memory\");\n        return(NULL);\n    }\n\n    /* Essentially just skip to the audio data (no error checking - fast) */\n    chunk->allocated = 0;\n    mem += 12; /* WAV header */\n    do {\n        SDL_memcpy(magic, mem, 4);\n        mem += 4;\n        chunk->alen = ((mem[3]<<24)|(mem[2]<<16)|(mem[1]<<8)|(mem[0]));\n        mem += 4;\n        chunk->abuf = mem;\n        mem += chunk->alen;\n    } while (memcmp(magic, \"data\", 4) != 0);\n    chunk->volume = MIX_MAX_VOLUME;\n\n    return(chunk);\n}\n\n/* Load raw audio data of the mixer format from a memory buffer */\nMix_Chunk *Mix_QuickLoad_RAW(Uint8 *mem, Uint32 len)\n{\n    Mix_Chunk *chunk;\n\n    /* Make sure audio has been opened */\n    if (! audio_opened) {\n        SDL_SetError(\"Audio device hasn't been opened\");\n        return(NULL);\n    }\n\n    /* Allocate the chunk memory */\n    chunk = (Mix_Chunk *)SDL_malloc(sizeof(Mix_Chunk));\n    if (chunk == NULL) {\n        SDL_SetError(\"Out of memory\");\n        return(NULL);\n    }\n\n    /* Essentially just point at the audio data (no error checking - fast) */\n    chunk->allocated = 0;\n    chunk->alen = len;\n    chunk->abuf = mem;\n    chunk->volume = MIX_MAX_VOLUME;\n\n    return(chunk);\n}\n\n/* Free an audio chunk previously loaded */\nvoid Mix_FreeChunk(Mix_Chunk *chunk)\n{\n    int i;\n\n    /* Caution -- if the chunk is playing, the mixer will crash */\n    if (chunk) {\n        /* Guarantee that this chunk isn't playing */\n        Mix_LockAudio();\n        if (mix_channel) {\n            for (i=0; i<num_channels; ++i) {\n                if (chunk == mix_channel[i].chunk) {\n                    mix_channel[i].playing = 0;\n                    mix_channel[i].looping = 0;\n                }\n            }\n        }\n        Mix_UnlockAudio();\n        /* Actually free the chunk */\n        if (chunk->allocated) {\n            SDL_free(chunk->abuf);\n        }\n        SDL_free(chunk);\n    }\n}\n\n/* Set a function that is called after all mixing is performed.\n   This can be used to provide real-time visual display of the audio stream\n   or add a custom mixer filter for the stream data.\n*/\nvoid Mix_SetPostMix(void (SDLCALL *mix_func)\n                    (void *udata, Uint8 *stream, int len), void *arg)\n{\n    Mix_LockAudio();\n    mix_postmix_data = arg;\n    mix_postmix = mix_func;\n    Mix_UnlockAudio();\n}\n\n/* Add your own music player or mixer function.\n   If 'mix_func' is NULL, the default music player is re-enabled.\n */\nvoid Mix_HookMusic(void (SDLCALL *mix_func)(void *udata, Uint8 *stream, int len),\n                                                                void *arg)\n{\n    Mix_LockAudio();\n    if (mix_func != NULL) {\n        music_data = arg;\n        mix_music = mix_func;\n    } else {\n        music_data = NULL;\n        mix_music = music_mixer;\n    }\n    Mix_UnlockAudio();\n}\n\nvoid *Mix_GetMusicHookData(void)\n{\n    return(music_data);\n}\n\nvoid Mix_ChannelFinished(void (SDLCALL *channel_finished)(int channel))\n{\n    Mix_LockAudio();\n    channel_done_callback = channel_finished;\n    Mix_UnlockAudio();\n}\n\n\n/* Reserve the first channels (0 -> n-1) for the application, i.e. don't allocate\n   them dynamically to the next sample if requested with a -1 value below.\n   Returns the number of reserved channels.\n */\nint Mix_ReserveChannels(int num)\n{\n    if (num > num_channels)\n        num = num_channels;\n    reserved_channels = num;\n    return num;\n}\n\nstatic int checkchunkintegral(Mix_Chunk *chunk)\n{\n    int frame_width = 1;\n\n    if ((mixer.format & 0xFF) == 16) frame_width = 2;\n    frame_width *= mixer.channels;\n    while (chunk->alen % frame_width) chunk->alen--;\n    return chunk->alen;\n}\n\n/* Play an audio chunk on a specific channel.\n   If the specified channel is -1, play on the first free channel.\n   'ticks' is the number of milliseconds at most to play the sample, or -1\n   if there is no limit.\n   Returns which channel was used to play the sound.\n*/\nint Mix_PlayChannelTimed(int which, Mix_Chunk *chunk, int loops, int ticks)\n{\n    int i;\n\n    /* Don't play null pointers :-) */\n    if (chunk == NULL) {\n        Mix_SetError(\"Tried to play a NULL chunk\");\n        return(-1);\n    }\n    if (!checkchunkintegral(chunk)) {\n        Mix_SetError(\"Tried to play a chunk with a bad frame\");\n        return(-1);\n    }\n\n    /* Lock the mixer while modifying the playing channels */\n    Mix_LockAudio();\n    {\n        /* If which is -1, play on the first free channel */\n        if (which == -1) {\n            for (i=reserved_channels; i<num_channels; ++i) {\n                if (mix_channel[i].playing <= 0)\n                    break;\n            }\n            if (i == num_channels) {\n                Mix_SetError(\"No free channels available\");\n                which = -1;\n            } else {\n                which = i;\n            }\n        }\n\n        /* Queue up the audio data for this channel */\n        if (which >= 0 && which < num_channels) {\n            Uint32 sdl_ticks = SDL_GetTicks();\n            if (Mix_Playing(which))\n                _Mix_channel_done_playing(which);\n            mix_channel[which].samples = chunk->abuf;\n            mix_channel[which].playing = chunk->alen;\n            mix_channel[which].looping = loops;\n            mix_channel[which].chunk = chunk;\n            mix_channel[which].paused = 0;\n            mix_channel[which].fading = MIX_NO_FADING;\n            mix_channel[which].start_time = sdl_ticks;\n            mix_channel[which].expire = (ticks>0) ? (sdl_ticks + ticks) : 0;\n        }\n    }\n    Mix_UnlockAudio();\n\n    /* Return the channel on which the sound is being played */\n    return(which);\n}\n\n/* Change the expiration delay for a channel */\nint Mix_ExpireChannel(int which, int ticks)\n{\n    int status = 0;\n\n    if (which == -1) {\n        int i;\n        for (i=0; i < num_channels; ++ i) {\n            status += Mix_ExpireChannel(i, ticks);\n        }\n    } else if (which < num_channels) {\n        Mix_LockAudio();\n        mix_channel[which].expire = (ticks>0) ? (SDL_GetTicks() + ticks) : 0;\n        Mix_UnlockAudio();\n        ++ status;\n    }\n    return(status);\n}\n\n/* Fade in a sound on a channel, over ms milliseconds */\nint Mix_FadeInChannelTimed(int which, Mix_Chunk *chunk, int loops, int ms, int ticks)\n{\n    int i;\n\n    /* Don't play null pointers :-) */\n    if (chunk == NULL) {\n        return(-1);\n    }\n    if (!checkchunkintegral(chunk)) {\n        Mix_SetError(\"Tried to play a chunk with a bad frame\");\n        return(-1);\n    }\n\n    /* Lock the mixer while modifying the playing channels */\n    Mix_LockAudio();\n    {\n        /* If which is -1, play on the first free channel */\n        if (which == -1) {\n            for (i=reserved_channels; i<num_channels; ++i) {\n                if (mix_channel[i].playing <= 0)\n                    break;\n            }\n            if (i == num_channels) {\n                which = -1;\n            } else {\n                which = i;\n            }\n        }\n\n        /* Queue up the audio data for this channel */\n        if (which >= 0 && which < num_channels) {\n            Uint32 sdl_ticks = SDL_GetTicks();\n            if (Mix_Playing(which))\n                _Mix_channel_done_playing(which);\n            mix_channel[which].samples = chunk->abuf;\n            mix_channel[which].playing = chunk->alen;\n            mix_channel[which].looping = loops;\n            mix_channel[which].chunk = chunk;\n            mix_channel[which].paused = 0;\n            mix_channel[which].fading = MIX_FADING_IN;\n            mix_channel[which].fade_volume = mix_channel[which].volume;\n            mix_channel[which].fade_volume_reset = mix_channel[which].volume;\n            mix_channel[which].volume = 0;\n            mix_channel[which].fade_length = (Uint32)ms;\n            mix_channel[which].start_time = mix_channel[which].ticks_fade = sdl_ticks;\n            mix_channel[which].expire = (ticks > 0) ? (sdl_ticks+ticks) : 0;\n        }\n    }\n    Mix_UnlockAudio();\n\n    /* Return the channel on which the sound is being played */\n    return(which);\n}\n\n/* Set volume of a particular channel */\nint Mix_Volume(int which, int volume)\n{\n    int i;\n    int prev_volume = 0;\n\n    if (which == -1) {\n        for (i=0; i<num_channels; ++i) {\n            prev_volume += Mix_Volume(i, volume);\n        }\n        prev_volume /= num_channels;\n    } else if (which < num_channels) {\n        prev_volume = mix_channel[which].volume;\n        if (volume >= 0) {\n            if (volume > MIX_MAX_VOLUME) {\n                volume = MIX_MAX_VOLUME;\n            }\n            mix_channel[which].volume = volume;\n        }\n    }\n    return(prev_volume);\n}\n/* Set volume of a particular chunk */\nint Mix_VolumeChunk(Mix_Chunk *chunk, int volume)\n{\n    int prev_volume;\n\n    prev_volume = chunk->volume;\n    if (volume >= 0) {\n        if (volume > MIX_MAX_VOLUME) {\n            volume = MIX_MAX_VOLUME;\n        }\n        chunk->volume = volume;\n    }\n    return(prev_volume);\n}\n\n/* Halt playing of a particular channel */\nint Mix_HaltChannel(int which)\n{\n    int i;\n\n    if (which == -1) {\n        for (i=0; i<num_channels; ++i) {\n            Mix_HaltChannel(i);\n        }\n    } else if (which < num_channels) {\n        Mix_LockAudio();\n        if (mix_channel[which].playing) {\n            _Mix_channel_done_playing(which);\n            mix_channel[which].playing = 0;\n            mix_channel[which].looping = 0;\n        }\n        mix_channel[which].expire = 0;\n        if(mix_channel[which].fading != MIX_NO_FADING) /* Restore volume */\n            mix_channel[which].volume = mix_channel[which].fade_volume_reset;\n        mix_channel[which].fading = MIX_NO_FADING;\n        Mix_UnlockAudio();\n    }\n    return(0);\n}\n\n/* Halt playing of a particular group of channels */\nint Mix_HaltGroup(int tag)\n{\n    int i;\n\n    for (i=0; i<num_channels; ++i) {\n        if(mix_channel[i].tag == tag) {\n            Mix_HaltChannel(i);\n        }\n    }\n    return(0);\n}\n\n/* Fade out a channel and then stop it automatically */\nint Mix_FadeOutChannel(int which, int ms)\n{\n    int status;\n\n    status = 0;\n    if (audio_opened) {\n        if (which == -1) {\n            int i;\n\n            for (i=0; i<num_channels; ++i) {\n                status += Mix_FadeOutChannel(i, ms);\n            }\n        } else if (which < num_channels) {\n            Mix_LockAudio();\n            if (mix_channel[which].playing &&\n                (mix_channel[which].volume > 0) &&\n                (mix_channel[which].fading != MIX_FADING_OUT)) {\n                mix_channel[which].fade_volume = mix_channel[which].volume;\n                mix_channel[which].fading = MIX_FADING_OUT;\n                mix_channel[which].fade_length = (Uint32)ms;\n                mix_channel[which].ticks_fade = SDL_GetTicks();\n\n                /* only change fade_volume_reset if we're not fading. */\n                if (mix_channel[which].fading == MIX_NO_FADING) {\n                    mix_channel[which].fade_volume_reset = mix_channel[which].volume;\n                }\n                ++status;\n            }\n            Mix_UnlockAudio();\n        }\n    }\n    return(status);\n}\n\n/* Halt playing of a particular group of channels */\nint Mix_FadeOutGroup(int tag, int ms)\n{\n    int i;\n    int status = 0;\n    for (i=0; i<num_channels; ++i) {\n        if(mix_channel[i].tag == tag) {\n            status += Mix_FadeOutChannel(i,ms);\n        }\n    }\n    return(status);\n}\n\nMix_Fading Mix_FadingChannel(int which)\n{\n    if (which < 0 || which >= num_channels) {\n        return MIX_NO_FADING;\n    }\n    return mix_channel[which].fading;\n}\n\n/* Check the status of a specific channel.\n   If the specified mix_channel is -1, check all mix channels.\n*/\nint Mix_Playing(int which)\n{\n    int status;\n\n    status = 0;\n    if (which == -1) {\n        int i;\n\n        for (i=0; i<num_channels; ++i) {\n            if ((mix_channel[i].playing > 0) ||\n                mix_channel[i].looping)\n            {\n                ++status;\n            }\n        }\n    } else if (which < num_channels) {\n        if ((mix_channel[which].playing > 0) ||\n             mix_channel[which].looping)\n        {\n            ++status;\n        }\n    }\n    return(status);\n}\n\n/* rcg06072001 Get the chunk associated with a channel. */\nMix_Chunk *Mix_GetChunk(int channel)\n{\n    Mix_Chunk *retval = NULL;\n\n    if ((channel >= 0) && (channel < num_channels)) {\n        retval = mix_channel[channel].chunk;\n    }\n\n    return(retval);\n}\n\n/* Close the mixer, halting all playing audio */\nvoid Mix_CloseAudio(void)\n{\n    int i;\n\n    if (audio_opened) {\n        if (audio_opened == 1) {\n            for (i = 0; i < num_channels; i++) {\n                Mix_UnregisterAllEffects(i);\n            }\n            Mix_UnregisterAllEffects(MIX_CHANNEL_POST);\n            close_music();\n            Mix_SetMusicCMD(NULL);\n            Mix_HaltChannel(-1);\n            _Mix_DeinitEffects();\n            SDL_CloseAudioDevice(audio_device);\n            audio_device = 0;\n            SDL_free(mix_channel);\n            mix_channel = NULL;\n\n            /* rcg06042009 report available decoders at runtime. */\n            SDL_free((void *)chunk_decoders);\n            chunk_decoders = NULL;\n            num_decoders = 0;\n        }\n        --audio_opened;\n    }\n}\n\n/* Pause a particular channel (or all) */\nvoid Mix_Pause(int which)\n{\n    Uint32 sdl_ticks = SDL_GetTicks();\n    if (which == -1) {\n        int i;\n\n        for (i=0; i<num_channels; ++i) {\n            if (mix_channel[i].playing > 0) {\n                mix_channel[i].paused = sdl_ticks;\n            }\n        }\n    } else if (which < num_channels) {\n        if (mix_channel[which].playing > 0) {\n            mix_channel[which].paused = sdl_ticks;\n        }\n    }\n}\n\n/* Resume a paused channel */\nvoid Mix_Resume(int which)\n{\n    Uint32 sdl_ticks = SDL_GetTicks();\n\n    Mix_LockAudio();\n    if (which == -1) {\n        int i;\n\n        for (i=0; i<num_channels; ++i) {\n            if (mix_channel[i].playing > 0) {\n                if(mix_channel[i].expire > 0)\n                    mix_channel[i].expire += sdl_ticks - mix_channel[i].paused;\n                mix_channel[i].paused = 0;\n            }\n        }\n    } else if (which < num_channels) {\n        if (mix_channel[which].playing > 0) {\n            if(mix_channel[which].expire > 0)\n                mix_channel[which].expire += sdl_ticks - mix_channel[which].paused;\n            mix_channel[which].paused = 0;\n        }\n    }\n    Mix_UnlockAudio();\n}\n\nint Mix_Paused(int which)\n{\n    if (which < 0) {\n        int status = 0;\n        int i;\n        for(i=0; i < num_channels; ++i) {\n            if (mix_channel[i].paused) {\n                ++ status;\n            }\n        }\n        return(status);\n    } else if (which < num_channels) {\n        return(mix_channel[which].paused != 0);\n    } else {\n        return(0);\n    }\n}\n\n/* Change the group of a channel */\nint Mix_GroupChannel(int which, int tag)\n{\n    if (which < 0 || which > num_channels)\n        return(0);\n\n    Mix_LockAudio();\n    mix_channel[which].tag = tag;\n    Mix_UnlockAudio();\n    return(1);\n}\n\n/* Assign several consecutive channels to a group */\nint Mix_GroupChannels(int from, int to, int tag)\n{\n    int status = 0;\n    for(; from <= to; ++ from) {\n        status += Mix_GroupChannel(from, tag);\n    }\n    return(status);\n}\n\n/* Finds the first available channel in a group of channels */\nint Mix_GroupAvailable(int tag)\n{\n    int i;\n    for(i=0; i < num_channels; i ++) {\n        if (((tag == -1) || (tag == mix_channel[i].tag)) &&\n                            (mix_channel[i].playing <= 0))\n            return i;\n    }\n    return(-1);\n}\n\nint Mix_GroupCount(int tag)\n{\n    int count = 0;\n    int i;\n    for(i=0; i < num_channels; i ++) {\n        if (mix_channel[i].tag==tag || tag==-1)\n            ++ count;\n    }\n    return(count);\n}\n\n/* Finds the \"oldest\" sample playing in a group of channels */\nint Mix_GroupOldest(int tag)\n{\n    int chan = -1;\n    Uint32 mintime = SDL_GetTicks();\n    int i;\n    for(i=0; i < num_channels; i ++) {\n        if ((mix_channel[i].tag==tag || tag==-1) && mix_channel[i].playing > 0\n             && mix_channel[i].start_time <= mintime) {\n            mintime = mix_channel[i].start_time;\n            chan = i;\n        }\n    }\n    return(chan);\n}\n\n/* Finds the \"most recent\" (i.e. last) sample playing in a group of channels */\nint Mix_GroupNewer(int tag)\n{\n    int chan = -1;\n    Uint32 maxtime = 0;\n    int i;\n    for(i=0; i < num_channels; i ++) {\n        if ((mix_channel[i].tag==tag || tag==-1) && mix_channel[i].playing > 0\n             && mix_channel[i].start_time >= maxtime) {\n            maxtime = mix_channel[i].start_time;\n            chan = i;\n        }\n    }\n    return(chan);\n}\n\n\n\n/*\n * rcg06122001 The special effects exportable API.\n *  Please see effect_*.c for internally-implemented effects, such\n *  as Mix_SetPanning().\n */\n\n/* MAKE SURE you hold the audio lock (Mix_LockAudio()) before calling this! */\nstatic int _Mix_register_effect(effect_info **e, Mix_EffectFunc_t f,\n                Mix_EffectDone_t d, void *arg)\n{\n    effect_info *new_e;\n\n    if (!e) {\n        Mix_SetError(\"Internal error\");\n        return(0);\n    }\n\n    if (f == NULL) {\n        Mix_SetError(\"NULL effect callback\");\n        return(0);\n    }\n\n    new_e = SDL_malloc(sizeof (effect_info));\n    if (new_e == NULL) {\n        Mix_SetError(\"Out of memory\");\n        return(0);\n    }\n\n    new_e->callback = f;\n    new_e->done_callback = d;\n    new_e->udata = arg;\n    new_e->next = NULL;\n\n    /* add new effect to end of linked list... */\n    if (*e == NULL) {\n        *e = new_e;\n    } else {\n        effect_info *cur = *e;\n        while (1) {\n            if (cur->next == NULL) {\n                cur->next = new_e;\n                break;\n            }\n            cur = cur->next;\n        }\n    }\n\n    return(1);\n}\n\n\n/* MAKE SURE you hold the audio lock (Mix_LockAudio()) before calling this! */\nstatic int _Mix_remove_effect(int channel, effect_info **e, Mix_EffectFunc_t f)\n{\n    effect_info *cur;\n    effect_info *prev = NULL;\n    effect_info *next = NULL;\n\n    if (!e) {\n        Mix_SetError(\"Internal error\");\n        return(0);\n    }\n\n    for (cur = *e; cur != NULL; cur = cur->next) {\n        if (cur->callback == f) {\n            next = cur->next;\n            if (cur->done_callback != NULL) {\n                cur->done_callback(channel, cur->udata);\n            }\n            SDL_free(cur);\n\n            if (prev == NULL) {   /* removing first item of list? */\n                *e = next;\n            } else {\n                prev->next = next;\n            }\n            return(1);\n        }\n        prev = cur;\n    }\n\n    Mix_SetError(\"No such effect registered\");\n    return(0);\n}\n\n\n/* MAKE SURE you hold the audio lock (Mix_LockAudio()) before calling this! */\nstatic int _Mix_remove_all_effects(int channel, effect_info **e)\n{\n    effect_info *cur;\n    effect_info *next;\n\n    if (!e) {\n        Mix_SetError(\"Internal error\");\n        return(0);\n    }\n\n    for (cur = *e; cur != NULL; cur = next) {\n        next = cur->next;\n        if (cur->done_callback != NULL) {\n            cur->done_callback(channel, cur->udata);\n        }\n        SDL_free(cur);\n    }\n    *e = NULL;\n\n    return(1);\n}\n\n\n/* MAKE SURE you hold the audio lock (Mix_LockAudio()) before calling this! */\nint _Mix_RegisterEffect_locked(int channel, Mix_EffectFunc_t f,\n            Mix_EffectDone_t d, void *arg)\n{\n    effect_info **e = NULL;\n\n    if (channel == MIX_CHANNEL_POST) {\n        e = &posteffects;\n    } else {\n        if ((channel < 0) || (channel >= num_channels)) {\n            Mix_SetError(\"Invalid channel number\");\n            return(0);\n        }\n        e = &mix_channel[channel].effects;\n    }\n\n    return _Mix_register_effect(e, f, d, arg);\n}\n\nint Mix_RegisterEffect(int channel, Mix_EffectFunc_t f,\n            Mix_EffectDone_t d, void *arg)\n{\n    int retval;\n    Mix_LockAudio();\n    retval = _Mix_RegisterEffect_locked(channel, f, d, arg);\n    Mix_UnlockAudio();\n    return retval;\n}\n\n\n/* MAKE SURE you hold the audio lock (Mix_LockAudio()) before calling this! */\nint _Mix_UnregisterEffect_locked(int channel, Mix_EffectFunc_t f)\n{\n    effect_info **e = NULL;\n\n    if (channel == MIX_CHANNEL_POST) {\n        e = &posteffects;\n    } else {\n        if ((channel < 0) || (channel >= num_channels)) {\n            Mix_SetError(\"Invalid channel number\");\n            return(0);\n        }\n        e = &mix_channel[channel].effects;\n    }\n\n    return _Mix_remove_effect(channel, e, f);\n}\n\nint Mix_UnregisterEffect(int channel, Mix_EffectFunc_t f)\n{\n    int retval;\n    Mix_LockAudio();\n    retval = _Mix_UnregisterEffect_locked(channel, f);\n    Mix_UnlockAudio();\n    return(retval);\n}\n\n/* MAKE SURE you hold the audio lock (Mix_LockAudio()) before calling this! */\nint _Mix_UnregisterAllEffects_locked(int channel)\n{\n    effect_info **e = NULL;\n\n    if (channel == MIX_CHANNEL_POST) {\n        e = &posteffects;\n    } else {\n        if ((channel < 0) || (channel >= num_channels)) {\n            Mix_SetError(\"Invalid channel number\");\n            return(0);\n        }\n        e = &mix_channel[channel].effects;\n    }\n\n    return _Mix_remove_all_effects(channel, e);\n}\n\nint Mix_UnregisterAllEffects(int channel)\n{\n    int retval;\n    Mix_LockAudio();\n    retval = _Mix_UnregisterAllEffects_locked(channel);\n    Mix_UnlockAudio();\n    return(retval);\n}\n\nvoid Mix_LockAudio(void)\n{\n    SDL_LockAudioDevice(audio_device);\n}\n\nvoid Mix_UnlockAudio(void)\n{\n    SDL_UnlockAudioDevice(audio_device);\n}\n\n/* end of mixer.c ... */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","/*\n  SDL_mixer:  An audio mixer library based on the SDL library\n  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n#include <string.h> /* for strtok() and strtok_s() */\n\n#include \"SDL_hints.h\"\n#include \"SDL_log.h\"\n#include \"SDL_timer.h\"\n\n#include \"SDL_mixer.h\"\n#include \"mixer.h\"\n#include \"music.h\"\n\n#include \"music_cmd.h\"\n#include \"music_wav.h\"\n#include \"music_mikmod.h\"\n#include \"music_modplug.h\"\n#include \"music_nativemidi.h\"\n#include \"music_fluidsynth.h\"\n#include \"music_timidity.h\"\n#include \"music_ogg.h\"\n#include \"music_mpg123.h\"\n#include \"music_mad.h\"\n#include \"music_smpeg.h\"\n#include \"music_flac.h\"\n#include \"native_midi/native_midi.h\"\n\n\nchar *music_cmd = NULL;\nstatic SDL_bool music_active = SDL_TRUE;\nstatic int music_volume = MIX_MAX_VOLUME;\nstatic Mix_Music * volatile music_playing = NULL;\nSDL_AudioSpec music_spec;\n\nstruct _Mix_Music {\n    Mix_MusicInterface *interface;\n    void *context;\n\n    SDL_bool playing;\n    Mix_Fading fading;\n    int fade_step;\n    int fade_steps;\n};\n\n/* Used to calculate fading steps */\nstatic int ms_per_step;\n\n/* rcg06042009 report available decoders at runtime. */\nstatic const char **music_decoders = NULL;\nstatic int num_decoders = 0;\n\n/* Semicolon-separated SoundFont paths */\nstatic char* soundfont_paths = NULL;\n\n/* Interfaces for the various music interfaces, ordered by priority */\nstatic Mix_MusicInterface *s_music_interfaces[] =\n{\n#ifdef MUSIC_CMD\n    &Mix_MusicInterface_CMD,\n#endif\n#ifdef MUSIC_WAV\n    &Mix_MusicInterface_WAV,\n#endif\n#ifdef MUSIC_FLAC\n    &Mix_MusicInterface_FLAC,\n#endif\n#ifdef MUSIC_OGG\n    &Mix_MusicInterface_OGG,\n#endif\n#ifdef MUSIC_MP3_MPG123\n    &Mix_MusicInterface_MPG123,\n#endif\n#ifdef MUSIC_MP3_MAD\n    &Mix_MusicInterface_MAD,\n#endif\n#ifdef MUSIC_MP3_SMPEG\n    &Mix_MusicInterface_SMPEG,\n#endif\n#ifdef MUSIC_MOD_MODPLUG\n    &Mix_MusicInterface_MODPLUG,\n#endif\n#ifdef MUSIC_MOD_MIKMOD\n    &Mix_MusicInterface_MIKMOD,\n#endif\n#ifdef MUSIC_MID_FLUIDSYNTH\n    &Mix_MusicInterface_FLUIDSYNTH,\n#endif\n#ifdef MUSIC_MID_TIMIDITY\n    &Mix_MusicInterface_TIMIDITY,\n#endif\n#ifdef MUSIC_MID_NATIVE\n    &Mix_MusicInterface_NATIVEMIDI,\n#endif\n};\n\nint get_num_music_interfaces(void)\n{\n    return SDL_arraysize(s_music_interfaces);\n}\n\nMix_MusicInterface *get_music_interface(int index)\n{\n    return s_music_interfaces[index];\n}\n\nint Mix_GetNumMusicDecoders(void)\n{\n    return(num_decoders);\n}\n\nconst char *Mix_GetMusicDecoder(int index)\n{\n    if ((index < 0) || (index >= num_decoders)) {\n        return NULL;\n    }\n    return(music_decoders[index]);\n}\n\nstatic void add_music_decoder(const char *decoder)\n{\n    void *ptr = SDL_realloc((void *)music_decoders, (num_decoders + 1) * sizeof (const char *));\n    if (ptr == NULL) {\n        return;  /* oh well, go on without it. */\n    }\n    music_decoders = (const char **) ptr;\n    music_decoders[num_decoders++] = decoder;\n}\n\n/* Local low-level functions prototypes */\nstatic void music_internal_initialize_volume(void);\nstatic void music_internal_volume(int volume);\nstatic int  music_internal_play(Mix_Music *music, int play_count, double position);\nstatic int  music_internal_position(double position);\nstatic SDL_bool music_internal_playing(void);\nstatic void music_internal_halt(void);\n\n\n/* Support for hooking when the music has finished */\nstatic void (SDLCALL *music_finished_hook)(void) = NULL;\n\nvoid Mix_HookMusicFinished(void (SDLCALL *music_finished)(void))\n{\n    Mix_LockAudio();\n    music_finished_hook = music_finished;\n    Mix_UnlockAudio();\n}\n\n/* Convenience function to fill audio and mix at the specified volume\n   This is called from many music player's GetAudio callback.\n */\nint music_pcm_getaudio(void *context, void *data, int bytes, int volume,\n                       int (*GetSome)(void *context, void *data, int bytes, SDL_bool *done))\n{\n    Uint8 *snd = (Uint8 *)data;\n    Uint8 *dst;\n    int len = bytes;\n    SDL_bool done = SDL_FALSE;\n\n    if (volume == MIX_MAX_VOLUME) {\n        dst = snd;\n    } else {\n        dst = SDL_stack_alloc(Uint8, bytes);\n    }\n    while (len > 0 && !done) {\n        int consumed = GetSome(context, dst, len, &done);\n        if (consumed < 0) {\n            break;\n        }\n\n        if (volume == MIX_MAX_VOLUME) {\n            dst += consumed;\n        } else {\n            SDL_MixAudioFormat(snd, dst, music_spec.format, (Uint32)consumed, volume);\n            snd += consumed;\n        }\n        len -= consumed;\n    }\n    if (volume != MIX_MAX_VOLUME) {\n        SDL_stack_free(dst);\n    }\n    return len;\n}\n\n/* Mixing function */\nvoid SDLCALL music_mixer(void *udata, Uint8 *stream, int len)\n{\n    while (music_playing && music_active && len > 0) {\n        /* Handle fading */\n        if (music_playing->fading != MIX_NO_FADING) {\n            if (music_playing->fade_step++ < music_playing->fade_steps) {\n                int volume;\n                int fade_step = music_playing->fade_step;\n                int fade_steps = music_playing->fade_steps;\n\n                if (music_playing->fading == MIX_FADING_OUT) {\n                    volume = (music_volume * (fade_steps-fade_step)) / fade_steps;\n                } else { /* Fading in */\n                    volume = (music_volume * fade_step) / fade_steps;\n                }\n                music_internal_volume(volume);\n            } else {\n                if (music_playing->fading == MIX_FADING_OUT) {\n                    music_internal_halt();\n                    if (music_finished_hook) {\n                        music_finished_hook();\n                    }\n                    return;\n                }\n                music_playing->fading = MIX_NO_FADING;\n            }\n        }\n\n        if (music_playing->interface->GetAudio) {\n            int left = music_playing->interface->GetAudio(music_playing->context, stream, len);\n            if (left != 0) {\n                /* Either an error or finished playing with data left */\n                music_playing->playing = SDL_FALSE;\n            }\n            if (left > 0) {\n                stream += (len - left);\n                len = left;\n            } else {\n                len = 0;\n            }\n        } else {\n            len = 0;\n        }\n\n        if (!music_internal_playing()) {\n            music_internal_halt();\n            if (music_finished_hook) {\n                music_finished_hook();\n            }\n        }\n    }\n}\n\n/* Load the music interface libraries */\nint load_music(void)\n{\n    char hint[128];\n\n    int i;\n    for (i = 0; i < SDL_arraysize(s_music_interfaces); ++i) {\n        Mix_MusicInterface *interface = s_music_interfaces[i];\n        if (interface->loaded) {\n            continue;\n        }\n\n        SDL_snprintf(hint, sizeof(hint), \"SDL_MIXER_DISABLE_%s\", interface->tag);\n        if (SDL_GetHintBoolean(hint, SDL_FALSE)) {\n            continue;\n        }\n\n        if (!interface->Load || interface->Load() == 0) {\n            interface->loaded = SDL_TRUE;\n        }\n    }\n    return 0;\n}\n\n/* Return SDL_TRUE if the music type is available */\nSDL_bool has_music(Mix_MusicType type)\n{\n    int i;\n    for (i = 0; i < SDL_arraysize(s_music_interfaces); ++i) {\n        Mix_MusicInterface *interface = s_music_interfaces[i];\n        if (interface->type != type) {\n            continue;\n        }\n        if (interface->opened) {\n            return SDL_TRUE;\n        }\n    }\n    return SDL_FALSE;\n}\n\n/* Initialize the music interfaces with a certain desired audio format */\nint open_music(const SDL_AudioSpec *spec)\n{\n    int i;\n    SDL_bool use_native_midi = SDL_FALSE;\n\n#ifdef MIX_INIT_SOUNDFONT_PATHS\n    if (!soundfont_paths) {\n        soundfont_paths = SDL_strdup(MIX_INIT_SOUNDFONT_PATHS);\n    }\n#endif\n\n\n#ifdef MUSIC_MID_NATIVE\n    if (SDL_GetHintBoolean(\"SDL_NATIVE_MUSIC\", SDL_FALSE) && native_midi_detect()) {\n        use_native_midi = SDL_TRUE;\n    }\n#endif\n\n    music_spec = *spec;\n    for (i = 0; i < SDL_arraysize(s_music_interfaces); ++i) {\n        Mix_MusicInterface *interface = s_music_interfaces[i];\n        if (!interface->loaded) {\n            continue;\n        }\n\n        if (interface->type == MUS_MID && use_native_midi && interface->api != MIX_MUSIC_NATIVEMIDI) {\n            continue;\n        }\n\n        if (!interface->Open || interface->Open(spec) == 0) {\n            interface->opened = SDL_TRUE;\n            add_music_decoder(interface->tag);\n        }\n    }\n\n    if (has_music(MUS_MOD)) {\n        add_music_decoder(\"MOD\");\n    }\n    if (has_music(MUS_MID)) {\n        add_music_decoder(\"MIDI\");\n    }\n    if (has_music(MUS_MP3)) {\n        add_music_decoder(\"MP3\");\n    }\n\n    Mix_VolumeMusic(MIX_MAX_VOLUME);\n\n    /* Calculate the number of ms for each callback */\n    ms_per_step = (int) (((float)spec->samples * 1000.0) / spec->freq);\n\n    return 0;\n}\n\nMix_MusicType detect_music_type_from_magic(const Uint8 *magic)\n{\n    /* Ogg Vorbis files have the magic four bytes \"OggS\" */\n    if (SDL_memcmp(magic, \"OggS\", 4) == 0) {\n        return MUS_OGG;\n    }\n\n    /* FLAC files have the magic four bytes \"fLaC\" */\n    if (SDL_memcmp(magic, \"fLaC\", 4) == 0) {\n        return MUS_FLAC;\n    }\n\n    /* MIDI files have the magic four bytes \"MThd\" */\n    if (SDL_memcmp(magic, \"MThd\", 4) == 0) {\n        return MUS_MID;\n    }\n\n    if (SDL_memcmp(magic, \"ID3\", 3) == 0 ||\n        (magic[0] == 0xFF && (magic[1] & 0xFE) == 0xFA)) {\n        return MUS_MP3;\n    }\n\n    /* Assume MOD format.\n     *\n     * Apparently there is no way to check if the file is really a MOD,\n     * or there are too many formats supported by MikMod/ModPlug, or\n     * MikMod/ModPlug does this check by itself. */\n    return MUS_MOD;\n}\n\nstatic Mix_MusicType detect_music_type(SDL_RWops *src)\n{\n    Uint8 magic[12];\n\n    if (SDL_RWread(src, magic, 1, 12) != 12) {\n        Mix_SetError(\"Couldn't read first 12 bytes of audio data\");\n        return MUS_NONE;\n    }\n    SDL_RWseek(src, -12, RW_SEEK_CUR);\n\n    /* WAVE files have the magic four bytes \"RIFF\"\n       AIFF files have the magic 12 bytes \"FORM\" XXXX \"AIFF\" */\n    if (((SDL_memcmp(magic, \"RIFF\", 4) == 0) && (SDL_memcmp((magic+8), \"WAVE\", 4) == 0)) ||\n        (SDL_memcmp(magic, \"FORM\", 4) == 0)) {\n        return MUS_WAV;\n    }\n\n    return detect_music_type_from_magic(magic);\n}\n\n/* Load a music file */\nMix_Music *Mix_LoadMUS(const char *file)\n{\n    int i;\n    void *context;\n    char *ext;\n    Mix_MusicType type;\n    SDL_RWops *src;\n\n    for (i = 0; i < SDL_arraysize(s_music_interfaces); ++i) {\n        Mix_MusicInterface *interface = s_music_interfaces[i];\n        if (!interface->opened || !interface->CreateFromFile) {\n            continue;\n        }\n\n        context = interface->CreateFromFile(file);\n        if (context) {\n            /* Allocate memory for the music structure */\n            Mix_Music *music = (Mix_Music *)SDL_calloc(1, sizeof(Mix_Music));\n            if (music == NULL) {\n                Mix_SetError(\"Out of memory\");\n                return NULL;\n            }\n            music->interface = interface;\n            music->context = context;\n            return music;\n        }\n    }\n\n    src = SDL_RWFromFile(file, \"rb\");\n    if (src == NULL) {\n        Mix_SetError(\"Couldn't open '%s'\", file);\n        return NULL;\n    }\n\n    /* Use the extension as a first guess on the file type */\n    type = MUS_NONE;\n    ext = strrchr(file, '.');\n    if (ext) {\n        ++ext; /* skip the dot in the extension */\n        if (SDL_strcasecmp(ext, \"WAV\") == 0) {\n            type = MUS_WAV;\n        } else if (SDL_strcasecmp(ext, \"MID\") == 0 ||\n                    SDL_strcasecmp(ext, \"MIDI\") == 0 ||\n                    SDL_strcasecmp(ext, \"KAR\") == 0) {\n            type = MUS_MID;\n        } else if (SDL_strcasecmp(ext, \"OGG\") == 0) {\n            type = MUS_OGG;\n        } else if (SDL_strcasecmp(ext, \"FLAC\") == 0) {\n            type = MUS_FLAC;\n        } else  if (SDL_strcasecmp(ext, \"MPG\") == 0 ||\n                     SDL_strcasecmp(ext, \"MPEG\") == 0 ||\n                     SDL_strcasecmp(ext, \"MP3\") == 0 ||\n                     SDL_strcasecmp(ext, \"MAD\") == 0) {\n            type = MUS_MP3;\n        } else if (SDL_strcasecmp(ext, \"669\") == 0 ||\n                    SDL_strcasecmp(ext, \"AMF\") == 0 ||\n                    SDL_strcasecmp(ext, \"AMS\") == 0 ||\n                    SDL_strcasecmp(ext, \"DBM\") == 0 ||\n                    SDL_strcasecmp(ext, \"DSM\") == 0 ||\n                    SDL_strcasecmp(ext, \"FAR\") == 0 ||\n                    SDL_strcasecmp(ext, \"IT\") == 0 ||\n                    SDL_strcasecmp(ext, \"MED\") == 0 ||\n                    SDL_strcasecmp(ext, \"MDL\") == 0 ||\n                    SDL_strcasecmp(ext, \"MOD\") == 0 ||\n                    SDL_strcasecmp(ext, \"MOL\") == 0 ||\n                    SDL_strcasecmp(ext, \"MTM\") == 0 ||\n                    SDL_strcasecmp(ext, \"NST\") == 0 ||\n                    SDL_strcasecmp(ext, \"OKT\") == 0 ||\n                    SDL_strcasecmp(ext, \"PTM\") == 0 ||\n                    SDL_strcasecmp(ext, \"S3M\") == 0 ||\n                    SDL_strcasecmp(ext, \"STM\") == 0 ||\n                    SDL_strcasecmp(ext, \"ULT\") == 0 ||\n                    SDL_strcasecmp(ext, \"UMX\") == 0 ||\n                    SDL_strcasecmp(ext, \"WOW\") == 0 ||\n                    SDL_strcasecmp(ext, \"XM\") == 0) {\n            type = MUS_MOD;\n        }\n    }\n    return Mix_LoadMUSType_RW(src, type, SDL_TRUE);\n}\n\nMix_Music *Mix_LoadMUS_RW(SDL_RWops *src, int freesrc)\n{\n    return Mix_LoadMUSType_RW(src, MUS_NONE, freesrc);\n}\n\nMix_Music *Mix_LoadMUSType_RW(SDL_RWops *src, Mix_MusicType type, int freesrc)\n{\n    int i;\n    void *context;\n    Sint64 start;\n\n    if (!src) {\n        Mix_SetError(\"RWops pointer is NULL\");\n        return NULL;\n    }\n    start = SDL_RWtell(src);\n\n    /* If the caller wants auto-detection, figure out what kind of file\n     * this is. */\n    if (type == MUS_NONE) {\n        if ((type = detect_music_type(src)) == MUS_NONE) {\n            /* Don't call Mix_SetError() since detect_music_type() does that. */\n            if (freesrc) {\n                SDL_RWclose(src);\n            }\n            return NULL;\n        }\n    }\n\n    Mix_ClearError();\n\n    for (i = 0; i < SDL_arraysize(s_music_interfaces); ++i) {\n        Mix_MusicInterface *interface = s_music_interfaces[i];\n        if (!interface->opened || type != interface->type || !interface->CreateFromRW) {\n            continue;\n        }\n\n        context = interface->CreateFromRW(src, freesrc);\n        if (context) {\n            /* Allocate memory for the music structure */\n            Mix_Music *music = (Mix_Music *)SDL_calloc(1, sizeof(Mix_Music));\n            if (music == NULL) {\n                interface->Delete(context);\n                Mix_SetError(\"Out of memory\");\n                return NULL;\n            }\n            music->interface = interface;\n            music->context = context;\n#ifdef DEBUG_MUSIC\n            /* This would be useful to expose via an API */\n            SDL_Log(\"Music playing with %s\\n\", interface->tag);\n#endif\n            return music;\n        }\n\n        /* Reset the stream for the next decoder */\n        SDL_RWseek(src, start, RW_SEEK_SET);\n    }\n\n    if (!*Mix_GetError()) {\n        Mix_SetError(\"Unrecognized audio format\");\n    }\n    if (freesrc) {\n        SDL_RWclose(src);\n    } else {\n        SDL_RWseek(src, start, RW_SEEK_SET);\n    }\n    return NULL;\n}\n\n/* Free a music chunk previously loaded */\nvoid Mix_FreeMusic(Mix_Music *music)\n{\n    if (music) {\n        /* Stop the music if it's currently playing */\n        Mix_LockAudio();\n        if (music == music_playing) {\n            /* Wait for any fade out to finish */\n            while (music->fading == MIX_FADING_OUT) {\n                Mix_UnlockAudio();\n                SDL_Delay(100);\n                Mix_LockAudio();\n            }\n            if (music == music_playing) {\n                music_internal_halt();\n            }\n        }\n        Mix_UnlockAudio();\n\n        music->interface->Delete(music->context);\n        SDL_free(music);\n    }\n}\n\n/* Find out the music format of a mixer music, or the currently playing\n   music, if 'music' is NULL.\n*/\nMix_MusicType Mix_GetMusicType(const Mix_Music *music)\n{\n    Mix_MusicType type = MUS_NONE;\n\n    if (music) {\n        type = music->interface->type;\n    } else {\n        Mix_LockAudio();\n        if (music_playing) {\n            type = music_playing->interface->type;\n        }\n        Mix_UnlockAudio();\n    }\n    return(type);\n}\n\n/* Play a music chunk.  Returns 0, or -1 if there was an error.\n */\nstatic int music_internal_play(Mix_Music *music, int play_count, double position)\n{\n    int retval = 0;\n\n#if defined(__MACOSX__) && defined(MID_MUSIC_NATIVE)\n    /* This fixes a bug with native MIDI on Mac OS X, where you\n       can't really stop and restart MIDI from the audio callback.\n    */\n    if (music == music_playing && music->api == MIX_MUSIC_NATIVEMIDI) {\n        /* Just a seek suffices to restart playing */\n        music_internal_position(position);\n        return 0;\n    }\n#endif\n\n    /* Note the music we're playing */\n    if (music_playing) {\n        music_internal_halt();\n    }\n    music_playing = music;\n    music_playing->playing = SDL_TRUE;\n\n    /* Set the initial volume */\n    music_internal_initialize_volume();\n\n    /* Set up for playback */\n    retval = music->interface->Play(music->context, play_count);\n\n    /* Set the playback position, note any errors if an offset is used */\n    if (retval == 0) {\n        if (position > 0.0) {\n            if (music_internal_position(position) < 0) {\n                Mix_SetError(\"Position not implemented for music type\");\n                retval = -1;\n            }\n        } else {\n            music_internal_position(0.0);\n        }\n    }\n\n    /* If the setup failed, we're not playing any music anymore */\n    if (retval < 0) {\n        music->playing = SDL_FALSE;\n        music_playing = NULL;\n    }\n    return(retval);\n}\n\nint Mix_FadeInMusicPos(Mix_Music *music, int loops, int ms, double position)\n{\n    int retval;\n\n    if (ms_per_step == 0) {\n        SDL_SetError(\"Audio device hasn't been opened\");\n        return(-1);\n    }\n\n    /* Don't play null pointers :-) */\n    if (music == NULL) {\n        Mix_SetError(\"music parameter was NULL\");\n        return(-1);\n    }\n\n    /* Setup the data */\n    if (ms) {\n        music->fading = MIX_FADING_IN;\n    } else {\n        music->fading = MIX_NO_FADING;\n    }\n    music->fade_step = 0;\n    music->fade_steps = ms/ms_per_step;\n\n    /* Play the puppy */\n    Mix_LockAudio();\n    /* If the current music is fading out, wait for the fade to complete */\n    while (music_playing && (music_playing->fading == MIX_FADING_OUT)) {\n        Mix_UnlockAudio();\n        SDL_Delay(100);\n        Mix_LockAudio();\n    }\n    if (loops == 0) {\n        /* Loop is the number of times to play the audio */\n        loops = 1;\n    }\n    retval = music_internal_play(music, loops, position);\n    Mix_UnlockAudio();\n\n    return(retval);\n}\nint Mix_FadeInMusic(Mix_Music *music, int loops, int ms)\n{\n    return Mix_FadeInMusicPos(music, loops, ms, 0.0);\n}\nint Mix_PlayMusic(Mix_Music *music, int loops)\n{\n    return Mix_FadeInMusicPos(music, loops, 0, 0.0);\n}\n\n/* Set the playing music position */\nint music_internal_position(double position)\n{\n    if (music_playing->interface->Seek) {\n        return music_playing->interface->Seek(music_playing->context, position);\n    }\n    return -1;\n}\nint Mix_SetMusicPosition(double position)\n{\n    int retval;\n\n    Mix_LockAudio();\n    if (music_playing) {\n        retval = music_internal_position(position);\n        if (retval < 0) {\n            Mix_SetError(\"Position not implemented for music type\");\n        }\n    } else {\n        Mix_SetError(\"Music isn't playing\");\n        retval = -1;\n    }\n    Mix_UnlockAudio();\n\n    return(retval);\n}\n\n/* Set the music's initial volume */\nstatic void music_internal_initialize_volume(void)\n{\n    if (music_playing->fading == MIX_FADING_IN) {\n        music_internal_volume(0);\n    } else {\n        music_internal_volume(music_volume);\n    }\n}\n\n/* Set the music volume */\nstatic void music_internal_volume(int volume)\n{\n    if (music_playing->interface->SetVolume) {\n        music_playing->interface->SetVolume(music_playing->context, volume);\n    }\n}\nint Mix_VolumeMusic(int volume)\n{\n    int prev_volume;\n\n    prev_volume = music_volume;\n    if (volume < 0) {\n        return prev_volume;\n    }\n    if (volume > SDL_MIX_MAXVOLUME) {\n        volume = SDL_MIX_MAXVOLUME;\n    }\n    music_volume = volume;\n    Mix_LockAudio();\n    if (music_playing) {\n        music_internal_volume(music_volume);\n    }\n    Mix_UnlockAudio();\n    return(prev_volume);\n}\n\n/* Halt playing of music */\nstatic void music_internal_halt(void)\n{\n    if (music_playing->interface->Stop) {\n        music_playing->interface->Stop(music_playing->context);\n    }\n\n    music_playing->playing = SDL_FALSE;\n    music_playing->fading = MIX_NO_FADING;\n    music_playing = NULL;\n}\nint Mix_HaltMusic(void)\n{\n    Mix_LockAudio();\n    if (music_playing) {\n        music_internal_halt();\n        if (music_finished_hook) {\n            music_finished_hook();\n        }\n    }\n    Mix_UnlockAudio();\n\n    return(0);\n}\n\n/* Progressively stop the music */\nint Mix_FadeOutMusic(int ms)\n{\n    int retval = 0;\n\n    if (ms_per_step == 0) {\n        SDL_SetError(\"Audio device hasn't been opened\");\n        return 0;\n    }\n\n    if (ms <= 0) {  /* just halt immediately. */\n        Mix_HaltMusic();\n        return 1;\n    }\n\n    Mix_LockAudio();\n    if (music_playing) {\n        int fade_steps = (ms + ms_per_step - 1) / ms_per_step;\n        if (music_playing->fading == MIX_NO_FADING) {\n            music_playing->fade_step = 0;\n        } else {\n            int step;\n            int old_fade_steps = music_playing->fade_steps;\n            if (music_playing->fading == MIX_FADING_OUT) {\n                step = music_playing->fade_step;\n            } else {\n                step = old_fade_steps - music_playing->fade_step + 1;\n            }\n            music_playing->fade_step = (step * fade_steps) / old_fade_steps;\n        }\n        music_playing->fading = MIX_FADING_OUT;\n        music_playing->fade_steps = fade_steps;\n        retval = 1;\n    }\n    Mix_UnlockAudio();\n\n    return(retval);\n}\n\nMix_Fading Mix_FadingMusic(void)\n{\n    Mix_Fading fading = MIX_NO_FADING;\n\n    Mix_LockAudio();\n    if (music_playing) {\n        fading = music_playing->fading;\n    }\n    Mix_UnlockAudio();\n\n    return(fading);\n}\n\n/* Pause/Resume the music stream */\nvoid Mix_PauseMusic(void)\n{\n    Mix_LockAudio();\n    if (music_playing) {\n        if (music_playing->interface->Pause) {\n            music_playing->interface->Pause(music_playing->context);\n        }\n    }\n    music_active = SDL_FALSE;\n    Mix_UnlockAudio();\n}\n\nvoid Mix_ResumeMusic(void)\n{\n    Mix_LockAudio();\n    if (music_playing) {\n        if (music_playing->interface->Resume) {\n            music_playing->interface->Resume(music_playing->context);\n        }\n    }\n    music_active = SDL_TRUE;\n    Mix_UnlockAudio();\n}\n\nvoid Mix_RewindMusic(void)\n{\n    Mix_SetMusicPosition(0.0);\n}\n\nint Mix_PausedMusic(void)\n{\n    return (music_active == SDL_FALSE);\n}\n\n/* Check the status of the music */\nstatic SDL_bool music_internal_playing(void)\n{\n    if (!music_playing) {\n        return SDL_FALSE;\n    }\n\n    if (music_playing->interface->IsPlaying) {\n        music_playing->playing = music_playing->interface->IsPlaying(music_playing->context);\n    }\n    return music_playing->playing;\n}\nint Mix_PlayingMusic(void)\n{\n    SDL_bool playing;\n\n    Mix_LockAudio();\n    playing = music_internal_playing();\n    Mix_UnlockAudio();\n\n    return playing ? 1 : 0;\n}\n\n/* Set the external music playback command */\nint Mix_SetMusicCMD(const char *command)\n{\n    Mix_HaltMusic();\n    if (music_cmd) {\n        SDL_free(music_cmd);\n        music_cmd = NULL;\n    }\n    if (command) {\n        size_t length = SDL_strlen(command) + 1;\n        music_cmd = (char *)SDL_malloc(length);\n        if (music_cmd == NULL) {\n            return SDL_OutOfMemory();\n        }\n        SDL_memcpy(music_cmd, command, length);\n    }\n    return 0;\n}\n\nint Mix_SetSynchroValue(int i)\n{\n    /* Not supported by any players at this time */\n    return(-1);\n}\n\nint Mix_GetSynchroValue(void)\n{\n    /* Not supported by any players at this time */\n    return(-1);\n}\n\n\n/* Uninitialize the music interfaces */\nvoid close_music(void)\n{\n    int i;\n\n    Mix_HaltMusic();\n\n    for (i = 0; i < SDL_arraysize(s_music_interfaces); ++i) {\n        Mix_MusicInterface *interface = s_music_interfaces[i];\n        if (!interface || !interface->opened) {\n            continue;\n        }\n\n        if (interface->Close) {\n            interface->Close();\n        }\n        interface->opened = SDL_FALSE;\n    }\n\n    if (soundfont_paths) {\n        SDL_free(soundfont_paths);\n        soundfont_paths = NULL;\n    }\n\n    /* rcg06042009 report available decoders at runtime. */\n    if (music_decoders) {\n        SDL_free((void *)music_decoders);\n        music_decoders = NULL;\n    }\n    num_decoders = 0;\n\n    ms_per_step = 0;\n}\n\n/* Unload the music interface libraries */\nvoid unload_music(void)\n{\n    int i;\n    for (i = 0; i < SDL_arraysize(s_music_interfaces); ++i) {\n        Mix_MusicInterface *interface = s_music_interfaces[i];\n        if (!interface || !interface->loaded) {\n            continue;\n        }\n\n        if (interface->Unload) {\n            interface->Unload();\n        }\n        interface->loaded = SDL_FALSE;\n    }\n}\n\nint Mix_SetSoundFonts(const char *paths)\n{\n    if (soundfont_paths) {\n        SDL_free(soundfont_paths);\n        soundfont_paths = NULL;\n    }\n\n    if (paths) {\n        if (!(soundfont_paths = SDL_strdup(paths))) {\n            Mix_SetError(\"Insufficient memory to set SoundFonts\");\n            return 0;\n        }\n    }\n    return 1;\n}\n\nconst char* Mix_GetSoundFonts(void)\n{\n    const char *env_paths = SDL_getenv(\"SDL_SOUNDFONTS\");\n    SDL_bool force_env_paths = SDL_GetHintBoolean(\"SDL_FORCE_SOUNDFONTS\", SDL_FALSE);\n    if (force_env_paths && (!env_paths || !*env_paths)) {\n        force_env_paths = SDL_FALSE;\n    }\n    if (soundfont_paths && *soundfont_paths && !force_env_paths) {\n        return soundfont_paths;\n    }\n    if (env_paths) {\n        return env_paths;\n    }\n\n    /* We don't have any sound fonts set programmatically or in the environment\n       Time to start guessing where they might be...\n     */\n    {\n        static char *s_soundfont_paths[] = {\n            \"/usr/share/sounds/sf2/FluidR3_GM.sf2\"  /* Remember to add ',' here */\n        };\n        unsigned i;\n\n        for (i = 0; i < SDL_arraysize(s_soundfont_paths); ++i) {\n            SDL_RWops *rwops = SDL_RWFromFile(s_soundfont_paths[i], \"rb\");\n            if (rwops) {\n                SDL_RWclose(rwops);\n                return s_soundfont_paths[i];\n            }\n        }\n    }\n    return NULL;\n}\n\nint Mix_EachSoundFont(int (SDLCALL *function)(const char*, void*), void *data)\n{\n    char *context, *path, *paths;\n    const char* cpaths = Mix_GetSoundFonts();\n    int soundfonts_found = 0;\n\n    if (!cpaths) {\n        Mix_SetError(\"No SoundFonts have been requested\");\n        return 0;\n    }\n\n    if (!(paths = SDL_strdup(cpaths))) {\n        Mix_SetError(\"Insufficient memory to iterate over SoundFonts\");\n        return 0;\n    }\n\n#if defined(__MINGW32__) || defined(__MINGW64__) || defined(__WATCOMC__)\n    for (path = strtok(paths, \";\"); path; path = strtok(NULL, \";\")) {\n#elif defined(_WIN32)\n    for (path = strtok_s(paths, \";\", &context); path; path = strtok_s(NULL, \";\", &context)) {\n#else\n    for (path = strtok_r(paths, \":;\", &context); path; path = strtok_r(NULL, \":;\", &context)) {\n#endif\n        if (!function(path, data)) {\n            continue;\n        } else {\n            soundfonts_found++;\n        }\n    }\n\n    SDL_free(paths);\n    if (soundfonts_found > 0)\n        return 1;\n    else\n        return 0;\n}\n\n/* vi: set ts=4 sw=4 expandtab: */\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// DESCRIPTION: Event handling.\n//\n// Events are asynchronous inputs generally generated by the game user.\n// Events can be discarded if no responder claims them\n//\n\n#include <stdlib.h>\n#include \"d_event.h\"\n\n#define MAXEVENTS 64\n\nstatic event_t events[MAXEVENTS];\nstatic int eventhead;\nstatic int eventtail;\n\n//\n// D_PostEvent\n// Called by the I/O functions when input is detected\n//\nvoid D_PostEvent (event_t* ev)\n{\n    events[eventhead] = *ev;\n    eventhead = (eventhead + 1) % MAXEVENTS;\n}\n\nboolean D_EqualsEventHead (event_t* ev)\n{\n    event_t head = events[eventhead - 1];\n    return (head.type == ev->type &&\n        head.data1 == ev->data1 &&\n        head.data2 == ev->data2 &&\n        head.data3 == ev->data3);\n}\n\n// Read an event from the queue.\n\nevent_t *D_PopEvent(void)\n{\n    event_t *result;\n\n    // No more events waiting.\n\n    if (eventtail == eventhead)\n    {\n        return NULL;\n    }\n    \n    result = &events[eventtail];\n\n    // Advance to the next event in the queue.\n\n    eventtail = (eventtail + 1) % MAXEVENTS;\n\n    return result;\n}\n\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//     Search for and locate an IWAD file, and initialize according\n//     to the IWAD type.\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n#include <string.h>\n\n#include \"deh_str.h\"\n#include \"doomkeys.h\"\n#include \"d_iwad.h\"\n#include \"i_system.h\"\n#include \"m_argv.h\"\n#include \"m_config.h\"\n#include \"m_misc.h\"\n#include \"w_wad.h\"\n#include \"z_zone.h\"\n\nstatic const iwad_t iwads[] =\n{\n    { \"doom2.wad\",    doom2,     commercial, \"Doom II\" },\n    { \"plutonia.wad\", pack_plut, commercial, \"Final Doom: Plutonia Experiment\" },\n    { \"tnt.wad\",      pack_tnt,  commercial, \"Final Doom: TNT: Evilution\" },\n    { \"doom.wad\",     doom,      retail,     \"Doom\" },\n    { \"doom1.wad\",    doom,      shareware,  \"Doom Shareware\" },\n    { \"chex.wad\",     pack_chex, retail,     \"Chex Quest\" },\n    { \"hacx.wad\",     pack_hacx, commercial, \"Hacx\" },\n    { \"freedm.wad\",   doom2,     commercial, \"FreeDM\" },\n    { \"freedoom2.wad\", doom2,    commercial, \"Freedoom: Phase 2\" },\n    { \"freedoom1.wad\", doom,     retail,     \"Freedoom: Phase 1\" },\n    { \"heretic.wad\",  heretic,   retail,     \"Heretic\" },\n    { \"heretic1.wad\", heretic,   shareware,  \"Heretic Shareware\" },\n    { \"hexen.wad\",    hexen,     commercial, \"Hexen\" },\n    //{ \"strife0.wad\",  strife,    commercial, \"Strife\" }, // haleyjd: STRIFE-FIXME\n    { \"strife1.wad\",  strife,    commercial, \"Strife\" },\n};\n\n// Array of locations to search for IWAD files\n//\n// \"128 IWAD search directories should be enough for anybody\".\n\n#define MAX_IWAD_DIRS 128\n\nstatic boolean iwad_dirs_built = false;\nstatic char *iwad_dirs[MAX_IWAD_DIRS];\nstatic int num_iwad_dirs = 0;\n\nstatic void AddIWADDir(char *dir)\n{\n    if (num_iwad_dirs < MAX_IWAD_DIRS)\n    {\n        iwad_dirs[num_iwad_dirs] = dir;\n        ++num_iwad_dirs;\n    }\n}\n\n// This is Windows-specific code that automatically finds the location\n// of installed IWAD files.  The registry is inspected to find special\n// keys installed by the Windows installers for various CD versions\n// of Doom.  From these keys we can deduce where to find an IWAD.\n\n#if defined(_WIN32) && !defined(_WIN32_WCE)\n\n#define WIN32_LEAN_AND_MEAN\n#include <windows.h>\n\ntypedef struct \n{\n    HKEY root;\n    char *path;\n    char *value;\n} registry_value_t;\n\n#define UNINSTALLER_STRING \"\\\\uninstl.exe /S \"\n\n// Keys installed by the various CD editions.  These are actually the \n// commands to invoke the uninstaller and look like this:\n//\n// C:\\Program Files\\Path\\uninstl.exe /S C:\\Program Files\\Path\n//\n// With some munging we can find where Doom was installed.\n\n// [AlexMax] From the persepctive of a 64-bit executable, 32-bit registry\n// keys are located in a different spot.\n#if _WIN64\n#define SOFTWARE_KEY \"Software\\\\Wow6432Node\"\n#else\n#define SOFTWARE_KEY \"Software\"\n#endif\n\nstatic registry_value_t uninstall_values[] =\n{\n    // Ultimate Doom, CD version (Depths of Doom trilogy)\n\n    {\n        HKEY_LOCAL_MACHINE,\n        SOFTWARE_KEY \"\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\\"\n            \"Uninstall\\\\Ultimate Doom for Windows 95\",\n        \"UninstallString\",\n    },\n\n    // Doom II, CD version (Depths of Doom trilogy)\n\n    {\n        HKEY_LOCAL_MACHINE,\n        SOFTWARE_KEY \"\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\\"\n            \"Uninstall\\\\Doom II for Windows 95\",\n        \"UninstallString\",\n    },\n\n    // Final Doom\n\n    {\n        HKEY_LOCAL_MACHINE,\n        SOFTWARE_KEY \"\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\\"\n            \"Uninstall\\\\Final Doom for Windows 95\",\n        \"UninstallString\",\n    },\n\n    // Shareware version\n\n    {\n        HKEY_LOCAL_MACHINE,\n        SOFTWARE_KEY \"\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\\"\n            \"Uninstall\\\\Doom Shareware for Windows 95\",\n        \"UninstallString\",\n    },\n};\n\n// Values installed by the GOG.com and Collector's Edition versions\n\nstatic registry_value_t root_path_keys[] =\n{\n    // Doom Collector's Edition\n\n    {\n        HKEY_LOCAL_MACHINE,\n        SOFTWARE_KEY \"\\\\Activision\\\\DOOM Collector's Edition\\\\v1.0\",\n        \"INSTALLPATH\",\n    },\n\n    // Doom II\n\n    {\n        HKEY_LOCAL_MACHINE,\n        SOFTWARE_KEY \"\\\\GOG.com\\\\Games\\\\1435848814\",\n        \"PATH\",\n    },\n\n    // Doom 3: BFG Edition\n\n    {\n        HKEY_LOCAL_MACHINE,\n        SOFTWARE_KEY \"\\\\GOG.com\\\\Games\\\\1135892318\",\n        \"PATH\",\n    },\n\n    // Final Doom\n\n    {\n        HKEY_LOCAL_MACHINE,\n        SOFTWARE_KEY \"\\\\GOG.com\\\\Games\\\\1435848742\",\n        \"PATH\",\n    },\n\n    // Ultimate Doom\n\n    {\n        HKEY_LOCAL_MACHINE,\n        SOFTWARE_KEY \"\\\\GOG.com\\\\Games\\\\1435827232\",\n        \"PATH\",\n    },\n\n    // Strife: Veteran Edition\n\n    {\n        HKEY_LOCAL_MACHINE,\n        SOFTWARE_KEY \"\\\\GOG.com\\\\Games\\\\1432899949\",\n        \"PATH\",\n    },\n};\n\n// Subdirectories of the above install path, where IWADs are installed.\n\nstatic char *root_path_subdirs[] =\n{\n    \".\",\n    \"Doom2\",\n    \"Final Doom\",\n    \"Ultimate Doom\",\n    \"Plutonia\",\n    \"TNT\",\n    \"base\\\\wads\",\n};\n\n// Location where Steam is installed\n\nstatic registry_value_t steam_install_location =\n{\n    HKEY_LOCAL_MACHINE,\n    SOFTWARE_KEY \"\\\\Valve\\\\Steam\",\n    \"InstallPath\",\n};\n\n// Subdirs of the steam install directory where IWADs are found\n\nstatic char *steam_install_subdirs[] =\n{\n    \"steamapps\\\\common\\\\doom 2\\\\base\",\n    \"steamapps\\\\common\\\\final doom\\\\base\",\n    \"steamapps\\\\common\\\\ultimate doom\\\\base\",\n    \"steamapps\\\\common\\\\heretic shadow of the serpent riders\\\\base\",\n    \"steamapps\\\\common\\\\hexen\\\\base\",\n    \"steamapps\\\\common\\\\hexen deathkings of the dark citadel\\\\base\",\n\n    // From Doom 3: BFG Edition:\n\n    \"steamapps\\\\common\\\\DOOM 3 BFG Edition\\\\base\\\\wads\",\n\n    // From Strife: Veteran Edition:\n\n    \"steamapps\\\\common\\\\Strife\",\n};\n\n#define STEAM_BFG_GUS_PATCHES \\\n    \"steamapps\\\\common\\\\DOOM 3 BFG Edition\\\\base\\\\classicmusic\\\\instruments\"\n\nstatic char *GetRegistryString(registry_value_t *reg_val)\n{\n    HKEY key;\n    DWORD len;\n    DWORD valtype;\n    char *result;\n\n    // Open the key (directory where the value is stored)\n\n    if (RegOpenKeyEx(reg_val->root, reg_val->path,\n                     0, KEY_READ, &key) != ERROR_SUCCESS)\n    {\n        return NULL;\n    }\n\n    result = NULL;\n\n    // Find the type and length of the string, and only accept strings.\n\n    if (RegQueryValueEx(key, reg_val->value,\n                        NULL, &valtype, NULL, &len) == ERROR_SUCCESS\n     && valtype == REG_SZ)\n    {\n        // Allocate a buffer for the value and read the value\n\n        result = malloc(len + 1);\n\n        if (RegQueryValueEx(key, reg_val->value, NULL, &valtype,\n                            (unsigned char *) result, &len) != ERROR_SUCCESS)\n        {\n            free(result);\n            result = NULL;\n        }\n        else\n        {\n            // Ensure the value is null-terminated\n            result[len] = '\\0';\n        }\n    }\n\n    // Close the key\n\n    RegCloseKey(key);\n\n    return result;\n}\n\n// Check for the uninstall strings from the CD versions\n\nstatic void CheckUninstallStrings(void)\n{\n    unsigned int i;\n\n    for (i=0; i<arrlen(uninstall_values); ++i)\n    {\n        char *val;\n        char *path;\n        char *unstr;\n\n        val = GetRegistryString(&uninstall_values[i]);\n\n        if (val == NULL)\n        {\n            continue;\n        }\n\n        unstr = strstr(val, UNINSTALLER_STRING);\n\n        if (unstr == NULL)\n        {\n            free(val);\n        }\n        else\n        {\n            path = unstr + strlen(UNINSTALLER_STRING);\n\n            AddIWADDir(path);\n        }\n    }\n}\n\n// Check for GOG.com and Doom: Collector's Edition\n\nstatic void CheckInstallRootPaths(void)\n{\n    unsigned int i;\n\n    for (i=0; i<arrlen(root_path_keys); ++i)\n    {\n        char *install_path;\n        char *subpath;\n        unsigned int j;\n\n        install_path = GetRegistryString(&root_path_keys[i]);\n\n        if (install_path == NULL)\n        {\n            continue;\n        }\n\n        for (j=0; j<arrlen(root_path_subdirs); ++j)\n        {\n            subpath = M_StringJoin(install_path, DIR_SEPARATOR_S,\n                                   root_path_subdirs[j], NULL);\n            AddIWADDir(subpath);\n        }\n\n        free(install_path);\n    }\n}\n\n\n// Check for Doom downloaded via Steam\n\nstatic void CheckSteamEdition(void)\n{\n    char *install_path;\n    char *subpath;\n    size_t i;\n\n    install_path = GetRegistryString(&steam_install_location);\n\n    if (install_path == NULL)\n    {\n        return;\n    }\n\n    for (i=0; i<arrlen(steam_install_subdirs); ++i)\n    {\n        subpath = M_StringJoin(install_path, DIR_SEPARATOR_S,\n                               steam_install_subdirs[i], NULL);\n\n        AddIWADDir(subpath);\n    }\n\n    free(install_path);\n}\n\n// The BFG edition ships with a full set of GUS patches. If we find them,\n// we can autoconfigure to use them.\n\nstatic void CheckSteamGUSPatches(void)\n{\n    const char *current_path;\n    char *install_path;\n    char *patch_path;\n    int len;\n\n    // Already configured? Don't stomp on the user's choices.\n    current_path = M_GetStringVariable(\"gus_patch_path\");\n    if (current_path != NULL && strlen(current_path) > 0)\n    {\n        return;\n    }\n\n    install_path = GetRegistryString(&steam_install_location);\n\n    if (install_path == NULL)\n    {\n        return;\n    }\n\n    len = strlen(install_path) + strlen(STEAM_BFG_GUS_PATCHES) + 20;\n    patch_path = malloc(len);\n    M_snprintf(patch_path, len, \"%s\\\\%s\\\\ACBASS.PAT\",\n               install_path, STEAM_BFG_GUS_PATCHES);\n\n    // Does acbass.pat exist? If so, then set gus_patch_path.\n    if (M_FileExists(patch_path))\n    {\n        M_snprintf(patch_path, len, \"%s\\\\%s\",\n                   install_path, STEAM_BFG_GUS_PATCHES);\n        M_SetVariable(\"gus_patch_path\", patch_path);\n    }\n\n    free(patch_path);\n    free(install_path);\n}\n\n// Default install directories for DOS Doom\n\nstatic void CheckDOSDefaults(void)\n{\n    // These are the default install directories used by the deice\n    // installer program:\n\n    AddIWADDir(\"\\\\doom2\");              // Doom II\n    AddIWADDir(\"\\\\plutonia\");           // Final Doom\n    AddIWADDir(\"\\\\tnt\");\n    AddIWADDir(\"\\\\doom_se\");            // Ultimate Doom\n    AddIWADDir(\"\\\\doom\");               // Shareware / Registered Doom\n    AddIWADDir(\"\\\\dooms\");              // Shareware versions\n    AddIWADDir(\"\\\\doomsw\");\n\n    AddIWADDir(\"\\\\heretic\");            // Heretic\n    AddIWADDir(\"\\\\hrtic_se\");           // Heretic Shareware from Quake disc\n\n    AddIWADDir(\"\\\\hexen\");              // Hexen\n    AddIWADDir(\"\\\\hexendk\");            // Hexen Deathkings of the Dark Citadel\n\n    AddIWADDir(\"\\\\strife\");             // Strife\n}\n\n#endif\n\n// Returns true if the specified path is a path to a file\n// of the specified name.\n\nstatic boolean DirIsFile(const char *path, const char *filename)\n{\n    size_t path_len;\n    size_t filename_len;\n\n    path_len = strlen(path);\n    filename_len = strlen(filename);\n\n    return path_len >= filename_len + 1\n        && path[path_len - filename_len - 1] == DIR_SEPARATOR\n        && !strcasecmp(&path[path_len - filename_len], filename);\n}\n\n// Check if the specified directory contains the specified IWAD\n// file, returning the full path to the IWAD if found, or NULL\n// if not found.\n\nstatic char *CheckDirectoryHasIWAD(const char *dir, const char *iwadname)\n{\n    char *filename; \n    char *probe;\n\n    // As a special case, the \"directory\" may refer directly to an\n    // IWAD file if the path comes from DOOMWADDIR or DOOMWADPATH.\n\n    probe = M_FileCaseExists(dir);\n    if (DirIsFile(dir, iwadname) && probe != NULL)\n    {\n        return probe;\n    }\n\n    // Construct the full path to the IWAD if it is located in\n    // this directory, and check if it exists.\n\n    if (!strcmp(dir, \".\"))\n    {\n        filename = M_StringDuplicate(iwadname);\n    }\n    else\n    {\n        filename = M_StringJoin(dir, DIR_SEPARATOR_S, iwadname, NULL);\n    }\n\n    probe = M_FileCaseExists(filename);\n    free(filename);\n    if (probe != NULL)\n    {\n        return probe;\n    }\n\n    return NULL;\n}\n\n// Search a directory to try to find an IWAD\n// Returns the location of the IWAD if found, otherwise NULL.\n\nstatic char *SearchDirectoryForIWAD(char *dir, int mask, GameMission_t *mission)\n{\n    char *filename;\n    size_t i;\n\n    for (i=0; i<arrlen(iwads); ++i) \n    {\n        if (((1 << iwads[i].mission) & mask) == 0)\n        {\n            continue;\n        }\n\n        filename = CheckDirectoryHasIWAD(dir, DEH_String(iwads[i].name));\n\n        if (filename != NULL)\n        {\n            *mission = iwads[i].mission;\n\n            return filename;\n        }\n    }\n\n    return NULL;\n}\n\n// When given an IWAD with the '-iwad' parameter,\n// attempt to identify it by its name.\n\nstatic GameMission_t IdentifyIWADByName(char *name, int mask)\n{\n    size_t i;\n    GameMission_t mission;\n    char *p;\n\n    p = strrchr(name, DIR_SEPARATOR);\n\n    if (p != NULL)\n    {\n        name = p + 1;\n    }\n\n    mission = none;\n\n    for (i=0; i<arrlen(iwads); ++i)\n    {\n        // Check if the filename is this IWAD name.\n\n        // Only use supported missions:\n\n        if (((1 << iwads[i].mission) & mask) == 0)\n            continue;\n\n        // Check if it ends in this IWAD name.\n\n        if (!strcasecmp(name, iwads[i].name))\n        {\n            mission = iwads[i].mission;\n            break;\n        }\n    }\n\n    return mission;\n}\n\n// Add IWAD directories parsed from splitting a path string containing\n// paths separated by PATH_SEPARATOR. 'suffix' is a string to concatenate\n// to the end of the paths before adding them.\nstatic void AddIWADPath(char *path, char *suffix)\n{\n    char *left, *p;\n\n    path = M_StringDuplicate(path);\n\n    // Split into individual dirs within the list.\n    left = path;\n\n    for (;;)\n    {\n        p = strchr(left, PATH_SEPARATOR);\n        if (p != NULL)\n        {\n            // Break at the separator and use the left hand side\n            // as another iwad dir\n            *p = '\\0';\n\n            AddIWADDir(M_StringJoin(left, suffix, NULL));\n            left = p + 1;\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    AddIWADDir(M_StringJoin(left, suffix, NULL));\n\n    free(path);\n}\n\n#ifndef _WIN32\n// Add standard directories where IWADs are located on Unix systems.\n// To respect the freedesktop.org specification we support overriding\n// using standard environment variables. See the XDG Base Directory\n// Specification:\n// <http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html>\nstatic void AddXdgDirs(void)\n{\n    char *env, *tmp_env;\n\n    // Quote:\n    // > $XDG_DATA_HOME defines the base directory relative to which\n    // > user specific data files should be stored. If $XDG_DATA_HOME\n    // > is either not set or empty, a default equal to\n    // > $HOME/.local/share should be used.\n    env = getenv(\"XDG_DATA_HOME\");\n    tmp_env = NULL;\n\n    if (env == NULL)\n    {\n        char *homedir = getenv(\"HOME\");\n        if (homedir == NULL)\n        {\n            homedir = \"/\";\n        }\n\n        tmp_env = M_StringJoin(homedir, \"/.local/share\", NULL);\n        env = tmp_env;\n    }\n\n    // We support $XDG_DATA_HOME/games/doom (which will usually be\n    // ~/.local/share/games/doom) as a user-writeable extension to\n    // the usual /usr/share/games/doom location.\n    AddIWADDir(M_StringJoin(env, \"/games/doom\", NULL));\n    free(tmp_env);\n\n    // Quote:\n    // > $XDG_DATA_DIRS defines the preference-ordered set of base\n    // > directories to search for data files in addition to the\n    // > $XDG_DATA_HOME base directory. The directories in $XDG_DATA_DIRS\n    // > should be seperated with a colon ':'.\n    // >\n    // > If $XDG_DATA_DIRS is either not set or empty, a value equal to\n    // > /usr/local/share/:/usr/share/ should be used.\n    env = getenv(\"XDG_DATA_DIRS\");\n    if (env == NULL)\n    {\n        // (Trailing / omitted from paths, as it is added below)\n        env = \"/usr/local/share:/usr/share\";\n    }\n\n    // The \"standard\" location for IWADs on Unix that is supported by most\n    // source ports is /usr/share/games/doom - we support this through the\n    // XDG_DATA_DIRS mechanism, through which it can be overridden.\n    AddIWADPath(env, \"/games/doom\");\n\n    // The convention set by RBDOOM-3-BFG is to install Doom 3: BFG\n    // Edition into this directory, under which includes the Doom\n    // Classic WADs.\n    AddIWADPath(env, \"/games/doom3bfg/base/wads\");\n}\n#endif\n\n//\n// Build a list of IWAD files\n//\n\nstatic void BuildIWADDirList(void)\n{\n    char *env;\n\n    if (iwad_dirs_built)\n    {\n        return;\n    }\n\n    // Look in the current directory.  Doom always does this.\n    AddIWADDir(\".\");\n\n    // Add DOOMWADDIR if it is in the environment\n    env = getenv(\"DOOMWADDIR\");\n    if (env != NULL)\n    {\n        AddIWADDir(env);\n    }\n\n    // Add dirs from DOOMWADPATH:\n    env = getenv(\"DOOMWADPATH\");\n    if (env != NULL)\n    {\n        AddIWADPath(env, \"\");\n    }\n\n#ifdef _WIN32\n\n    // Search the registry and find where IWADs have been installed.\n\n    CheckUninstallStrings();\n    CheckInstallRootPaths();\n    CheckSteamEdition();\n    CheckDOSDefaults();\n\n    // Check for GUS patches installed with the BFG edition!\n\n    CheckSteamGUSPatches();\n\n#else\n    AddXdgDirs();\n#endif\n\n    // Don't run this function again.\n\n    iwad_dirs_built = true;\n}\n\n//\n// Searches WAD search paths for an WAD with a specific filename.\n// \n\nchar *D_FindWADByName(const char *name)\n{\n    char *path;\n    char *probe;\n    int i;\n    \n    // Absolute path?\n\n    probe = M_FileCaseExists(name);\n    if (probe != NULL)\n    {\n        return probe;\n    }\n\n    BuildIWADDirList();\n\n    // Search through all IWAD paths for a file with the given name.\n\n    for (i=0; i<num_iwad_dirs; ++i)\n    {\n        // As a special case, if this is in DOOMWADDIR or DOOMWADPATH,\n        // the \"directory\" may actually refer directly to an IWAD\n        // file.\n\n        probe = M_FileCaseExists(iwad_dirs[i]);\n        if (DirIsFile(iwad_dirs[i], name) && probe != NULL)\n        {\n            return probe;\n        }\n\n        // Construct a string for the full path\n\n        path = M_StringJoin(iwad_dirs[i], DIR_SEPARATOR_S, name, NULL);\n\n        probe = M_FileCaseExists(path);\n        if (probe != NULL)\n        {\n            return probe;\n        }\n\n        free(path);\n    }\n\n    // File not found\n\n    return NULL;\n}\n\n//\n// D_TryWADByName\n//\n// Searches for a WAD by its filename, or passes through the filename\n// if not found.\n//\n\nchar *D_TryFindWADByName(char *filename)\n{\n    char *result;\n\n    result = D_FindWADByName(filename);\n\n    if (result != NULL)\n    {\n        return result;\n    }\n    else\n    {\n        return filename;\n    }\n}\n\n//\n// FindIWAD\n// Checks availability of IWAD files by name,\n// to determine whether registered/commercial features\n// should be executed (notably loading PWADs).\n//\n\nchar *D_FindIWAD(int mask, GameMission_t *mission)\n{\n    char *result;\n    char *iwadfile;\n    int iwadparm;\n    int i;\n\n    // Check for the -iwad parameter\n\n    //!\n    // Specify an IWAD file to use.\n    //\n    // @arg <file>\n    //\n\n    iwadparm = M_CheckParmWithArgs(\"-iwad\", 1);\n\n    if (iwadparm)\n    {\n        // Search through IWAD dirs for an IWAD with the given name.\n\n        iwadfile = myargv[iwadparm + 1];\n\n        result = D_FindWADByName(iwadfile);\n\n        if (result == NULL)\n        {\n            I_Error(\"IWAD file '%s' not found!\", iwadfile);\n        }\n        \n        *mission = IdentifyIWADByName(result, mask);\n    }\n    else\n    {\n        // Search through the list and look for an IWAD\n\n        result = NULL;\n\n        BuildIWADDirList();\n    \n        for (i=0; result == NULL && i<num_iwad_dirs; ++i)\n        {\n            result = SearchDirectoryForIWAD(iwad_dirs[i], mask, mission);\n        }\n    }\n\n    return result;\n}\n\n// Find all IWADs in the IWAD search path matching the given mask.\n\nconst iwad_t **D_FindAllIWADs(int mask)\n{\n    const iwad_t **result;\n    int result_len;\n    char *filename;\n    int i;\n\n    result = malloc(sizeof(iwad_t *) * (arrlen(iwads) + 1));\n    result_len = 0;\n\n    // Try to find all IWADs\n\n    for (i=0; i<arrlen(iwads); ++i)\n    {\n        if (((1 << iwads[i].mission) & mask) == 0)\n        {\n            continue;\n        }\n\n        filename = D_FindWADByName(iwads[i].name);\n\n        if (filename != NULL)\n        {\n            result[result_len] = &iwads[i];\n            ++result_len;\n        }\n    }\n\n    // End of list\n\n    result[result_len] = NULL;\n\n    return result;\n}\n\n//\n// Get the IWAD name used for savegames.\n//\n\nchar *D_SaveGameIWADName(GameMission_t gamemission)\n{\n    size_t i;\n\n    // Determine the IWAD name to use for savegames.\n    // This determines the directory the savegame files get put into.\n    //\n    // Note that we match on gamemission rather than on IWAD name.\n    // This ensures that doom1.wad and doom.wad saves are stored\n    // in the same place.\n\n    for (i=0; i<arrlen(iwads); ++i)\n    {\n        if (gamemission == iwads[i].mission)\n        {\n            return iwads[i].name;\n        }\n    }\n\n    // Default fallback:\n\n    return \"unknown.wad\";\n}\n\nchar *D_SuggestIWADName(GameMission_t mission, GameMode_t mode)\n{\n    int i;\n\n    for (i = 0; i < arrlen(iwads); ++i)\n    {\n        if (iwads[i].mission == mission && iwads[i].mode == mode)\n        {\n            return iwads[i].name;\n        }\n    }\n\n    return \"unknown.wad\";\n}\n\nchar *D_SuggestGameName(GameMission_t mission, GameMode_t mode)\n{\n    int i;\n\n    for (i = 0; i < arrlen(iwads); ++i)\n    {\n        if (iwads[i].mission == mission\n         && (mode == indetermined || iwads[i].mode == mode))\n        {\n            return iwads[i].description;\n        }\n    }\n\n    return \"Unknown game?\";\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//     Main loop code.\n//\n\n#include <stdlib.h>\n#include <string.h>\n\n#include \"d_event.h\"\n#include \"d_loop.h\"\n#include \"d_ticcmd.h\"\n\n#include \"i_system.h\"\n#include \"i_timer.h\"\n#include \"i_video.h\"\n\n#include \"m_argv.h\"\n#include \"m_fixed.h\"\n\n#include <emscripten.h>\n\n// The complete set of data for a particular tic.\n\ntypedef struct\n{\n    ticcmd_t cmds[NET_MAXPLAYERS];\n    boolean ingame[NET_MAXPLAYERS];\n} ticcmd_set_t;\n\n// Maximum time that we wait in TryRunTics() for netgame data to be\n// received before we bail out and render a frame anyway.\n// Vanilla Doom used 20 for this value, but we use a smaller value\n// instead for better responsiveness of the menu when we're stuck.\n#define MAX_NETGAME_STALL_TICS  5\n\n//\n// gametic is the tic about to (or currently being) run\n// maketic is the tic that hasn't had control made for it yet\n// recvtic is the latest tic received from the server.\n//\n// a gametic cannot be run until ticcmds are received for it\n// from all players.\n//\n\nstatic ticcmd_set_t ticdata[BACKUPTICS];\n\n// The index of the next tic to be made (with a call to BuildTiccmd).\n\nstatic int maketic;\n\n// The number of complete tics received from the server so far.\n\nstatic int recvtic;\n\n// The number of tics that have been run (using RunTic) so far.\n\nint gametic;\n\n// When set to true, a single tic is run each time TryRunTics() is called.\n// This is used for -timedemo mode.\n\nboolean singletics = false;\n\n// Index of the local player.\n\nstatic int localplayer;\n\n// Used for original sync code.\n\nstatic int      skiptics = 0;\n\n// Reduce the bandwidth needed by sampling game input less and transmitting\n// less.  If ticdup is 2, sample half normal, 3 = one third normal, etc.\n\nint\t\tticdup = 1;\n\n// Amount to offset the timer for game sync.\n\nfixed_t         offsetms;\n\n// Use new client syncronisation code\n\nstatic boolean  new_sync = true;\n\n// Callback functions for loop code.\n\nstatic loop_interface_t *loop_interface = NULL;\n\n// Current players in the multiplayer game.\n// This is distinct from playeringame[] used by the game code, which may\n// modify playeringame[] when playing back multiplayer demos.\n\nstatic boolean local_playeringame[NET_MAXPLAYERS];\n\n// Requested player class \"sent\" to the server on connect.\n// If we are only doing a single player game then this needs to be remembered\n// and saved in the game settings.\n\nstatic int player_class;\n\n\n// 35 fps clock adjusted by offsetms milliseconds\n\nstatic int GetAdjustedTime(void)\n{\n    int time_ms;\n\n    time_ms = I_GetTimeMS();\n\n    if (new_sync)\n    {\n\t// Use the adjustments from net_client.c only if we are\n\t// using the new sync mode.\n\n        time_ms += (offsetms / FRACUNIT);\n    }\n\n    return (time_ms * TICRATE) / 1000;\n}\n\nstatic boolean BuildNewTic(void)\n{\n    int\tgameticdiv;\n    ticcmd_t cmd;\n\n    gameticdiv = gametic/ticdup;\n\n    I_StartTic ();\n    loop_interface->ProcessEvents();\n\n    // Always run the menu\n\n    loop_interface->RunMenu();\n\n    if (new_sync)\n    {\n       // If playing single player, do not allow tics to buffer\n       // up very far\n\n       if (maketic - gameticdiv > 2)\n           return false;\n\n       // Never go more than ~200ms ahead\n\n       if (maketic - gameticdiv > 8)\n           return false;\n    }\n    else\n    {\n       if (maketic - gameticdiv >= 5)\n           return false;\n    }\n\n    memset(&cmd, 0, sizeof(ticcmd_t));\n    loop_interface->BuildTiccmd(&cmd, maketic);\n\n    ticdata[maketic % BACKUPTICS].cmds[localplayer] = cmd;\n    ticdata[maketic % BACKUPTICS].ingame[localplayer] = true;\n\n    ++maketic;\n\n    return true;\n}\n\n//\n// NetUpdate\n// Builds ticcmds for console player,\n// sends out a packet\n//\nint      lasttime;\n\nvoid NetUpdate (void)\n{\n    int nowtime;\n    int newtics;\n    int\ti;\n\n    // If we are running with singletics (timing a demo), this\n    // is all done separately.\n\n    if (singletics)\n        return;\n\n    // check time\n    nowtime = GetAdjustedTime() / ticdup;\n    newtics = nowtime - lasttime;\n\n    lasttime = nowtime;\n\n    if (skiptics <= newtics)\n    {\n        newtics -= skiptics;\n        skiptics = 0;\n    }\n    else\n    {\n        skiptics -= newtics;\n        newtics = 0;\n    }\n\n    // build new ticcmds for console player\n\n    for (i=0 ; i<newtics ; i++)\n    {\n        if (!BuildNewTic())\n        {\n            break;\n        }\n    }\n}\n\n//\n// Invoked by the network engine when a complete set of ticcmds is\n// available.\n//\n\nvoid D_ReceiveTic(ticcmd_t *ticcmds, boolean *players_mask)\n{\n    int i;\n\n    // Disconnected from server?\n\n    if (ticcmds == NULL && players_mask == NULL)\n    {\n        return;\n    }\n\n    for (i = 0; i < NET_MAXPLAYERS; ++i)\n    {\n        if (i == localplayer)\n        {\n            // This is us.  Don't overwrite it.\n        }\n        else\n        {\n            ticdata[recvtic % BACKUPTICS].cmds[i] = ticcmds[i];\n            ticdata[recvtic % BACKUPTICS].ingame[i] = players_mask[i];\n        }\n    }\n\n    ++recvtic;\n}\n\n//\n// Start game loop\n//\n// Called after the screen is set but before the game starts running.\n//\n\nvoid D_StartGameLoop(void)\n{\n    lasttime = GetAdjustedTime() / ticdup;\n}\n\nvoid D_StartNetGame(net_gamesettings_t *settings,\n                    netgame_startup_callback_t callback)\n{\n    int i;\n\n    offsetms = 0;\n    recvtic = 0;\n\n    settings->consoleplayer = 0;\n    settings->num_players = 1;\n    settings->player_classes[0] = player_class;\n    settings->extratics = 1;\n    settings->ticdup = 1;\n\n    // Set the local player and playeringame[] values.\n\n    localplayer = settings->consoleplayer;\n\n    for (i = 0; i < NET_MAXPLAYERS; ++i)\n    {\n        local_playeringame[i] = i < settings->num_players;\n    }\n\n    // Copy settings to global variables.\n\n    ticdup = settings->ticdup;\n    new_sync = settings->new_sync;\n}\n\nboolean D_InitNetGame(net_connect_data_t *connect_data)\n{\n    boolean result = false;\n\n    I_AtExit(D_QuitNetGame, true);\n\n    player_class = connect_data->player_class;\n\n    return result;\n}\n\n\n//\n// D_QuitNetGame\n// Called before quitting to leave a net game\n// without hanging the other players\n//\nvoid D_QuitNetGame (void)\n{\n}\n\nstatic int GetLowTic(void)\n{\n    int lowtic;\n    lowtic = maketic;\n    return lowtic;\n}\n\n// Returns true if there are players in the game:\n\nstatic boolean PlayersInGame(void)\n{\n    return true;\n}\n\n// When using ticdup, certain values must be cleared out when running\n// the duplicate ticcmds.\n\nstatic void TicdupSquash(ticcmd_set_t *set)\n{\n    ticcmd_t *cmd;\n    unsigned int i;\n\n    for (i = 0; i < NET_MAXPLAYERS ; ++i)\n    {\n        cmd = &set->cmds[i];\n        cmd->chatchar = 0;\n        if (cmd->buttons & BT_SPECIAL)\n            cmd->buttons = 0;\n    }\n}\n\n// When running in single player mode, clear all the ingame[] array\n// except the local player.\n\nstatic void SinglePlayerClear(ticcmd_set_t *set)\n{\n    unsigned int i;\n\n    for (i = 0; i < NET_MAXPLAYERS; ++i)\n    {\n        if (i != localplayer)\n        {\n            set->ingame[i] = false;\n        }\n    }\n}\n\n//\n// TryRunTics\n//\n\nvoid TryRunTics (void)\n{\n    int\ti;\n    int\tlowtic;\n    int\tentertic;\n    static int oldentertics;\n    int realtics;\n    int\tavailabletics;\n    int\tcounts;\n\n    // get real tics\n    entertic = I_GetTime() / ticdup;\n    realtics = entertic - oldentertics;\n    oldentertics = entertic;\n\n    // in singletics mode, run a single tic every time this function\n    // is called.\n\n    if (singletics)\n    {\n        BuildNewTic();\n    }\n    else\n    {\n        NetUpdate ();\n    }\n\n    lowtic = GetLowTic();\n\n    availabletics = lowtic - gametic/ticdup;\n\n    // decide how many tics to run\n\n    if (new_sync)\n    {\n\tcounts = availabletics;\n    }\n    else\n    {\n        // decide how many tics to run\n        if (realtics < availabletics-1)\n            counts = realtics+1;\n        else if (realtics < availabletics)\n            counts = realtics;\n        else\n            counts = availabletics;\n\n        if (counts < 1)\n            counts = 1;\n    }\n\n    if (counts < 1)\n\tcounts = 1;\n\n    // wait for new tics if needed\n    while (!PlayersInGame() || lowtic < gametic/ticdup + counts)\n    {\n\t    NetUpdate ();\n        lowtic = GetLowTic();\n    }\n\n    // run the count * ticdup dics\n    while (counts--)\n    {\n        ticcmd_set_t *set;\n\n        if (!PlayersInGame())\n        {\n            return;\n        }\n\n        set = &ticdata[(gametic / ticdup) % BACKUPTICS];\n        SinglePlayerClear(set);\n\n\tfor (i=0 ; i<ticdup ; i++)\n\t{\n            memcpy(local_playeringame, set->ingame, sizeof(local_playeringame));\n\n            loop_interface->RunTic(set->cmds, set->ingame);\n\t    gametic++;\n\n\t    // modify command for duplicated tics\n\n            TicdupSquash(set);\n\t}\n\n\tNetUpdate ();\t// check for new console commands\n    }\n}\n\nvoid D_RegisterLoopCallbacks(loop_interface_t *i)\n{\n    loop_interface = i;\n}\n\n// TODO: Move nonvanilla demo functions into a dedicated file.\n#include \"m_misc.h\"\n#include \"w_wad.h\"\n\nstatic boolean StrictDemos(void)\n{\n    //!\n    // @category demo\n    //\n    // When recording or playing back demos, disable any extensions\n    // of the vanilla demo format - record demos as vanilla would do,\n    // and play back demos as vanilla would do.\n    //\n    return M_ParmExists(\"-strictdemos\");\n}\n\n// If the provided conditional value is true, we're trying to record\n// a demo file that will include a non-vanilla extension. The function\n// will return true if the conditional is true and it's allowed to use\n// this extension (no extensions are allowed if -strictdemos is given\n// on the command line). A warning is shown on the console using the\n// provided string describing the non-vanilla expansion.\nboolean D_NonVanillaRecord(boolean conditional, char *feature)\n{\n    if (!conditional || StrictDemos())\n    {\n        return false;\n    }\n\n    printf(\"Warning: Recording a demo file with a non-vanilla extension \"\n           \"(%s). Use -strictdemos to disable this extension.\\n\",\n           feature);\n\n    return true;\n}\n\n// Returns true if the given lump number corresponds to data from a .lmp\n// file, as opposed to a WAD.\nstatic boolean IsDemoFile(int lumpnum)\n{\n    char *lower;\n    boolean result;\n\n    lower = M_StringDuplicate(lumpinfo[lumpnum]->wad_file->path);\n    M_ForceLowercase(lower);\n    result = M_StringEndsWith(lower, \".lmp\");\n    free(lower);\n\n    return result;\n}\n\n// If the provided conditional value is true, we're trying to play back\n// a demo that includes a non-vanilla extension. We return true if the\n// conditional is true and it's allowed to use this extension, checking\n// that:\n//  - The -strictdemos command line argument is not provided.\n//  - The given lumpnum identifying the demo to play back identifies a\n//    demo that comes from a .lmp file, not a .wad file.\n//  - Before proceeding, a warning is shown to the user on the console.\nboolean D_NonVanillaPlayback(boolean conditional, int lumpnum,\n                             char *feature)\n{\n    if (!conditional || StrictDemos())\n    {\n        return false;\n    }\n\n    if (!IsDemoFile(lumpnum))\n    {\n        printf(\"Warning: WAD contains demo with a non-vanilla extension \"\n               \"(%s)\\n\", feature);\n        return false;\n    }\n\n    printf(\"Warning: Playing back a demo file with a non-vanilla extension \"\n           \"(%s). Use -strictdemos to disable this extension.\\n\",\n           feature);\n\n    return true;\n}\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// DESCRIPTION:\n//   Functions and definitions relating to the game type and operational\n//   mode.\n//\n\n#include \"doomtype.h\"\n#include \"d_mode.h\"\n\n// Valid game mode/mission combinations, with the number of\n// episodes/maps for each.\n\nstatic struct\n{\n    GameMission_t mission;\n    GameMode_t mode;\n    int episode;\n    int map;\n} valid_modes[] = {\n    { pack_chex, retail,     1, 5 },\n    { doom,      shareware,  1, 9 },\n    { doom,      registered, 3, 9 },\n    { doom,      retail,     4, 9 },\n    { doom2,     commercial, 1, 32 },\n    { pack_tnt,  commercial, 1, 32 },\n    { pack_plut, commercial, 1, 32 },\n    { pack_hacx, commercial, 1, 32 },\n    { pack_nerve, commercial, 1, 9 },\n    { pack_master, commercial, 1, 21 },\n    { heretic,   shareware,  1, 9 },\n    { heretic,   registered, 3, 9 },\n    { heretic,   retail,     5, 9 },\n    { hexen,     commercial, 1, 60 },\n    { strife,    commercial, 1, 34 },\n};\n\n// Check that a gamemode+gamemission received over the network is valid.\n\nboolean D_ValidGameMode(GameMission_t mission, GameMode_t mode)\n{\n    int i;\n\n    for (i=0; i<arrlen(valid_modes); ++i)\n    {\n        if (valid_modes[i].mode == mode && valid_modes[i].mission == mission)\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nboolean D_ValidEpisodeMap(GameMission_t mission, GameMode_t mode,\n                          int episode, int map)\n{\n    int i;\n\n    // Hacks for Heretic secret episodes\n\n    if (mission == heretic)\n    {\n        if (mode == retail && episode == 6)\n        {\n            return map >= 1 && map <= 3;\n        }\n        else if (mode == registered && episode == 4)\n        {\n            return map == 1;\n        }\n    }\n\n    // Find the table entry for this mission/mode combination.\n\n    for (i=0; i<arrlen(valid_modes); ++i) \n    {\n        if (mission == valid_modes[i].mission\n         && mode == valid_modes[i].mode)\n        {\n            return episode >= 1 && episode <= valid_modes[i].episode\n                && map >= 1 && map <= valid_modes[i].map;\n        }\n    }\n\n    // Unknown mode/mission combination\n\n    return false;\n}\n\n// Get the number of valid episodes for the specified mission/mode.\n\nint D_GetNumEpisodes(GameMission_t mission, GameMode_t mode)\n{\n    int episode;\n\n    episode = 1;\n\n    while (D_ValidEpisodeMap(mission, mode, episode, 1))\n    {\n        ++episode;\n    }\n\n    return episode - 1;\n}\n\n// Table of valid versions\n\nstatic struct {\n    GameMission_t mission;\n    GameVersion_t version;\n} valid_versions[] = {\n    { doom,     exe_doom_1_666 },\n    { doom,     exe_doom_1_7 },\n    { doom,     exe_doom_1_8 },\n    { doom,     exe_doom_1_9 },\n    { doom,     exe_hacx },\n    { doom,     exe_ultimate },\n    { doom,     exe_final },\n    { doom,     exe_final2 },\n    { doom,     exe_chex },\n    { heretic,  exe_heretic_1_3 },\n    { hexen,    exe_hexen_1_1 },\n    { strife,   exe_strife_1_2 },\n    { strife,   exe_strife_1_31 },\n};\n\nboolean D_ValidGameVersion(GameMission_t mission, GameVersion_t version)\n{\n    int i;\n\n    // All Doom variants can use the Doom versions.\n\n    if (mission == doom2 || mission == pack_plut || mission == pack_tnt\n     || mission == pack_hacx || mission == pack_chex\n     || mission == pack_nerve || mission == pack_master)\n    {\n        mission = doom;\n    }\n\n    for (i=0; i<arrlen(valid_versions); ++i) \n    {\n        if (valid_versions[i].mission == mission \n         && valid_versions[i].version == version)\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Does this mission type use ExMy form, rather than MAPxy form?\n\nboolean D_IsEpisodeMap(GameMission_t mission)\n{\n    switch (mission)\n    {\n        case doom:\n        case heretic:\n        case pack_chex:\n            return true;\n\n        case none:\n        case hexen:\n        case doom2:\n        case pack_hacx:\n        case pack_tnt:\n        case pack_plut:\n        case pack_nerve:\n        case pack_master:\n        case strife:\n        default:\n            return false;\n    }\n}\n\nconst char *D_GameMissionString(GameMission_t mission)\n{\n    switch (mission)\n    {\n        case none:\n        default:\n            return \"none\";\n        case doom:\n            return \"doom\";\n        case doom2:\n            return \"doom2\";\n        case pack_tnt:\n            return \"tnt\";\n        case pack_plut:\n            return \"plutonia\";\n        case pack_hacx:\n            return \"hacx\";\n        case pack_chex:\n            return \"chex\";\n        case heretic:\n            return \"heretic\";\n        case hexen:\n            return \"hexen\";\n        case strife:\n            return \"strife\";\n    }\n}\n\nconst char *D_GameModeString(GameMode_t mode)\n{\n    switch (mode)\n    {\n        case shareware:\n            return \"shareware\";\n        case registered:\n            return \"registered\";\n        case commercial:\n            return \"commercial\";\n        case retail:\n            return \"retail\";\n        case indetermined:\n        default:\n            return \"unknown\";\n    }\n}\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Dehacked I/O code (does all reads from dehacked files)\n//\n\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"m_misc.h\"\n#include \"w_wad.h\"\n#include \"z_zone.h\"\n\n#include \"deh_defs.h\"\n#include \"deh_io.h\"\n\ntypedef enum\n{\n    DEH_INPUT_FILE,\n    DEH_INPUT_LUMP\n} deh_input_type_t;\n\nstruct deh_context_s\n{\n    deh_input_type_t type;\n    char *filename;\n\n    // If the input comes from a memory buffer, pointer to the memory\n    // buffer.\n    unsigned char *input_buffer;\n    size_t input_buffer_len;\n    unsigned int input_buffer_pos;\n    int lumpnum;\n\n    // If the input comes from a file, the file stream for reading\n    // data.\n    FILE *stream;\n\n    // Current line number that we have reached:\n    int linenum;\n\n    // Used by DEH_ReadLine:\n    boolean last_was_newline;\n    char *readbuffer;\n    int readbuffer_size;\n\n    // Error handling.\n    boolean had_error;\n};\n\nstatic deh_context_t *DEH_NewContext(void)\n{\n    deh_context_t *context;\n\n    context = Z_Malloc(sizeof(*context), PU_STATIC, NULL);\n\n    // Initial read buffer size of 128 bytes\n\n    context->readbuffer_size = 128;\n    context->readbuffer = Z_Malloc(context->readbuffer_size, PU_STATIC, NULL);\n    context->linenum = 0;\n    context->last_was_newline = true;\n\n    context->had_error = false;\n\n    return context;\n}\n\n// Open a dehacked file for reading\n// Returns NULL if open failed\n\ndeh_context_t *DEH_OpenFile(const char *filename)\n{\n    FILE *fstream;\n    deh_context_t *context;\n\n    fstream = fopen(filename, \"r\");\n\n    if (fstream == NULL)\n        return NULL;\n\n    context = DEH_NewContext();\n\n    context->type = DEH_INPUT_FILE;\n    context->stream = fstream;\n    context->filename = M_StringDuplicate(filename);\n\n    return context;\n}\n\n// Open a WAD lump for reading.\n\ndeh_context_t *DEH_OpenLump(int lumpnum)\n{\n    deh_context_t *context;\n    void *lump;\n\n    lump = W_CacheLumpNum(lumpnum, PU_STATIC);\n\n    context = DEH_NewContext();\n\n    context->type = DEH_INPUT_LUMP;\n    context->lumpnum = lumpnum;\n    context->input_buffer = lump;\n    context->input_buffer_len = W_LumpLength(lumpnum);\n    context->input_buffer_pos = 0;\n\n    context->filename = malloc(9);\n    M_StringCopy(context->filename, lumpinfo[lumpnum]->name, 9);\n\n    return context;\n}\n\n// Close dehacked file\n\nvoid DEH_CloseFile(deh_context_t *context)\n{\n    if (context->type == DEH_INPUT_FILE)\n    {\n        fclose(context->stream);\n    }\n    else if (context->type == DEH_INPUT_LUMP)\n    {\n        W_ReleaseLumpNum(context->lumpnum);\n    }\n\n    free(context->filename);\n    Z_Free(context->readbuffer);\n    Z_Free(context);\n}\n\nint DEH_GetCharFile(deh_context_t *context)\n{\n    if (feof(context->stream))\n    {\n        // end of file\n\n        return -1;\n    }\n\n    return fgetc(context->stream);\n}\n\nint DEH_GetCharLump(deh_context_t *context)\n{\n    int result;\n\n    if (context->input_buffer_pos >= context->input_buffer_len)\n    {\n        return -1;\n    }\n\n    result = context->input_buffer[context->input_buffer_pos];\n    ++context->input_buffer_pos;\n\n    return result;\n}\n\n// Reads a single character from a dehacked file\n\nint DEH_GetChar(deh_context_t *context)\n{\n    int result = 0;\n\n    // Read characters, but ignore carriage returns\n    // Essentially this is a DOS->Unix conversion\n\n    do\n    {\n        switch (context->type)\n        {\n            case DEH_INPUT_FILE:\n                result = DEH_GetCharFile(context);\n                break;\n\n            case DEH_INPUT_LUMP:\n                result = DEH_GetCharLump(context);\n                break;\n        }\n    } while (result == '\\r');\n\n    // Track the current line number\n\n    if (context->last_was_newline)\n    {\n        ++context->linenum;\n    }\n\n    context->last_was_newline = result == '\\n';\n\n    return result;\n}\n\n// Increase the read buffer size\n\nstatic void IncreaseReadBuffer(deh_context_t *context)\n{\n    char *newbuffer;\n    int newbuffer_size;\n\n    newbuffer_size = context->readbuffer_size * 2;\n    newbuffer = Z_Malloc(newbuffer_size, PU_STATIC, NULL);\n\n    memcpy(newbuffer, context->readbuffer, context->readbuffer_size);\n\n    Z_Free(context->readbuffer);\n\n    context->readbuffer = newbuffer;\n    context->readbuffer_size = newbuffer_size;\n}\n\n// Read a whole line\n\nchar *DEH_ReadLine(deh_context_t *context, boolean extended)\n{\n    int c;\n    int pos;\n    boolean escaped = false;\n\n    for (pos = 0;;)\n    {\n        c = DEH_GetChar(context);\n\n        if (c < 0 && pos == 0)\n        {\n            // end of file\n\n            return NULL;\n        }\n\n        // cope with lines of any length: increase the buffer size\n\n        if (pos >= context->readbuffer_size)\n        {\n            IncreaseReadBuffer(context);\n        }\n\n        // extended string support\n        if (extended && c == '\\\\')\n        {\n            c = DEH_GetChar(context);\n\n            // \"\\n\" in the middle of a string indicates an internal linefeed\n            if (c == 'n')\n            {\n                context->readbuffer[pos] = '\\n';\n                ++pos;\n                continue;\n            }\n\n            // values to be assigned may be split onto multiple lines by ending\n            // each line that is to be continued with a backslash\n            if (c == '\\n')\n            {\n                escaped = true;\n                continue;\n            }\n        }\n\n        // blanks before the backslash are included in the string\n        // but indentation after the linefeed is not\n        if (escaped && c >= 0 && isspace(c) && c != '\\n')\n        {\n            continue;\n        }\n        else\n        {\n            escaped = false;\n        }\n\n        if (c == '\\n' || c < 0)\n        {\n            // end of line: a full line has been read\n\n            context->readbuffer[pos] = '\\0';\n            break;\n        }\n        else if (c != '\\0')\n        {\n            // normal character; don't allow NUL characters to be\n            // added.\n\n            context->readbuffer[pos] = (char) c;\n            ++pos;\n        }\n    }\n    \n    return context->readbuffer;\n}\n\nvoid DEH_Warning(deh_context_t *context, const char *msg, ...)\n{\n    va_list args;\n\n    va_start(args, msg);\n\n    fprintf(stderr, \"%s:%i: warning: \", context->filename, context->linenum);\n    vfprintf(stderr, msg, args);\n    fprintf(stderr, \"\\n\");\n\n    va_end(args);\n}\n\nvoid DEH_Error(deh_context_t *context, const char *msg, ...)\n{\n    va_list args;\n\n    va_start(args, msg);\n\n    fprintf(stderr, \"%s:%i: \", context->filename, context->linenum);\n    vfprintf(stderr, msg, args);\n    fprintf(stderr, \"\\n\");\n\n    va_end(args);\n\n    context->had_error = true;\n}\n\nboolean DEH_HadError(deh_context_t *context)\n{\n    return context->had_error;\n}\n\n// [crispy] return the filename of the DEHACKED file\n// or NULL if it is a DEHACKED lump loaded from a PWAD\nchar *DEH_FileName(deh_context_t *context)\n{\n    if (context->type == DEH_INPUT_FILE)\n    {\n        return context->filename;\n    }\n\n    return NULL;\n}","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Main dehacked code\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#include \"doomtype.h\"\n#include \"i_system.h\"\n#include \"d_iwad.h\"\n#include \"m_argv.h\"\n#include \"w_wad.h\"\n\n#include \"deh_defs.h\"\n#include \"deh_io.h\"\n\nextern deh_section_t *deh_section_types[];\nextern char *deh_signatures[];\n\nstatic boolean deh_initialized = false;\n\n// If true, we can parse [STRINGS] sections in BEX format.\n\nboolean deh_allow_extended_strings = true;\n\n// If true, we can do long string replacements.\n\nboolean deh_allow_long_strings = true;\n\n// If true, we can do cheat replacements longer than the originals.\n\nboolean deh_allow_long_cheats = true;\n\n// If false, dehacked cheat replacements are ignored.\n\nboolean deh_apply_cheats = true;\n\nvoid DEH_Checksum(sha1_digest_t digest)\n{\n    sha1_context_t sha1_context;\n    unsigned int i;\n\n    SHA1_Init(&sha1_context);\n\n    for (i=0; deh_section_types[i] != NULL; ++i)\n    {\n        if (deh_section_types[i]->sha1_hash != NULL)\n        {\n            deh_section_types[i]->sha1_hash(&sha1_context);\n        }\n    }\n\n    SHA1_Final(digest, &sha1_context);\n}\n\n// Called on startup to call the Init functions\n\nstatic void InitializeSections(void)\n{\n    unsigned int i;\n\n    for (i=0; deh_section_types[i] != NULL; ++i)\n    {\n        if (deh_section_types[i]->init != NULL)\n        {\n            deh_section_types[i]->init();\n        }\n    }\n}\n\nstatic void DEH_Init(void)\n{\n    //!\n    // @category mod\n    //\n    // Ignore cheats in dehacked files.\n    //\n\n    if (M_CheckParm(\"-nocheats\") > 0) \n    {\n\tdeh_apply_cheats = false;\n    }\n\n    // Call init functions for all the section definitions.\n    InitializeSections();\n\n    deh_initialized = true;\n}\n\n// Given a section name, get the section structure which corresponds\n\nstatic deh_section_t *GetSectionByName(char *name)\n{\n    unsigned int i;\n\n    // we explicitely do not recognize [STRINGS] sections at all\n    // if extended strings are not allowed\n\n    if (!deh_allow_extended_strings && !strncasecmp(\"[STRINGS]\", name, 9))\n    {\n        return NULL;\n    }\n\n    for (i=0; deh_section_types[i] != NULL; ++i)\n    {\n        if (!strcasecmp(deh_section_types[i]->name, name))\n        {\n            return deh_section_types[i];\n        }\n    }\n\n    return NULL;\n}\n\n// Is the string passed just whitespace?\n\nstatic boolean IsWhitespace(char *s)\n{\n    for (; *s; ++s)\n    {\n        if (!isspace(*s))\n            return false;\n    }\n\n    return true;\n}\n\n// Strip whitespace from the start and end of a string\n\nstatic char *CleanString(char *s)\n{\n    char *strending;\n\n    // Leading whitespace\n\n    while (*s && isspace(*s))\n        ++s;\n\n    // Trailing whitespace\n   \n    strending = s + strlen(s) - 1;\n\n    while (strlen(s) > 0 && isspace(*strending))\n    {\n        *strending = '\\0';\n        --strending;\n    }\n\n    return s;\n}\n\n// This pattern is used a lot of times in different sections, \n// an assignment is essentially just a statement of the form:\n//\n// Variable Name = Value\n//\n// The variable name can include spaces or any other characters.\n// The string is split on the '=', essentially.\n//\n// Returns true if read correctly\n\nboolean DEH_ParseAssignment(char *line, char **variable_name, char **value)\n{\n    char *p;\n\n    // find the equals\n    \n    p = strchr(line, '=');\n\n    if (p == NULL)\n    {\n        return false;\n    }\n\n    // variable name at the start\n    // turn the '=' into a \\0 to terminate the string here\n\n    *p = '\\0';\n    *variable_name = CleanString(line);\n    \n    // value immediately follows the '='\n    \n    *value = CleanString(p+1);\n    \n    return true;\n}\n\nstatic boolean CheckSignatures(deh_context_t *context)\n{\n    size_t i;\n    char *line;\n    \n    // Read the first line\n\n    line = DEH_ReadLine(context, false);\n\n    if (line == NULL)\n    {\n        return false;\n    }\n\n    // Check all signatures to see if one matches\n\n    for (i=0; deh_signatures[i] != NULL; ++i)\n    {\n        if (!strcmp(deh_signatures[i], line))\n        {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// Parses a comment string in a dehacked file.\n\nstatic void DEH_ParseComment(char *comment)\n{\n    //\n    // Welcome, to the super-secret Chocolate Doom-specific Dehacked\n    // overrides function.\n    //\n    // Putting these magic comments into your Dehacked lumps will\n    // allow you to go beyond the normal limits of Vanilla Dehacked.\n    // Because of this, these comments are deliberately undocumented,\n    // and if you're using them you should be aware that your mod\n    // is not compatible with Vanilla Doom and you're probably a\n    // very naughty person.\n    //\n\n    // Allow comments containing this special value to allow string\n    // replacements longer than those permitted by DOS dehacked.\n    // This allows us to use a dehacked patch for doing string \n    // replacements for emulating Chex Quest.\n    //\n    // If you use this, your dehacked patch may not work in Vanilla\n    // Doom.\n\n    if (strstr(comment, \"*allow-long-strings*\") != NULL)\n    {\n        deh_allow_long_strings = true;\n    }\n\n    // Allow magic comments to allow longer cheat replacements than\n    // those permitted by DOS dehacked.  This is also for Chex\n    // Quest.\n\n    if (strstr(comment, \"*allow-long-cheats*\") != NULL)\n    {\n        deh_allow_long_cheats = true;\n    }\n\n    // Allow magic comments to allow parsing [STRINGS] section\n    // that are usually only found in BEX format files. This allows\n    // for substitution of map and episode names when loading\n    // Freedoom/FreeDM IWADs.\n\n    if (strstr(comment, \"*allow-extended-strings*\") != NULL)\n    {\n        deh_allow_extended_strings = true;\n    }\n}\n\n// Parses a dehacked file by reading from the context\n\nstatic void DEH_ParseContext(deh_context_t *context)\n{\n    deh_section_t *current_section = NULL;\n    char section_name[20];\n    void *tag = NULL;\n    boolean extended;\n    char *line;\n\n    // Read the header and check it matches the signature\n\n    if (!CheckSignatures(context))\n    {\n        DEH_Error(context, \"This is not a valid dehacked patch file!\");\n    }\n\n    // Read the file\n\n    while (!DEH_HadError(context))\n    {\n        // Read the next line. We only allow the special extended parsing\n        // for the BEX [STRINGS] section.\n        extended = current_section != NULL\n                && !strcasecmp(current_section->name, \"[STRINGS]\");\n        line = DEH_ReadLine(context, extended);\n\n        // end of file?\n\n        if (line == NULL)\n        {\n            return;\n        }\n\n        while (line[0] != '\\0' && isspace(line[0]))\n            ++line;\n\n        if (line[0] == '#')\n        {\n            // comment\n\n            DEH_ParseComment(line);\n            continue;\n        }\n\n        if (IsWhitespace(line))\n        {\n            if (current_section != NULL)\n            {\n                // end of section\n\n                if (current_section->end != NULL)\n                {\n                    current_section->end(context, tag);\n                }\n\n                current_section = NULL;\n            }\n        }\n        else\n        {\n            if (current_section != NULL)\n            {\n                // parse this line\n\n                current_section->line_parser(context, line, tag);\n            }\n            else\n            {\n                // possibly the start of a new section\n\n                sscanf(line, \"%19s\", section_name);\n\n                current_section = GetSectionByName(section_name);\n\n                if (current_section != NULL)\n                {\n\n                    tag = current_section->start(context, line);\n                }\n            }\n        }\n    }\n}\n\n// Parses a dehacked file\n\nint DEH_LoadFile(const char *filename)\n{\n    deh_context_t *context;\n\n    if (!deh_initialized)\n    {\n        DEH_Init();\n    }\n\n    context = DEH_OpenFile(filename);\n\n    if (context == NULL)\n    {\n        fprintf(stderr, \"DEH_LoadFile: Unable to open %s\\n\", filename);\n        return 0;\n    }\n\n    DEH_ParseContext(context);\n\n    DEH_CloseFile(context);\n\n    if (DEH_HadError(context))\n    {\n        I_Error(\"Error parsing dehacked file\");\n    }\n\n    return 1;\n}\n\n// Load dehacked file from WAD lump.\n// If allow_long is set, allow long strings and cheats just for this lump.\n\nint DEH_LoadLump(int lumpnum, boolean allow_long, boolean allow_error)\n{\n    deh_context_t *context;\n\n    if (!deh_initialized)\n    {\n        DEH_Init();\n    }\n\n    // Reset all special flags to defaults.\n    // deh_allow_long_strings = allow_long;\n    // deh_allow_long_cheats = allow_long;\n    // deh_allow_extended_strings = false;\n\n    context = DEH_OpenLump(lumpnum);\n\n    if (context == NULL)\n    {\n        fprintf(stderr, \"DEH_LoadFile: Unable to open lump %i\\n\", lumpnum);\n        return 0;\n    }\n\n    DEH_ParseContext(context);\n\n    DEH_CloseFile(context);\n\n    // If there was an error while parsing, abort with an error, but allow\n    // errors to just be ignored if allow_error=true.\n    if (!allow_error && DEH_HadError(context))\n    {\n        I_Error(\"Error parsing dehacked lump\");\n    }\n\n    return 1;\n}\n\nint DEH_LoadLumpByName(const char *name, boolean allow_long, boolean allow_error)\n{\n    int lumpnum;\n\n    lumpnum = W_CheckNumForName(name);\n\n    if (lumpnum == -1)\n    {\n        fprintf(stderr, \"DEH_LoadLumpByName: '%s' lump not found\\n\", name);\n        return 0;\n    }\n\n    return DEH_LoadLump(lumpnum, allow_long, allow_error);\n}\n\n// Check the command line for -deh argument, and others.\nvoid DEH_ParseCommandLine(void)\n{\n    char *filename;\n    int p;\n\n    //!\n    // @arg <files>\n    // @category mod\n    //\n    // Load the given dehacked patch(es)\n    //\n\n    p = M_CheckParm(\"-deh\");\n\n    if (p > 0)\n    {\n        ++p;\n\n        while (p < myargc && myargv[p][0] != '-')\n        {\n            filename = D_TryFindWADByName(myargv[p]);\n            DEH_LoadFile(filename);\n            ++p;\n        }\n    }\n}\n\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n/**\n *  \\file SDL_endian.h\n *\n *  Functions for reading and writing endian-specific values\n */\n\n#ifndef SDL_endian_h_\n#define SDL_endian_h_\n\n#include \"SDL_stdinc.h\"\n\n/**\n *  \\name The two types of endianness\n */\n/* @{ */\n#define SDL_LIL_ENDIAN  1234\n#define SDL_BIG_ENDIAN  4321\n/* @} */\n\n#ifndef SDL_BYTEORDER           /* Not defined in SDL_config.h? */\n#ifdef __linux__\n#include <endian.h>\n#define SDL_BYTEORDER  __BYTE_ORDER\n#else /* __linux__ */\n#if defined(__hppa__) || \\\n    defined(__m68k__) || defined(mc68000) || defined(_M_M68K) || \\\n    (defined(__MIPS__) && defined(__MISPEB__)) || \\\n    defined(__ppc__) || defined(__POWERPC__) || defined(_M_PPC) || \\\n    defined(__sparc__)\n#define SDL_BYTEORDER   SDL_BIG_ENDIAN\n#else\n#define SDL_BYTEORDER   SDL_LIL_ENDIAN\n#endif\n#endif /* __linux__ */\n#endif /* !SDL_BYTEORDER */\n\n\n#include \"begin_code.h\"\n/* Set up for C function definitions, even when using C++ */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n *  \\file SDL_endian.h\n */\n#if defined(__GNUC__) && defined(__i386__) && \\\n   !(__GNUC__ == 2 && __GNUC_MINOR__ == 95 /* broken gcc version */)\nSDL_FORCE_INLINE Uint16\nSDL_Swap16(Uint16 x)\n{\n  __asm__(\"xchgb %b0,%h0\": \"=q\"(x):\"0\"(x));\n    return x;\n}\n#elif defined(__GNUC__) && defined(__x86_64__)\nSDL_FORCE_INLINE Uint16\nSDL_Swap16(Uint16 x)\n{\n  __asm__(\"xchgb %b0,%h0\": \"=Q\"(x):\"0\"(x));\n    return x;\n}\n#elif defined(__GNUC__) && (defined(__powerpc__) || defined(__ppc__))\nSDL_FORCE_INLINE Uint16\nSDL_Swap16(Uint16 x)\n{\n    int result;\n\n  __asm__(\"rlwimi %0,%2,8,16,23\": \"=&r\"(result):\"0\"(x >> 8), \"r\"(x));\n    return (Uint16)result;\n}\n#elif defined(__GNUC__) && (defined(__M68000__) || defined(__M68020__)) && !defined(__mcoldfire__)\nSDL_FORCE_INLINE Uint16\nSDL_Swap16(Uint16 x)\n{\n  __asm__(\"rorw #8,%0\": \"=d\"(x): \"0\"(x):\"cc\");\n    return x;\n}\n#elif defined(__WATCOMC__) && defined(__386__)\nextern _inline Uint16 SDL_Swap16(Uint16);\n#pragma aux SDL_Swap16 = \\\n  \"xchg al, ah\" \\\n  parm   [ax]   \\\n  modify [ax];\n#else\nSDL_FORCE_INLINE Uint16\nSDL_Swap16(Uint16 x)\n{\n    return SDL_static_cast(Uint16, ((x << 8) | (x >> 8)));\n}\n#endif\n\n#if defined(__GNUC__) && defined(__i386__)\nSDL_FORCE_INLINE Uint32\nSDL_Swap32(Uint32 x)\n{\n  __asm__(\"bswap %0\": \"=r\"(x):\"0\"(x));\n    return x;\n}\n#elif defined(__GNUC__) && defined(__x86_64__)\nSDL_FORCE_INLINE Uint32\nSDL_Swap32(Uint32 x)\n{\n  __asm__(\"bswapl %0\": \"=r\"(x):\"0\"(x));\n    return x;\n}\n#elif defined(__GNUC__) && (defined(__powerpc__) || defined(__ppc__))\nSDL_FORCE_INLINE Uint32\nSDL_Swap32(Uint32 x)\n{\n    Uint32 result;\n\n  __asm__(\"rlwimi %0,%2,24,16,23\": \"=&r\"(result):\"0\"(x >> 24), \"r\"(x));\n  __asm__(\"rlwimi %0,%2,8,8,15\": \"=&r\"(result):\"0\"(result), \"r\"(x));\n  __asm__(\"rlwimi %0,%2,24,0,7\": \"=&r\"(result):\"0\"(result), \"r\"(x));\n    return result;\n}\n#elif defined(__GNUC__) && (defined(__M68000__) || defined(__M68020__)) && !defined(__mcoldfire__)\nSDL_FORCE_INLINE Uint32\nSDL_Swap32(Uint32 x)\n{\n  __asm__(\"rorw #8,%0\\n\\tswap %0\\n\\trorw #8,%0\": \"=d\"(x): \"0\"(x):\"cc\");\n    return x;\n}\n#elif defined(__WATCOMC__) && defined(__386__)\nextern _inline Uint32 SDL_Swap32(Uint32);\n#ifndef __SW_3 /* 486+ */\n#pragma aux SDL_Swap32 = \\\n  \"bswap eax\"  \\\n  parm   [eax] \\\n  modify [eax];\n#else  /* 386-only */\n#pragma aux SDL_Swap32 = \\\n  \"xchg al, ah\"  \\\n  \"ror  eax, 16\" \\\n  \"xchg al, ah\"  \\\n  parm   [eax]   \\\n  modify [eax];\n#endif\n#else\nSDL_FORCE_INLINE Uint32\nSDL_Swap32(Uint32 x)\n{\n    return SDL_static_cast(Uint32, ((x << 24) | ((x << 8) & 0x00FF0000) |\n                                    ((x >> 8) & 0x0000FF00) | (x >> 24)));\n}\n#endif\n\n#if defined(__GNUC__) && defined(__i386__)\nSDL_FORCE_INLINE Uint64\nSDL_Swap64(Uint64 x)\n{\n    union\n    {\n        struct\n        {\n            Uint32 a, b;\n        } s;\n        Uint64 u;\n    } v;\n    v.u = x;\n  __asm__(\"bswapl %0 ; bswapl %1 ; xchgl %0,%1\": \"=r\"(v.s.a), \"=r\"(v.s.b):\"0\"(v.s.a),\n            \"1\"(v.s.\n                b));\n    return v.u;\n}\n#elif defined(__GNUC__) && defined(__x86_64__)\nSDL_FORCE_INLINE Uint64\nSDL_Swap64(Uint64 x)\n{\n  __asm__(\"bswapq %0\": \"=r\"(x):\"0\"(x));\n    return x;\n}\n#else\nSDL_FORCE_INLINE Uint64\nSDL_Swap64(Uint64 x)\n{\n    Uint32 hi, lo;\n\n    /* Separate into high and low 32-bit values and swap them */\n    lo = SDL_static_cast(Uint32, x & 0xFFFFFFFF);\n    x >>= 32;\n    hi = SDL_static_cast(Uint32, x & 0xFFFFFFFF);\n    x = SDL_Swap32(lo);\n    x <<= 32;\n    x |= SDL_Swap32(hi);\n    return (x);\n}\n#endif\n\n\nSDL_FORCE_INLINE float\nSDL_SwapFloat(float x)\n{\n    union\n    {\n        float f;\n        Uint32 ui32;\n    } swapper;\n    swapper.f = x;\n    swapper.ui32 = SDL_Swap32(swapper.ui32);\n    return swapper.f;\n}\n\n\n/**\n *  \\name Swap to native\n *  Byteswap item from the specified endianness to the native endianness.\n */\n/* @{ */\n#if SDL_BYTEORDER == SDL_LIL_ENDIAN\n#define SDL_SwapLE16(X) (X)\n#define SDL_SwapLE32(X) (X)\n#define SDL_SwapLE64(X) (X)\n#define SDL_SwapFloatLE(X)  (X)\n#define SDL_SwapBE16(X) SDL_Swap16(X)\n#define SDL_SwapBE32(X) SDL_Swap32(X)\n#define SDL_SwapBE64(X) SDL_Swap64(X)\n#define SDL_SwapFloatBE(X)  SDL_SwapFloat(X)\n#else\n#define SDL_SwapLE16(X) SDL_Swap16(X)\n#define SDL_SwapLE32(X) SDL_Swap32(X)\n#define SDL_SwapLE64(X) SDL_Swap64(X)\n#define SDL_SwapFloatLE(X)  SDL_SwapFloat(X)\n#define SDL_SwapBE16(X) (X)\n#define SDL_SwapBE32(X) (X)\n#define SDL_SwapBE64(X) (X)\n#define SDL_SwapFloatBE(X)  (X)\n#endif\n/* @} *//* Swap to native */\n\n/* Ends C function definitions when using C++ */\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif /* SDL_endian_h_ */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tLineOfSight/Visibility checks, uses REJECT Lookup Table.\n//\n\n\n\n#include \"doomdef.h\"\n\n#include \"i_system.h\"\n#include \"p_local.h\"\n\n// State.\n#include \"r_state.h\"\n\n//\n// P_CheckSight\n//\nfixed_t\t\tsightzstart;\t\t// eye z of looker\nfixed_t\t\ttopslope;\nfixed_t\t\tbottomslope;\t\t// slopes to top and bottom of target\n\ndivline_t\tstrace;\t\t\t// from t1 to t2\nfixed_t\t\tt2x;\nfixed_t\t\tt2y;\n\nint\t\tsightcounts[2];\n\n\n//\n// P_DivlineSide\n// Returns side 0 (front), 1 (back), or 2 (on).\n//\nint\nP_DivlineSide\n( fixed_t\tx,\n  fixed_t\ty,\n  divline_t*\tnode )\n{\n    fixed_t\tdx;\n    fixed_t\tdy;\n    fixed_t\tleft;\n    fixed_t\tright;\n\n    if (!node->dx)\n    {\n\tif (x==node->x)\n\t    return 2;\n\t\n\tif (x <= node->x)\n\t    return node->dy > 0;\n\n\treturn node->dy < 0;\n    }\n    \n    if (!node->dy)\n    {\n\tif (x==node->y)\n\t    return 2;\n\n\tif (y <= node->y)\n\t    return node->dx < 0;\n\n\treturn node->dx > 0;\n    }\n\t\n    dx = (x - node->x);\n    dy = (y - node->y);\n\n    left =  (node->dy>>FRACBITS) * (dx>>FRACBITS);\n    right = (dy>>FRACBITS) * (node->dx>>FRACBITS);\n\t\n    if (right < left)\n\treturn 0;\t// front side\n    \n    if (left == right)\n\treturn 2;\n    return 1;\t\t// back side\n}\n\n\n//\n// P_InterceptVector2\n// Returns the fractional intercept point\n// along the first divline.\n// This is only called by the addthings and addlines traversers.\n//\nfixed_t\nP_InterceptVector2\n( divline_t*\tv2,\n  divline_t*\tv1 )\n{\n    fixed_t\tfrac;\n    fixed_t\tnum;\n    fixed_t\tden;\n\t\n    den = FixedMul (v1->dy>>8,v2->dx) - FixedMul(v1->dx>>8,v2->dy);\n\n    if (den == 0)\n\treturn 0;\n    //\tI_Error (\"P_InterceptVector: parallel\");\n    \n    num = FixedMul ( (v1->x - v2->x)>>8 ,v1->dy) + \n\tFixedMul ( (v2->y - v1->y)>>8 , v1->dx);\n    frac = FixedDiv (num , den);\n\n    return frac;\n}\n\n//\n// P_CrossSubsector\n// Returns true\n//  if strace crosses the given subsector successfully.\n//\nboolean P_CrossSubsector (int num)\n{\n    seg_t*\t\tseg;\n    line_t*\t\tline;\n    int\t\t\ts1;\n    int\t\t\ts2;\n    int\t\t\tcount;\n    subsector_t*\tsub;\n    sector_t*\t\tfront;\n    sector_t*\t\tback;\n    fixed_t\t\topentop;\n    fixed_t\t\topenbottom;\n    divline_t\t\tdivl;\n    vertex_t*\t\tv1;\n    vertex_t*\t\tv2;\n    fixed_t\t\tfrac;\n    fixed_t\t\tslope;\n\t\n#ifdef RANGECHECK\n    if (num>=numsubsectors)\n\tI_Error (\"P_CrossSubsector: ss %i with numss = %i\",\n\t\t num,\n\t\t numsubsectors);\n#endif\n\n    sub = &subsectors[num];\n    \n    // check lines\n    count = sub->numlines;\n    seg = &segs[sub->firstline];\n\n    for ( ; count ; seg++, count--)\n    {\n\tline = seg->linedef;\n\n\t// allready checked other side?\n\tif (line->validcount == validcount)\n\t    continue;\n\t\n\tline->validcount = validcount;\n\n\tv1 = line->v1;\n\tv2 = line->v2;\n\ts1 = P_DivlineSide (v1->x,v1->y, &strace);\n\ts2 = P_DivlineSide (v2->x, v2->y, &strace);\n\n\t// line isn't crossed?\n\tif (s1 == s2)\n\t    continue;\n\t\n\tdivl.x = v1->x;\n\tdivl.y = v1->y;\n\tdivl.dx = v2->x - v1->x;\n\tdivl.dy = v2->y - v1->y;\n\ts1 = P_DivlineSide (strace.x, strace.y, &divl);\n\ts2 = P_DivlineSide (t2x, t2y, &divl);\n\n\t// line isn't crossed?\n\tif (s1 == s2)\n\t    continue;\t\n\n        // Backsector may be NULL if this is an \"impassible\n        // glass\" hack line.\n\n        if (line->backsector == NULL)\n        {\n            return false;\n        }\n\n\t// stop because it is not two sided anyway\n\t// might do this after updating validcount?\n\tif ( !(line->flags & ML_TWOSIDED) )\n\t    return false;\n\t\n\t// crosses a two sided line\n\tfront = seg->frontsector;\n\tback = seg->backsector;\n\n\t// no wall to block sight with?\n\tif (front->floorheight == back->floorheight\n\t    && front->ceilingheight == back->ceilingheight)\n\t    continue;\t\n\n\t// possible occluder\n\t// because of ceiling height differences\n\tif (front->ceilingheight < back->ceilingheight)\n\t    opentop = front->ceilingheight;\n\telse\n\t    opentop = back->ceilingheight;\n\n\t// because of ceiling height differences\n\tif (front->floorheight > back->floorheight)\n\t    openbottom = front->floorheight;\n\telse\n\t    openbottom = back->floorheight;\n\t\t\n\t// quick test for totally closed doors\n\tif (openbottom >= opentop)\t\n\t    return false;\t\t// stop\n\t\n\tfrac = P_InterceptVector2 (&strace, &divl);\n\t\t\n\tif (front->floorheight != back->floorheight)\n\t{\n\t    slope = FixedDiv (openbottom - sightzstart , frac);\n\t    if (slope > bottomslope)\n\t\tbottomslope = slope;\n\t}\n\t\t\n\tif (front->ceilingheight != back->ceilingheight)\n\t{\n\t    slope = FixedDiv (opentop - sightzstart , frac);\n\t    if (slope < topslope)\n\t\ttopslope = slope;\n\t}\n\t\t\n\tif (topslope <= bottomslope)\n\t    return false;\t\t// stop\t\t\t\t\n    }\n    // passed the subsector ok\n    return true;\t\t\n}\n\n\n\n//\n// P_CrossBSPNode\n// Returns true\n//  if strace crosses the given node successfully.\n//\nboolean P_CrossBSPNode (int bspnum)\n{\n    node_t*\tbsp;\n    int\t\tside;\n\n    if (bspnum & NF_SUBSECTOR)\n    {\n\tif (bspnum == -1)\n\t    return P_CrossSubsector (0);\n\telse\n\t    return P_CrossSubsector (bspnum&(~NF_SUBSECTOR));\n    }\n\t\t\n    bsp = &nodes[bspnum];\n    \n    // decide which side the start point is on\n    side = P_DivlineSide (strace.x, strace.y, (divline_t *)bsp);\n    if (side == 2)\n\tside = 0;\t// an \"on\" should cross both sides\n\n    // cross the starting side\n    if (!P_CrossBSPNode (bsp->children[side]) )\n\treturn false;\n\t\n    // the partition plane is crossed here\n    if (side == P_DivlineSide (t2x, t2y,(divline_t *)bsp))\n    {\n\t// the line doesn't touch the other side\n\treturn true;\n    }\n    \n    // cross the ending side\t\t\n    return P_CrossBSPNode (bsp->children[side^1]);\n}\n\n\n//\n// P_CheckSight\n// Returns true\n//  if a straight line between t1 and t2 is unobstructed.\n// Uses REJECT.\n//\nboolean\nP_CheckSight\n( mobj_t*\tt1,\n  mobj_t*\tt2 )\n{\n    sector_t\t\t*s1;\n    sector_t\t\t*s2;\n    int\t\tpnum;\n    int\t\tbytenum;\n    int\t\tbitnum;\n    \n    // First check for trivial rejection.\n\n    // Determine subsector entries in REJECT table.\n    s1 = t1->subsector->sector;\n    s2 = t2->subsector->sector;\n    pnum = s1->id*numsectors + s2->id;\n    bytenum = pnum>>3;\n    bitnum = 1 << (pnum&7);\n\n    // Check in REJECT table.\n    if (rejectmatrix[bytenum]&bitnum)\n    {\n\tsightcounts[0]++;\n\n\t// can't possibly be connected\n\treturn false;\t\n    }\n\n    // killough 4/19/98: make fake floors and ceilings block monster view\n\n  if ((s1->heightsec != -1 &&\n       ((t1->z + t1->height <= sectors[s1->heightsec].floorheight &&\n         t2->z >= sectors[s1->heightsec].floorheight) ||\n        (t1->z >= sectors[s1->heightsec].ceilingheight &&\n         t2->z + t1->height <= sectors[s1->heightsec].ceilingheight)))\n      ||\n      (s2->heightsec != -1 &&\n       ((t2->z + t2->height <= sectors[s2->heightsec].floorheight &&\n         t1->z >= sectors[s2->heightsec].floorheight) ||\n        (t2->z >= sectors[s2->heightsec].ceilingheight &&\n         t1->z + t2->height <= sectors[s2->heightsec].ceilingheight))))\n    return false;\n\n    // An unobstructed LOS is possible.\n    // Now look from eyes of t1 to any part of t2.\n    sightcounts[1]++;\n\n    validcount++;\n\t\n    sightzstart = t1->z + t1->height - (t1->height>>2);\n    topslope = (t2->z+t2->height) - sightzstart;\n    bottomslope = (t2->z) - sightzstart;\n\t\n    strace.x = t1->x;\n    strace.y = t1->y;\n    t2x = t2->x;\n    t2y = t2->y;\n    strace.dx = t2->x - t1->x;\n    strace.dy = t2->y - t1->y;\n\n    // the head node is the last node output\n    return P_CrossBSPNode (numnodes-1);\t\n}\n\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n// Copyright(C) 2013-2017 Brad Harding\n// Copyright(C) 2017 Fabian Greffrath\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tBrightmaps for wall textures\n//\tAdapted from doomretro/src/r_data.c:97-209\n//\n\n#include \"doomtype.h\"\n#include \"doomstat.h\"\n#include \"r_data.h\"\n#include \"w_wad.h\"\n\n// [crispy] brightmap data\n\nstatic byte nobrightmap[256] = {0};\n\nstatic byte notgray[256] =\n{\n\t0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n};\n\nstatic byte notgrayorbrown[256] =\n{\n\t0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n};\n\nstatic byte redonly[256] =\n{\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nstatic byte greenonly1[256] =\n{\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nstatic byte greenonly2[256] =\n{\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nstatic byte greenonly3[256] =\n{\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nstatic byte yellowonly[256] =\n{\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,\n};\n\nstatic byte redandgreen[256] =\n{\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nstatic byte blueandgreen[256] =\n{\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nstatic byte brighttan[256] =\n{\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0,\n\t1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1,\n\t0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\n// [crispy] Chex Quest's \"locked\" door switches\n\nstatic byte chexred[256] =\n{\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\n// [crispy] Chex Quest's \"open\" door switches\n\nstatic byte chexgreen[256] =\n{\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\n// [crispy] Chex Quest's \"lock\"/\"open\" knobs\n\nstatic byte chexredgreen[256] =\n{\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,\n\t1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n};\n\nbyte *dc_brightmap = nobrightmap;\n\n// [crispy] brightmaps for textures\n\nenum\n{\n\tDOOM1AND2,\n\tDOOM1ONLY,\n\tDOOM2ONLY,\n};\n\ntypedef struct\n{\n\tconst char *const texture;\n\tconst int game;\n\tbyte *colormask;\n} fullbright_t;\n\nstatic const fullbright_t fullbright_doom[] = {\n\t// [crispy] common textures\n\t{\"COMP2\",    DOOM1AND2, blueandgreen},\n\t{\"COMPSTA1\", DOOM1AND2, notgray},\n\t{\"COMPSTA2\", DOOM1AND2, notgray},\n\t{\"COMPUTE1\", DOOM1AND2, notgrayorbrown},\n\t{\"COMPUTE2\", DOOM1AND2, notgrayorbrown},\n\t{\"COMPUTE3\", DOOM1AND2, notgrayorbrown},\n\t{\"EXITSIGN\", DOOM1AND2, notgray},\n\t{\"EXITSTON\", DOOM1AND2, redonly},\n\t{\"PLANET1\",  DOOM1AND2, notgray},\n\t{\"SILVER2\",  DOOM1AND2, notgray},\n\t{\"SILVER3\",  DOOM1AND2, notgrayorbrown},\n\t{\"SLADSKUL\", DOOM1AND2, redonly},\n\t{\"SW1BRCOM\", DOOM1AND2, redonly},\n\t{\"SW1BRIK\",  DOOM1AND2, redonly},\n\t{\"SW1BRN1\",  DOOM2ONLY, redonly},\n\t{\"SW1COMM\",  DOOM1AND2, redonly},\n\t{\"SW1DIRT\",  DOOM1AND2, redonly},\n\t{\"SW1MET2\",  DOOM1AND2, redonly},\n\t{\"SW1STARG\", DOOM2ONLY, redonly},\n\t{\"SW1STON1\", DOOM1AND2, redonly},\n\t{\"SW1STON2\", DOOM2ONLY, redonly},\n\t{\"SW1STONE\", DOOM1AND2, redonly},\n\t{\"SW1STRTN\", DOOM1AND2, redonly},\n\t{\"SW2BLUE\",  DOOM1AND2, redonly},\n\t{\"SW2BRCOM\", DOOM1AND2, greenonly2},\n\t{\"SW2BRIK\",  DOOM1AND2, greenonly1},\n\t{\"SW2BRN1\",  DOOM1AND2, greenonly2},\n\t{\"SW2BRN2\",  DOOM1AND2, greenonly1},\n\t{\"SW2BRNGN\", DOOM1AND2, greenonly3},\n\t{\"SW2COMM\",  DOOM1AND2, greenonly1},\n\t{\"SW2COMP\",  DOOM1AND2, redonly},\n\t{\"SW2DIRT\",  DOOM1AND2, greenonly2},\n\t{\"SW2EXIT\",  DOOM1AND2, notgray},\n\t{\"SW2GRAY\",  DOOM1AND2, notgray},\n\t{\"SW2GRAY1\", DOOM1AND2, notgray},\n\t{\"SW2GSTON\", DOOM1AND2, redonly},\n\t{\"SW2MARB\",  DOOM2ONLY, redonly},\n\t{\"SW2MET2\",  DOOM1AND2, greenonly1},\n\t{\"SW2METAL\", DOOM1AND2, greenonly3},\n\t{\"SW2MOD1\",  DOOM1AND2, greenonly1},\n\t{\"SW2PANEL\", DOOM1AND2, redonly},\n\t{\"SW2ROCK\",  DOOM1AND2, redonly},\n\t{\"SW2SLAD\",  DOOM1AND2, redonly},\n\t{\"SW2STARG\", DOOM2ONLY, greenonly2},\n\t{\"SW2STON1\", DOOM1AND2, greenonly3},\n\t// [crispy] beware!\n\t{\"SW2STON2\", DOOM1ONLY, redonly},\n\t{\"SW2STON2\", DOOM2ONLY, greenonly2},\n\t{\"SW2STON6\", DOOM1AND2, redonly},\n\t{\"SW2STONE\", DOOM1AND2, greenonly2},\n\t{\"SW2STRTN\", DOOM1AND2, greenonly1},\n\t{\"SW2TEK\",   DOOM1AND2, greenonly1},\n\t{\"SW2VINE\",  DOOM1AND2, greenonly1},\n\t{\"SW2WOOD\",  DOOM1AND2, redonly},\n\t{\"SW2ZIM\",   DOOM1AND2, redonly},\n\t{\"WOOD4\",    DOOM1AND2, redonly},\n\t{\"WOODGARG\", DOOM1AND2, redonly},\n\t{\"WOODSKUL\", DOOM1AND2, redonly},\n//\t{\"ZELDOOR\",  DOOM1AND2, redonly},\n\t{\"LITEBLU1\", DOOM1AND2, notgray},\n\t{\"LITEBLU2\", DOOM1AND2, notgray},\n\t{\"SPCDOOR3\", DOOM2ONLY, greenonly1},\n\t{\"PIPEWAL1\", DOOM2ONLY, greenonly1},\n\t{\"TEKLITE2\", DOOM2ONLY, greenonly1},\n\t{\"TEKBRON2\", DOOM2ONLY, yellowonly},\n//\t{\"SW2SKULL\", DOOM2ONLY, greenonly2},\n\t{\"SW2SATYR\", DOOM1AND2, brighttan},\n\t{\"SW2LION\",  DOOM1AND2, brighttan},\n\t{\"SW2GARG\",  DOOM1AND2, brighttan},\n\t// [crispy] Final Doom textures\n\t// TNT - Evilution exclusive\n\t{\"PNK4EXIT\", DOOM2ONLY, redonly},\n\t{\"SLAD2\",    DOOM2ONLY, notgrayorbrown},\n\t{\"SLAD3\",    DOOM2ONLY, notgrayorbrown},\n\t{\"SLAD4\",    DOOM2ONLY, notgrayorbrown},\n\t{\"SLAD5\",    DOOM2ONLY, notgrayorbrown},\n\t{\"SLAD6\",    DOOM2ONLY, notgrayorbrown},\n\t{\"SLAD7\",    DOOM2ONLY, notgrayorbrown},\n\t{\"SLAD8\",    DOOM2ONLY, notgrayorbrown},\n\t{\"SLAD9\",    DOOM2ONLY, notgrayorbrown},\n\t{\"SLAD10\",   DOOM2ONLY, notgrayorbrown},\n\t{\"SLAD11\",   DOOM2ONLY, notgrayorbrown},\n\t{\"SLADRIP1\", DOOM2ONLY, notgrayorbrown},\n\t{\"SLADRIP3\", DOOM2ONLY, notgrayorbrown},\n\t{\"M_TEC\",    DOOM2ONLY, greenonly2},\n\t{\"LITERED2\", DOOM2ONLY, redonly},\n\t{\"BTNTMETL\", DOOM2ONLY, notgrayorbrown},\n\t{\"BTNTSLVR\", DOOM2ONLY, notgrayorbrown},\n\t{\"LITEYEL2\", DOOM2ONLY, yellowonly},\n\t{\"LITEYEL3\", DOOM2ONLY, yellowonly},\n\t{\"YELMETAL\", DOOM2ONLY, yellowonly},\n\t// Plutonia exclusive\n//\t{\"SW2SKULL\", DOOM2ONLY, redonly},\n};\n\nstatic const fullbright_t fullbright_chex[] = {\n\t{\"BIGDOOR1\", DOOM1AND2, greenonly3},\n//\t{\"BIGDOOR4\", DOOM1AND2, greenonly3}, // C1: some stray green pixels, C2: many stray green pixels\n//\t{\"BRNBIGL\",  DOOM1AND2, greenonly3},\n//\t{\"BRNBIGR\",  DOOM1AND2, greenonly3}, // C1, C2: one stray green pixel\n//\t{\"BRNSMAL2\", DOOM1AND2, greenonly3}, // C1, C2: many stray green pixels\n\t{\"COMP2\",    DOOM1AND2, notgray},\n//\t{\"COMPTALL\", DOOM1ONLY, notgray},\n//\t{\"COMPTALL\", DOOM2ONLY, greenonly3}, // C2: many stray green pixels\n\t{\"COMPUTE2\", DOOM1AND2, notgray},\n\t{\"LITE5\",    DOOM1ONLY, greenonly2},\n\t{\"STARTAN3\", DOOM1AND2, greenonly2},\n\t{\"SW1BRCOM\", DOOM1AND2, chexred},\n\t{\"SW1BRN1\",  DOOM1AND2, chexgreen},\n\t{\"SW1BRN2\",  DOOM1AND2, chexred},\n\t{\"SW1BRNGN\", DOOM1AND2, chexred},\n\t{\"SW1BROWN\", DOOM1AND2, chexred},\n\t{\"SW1COMM\",  DOOM1AND2, chexred},\n\t{\"SW1COMP\",  DOOM1AND2, chexred},\n\t{\"SW1DIRT\",  DOOM1AND2, chexgreen},\n\t{\"SW1METAL\", DOOM1AND2, chexredgreen},\n\t{\"SW1PIPE\",  DOOM1AND2, chexgreen},\n\t{\"SW1STARG\", DOOM1AND2, chexred},\n\t{\"SW1STON1\", DOOM1AND2, chexred},\n\t{\"SW1STRTN\", DOOM1AND2, chexred},\n\t{\"SW2BRCOM\", DOOM1AND2, chexgreen},\n\t{\"SW2BRN1\",  DOOM1AND2, chexred},\n\t{\"SW2BRN2\",  DOOM1AND2, chexgreen},\n\t{\"SW2BRNGN\", DOOM1AND2, chexgreen},\n\t{\"SW2BROWN\", DOOM1AND2, chexgreen},\n\t{\"SW2COMM\",  DOOM1AND2, chexgreen},\n\t{\"SW2COMP\",  DOOM1AND2, chexgreen},\n\t{\"SW2DIRT\",  DOOM1AND2, chexred},\n\t{\"SW2METAL\", DOOM1AND2, chexredgreen},\n\t{\"SW2PIPE\",  DOOM1AND2, chexred},\n\t{\"SW2STARG\", DOOM1AND2, chexgreen},\n\t{\"SW2STON1\", DOOM1AND2, chexgreen},\n\t{\"SW2STONE\", DOOM1AND2, chexgreen},\n\t{\"SW2STRTN\", DOOM1AND2, chexgreen},\n//\t{\"BIGDOOR5\", DOOM1AND2, greenonly1}, // C1, C2: some stray green pixels\n//\t{\"BIGDOOR6\", DOOM1AND2, greenonly1}, // C1, C2: some stray green pixels\n\t{\"CEMENT3\",  DOOM1AND2, greenonly3},\n\t{\"SKINFACE\", DOOM1AND2, greenonly1},\n\t{\"SKINTEK1\", DOOM1ONLY, greenonly1},\n\t{\"SKSPINE2\", DOOM1AND2, greenonly3},\n\t{\"SW1BLUE\",  DOOM1AND2, chexgreen},\n\t{\"SW1HOT\",   DOOM1AND2, chexgreen},\n\t{\"SW1SKIN\",  DOOM1AND2, chexgreen},\n\t{\"SW1VINE\",  DOOM1ONLY, chexgreen}, // C1: some stray green pixels in the vines\n\t{\"SW1WOOD\",  DOOM1AND2, chexgreen},\n\t{\"SW2BLUE\",  DOOM1AND2, chexred},\n\t{\"SW2CMT\",   DOOM1AND2, chexgreen},\n\t{\"SW2GSTON\", DOOM1AND2, chexred},\n\t{\"SW2HOT\",   DOOM1AND2, chexred},\n\t{\"SW2SKIN\",  DOOM1AND2, chexred},\n\t{\"SW2VINE\",  DOOM1ONLY, chexred},\n\t{\"SW2WOOD\",  DOOM1AND2, chexred},\n\t{\"WOOD4\",    DOOM1AND2, chexredgreen},\n\t{\"WOODGARG\", DOOM1AND2, chexred},\n\t{\"WOODSKUL\", DOOM1AND2, chexredgreen},\n};\n\nstatic const fullbright_t fullbright_hacx[] = {\n//\t{\"BFALL1\",   DOOM2ONLY, redandgreen},\n//\t{\"BFALL2\",   DOOM2ONLY, redandgreen},\n//\t{\"BFALL3\",   DOOM2ONLY, redandgreen},\n//\t{\"BFALL4\",   DOOM2ONLY, redandgreen},\n\t{\"BRNSMALR\", DOOM2ONLY, greenonly1},\n\t{\"DOORRED\",  DOOM2ONLY, redandgreen},\n\t{\"SLADWALL\", DOOM2ONLY, chexred},\n//\t{\"SW1BRCOM\", DOOM2ONLY, redonly},\n//\t{\"SW1BRN1\",  DOOM2ONLY, redandgreen},\n\t{\"SW1BRN2\",  DOOM2ONLY, notgrayorbrown},\n\t{\"SW1BRNGN\", DOOM2ONLY, notgrayorbrown},\n//\t{\"SW1BROWN\", DOOM2ONLY, notgrayorbrown},\n//\t{\"SW2BRCOM\", DOOM2ONLY, greenonly1},\n//\t{\"SW2BRN1\",  DOOM2ONLY, redandgreen},\n\t{\"SW2BRN2\",  DOOM2ONLY, notgrayorbrown},\n//\t{\"SW2BROWN\", DOOM2ONLY, notgrayorbrown},\n\t{\"COMPSPAN\", DOOM2ONLY, greenonly1},\n\t{\"COMPSTA1\", DOOM2ONLY, notgrayorbrown},\n//\t{\"COMPSTA2\", DOOM2ONLY, notgrayorbrown},\n\t{\"HD5\",      DOOM2ONLY, redandgreen},\n//\t{\"HD8\",      DOOM2ONLY, redandgreen},\n//\t{\"HD9\",      DOOM2ONLY, redandgreen},\n\t{\"BLAKWAL2\", DOOM2ONLY, redandgreen},\n\t{\"CEMENT7\",  DOOM2ONLY, greenonly1},\n\t{\"ROCK4\",    DOOM2ONLY, redonly},\n//\t{\"SLOPPY1\",  DOOM2ONLY, notgrayorbrown},\n//\t{\"SPCDOOR4\", DOOM2ONLY, notgrayorbrown},\n\t{\"ZZZFACE1\", DOOM2ONLY, greenonly1},\n\t{\"ZZZFACE2\", DOOM2ONLY, redandgreen},\n\t{\"HW166\",    DOOM2ONLY, redandgreen},\n\t{\"HW510\",    DOOM2ONLY, notgrayorbrown},\n\t{\"HW511\",    DOOM2ONLY, notgrayorbrown},\n\t{\"HW512\",    DOOM2ONLY, notgrayorbrown},\n};\n\nstatic byte *R_BrightmapForTexName_Doom (const char *texname)\n{\n\tint i;\n\n\tfor (i = 0; i < arrlen(fullbright_doom); i++)\n\t{\n\t\tconst fullbright_t *fullbright = &fullbright_doom[i];\n\n\t\tif ((gamemission == doom && fullbright->game == DOOM2ONLY) ||\n\t\t    (gamemission != doom && fullbright->game == DOOM1ONLY))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strncasecmp(fullbright->texture, texname, 8))\n\t\t{\n\t\t\treturn fullbright->colormask;\n\t\t}\n\t}\n\n\treturn nobrightmap;\n}\n\nstatic boolean chex2 = false;\n\nstatic byte *R_BrightmapForTexName_Chex (const char *texname)\n{\n\tint i;\n\n\tfor (i = 0; i < arrlen(fullbright_chex); i++)\n\t{\n\t\tconst fullbright_t *fullbright = &fullbright_chex[i];\n\n\t\tif ((chex2 && fullbright->game == DOOM1ONLY) ||\n\t\t    (!chex2 && fullbright->game == DOOM2ONLY))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!strncasecmp(fullbright->texture, texname, 8))\n\t\t{\n\t\t\treturn fullbright->colormask;\n\t\t}\n\t}\n\n\treturn nobrightmap;\n}\n\nstatic byte *R_BrightmapForTexName_Hacx (const char *texname)\n{\n\tint i;\n\n\tfor (i = 0; i < arrlen(fullbright_hacx); i++)\n\t{\n\t\tconst fullbright_t *fullbright = &fullbright_hacx[i];\n\n\t\tif (!strncasecmp(fullbright->texture, texname, 8))\n\t\t{\n\t\t\treturn fullbright->colormask;\n\t\t}\n\t}\n\n\treturn nobrightmap;\n}\n\n// [crispy] brightmaps for sprites\n\n// [crispy] adapted from russian-doom/src/doom/r_things.c:617-639\nstatic byte *R_BrightmapForSprite_Doom (const int type)\n{\n\treturn nobrightmap;\n}\n\nstatic byte *R_BrightmapForSprite_Chex (const int type)\n{\n\treturn nobrightmap;\n}\n\nstatic byte *R_BrightmapForSprite_Hacx (const int type)\n{\n\treturn nobrightmap;\n}\n\n// [crispy] brightmaps for flats\n\nstatic int bmapflatnum[12];\n\nstatic byte *R_BrightmapForFlatNum_Doom (const int num)\n{\n\treturn nobrightmap;\n}\n\nstatic byte *R_BrightmapForFlatNum_Hacx (const int num)\n{\n\treturn nobrightmap;\n}\n\nstatic byte *R_BrightmapForFlatNum_None (const int num)\n{\n\treturn nobrightmap;\n}\n\n// [crispy] brightmaps for states\n\nstatic byte *R_BrightmapForState_Doom (const int state)\n{\n\treturn nobrightmap;\n}\n\nstatic byte *R_BrightmapForState_Hacx (const int state)\n{\n\treturn nobrightmap;\n}\n\nstatic byte *R_BrightmapForState_None (const int state)\n{\n\treturn nobrightmap;\n}\n\n// [crispy] initialize brightmaps\n\nbyte *(*R_BrightmapForTexName) (const char *texname);\nbyte *(*R_BrightmapForSprite) (const int type);\nbyte *(*R_BrightmapForFlatNum) (const int num);\nbyte *(*R_BrightmapForState) (const int state);\n\nvoid R_InitBrightmaps (int flats)\n{\n\tif (gameversion == exe_hacx)\n\t{\n\t\tif (flats)\n\t\t{\n\t\t\tbmapflatnum[0] = R_FlatNumForName(\"FLOOR1_1\");\n\t\t\tbmapflatnum[1] = R_FlatNumForName(\"FLOOR1_7\");\n\t\t\tbmapflatnum[2] = R_FlatNumForName(\"FLOOR3_3\");\n\t\t\tbmapflatnum[3] = R_FlatNumForName(\"NUKAGE1\");\n\t\t\tbmapflatnum[4] = R_FlatNumForName(\"NUKAGE2\");\n\t\t\tbmapflatnum[5] = R_FlatNumForName(\"NUKAGE3\");\n\t\t\tbmapflatnum[6] = R_FlatNumForName(\"BLOOD1\");\n\t\t\tbmapflatnum[7] = R_FlatNumForName(\"BLOOD2\");\n\t\t\tbmapflatnum[8] = R_FlatNumForName(\"BLOOD2\");\n\t\t\tbmapflatnum[9] = R_FlatNumForName(\"SLIME13\");\n\t\t\tbmapflatnum[10] = R_FlatNumForName(\"SLIME14\");\n\t\t\tbmapflatnum[11] = R_FlatNumForName(\"SLIME15\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tR_BrightmapForTexName = R_BrightmapForTexName_Hacx;\n\t\t\tR_BrightmapForSprite = R_BrightmapForSprite_Hacx;\n\t\t\tR_BrightmapForFlatNum = R_BrightmapForFlatNum_Hacx;\n\t\t\tR_BrightmapForState = R_BrightmapForState_Hacx;\n\t\t}\n\t}\n\telse\n\tif (gameversion == exe_chex)\n\t{\n\t\tif (!flats)\n\t\t{\n\t\t\tint lump;\n\n\t\t\t// [crispy] detect Chex Quest 2\n\t\t\tlump = W_CheckNumForName(\"INTERPIC\");\n\t\t\tif (!strcasecmp(W_WadNameForLump(lumpinfo[lump]), \"chex2.wad\"))\n\t\t\t{\n\t\t\t\tchex2 = true;\n\t\t\t}\n\n\t\t\tR_BrightmapForTexName = R_BrightmapForTexName_Chex;\n\t\t\tR_BrightmapForSprite = R_BrightmapForSprite_Chex;\n\t\t\tR_BrightmapForFlatNum = R_BrightmapForFlatNum_None;\n\t\t\tR_BrightmapForState = R_BrightmapForState_None;\n\t\t}\n\t}\n\telse\n\t{\n\t\tif (flats)\n\t\t{\n\t\t\t// [crispy] only three select brightmapped flats\n\t\t\tbmapflatnum[0] = R_FlatNumForName(\"CONS1_1\");\n\t\t\tbmapflatnum[1] = R_FlatNumForName(\"CONS1_5\");\n\t\t\tbmapflatnum[2] = R_FlatNumForName(\"CONS1_7\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tR_BrightmapForTexName = R_BrightmapForTexName_Doom;\n\t\t\tR_BrightmapForSprite = R_BrightmapForSprite_Doom;\n\t\t\tR_BrightmapForFlatNum = R_BrightmapForFlatNum_Doom;\n\t\t\tR_BrightmapForState = R_BrightmapForState_Doom;\n\t\t}\n\t}\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tBSP traversal, handling of LineSegs for rendering.\n//\n\n\n\n\n#include \"doomdef.h\"\n\n#include \"m_bbox.h\"\n\n#include \"i_system.h\"\n\n#include \"r_main.h\"\n#include \"r_plane.h\"\n#include \"r_things.h\"\n\n// State.\n#include \"doomstat.h\"\n#include \"r_state.h\"\n\n\n\n\nseg_t*\t\tcurline;\nside_t*\t\tsidedef;\nline_t*\t\tlinedef;\nsector_t*\tfrontsector;\nsector_t*\tbacksector;\n\ndrawseg_t*\tdrawsegs = NULL;\ndrawseg_t*\tds_p;\nint\t\tnumdrawsegs = 0;\n\n\nvoid\nR_StoreWallRange\n( int\tstart,\n  int\tstop );\n\n\n\n\n//\n// R_ClearDrawSegs\n//\nvoid R_ClearDrawSegs (void)\n{\n    ds_p = drawsegs;\n}\n\n\n\n//\n// ClipWallSegment\n// Clips the given range of columns\n// and includes it in the new clip list.\n//\ntypedef\tstruct\n{\n    int\tfirst;\n    int last;\n    \n} cliprange_t;\n\n// We must expand MAXSEGS to the theoretical limit of the number of solidsegs\n// that can be generated in a scene by the DOOM engine. This was determined by\n// Lee Killough during BOOM development to be a function of the screensize.\n// The simplest thing we can do, other than fix this bug, is to let the game\n// render overage and then bomb out by detecting the overflow after the \n// fact. -haleyjd\n//#define MAXSEGS 32\n#define MAXSEGS (MAXWIDTH / 2 + 1)\n\n// newend is one past the last valid seg\ncliprange_t*\tnewend;\ncliprange_t\tsolidsegs[MAXSEGS];\n\n\n\n\n//\n// R_ClipSolidWallSegment\n// Does handle solid walls,\n//  e.g. single sided LineDefs (middle texture)\n//  that entirely block the view.\n// \nvoid\nR_ClipSolidWallSegment\n( int\t\t\tfirst,\n  int\t\t\tlast )\n{\n    cliprange_t*\tnext;\n    cliprange_t*\tstart;\n\n    // Find the first range that touches the range\n    //  (adjacent pixels are touching).\n    start = solidsegs;\n    while (start->last < first-1)\n\tstart++;\n\n    if (first < start->first)\n    {\n\tif (last < start->first-1)\n\t{\n\t    // Post is entirely visible (above start),\n\t    //  so insert a new clippost.\n\t    R_StoreWallRange (first, last);\n\t    next = newend;\n\t    newend++;\n\t    \n\t    while (next != start)\n\t    {\n\t\t*next = *(next-1);\n\t\tnext--;\n\t    }\n\t    next->first = first;\n\t    next->last = last;\n\t    return;\n\t}\n\t\t\n\t// There is a fragment above *start.\n\tR_StoreWallRange (first, start->first - 1);\n\t// Now adjust the clip size.\n\tstart->first = first;\t\n    }\n\n    // Bottom contained in start?\n    if (last <= start->last)\n\treturn;\t\t\t\n\t\t\n    next = start;\n    while (last >= (next+1)->first-1)\n    {\n\t// There is a fragment between two posts.\n\tR_StoreWallRange (next->last + 1, (next+1)->first - 1);\n\tnext++;\n\t\n\tif (last <= next->last)\n\t{\n\t    // Bottom is contained in next.\n\t    // Adjust the clip size.\n\t    start->last = next->last;\t\n\t    goto crunch;\n\t}\n    }\n\t\n    // There is a fragment after *next.\n    R_StoreWallRange (next->last + 1, last);\n    // Adjust the clip size.\n    start->last = last;\n\t\n    // Remove start+1 to next from the clip list,\n    // because start now covers their area.\n  crunch:\n    if (next == start)\n    {\n\t// Post just extended past the bottom of one post.\n\treturn;\n    }\n    \n\n    while (next++ != newend)\n    {\n\t// Remove a post.\n\t*++start = *next;\n    }\n\n    newend = start+1;\n}\n\n\n\n//\n// R_ClipPassWallSegment\n// Clips the given range of columns,\n//  but does not includes it in the clip list.\n// Does handle windows,\n//  e.g. LineDefs with upper and lower texture.\n//\nvoid\nR_ClipPassWallSegment\n( int\tfirst,\n  int\tlast )\n{\n    cliprange_t*\tstart;\n\n    // Find the first range that touches the range\n    //  (adjacent pixels are touching).\n    start = solidsegs;\n    while (start->last < first-1)\n\tstart++;\n\n    if (first < start->first)\n    {\n\tif (last < start->first-1)\n\t{\n\t    // Post is entirely visible (above start).\n\t    R_StoreWallRange (first, last);\n\t    return;\n\t}\n\t\t\n\t// There is a fragment above *start.\n\tR_StoreWallRange (first, start->first - 1);\n    }\n\n    // Bottom contained in start?\n    if (last <= start->last)\n\treturn;\t\t\t\n\t\t\n    while (last >= (start+1)->first-1)\n    {\n\t// There is a fragment between two posts.\n\tR_StoreWallRange (start->last + 1, (start+1)->first - 1);\n\tstart++;\n\t\n\tif (last <= start->last)\n\t    return;\n    }\n\t\n    // There is a fragment after *next.\n    R_StoreWallRange (start->last + 1, last);\n}\n\n\n\n//\n// R_ClearClipSegs\n//\nvoid R_ClearClipSegs (void)\n{\n    solidsegs[0].first = -0x7fffffff;\n    solidsegs[0].last = -1;\n    solidsegs[1].first = viewwidth;\n    solidsegs[1].last = 0x7fffffff;\n    newend = solidsegs+2;\n}\n\n// [AM] Interpolate the passed sector, if prudent.\nvoid R_MaybeInterpolateSector(sector_t* sector)\n{\n    sector->interpfloorheight = sector->floorheight;\n    sector->interpceilingheight = sector->ceilingheight;\n}\n\n//\n// killough 3/7/98: Hack floor/ceiling heights for deep water etc.\n//\n// If player's view height is underneath fake floor, lower the\n// drawn ceiling to be just under the floor height, and replace\n// the drawn floor and ceiling textures, and light level, with\n// the control sector's.\n//\n// Similar for ceiling, only reflected.\n//\n// killough 4/11/98, 4/13/98: fix bugs, add 'back' parameter\n//\n\nsector_t *R_FakeFlat(sector_t *sec, sector_t *tempsec,\n                     int *floorlightlevel, int *ceilinglightlevel,\n                     boolean back)\n{\n  if (floorlightlevel)\n    *floorlightlevel = sec->floorlightsec == -1 ?\n      sec->lightlevel : sectors[sec->floorlightsec].lightlevel;\n\n  if (ceilinglightlevel)\n    *ceilinglightlevel = sec->ceilinglightsec == -1 ? // killough 4/11/98\n      sec->lightlevel : sectors[sec->ceilinglightsec].lightlevel;\n\n  if (sec->heightsec != -1)\n    {\n      const sector_t *s = &sectors[sec->heightsec];\n      int heightsec = viewplayer->mo->subsector->sector->heightsec;\n      int underwater = heightsec!=-1 && viewz<=sectors[heightsec].floorheight;\n\n      // Replace sector being drawn, with a copy to be hacked\n      *tempsec = *sec;\n\n      // Replace floor and ceiling height with other sector's heights.\n      tempsec->floorheight   = s->floorheight;\n      tempsec->ceilingheight = s->ceilingheight;\n\n      // killough 11/98: prevent sudden light changes from non-water sectors:\n      if (underwater && (tempsec->  floorheight = sec->floorheight,\n                          tempsec->ceilingheight = s->floorheight-1, !back))\n        {                   // head-below-floor hack\n          tempsec->floorpic    = s->floorpic;\n          tempsec->floor_xoffs = s->floor_xoffs;\n          tempsec->floor_yoffs = s->floor_yoffs;\n\n          if (underwater) {\n            if (s->ceilingpic == skyflatnum) {\n\t\ttempsec->floorheight   = tempsec->ceilingheight+1;\n\t\ttempsec->ceilingpic    = tempsec->floorpic;\n                tempsec->ceiling_xoffs = tempsec->floor_xoffs;\n                tempsec->ceiling_yoffs = tempsec->floor_yoffs;\n\t    } else {\n\t\ttempsec->ceilingpic    = s->ceilingpic;\n\t\ttempsec->ceiling_xoffs = s->ceiling_xoffs;\n\t\ttempsec->ceiling_yoffs = s->ceiling_yoffs;\n\t    }\n\t  }\n\n          tempsec->lightlevel  = s->lightlevel;\n\n          if (floorlightlevel)\n            *floorlightlevel = s->floorlightsec == -1 ? s->lightlevel :\n            sectors[s->floorlightsec].lightlevel; // killough 3/16/98\n\n          if (ceilinglightlevel)\n            *ceilinglightlevel = s->ceilinglightsec == -1 ? s->lightlevel :\n            sectors[s->ceilinglightsec].lightlevel; // killough 4/11/98\n        }\n      else\n        if (heightsec != -1 && viewz >= sectors[heightsec].ceilingheight &&\n            sec->ceilingheight > s->ceilingheight)\n          {   // Above-ceiling hack\n            tempsec->ceilingheight = s->ceilingheight;\n            tempsec->floorheight   = s->ceilingheight + 1;\n\n            tempsec->floorpic    = tempsec->ceilingpic    = s->ceilingpic;\n            tempsec->floor_xoffs = tempsec->ceiling_xoffs = s->ceiling_xoffs;\n            tempsec->floor_yoffs = tempsec->ceiling_yoffs = s->ceiling_yoffs;\n\n            if (s->floorpic != skyflatnum)\n              {\n                tempsec->ceilingheight = sec->ceilingheight;\n                tempsec->floorpic      = s->floorpic;\n                tempsec->floor_xoffs   = s->floor_xoffs;\n                tempsec->floor_yoffs   = s->floor_yoffs;\n              }\n\n            tempsec->lightlevel  = s->lightlevel;\n\n            if (floorlightlevel)\n              *floorlightlevel = s->floorlightsec == -1 ? s->lightlevel :\n              sectors[s->floorlightsec].lightlevel; // killough 3/16/98\n\n            if (ceilinglightlevel)\n              *ceilinglightlevel = s->ceilinglightsec == -1 ? s->lightlevel :\n              sectors[s->ceilinglightsec].lightlevel; // killough 4/11/98\n          }\n      sec = tempsec;               // Use other sector\n    }\n  return sec;\n}\n\n//\n// R_AddLine\n// Clips the given segment\n// and adds any visible pieces to the line list.\n//\nvoid R_AddLine (seg_t*\tline)\n{\n    int\t\t\tx1;\n    int\t\t\tx2;\n    angle_t\t\tangle1;\n    angle_t\t\tangle2;\n    angle_t\t\tspan;\n    angle_t\t\ttspan;\n    sector_t    tempsec;     // killough 3/8/98: ceiling/water hack\n\n    curline = line;\n\n    // OPTIMIZE: quickly reject orthogonal back sides.\n    // [crispy] remove slime trails\n    angle1 = R_PointToAngleCrispy (line->v1->r_x, line->v1->r_y);\n    angle2 = R_PointToAngleCrispy (line->v2->r_x, line->v2->r_y);\n    \n    // Clip to view edges.\n    // OPTIMIZE: make constant out of 2*clipangle (FIELDOFVIEW).\n    span = angle1 - angle2;\n    \n    // Back side? I.e. backface culling?\n    if (span >= ANG180)\n\treturn;\t\t\n\n    // Global angle needed by segcalc.\n    rw_angle1 = angle1;\n    angle1 -= viewangle;\n    angle2 -= viewangle;\n\t\n    tspan = angle1 + clipangle;\n    if (tspan > 2*clipangle)\n    {\n\ttspan -= 2*clipangle;\n\n\t// Totally off the left edge?\n\tif (tspan >= span)\n\t    return;\n\t\n\tangle1 = clipangle;\n    }\n    tspan = clipangle - angle2;\n    if (tspan > 2*clipangle)\n    {\n\ttspan -= 2*clipangle;\n\n\t// Totally off the left edge?\n\tif (tspan >= span)\n\t    return;\t\n\tangle2 = -clipangle;\n    }\n    \n    // The seg is in the view range,\n    // but not necessarily visible.\n    angle1 = (angle1+ANG90)>>ANGLETOFINESHIFT;\n    angle2 = (angle2+ANG90)>>ANGLETOFINESHIFT;\n    x1 = viewangletox[angle1];\n    x2 = viewangletox[angle2];\n\n    // Does not cross a pixel?\n    if (x1 == x2)\n\treturn;\t\t\t\t\n\t\n    backsector = line->backsector;\n\n    // Single sided line?\n    if (!backsector)\n\tgoto clipsolid;\t\t\n\n    // Single sided line?\n    if (backsector)\n        // killough 3/8/98, 4/4/98: hack for invisible ceilings / deep water\n        backsector = R_FakeFlat(backsector, &tempsec, NULL, NULL, true);\n\n    // [AM] Interpolate sector movement before\n    //      running clipping tests.  Frontsector\n    //      should already be interpolated.\n    R_MaybeInterpolateSector(backsector);\n\n    // Closed door.\n    if (backsector->interpceilingheight <= frontsector->interpfloorheight\n\t|| backsector->interpfloorheight >= frontsector->interpceilingheight)\n\tgoto clipsolid;\t\t\n\n    // Window.\n    if (backsector->interpceilingheight != frontsector->interpceilingheight\n\t|| backsector->interpfloorheight != frontsector->interpfloorheight)\n\tgoto clippass;\t\n\t\t\n    // Reject empty lines used for triggers\n    //  and special events.\n    // Identical floor and ceiling on both sides,\n    // identical light levels on both sides,\n    // and no middle texture.\n    if (backsector->ceilingpic == frontsector->ceilingpic\n\t&& backsector->floorpic == frontsector->floorpic\n\t&& backsector->lightlevel == frontsector->lightlevel\n\t&& curline->sidedef->midtexture == 0)\n    {\n\treturn;\n    }\n    \n\t\t\t\t\n  clippass:\n    R_ClipPassWallSegment (x1, x2-1);\t\n    return;\n\t\t\n  clipsolid:\n    R_ClipSolidWallSegment (x1, x2-1);\n}\n\n\n//\n// R_CheckBBox\n// Checks BSP node/subtree bounding box.\n// Returns true\n//  if some part of the bbox might be visible.\n//\nint\tcheckcoord[12][4] =\n{\n    {3,0,2,1},\n    {3,0,2,0},\n    {3,1,2,0},\n    {0},\n    {2,0,2,1},\n    {0,0,0,0},\n    {3,1,3,0},\n    {0},\n    {2,0,3,1},\n    {2,1,3,1},\n    {2,1,3,0}\n};\n\n\nboolean R_CheckBBox (fixed_t*\tbspcoord)\n{\n    int\t\t\tboxx;\n    int\t\t\tboxy;\n    int\t\t\tboxpos;\n\n    fixed_t\t\tx1;\n    fixed_t\t\ty1;\n    fixed_t\t\tx2;\n    fixed_t\t\ty2;\n    \n    angle_t\t\tangle1;\n    angle_t\t\tangle2;\n    angle_t\t\tspan;\n    angle_t\t\ttspan;\n    \n    cliprange_t*\tstart;\n\n    int\t\t\tsx1;\n    int\t\t\tsx2;\n    \n    // Find the corners of the box\n    // that define the edges from current viewpoint.\n    if (viewx <= bspcoord[BOXLEFT])\n\tboxx = 0;\n    else if (viewx < bspcoord[BOXRIGHT])\n\tboxx = 1;\n    else\n\tboxx = 2;\n\t\t\n    if (viewy >= bspcoord[BOXTOP])\n\tboxy = 0;\n    else if (viewy > bspcoord[BOXBOTTOM])\n\tboxy = 1;\n    else\n\tboxy = 2;\n\t\t\n    boxpos = (boxy<<2)+boxx;\n    if (boxpos == 5)\n\treturn true;\n\t\n    x1 = bspcoord[checkcoord[boxpos][0]];\n    y1 = bspcoord[checkcoord[boxpos][1]];\n    x2 = bspcoord[checkcoord[boxpos][2]];\n    y2 = bspcoord[checkcoord[boxpos][3]];\n    \n    // check clip list for an open space\n    angle1 = R_PointToAngleCrispy (x1, y1) - viewangle;\n    angle2 = R_PointToAngleCrispy (x2, y2) - viewangle;\n\t\n    span = angle1 - angle2;\n\n    // Sitting on a line?\n    if (span >= ANG180)\n\treturn true;\n    \n    tspan = angle1 + clipangle;\n\n    if (tspan > 2*clipangle)\n    {\n\ttspan -= 2*clipangle;\n\n\t// Totally off the left edge?\n\tif (tspan >= span)\n\t    return false;\t\n\n\tangle1 = clipangle;\n    }\n    tspan = clipangle - angle2;\n    if (tspan > 2*clipangle)\n    {\n\ttspan -= 2*clipangle;\n\n\t// Totally off the left edge?\n\tif (tspan >= span)\n\t    return false;\n\t\n\tangle2 = -clipangle;\n    }\n\n\n    // Find the first clippost\n    //  that touches the source post\n    //  (adjacent pixels are touching).\n    angle1 = (angle1+ANG90)>>ANGLETOFINESHIFT;\n    angle2 = (angle2+ANG90)>>ANGLETOFINESHIFT;\n    sx1 = viewangletox[angle1];\n    sx2 = viewangletox[angle2];\n\n    // Does not cross a pixel.\n    if (sx1 == sx2)\n\treturn false;\t\t\t\n    sx2--;\n\t\n    start = solidsegs;\n    while (start->last < sx2)\n\tstart++;\n    \n    if (sx1 >= start->first\n\t&& sx2 <= start->last)\n    {\n\t// The clippost contains the new span.\n\treturn false;\n    }\n\n    return true;\n}\n\n//\n// R_Subsector\n// Determine floor/ceiling planes.\n// Add sprites of things in sector.\n// Draw one or more line segments.\n//\nvoid R_Subsector (int num)\n{\n    int\t\t\tcount;\n    seg_t*\t\tline;\n    subsector_t*\tsub;\n\n    sector_t    tempsec;              // killough 3/7/98: deep water hack\n    int         floorlightlevel;      // killough 3/16/98: set floor lightlevel\n    int         ceilinglightlevel;    // killough 4/11/98\n\t\n#ifdef RANGECHECK\n    if (num>=numsubsectors)\n\tI_Error (\"R_Subsector: ss %i with numss = %i\",\n\t\t num,\n\t\t numsubsectors);\n#endif\n\n    sscount++;\n    sub = &subsectors[num];\n    frontsector = sub->sector;\n\n    // killough 3/8/98, 4/4/98: Deep water / fake ceiling effect\n    frontsector = R_FakeFlat(frontsector, &tempsec, &floorlightlevel,\n      &ceilinglightlevel, false);   // killough 4/11/98\n\n    count = sub->numlines;\n    line = &segs[sub->firstline];\n\n    // [AM] Interpolate sector movement.  Usually only needed\n    //      when you're standing inside the sector.\n    R_MaybeInterpolateSector(frontsector);\n\n    floorplane = frontsector->floorheight < viewz || // killough 3/7/98\n      (frontsector->heightsec != -1 &&\n       sectors[frontsector->heightsec].ceilingpic == skyflatnum) ?\n      R_FindPlane(frontsector->floorheight,\n                  frontsector->floorpic == skyflatnum &&  // kilough 10/98\n                  frontsector->sky & PL_SKYFLAT ? frontsector->sky :\n                  frontsector->floorpic,\n                  floorlightlevel//,                // killough 3/16/98\n                //   frontsector->floor_xoffs,       // killough 3/7/98\n                //   frontsector->floor_yoffs\n                  ) : NULL;\n\n    ceilingplane = frontsector->ceilingheight > viewz ||\n      frontsector->ceilingpic == skyflatnum ||\n      (frontsector->heightsec != -1 &&\n       sectors[frontsector->heightsec].floorpic == skyflatnum) ?\n      R_FindPlane(frontsector->ceilingheight,     // killough 3/8/98\n                  frontsector->ceilingpic == skyflatnum &&  // kilough 10/98\n                  frontsector->sky & PL_SKYFLAT ? frontsector->sky :\n                  frontsector->ceilingpic,\n                  ceilinglightlevel//,              // killough 4/11/98\n                //   frontsector->ceiling_xoffs,     // killough 3/7/98\n                //   frontsector->ceiling_yoffs\n                  ) : NULL;\n\n    // if (frontsector->interpfloorheight < viewz)\n    // {\n\t// floorplane = R_FindPlane(frontsector->interpfloorheight,\n\t// \t\t\t  // [crispy] add support for MBF sky tranfers\n\t// \t\t\t  frontsector->floorpic == skyflatnum &&\n\t// \t\t\t  frontsector->sky & PL_SKYFLAT ? frontsector->sky :\n\t// \t\t\t  frontsector->floorpic,\n\t// \t\t\t  frontsector->lightlevel);\n    // }\n    // else\n\t// floorplane = NULL;\n    \n    // if (frontsector->interpceilingheight > viewz\n\t// || frontsector->ceilingpic == skyflatnum)\n    // {\n\t// ceilingplane = R_FindPlane(frontsector->interpceilingheight,\n\t// \t\t\t  // [crispy] add support for MBF sky tranfers\n\t// \t\t\t    frontsector->ceilingpic == skyflatnum &&\n\t// \t\t\t    frontsector->sky & PL_SKYFLAT ? frontsector->sky :\n\t// \t\t\t    frontsector->ceilingpic,\n\t// \t\t\t    frontsector->lightlevel);\n    // }\n    // else\n\t// ceilingplane = NULL;\n\t\t\n    R_AddSprites (frontsector);\t\n\n    while (count--)\n    {\n\tR_AddLine (line);\n\tline++;\n    }\n\n    // check for solidsegs overflow - extremely unsatisfactory!\n    if(newend > &solidsegs[32] && false)\n        I_Error(\"R_Subsector: solidsegs overflow (vanilla may crash here)\\n\");\n}\n\n\n\n\n//\n// RenderBSPNode\n// Renders all subsectors below a given node,\n//  traversing subtree recursively.\n// Just call with BSP root.\nvoid R_RenderBSPNode (int bspnum)\n{\n    node_t*\tbsp;\n    int\t\tside;\n\n    // Found a subsector?\n    if (bspnum & NF_SUBSECTOR)\n    {\n\tif (bspnum == -1)\t\t\t\n\t    R_Subsector (0);\n\telse\n\t    R_Subsector (bspnum&(~NF_SUBSECTOR));\n\treturn;\n    }\n\t\t\n    bsp = &nodes[bspnum];\n    \n    // Decide which side the view point is on.\n    side = R_PointOnSide (viewx, viewy, bsp);\n\n    // Recursively divide front space.\n    R_RenderBSPNode (bsp->children[side]); \n\n    // Possibly divide back space.\n    if (R_CheckBBox (bsp->bbox[side^1]))\t\n\tR_RenderBSPNode (bsp->children[side^1]);\n}\n\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tHere is a core component: drawing the floors and ceilings,\n//\t while maintaining a per column clipping list only.\n//\tMoreover, the sky areas have to be determined.\n//\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"i_system.h\"\n#include \"z_zone.h\"\n#include \"w_wad.h\"\n\n#include \"doomdef.h\"\n#include \"doomstat.h\"\n\n#include \"r_local.h\"\n#include \"r_sky.h\"\n#include \"r_bmaps.h\" // [crispy] R_BrightmapForTexName()\n\n\nplanefunction_t\t\tfloorfunc;\nplanefunction_t\t\tceilingfunc;\n\n//\n// opening\n//\n\n// Here comes the obnoxious \"visplane\".\n#define MAXVISPLANES\t128\nvisplane_t*\t\tvisplanes = NULL;\nvisplane_t*\t\tlastvisplane;\nvisplane_t*\t\tfloorplane;\nvisplane_t*\t\tceilingplane;\nstatic int\t\tnumvisplanes;\n\n// ?\n#define MAXOPENINGS\tMAXWIDTH*64*4\nint\t\t\topenings[MAXOPENINGS]; // [crispy] 32-bit integer math\nint*\t\t\tlastopening; // [crispy] 32-bit integer math\n\n\n//\n// Clip values are the solid pixel bounding the range.\n//  floorclip starts out SCREENHEIGHT\n//  ceilingclip starts out -1\n//\nint\t\t\tfloorclip[MAXWIDTH]; // [crispy] 32-bit integer math\nint\t\t\tceilingclip[MAXWIDTH]; // [crispy] 32-bit integer math\n\n//\n// spanstart holds the start of a plane span\n// initialized to 0 at start\n//\nint\t\t\tspanstart[MAXHEIGHT];\nint\t\t\tspanstop[MAXHEIGHT];\n\n//\n// texture mapping\n//\nlighttable_t**\t\tplanezlight;\nfixed_t\t\t\tplaneheight;\n\nfixed_t*\t\t\tyslope;\nfixed_t\t\t\tyslopes[LOOKDIRS][MAXHEIGHT];\nfixed_t\t\t\tdistscale[MAXWIDTH];\nfixed_t\t\t\tbasexscale;\nfixed_t\t\t\tbaseyscale;\n\nfixed_t\t\t\tcachedheight[MAXHEIGHT];\nfixed_t\t\t\tcacheddistance[MAXHEIGHT];\nfixed_t\t\t\tcachedxstep[MAXHEIGHT];\nfixed_t\t\t\tcachedystep[MAXHEIGHT];\n\n\n\n//\n// R_InitPlanes\n// Only at game startup.\n//\nvoid R_InitPlanes (void)\n{\n  // Doh!\n}\n\n\n//\n// R_MapPlane\n//\n// Uses global vars:\n//  planeheight\n//  ds_source\n//  basexscale\n//  baseyscale\n//  viewx\n//  viewy\n//\n// BASIC PRIMITIVE\n//\nvoid\nR_MapPlane\n( int\t\ty,\n  int\t\tx1,\n  int\t\tx2 )\n{\n// [crispy] see below\n    fixed_t\tdistance;\n    unsigned\tindex;\n    int dx, dy;\n\t\n#ifdef RANGECHECK\n    if (x2 < x1\n     || x1 < 0\n     || x2 >= viewwidth\n     || y > viewheight)\n    {\n\tI_Error (\"R_MapPlane: %i, %i at %i\",x1,x2,y);\n    }\n#endif\n\n// [crispy] visplanes with the same flats now match up far better than before\n// adapted from prboom-plus/src/r_plane.c:191-239, translated to fixed-point math\n\n    if (!(dy = abs(centery - y)))\n    {\n\treturn;\n    }\n\n    if (planeheight != cachedheight[y])\n    {\n\tcachedheight[y] = planeheight;\n\tdistance = cacheddistance[y] = FixedMul (planeheight, yslope[y]);\n\tds_xstep = cachedxstep[y] = (FixedMul (viewsin, planeheight) / dy) << detailshift;\n\tds_ystep = cachedystep[y] = (FixedMul (viewcos, planeheight) / dy) << detailshift;\n    }\n    else\n    {\n\tdistance = cacheddistance[y];\n\tds_xstep = cachedxstep[y];\n\tds_ystep = cachedystep[y];\n    }\n\n    dx = x1 - centerx;\n\n    ds_xfrac = viewx + FixedMul(viewcos, distance) + dx * ds_xstep;\n    ds_yfrac = -viewy - FixedMul(viewsin, distance) + dx * ds_ystep;\n\n    if (fixedcolormap)\n\tds_colormap[0] = ds_colormap[1] = fixedcolormap;\n    else\n    {\n\tindex = distance >> LIGHTZSHIFT;\n\t\n\tif (index >= MAXLIGHTZ )\n\t    index = MAXLIGHTZ-1;\n\n\tds_colormap[0] = planezlight[index];\n\tds_colormap[1] = cm_zlight[LIGHTLEVELS-1][MAXLIGHTZ-1];\n    }\n\t\n    ds_y = y;\n    ds_x1 = x1;\n    ds_x2 = x2;\n\n    // high or low detail\n    spanfunc ();\t\n}\n\n\n//\n// R_ClearPlanes\n// At begining of frame.\n//\nvoid R_ClearPlanes (void)\n{\n    int\t\ti;\n    angle_t\tangle;\n    \n    // opening / clipping determination\n    for (i=0 ; i<viewwidth ; i++)\n    {\n\tfloorclip[i] = viewheight;\n\tceilingclip[i] = -1;\n    }\n\n    lastvisplane = visplanes;\n    lastopening = openings;\n    \n    // texture calculation\n    memset (cachedheight, 0, sizeof(cachedheight));\n\n    // left to right mapping\n    angle = (viewangle-ANG90)>>ANGLETOFINESHIFT;\n\t\n    // scale will be unit scale at SCREENWIDTH/2 distance\n    basexscale = FixedDiv (finecosine[angle],centerxfrac);\n    baseyscale = -FixedDiv (finesine[angle],centerxfrac);\n}\n\n\n\n// [crispy] remove MAXVISPLANES Vanilla limit\nstatic void R_RaiseVisplanes (visplane_t** vp)\n{\n    if (lastvisplane - visplanes == numvisplanes)\n    {\n\tint numvisplanes_old = numvisplanes;\n\tvisplane_t* visplanes_old = visplanes;\n\n\tnumvisplanes = numvisplanes ? 2 * numvisplanes : MAXVISPLANES;\n\tvisplanes = I_Realloc(visplanes, numvisplanes * sizeof(*visplanes));\n\tmemset(visplanes + numvisplanes_old, 0, (numvisplanes - numvisplanes_old) * sizeof(*visplanes));\n\n\tlastvisplane = visplanes + numvisplanes_old;\n\tfloorplane = visplanes + (floorplane - visplanes_old);\n\tceilingplane = visplanes + (ceilingplane - visplanes_old);\n\n\tif (numvisplanes_old)\n\t    fprintf(stderr, \"R_FindPlane: Hit MAXVISPLANES limit at %d, raised to %d.\\n\", numvisplanes_old, numvisplanes);\n\n\t// keep the pointer passed as argument in relation to the visplanes pointer\n\tif (vp)\n\t    *vp = visplanes + (*vp - visplanes_old);\n    }\n}\n\n//\n// R_FindPlane\n//\nvisplane_t*\nR_FindPlane\n( fixed_t\theight,\n  int\t\tpicnum,\n  int\t\tlightlevel )\n{\n    visplane_t*\tcheck;\n\t\n    // [crispy] add support for MBF sky tranfers\n    if (picnum == skyflatnum || picnum & PL_SKYFLAT)\n    {\n\theight = 0;\t\t\t// all skys map together\n\tlightlevel = 0;\n    }\n\t\n    for (check=visplanes; check<lastvisplane; check++)\n    {\n\tif (height == check->height\n\t    && picnum == check->picnum\n\t    && lightlevel == check->lightlevel)\n\t{\n\t    break;\n\t}\n    }\n    \n\t\t\t\n    if (check < lastvisplane)\n\treturn check;\n\t\t\n    R_RaiseVisplanes(&check); // [crispy] remove VISPLANES limit\n    if (lastvisplane - visplanes == MAXVISPLANES && false)\n\tI_Error (\"R_FindPlane: no more visplanes\");\n\t\t\n    lastvisplane++;\n\n    check->height = height;\n    check->picnum = picnum;\n    check->lightlevel = lightlevel;\n    check->minx = SCREENWIDTH;\n    check->maxx = -1;\n    \n    memset (check->top,0xff,sizeof(check->top));\n\t\t\n    return check;\n}\n\n\n//\n// R_CheckPlane\n//\nvisplane_t*\nR_CheckPlane\n( visplane_t*\tpl,\n  int\t\tstart,\n  int\t\tstop )\n{\n    int\t\tintrl;\n    int\t\tintrh;\n    int\t\tunionl;\n    int\t\tunionh;\n    int\t\tx;\n\t\n    if (start < pl->minx)\n    {\n\tintrl = pl->minx;\n\tunionl = start;\n    }\n    else\n    {\n\tunionl = pl->minx;\n\tintrl = start;\n    }\n\t\n    if (stop > pl->maxx)\n    {\n\tintrh = pl->maxx;\n\tunionh = stop;\n    }\n    else\n    {\n\tunionh = pl->maxx;\n\tintrh = stop;\n    }\n\n    for (x=intrl ; x<= intrh ; x++)\n\tif (pl->top[x] != 0xffffffffu) // [crispy] hires / 32-bit integer math\n\t    break;\n\n  // [crispy] fix HOM if ceilingplane and floorplane are the same\n  // visplane (e.g. both are skies)\n  if (!(pl == floorplane && markceiling && floorplane == ceilingplane))\n  {\n    if (x > intrh)\n    {\n\tpl->minx = unionl;\n\tpl->maxx = unionh;\n\n\t// use the same one\n\treturn pl;\t\t\n    }\n  }\n\t\n    // make a new visplane\n    R_RaiseVisplanes(&pl); // [crispy] remove VISPLANES limit\n    lastvisplane->height = pl->height;\n    lastvisplane->picnum = pl->picnum;\n    lastvisplane->lightlevel = pl->lightlevel;\n    \n    if (lastvisplane - visplanes == MAXVISPLANES && false) // [crispy] remove VISPLANES limit\n\tI_Error (\"R_CheckPlane: no more visplanes\");\n\n    pl = lastvisplane++;\n    pl->minx = start;\n    pl->maxx = stop;\n\n    memset (pl->top,0xff,sizeof(pl->top));\n\t\t\n    return pl;\n}\n\n\n//\n// R_MakeSpans\n//\nvoid\nR_MakeSpans\n( int\t\tx,\n  unsigned int\t\tt1, // [crispy] 32-bit integer math\n  unsigned int\t\tb1, // [crispy] 32-bit integer math\n  unsigned int\t\tt2, // [crispy] 32-bit integer math\n  unsigned int\t\tb2 ) // [crispy] 32-bit integer math\n{\n    while (t1 < t2 && t1<=b1)\n    {\n\tR_MapPlane (t1,spanstart[t1],x-1);\n\tt1++;\n    }\n    while (b1 > b2 && b1>=t1)\n    {\n\tR_MapPlane (b1,spanstart[b1],x-1);\n\tb1--;\n    }\n\t\n    while (t2 < t1 && t2<=b2)\n    {\n\tspanstart[t2] = x;\n\tt2++;\n    }\n    while (b2 > b1 && b2>=t2)\n    {\n\tspanstart[b2] = x;\n\tb2--;\n    }\n}\n\n// [crispy] add support for SMMU swirling flats\n// adapted from smmu/r_ripple.c, by Simon Howard\nstatic char *R_DistortedFlat (int flatnum)\n{\n    const int swirlfactor = 8192 / 64;\n    const int swirlfactor2 = 8192 / 32;\n    const int amp = 2;\n    const int amp2 = 2;\n    const int speed = 40;\n\n    static int swirltic;\n    static int offset[4096];\n\n    static char distortedflat[4096];\n    char *normalflat;\n    int i;\n\n    if (swirltic != gametic)\n    {\n\tint x, y;\n\n\tfor (x = 0; x < 64; x++)\n\t{\n\t    for (y = 0; y < 64; y++)\n\t    {\n\t\tint x1, y1;\n\t\tint sinvalue, sinvalue2;\n\n\t\tsinvalue = (y * swirlfactor + leveltime * speed * 5 + 900) & 8191;\n\t\tsinvalue2 = (x * swirlfactor2 + leveltime * speed * 4 + 300) & 8191;\n\t\tx1 = x + 128\n\t\t   + ((finesine[sinvalue] * amp) >> FRACBITS)\n\t\t   + ((finesine[sinvalue2] * amp2) >> FRACBITS);\n\n\t\tsinvalue = (x * swirlfactor + leveltime * speed * 3 + 700) & 8191;\n\t\tsinvalue2 = (y * swirlfactor2 + leveltime * speed * 4 + 1200) & 8191;\n\t\ty1 = y + 128\n\t\t   + ((finesine[sinvalue] * amp) >> FRACBITS)\n\t\t   + ((finesine[sinvalue2] * amp2) >> FRACBITS);\n\n\t\tx1 &= 63;\n\t\ty1 &= 63;\n\n\t\toffset[(y << 6) + x] = (y1 << 6) + x1;\n\t    }\n\t}\n\n\tswirltic = gametic;\n    }\n\n    normalflat = W_CacheLumpNum(flatnum, PU_STATIC);\n\n    for (i = 0; i < 4096; i++)\n    {\n\tdistortedflat[i] = normalflat[offset[i]];\n    }\n\n    Z_ChangeTag(normalflat, PU_CACHE);\n\n    return distortedflat;\n}\n\n\n//\n// R_DrawPlanes\n// At the end of each frame.\n//\nvoid R_DrawPlanes (void)\n{\n    visplane_t*\t\tpl;\n    int\t\t\tlight;\n    int\t\t\tx;\n    int\t\t\tstop;\n    int\t\t\tangle;\n    int                 lumpnum;\n\t\t\t\t\n#ifdef RANGECHECK\n    if (ds_p - drawsegs > numdrawsegs)\n\tI_Error (\"R_DrawPlanes: drawsegs overflow (%\" PRIiPTR \")\",\n\t\t (unsigned int)(ds_p - drawsegs));\n    \n    if (lastvisplane - visplanes > numvisplanes)\n\tI_Error (\"R_DrawPlanes: visplane overflow (%\" PRIiPTR \")\",\n\t\t (unsigned int)(lastvisplane - visplanes));\n    \n    if (lastopening - openings > MAXOPENINGS)\n\tI_Error (\"R_DrawPlanes: opening overflow (%\" PRIiPTR \")\",\n\t\t (unsigned int)(lastopening - openings));\n#endif\n\n    for (pl = visplanes ; pl < lastvisplane ; pl++)\n    {\n\tconst boolean swirling = (flattranslation[pl->picnum] == -1);\n\n\tif (pl->minx > pl->maxx)\n\t    continue;\n\n\t\n\t// sky flat\n\t// [crispy] add support for MBF sky tranfers\n\tif (pl->picnum == skyflatnum || pl->picnum & PL_SKYFLAT)\n\t{\n\t    int texture;\n\t    angle_t an = viewangle, flip;\n\t    if (pl->picnum & PL_SKYFLAT)\n\t    {\n\t\tconst line_t *l = &lines[pl->picnum & ~PL_SKYFLAT];\n\t\tconst side_t *s = *l->sidenum + sides;\n\t\ttexture = texturetranslation[s->toptexture];\n\t\tdc_texturemid = s->rowoffset - 28*FRACUNIT;\n\t\t\n\t\tflip = (l->special == 272) ? 0u : ~0u;\n\t\tan += s->textureoffset;\n\t    }\n\t    else\n\t    {\n\t\ttexture = skytexture;\n\t\tdc_texturemid = skytexturemid;\n\t\tflip = 0;\n\t    }\n\t    dc_iscale = pspriteiscale>>detailshift;\n\t    \n\t    // Sky is allways drawn full bright,\n\t    //  i.e. colormaps[0] is used.\n\t    // Because of this hack, sky is not affected\n\t    //  by INVUL inverse mapping.\n\t    // [crispy] no brightmaps for sky\n\t    dc_colormap[0] = dc_colormap[1] = fullcolormap;\n\t    dc_texheight = textureheight[texture]>>FRACBITS; // [crispy] Tutti-Frutti fix\n\t    \n\t    for (x=pl->minx ; x <= pl->maxx ; x++)\n\t    {\n\t\tdc_yl = pl->top[x];\n\t\tdc_yh = pl->bottom[x];\n\n\t\tif ((unsigned) dc_yl <= dc_yh) // [crispy] 32-bit integer math\n\t\t{\n\t\t    angle = ((an + xtoviewangle[x])^flip)>>ANGLETOSKYSHIFT;\n\t\t    dc_x = x;\n\t\t    dc_source = R_GetColumn(texture, angle, false);\n\t\t    colfunc ();\n\t\t}\n\t    }\n\t    continue;\n\t}\n\t\n\t// regular flat\n        lumpnum = firstflat + (swirling ? pl->picnum : flattranslation[pl->picnum]);\n\t// [crispy] add support for SMMU swirling flats\n\tds_source = swirling ? R_DistortedFlat(lumpnum) : W_CacheLumpNum(lumpnum, PU_STATIC);\n\tds_brightmap = R_BrightmapForFlatNum(lumpnum-firstflat);\n\t\n\tplaneheight = abs(pl->height-viewz);\n\tlight = (pl->lightlevel >> LIGHTSEGSHIFT)+(extralight * LIGHTBRIGHT);\n\n\tif (light >= LIGHTLEVELS)\n\t    light = LIGHTLEVELS-1;\n\n\tif (light < 0)\n\t    light = 0;\n\n\tplanezlight = cm_zlight[light];\n\n\tpl->top[pl->maxx+1] = 0xffffffffu; // [crispy] hires / 32-bit integer math\n\tpl->top[pl->minx-1] = 0xffffffffu; // [crispy] hires / 32-bit integer math\n\t\t\n\tstop = pl->maxx + 1;\n\n\tfor (x=pl->minx ; x<= stop ; x++)\n\t{\n\t    R_MakeSpans(x,pl->top[x-1],\n\t\t\tpl->bottom[x-1],\n\t\t\tpl->top[x],\n\t\t\tpl->bottom[x]);\n\t}\n\t\n        W_ReleaseLumpNum(lumpnum);\n    }\n}","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tMission begin melt/wipe screen special effect.\n//\n\n#include <string.h>\n\n#include \"z_zone.h\"\n#include \"i_video.h\"\n#include \"v_video.h\"\n#include \"m_random.h\"\n\n#include \"doomtype.h\"\n\n#include \"f_wipe.h\"\n\n//\n//                       SCREEN WIPE PACKAGE\n//\n\n// when zero, stop the wipe\nstatic boolean\tgo = 0;\n\nstatic pixel_t*\twipe_scr_start;\nstatic pixel_t*\twipe_scr_end;\nstatic pixel_t*\twipe_scr;\n\n\nvoid\nwipe_shittyColMajorXform\n( dpixel_t*\tarray,\n  int\t\twidth,\n  int\t\theight )\n{\n    int\t\tx;\n    int\t\ty;\n    dpixel_t*\tdest;\n\n    dest = (dpixel_t*) Z_Malloc(width*height*sizeof(*dest), PU_STATIC, 0);\n\n    for(y=0;y<height;y++)\n\tfor(x=0;x<width;x++)\n\t    dest[x*height+y] = array[y*width+x];\n\n    memcpy(array, dest, width*height*sizeof(*dest));\n\n    Z_Free(dest);\n\n}\n\nint\nwipe_initColorXForm\n( int\twidth,\n  int\theight,\n  int\tticks )\n{\n    memcpy(wipe_scr, wipe_scr_start, width*height*sizeof(*wipe_scr));\n    return 0;\n}\n\nint\nwipe_doColorXForm\n( int\twidth,\n  int\theight,\n  int\tticks )\n{\n    boolean\tchanged;\n    pixel_t*\tw;\n    pixel_t*\te;\n    int\t\tnewval;\n\n    changed = false;\n    w = wipe_scr;\n    e = wipe_scr_end;\n    \n    while (w!=wipe_scr+width*height)\n    {\n\tif (*w != *e)\n\t{\n\t    if (*w > *e)\n\t    {\n\t\tnewval = *w - ticks;\n\t\tif (newval < *e)\n\t\t    *w = *e;\n\t\telse\n\t\t    *w = newval;\n\t\tchanged = true;\n\t    }\n\t    else if (*w < *e)\n\t    {\n\t\tnewval = *w + ticks;\n\t\tif (newval > *e)\n\t\t    *w = *e;\n\t\telse\n\t\t    *w = newval;\n\t\tchanged = true;\n\t    }\n\t}\n\tw++;\n\te++;\n    }\n\n    return !changed;\n\n}\n\nint\nwipe_exitColorXForm\n( int\twidth,\n  int\theight,\n  int\tticks )\n{\n    return 0;\n}\n\n\nstatic int*\ty;\n\nint\nwipe_initMelt\n( int\twidth,\n  int\theight,\n  int\tticks )\n{\n    int i, r;\n    \n    // copy start screen to main screen\n    memcpy(wipe_scr, wipe_scr_start, width*height*sizeof(*wipe_scr));\n    \n    // makes this wipe faster (in theory)\n    // to have stuff in column-major format\n    wipe_shittyColMajorXform((dpixel_t*)wipe_scr_start, width/2, height);\n    wipe_shittyColMajorXform((dpixel_t*)wipe_scr_end, width/2, height);\n    \n    // setup initial column positions\n    // (y<0 => not ready to scroll yet)\n    y = (int *) Z_Malloc(width*sizeof(int), PU_STATIC, 0);\n    y[0] = -(M_Random()%16);\n    for (i=1;i<width;i++)\n    {\n\tr = (M_Random()%3) - 1;\n\ty[i] = y[i-1] + r;\n\tif (y[i] > 0) y[i] = 0;\n\telse if (y[i] == -16) y[i] = -15;\n    }\n\n    return 0;\n}\n\nint\nwipe_doMelt\n( int\twidth,\n  int\theight,\n  int\tticks )\n{\n    int\t\ti;\n    int\t\tj;\n    int\t\tdy;\n    int\t\tidx;\n    \n    dpixel_t*\ts;\n    dpixel_t*\td;\n    boolean\tdone = true;\n\n    width/=2;\n\n    while (ticks--)\n    {\n\tfor (i=0;i<width;i++)\n\t{\n\t    if (y[i]<0)\n\t    {\n\t\ty[i]++; done = false;\n\t    }\n\t    else if (y[i] < height)\n\t    {\n\t\tdy = (y[i] < 16) ? y[i]+1 : 8;\n\t\tif (y[i]+dy >= height) dy = height - y[i];\n\t\ts = &((dpixel_t *)wipe_scr_end)[i*height+y[i]];\n\t\td = &((dpixel_t *)wipe_scr)[y[i]*width+i];\n\t\tidx = 0;\n\t\tfor (j=dy;j;j--)\n\t\t{\n\t\t    d[idx] = *(s++);\n\t\t    idx += width;\n\t\t}\n\t\ty[i] += dy;\n\t\ts = &((dpixel_t *)wipe_scr_start)[i*height];\n\t\td = &((dpixel_t *)wipe_scr)[y[i]*width+i];\n\t\tidx = 0;\n\t\tfor (j=height-y[i];j;j--)\n\t\t{\n\t\t    d[idx] = *(s++);\n\t\t    idx += width;\n\t\t}\n\t\tdone = false;\n\t    }\n\t}\n    }\n\n    return done;\n\n}\n\nint\nwipe_exitMelt\n( int\twidth,\n  int\theight,\n  int\tticks )\n{\n    Z_Free(y);\n    Z_Free(wipe_scr_start);\n    Z_Free(wipe_scr_end);\n    return 0;\n}\n\nint\nwipe_StartScreen\n( int\tx,\n  int\ty,\n  int\twidth,\n  int\theight )\n{\n    wipe_scr_start = Z_Malloc(SCREENWIDTH * SCREENHEIGHT * sizeof(*wipe_scr_start), PU_STATIC, NULL);\n    I_ReadScreen(wipe_scr_start);\n    return 0;\n}\n\nint\nwipe_EndScreen\n( int\tx,\n  int\ty,\n  int\twidth,\n  int\theight )\n{\n    wipe_scr_end = Z_Malloc(SCREENWIDTH * SCREENHEIGHT * sizeof(*wipe_scr_end), PU_STATIC, NULL);\n    I_ReadScreen(wipe_scr_end);\n    V_DrawBlock(x, y, width, height, wipe_scr_start); // restore start scr.\n    return 0;\n}\n\nint\nwipe_ScreenWipe\n( int\twipeno,\n  int\tx,\n  int\ty,\n  int\twidth,\n  int\theight,\n  int\tticks )\n{\n    int rc;\n    static int (*wipes[])(int, int, int) =\n    {\n\twipe_initColorXForm, wipe_doColorXForm, wipe_exitColorXForm,\n\twipe_initMelt, wipe_doMelt, wipe_exitMelt\n    };\n\n    // initial stuff\n    if (!go)\n    {\n\tgo = 1;\n\t// wipe_scr = (pixel_t *) Z_Malloc(width*height, PU_STATIC, 0); // DEBUG\n\twipe_scr = I_VideoBuffer;\n\t(*wipes[wipeno*3])(width, height, ticks);\n    }\n\n    // do a piece of wipe-in\n    V_MarkRect(0, 0, width, height);\n    rc = (*wipes[wipeno*3+1])(width, height, ticks);\n    //  V_DrawBlock(x, y, 0, width, height, wipe_scr); // DEBUG\n\n    // final stuff\n    if (rc)\n    {\n\tgo = 0;\n\t(*wipes[wipeno*3+2])(width, height, ticks);\n    }\n\n    return !go;\n}\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:  heads-up text and input code\n//\n\n\n#include <ctype.h>\n\n#include \"doomdef.h\"\n#include \"doomkeys.h\"\n\n#include \"v_video.h\"\n#include \"i_video.h\"\n#include \"i_swap.h\"\n\n#include \"hu_lib.h\"\n#include \"r_local.h\"\n#include \"r_draw.h\"\n\n// boolean : whether the screen is always erased\n#define noterased viewwindowx\n\nextern boolean\tautomapactive;\t// in AM_map.c\n\nvoid HUlib_init(void)\n{\n}\n\nvoid HUlib_clearTextLine(hu_textline_t* t)\n{\n    t->len = 0;\n    t->l[0] = 0;\n    t->needsupdate = true;\n}\n\nvoid\nHUlib_initTextLine\n( hu_textline_t*\tt,\n  int\t\t\tx,\n  int\t\t\ty,\n  patch_t**\t\tf,\n  int\t\t\tsc )\n{\n    t->x = x;\n    t->y = y;\n    t->f = f;\n    t->sc = sc;\n    HUlib_clearTextLine(t);\n}\n\nboolean\nHUlib_addCharToTextLine\n( hu_textline_t*\tt,\n  char\t\t\tch )\n{\n\n    if (t->len == HU_MAXLINELENGTH)\n\treturn false;\n    else\n    {\n\tt->l[t->len++] = ch;\n\tt->l[t->len] = 0;\n\tt->needsupdate = 4;\n\treturn true;\n    }\n\n}\n\nboolean HUlib_delCharFromTextLine(hu_textline_t* t)\n{\n\n    if (!t->len) return false;\n    else\n    {\n\tt->l[--t->len] = 0;\n\tt->needsupdate = 4;\n\treturn true;\n    }\n\n}\n\nvoid\nHUlib_drawTextLine\n( hu_textline_t*\tl,\n  boolean\t\tdrawcursor )\n{\n\n    int\t\t\ti;\n    int\t\t\tw;\n    int\t\t\tx;\n    unsigned char\tc;\n\n    // draw the new stuff\n    x = l->x;\n    for (i=0;i<l->len;i++)\n    {\n\tc = toupper(l->l[i]);\n\tif (c != ' '\n\t    && c >= l->sc\n\t    && c <= '_')\n\t{\n\t    w = SHORT(l->f[c - l->sc]->width);\n\t    if (x+w > SCREENWIDTH)\n\t\tbreak;\n\t    V_DrawPatchDirect(x, l->y, l->f[c - l->sc]);\n\t    x += w;\n\t}\n\telse\n\t{\n\t    x += 4;\n\t    if (x >= SCREENWIDTH)\n\t\tbreak;\n\t}\n    }\n\n    // draw the cursor if requested\n    if (drawcursor\n\t&& x + SHORT(l->f['_' - l->sc]->width) <= SCREENWIDTH)\n    {\n\tV_DrawPatchDirect(x, l->y, l->f['_' - l->sc]);\n    }\n}\n\n\n// sorta called by HU_Erase and just better darn get things straight\nvoid HUlib_eraseTextLine(hu_textline_t* l)\n{\n    int\t\t\tlh;\n    int\t\t\ty;\n    int\t\t\tyoffset;\n\n    // Only erases when NOT in automap and the screen is reduced,\n    // and the text must either need updating or refreshing\n    // (because of a recent change back from the automap)\n\n    if (!automapactive &&\n\tviewwindowx && l->needsupdate)\n    {\n\tlh = SHORT(l->f[0]->height) + 1;\n\tfor (y=l->y,yoffset=y*SCREENWIDTH ; y<l->y+lh ; y++,yoffset+=SCREENWIDTH)\n\t{\n\t    if (y < viewwindowy || y >= viewwindowy + viewheight)\n\t\tR_VideoErase(yoffset, SCREENWIDTH); // erase entire line\n\t    else\n\t    {\n\t\tR_VideoErase(yoffset, viewwindowx); // erase left border\n\t\tR_VideoErase(yoffset + viewwindowx + viewwidth, viewwindowx);\n\t\t// erase right border\n\t    }\n\t}\n    }\n\n    if (l->needsupdate) l->needsupdate--;\n\n}\n\nvoid\nHUlib_initSText\n( hu_stext_t*\ts,\n  int\t\tx,\n  int\t\ty,\n  int\t\th,\n  patch_t**\tfont,\n  int\t\tstartchar,\n  boolean*\ton )\n{\n\n    int i;\n\n    s->h = h;\n    s->on = on;\n    s->laston = true;\n    s->cl = 0;\n    for (i=0;i<h;i++)\n\tHUlib_initTextLine(&s->l[i],\n\t\t\t   x, y - i*(SHORT(font[0]->height)+1),\n\t\t\t   font, startchar);\n\n}\n\nvoid HUlib_addLineToSText(hu_stext_t* s)\n{\n\n    int i;\n\n    // add a clear line\n    if (++s->cl == s->h)\n\ts->cl = 0;\n    HUlib_clearTextLine(&s->l[s->cl]);\n\n    // everything needs updating\n    for (i=0 ; i<s->h ; i++)\n\ts->l[i].needsupdate = 4;\n\n}\n\nvoid\nHUlib_addMessageToSText\n( hu_stext_t*\ts,\n  const char*\tprefix,\n  const char*\tmsg )\n{\n    HUlib_addLineToSText(s);\n    if (prefix)\n\twhile (*prefix)\n\t    HUlib_addCharToTextLine(&s->l[s->cl], *(prefix++));\n\n    while (*msg)\n\tHUlib_addCharToTextLine(&s->l[s->cl], *(msg++));\n}\n\nvoid HUlib_drawSText(hu_stext_t* s)\n{\n    int i, idx;\n    hu_textline_t *l;\n\n    if (!*s->on)\n\treturn; // if not on, don't draw\n\n    // draw everything\n    for (i=0 ; i<s->h ; i++)\n    {\n\tidx = s->cl - i;\n\tif (idx < 0)\n\t    idx += s->h; // handle queue of lines\n\t\n\tl = &s->l[idx];\n\n\t// need a decision made here on whether to skip the draw\n\tHUlib_drawTextLine(l, false); // no cursor, please\n    }\n\n}\n\nvoid HUlib_eraseSText(hu_stext_t* s)\n{\n\n    int i;\n\n    for (i=0 ; i<s->h ; i++)\n    {\n\tif (s->laston && !*s->on)\n\t    s->l[i].needsupdate = 4;\n\tHUlib_eraseTextLine(&s->l[i]);\n    }\n    s->laston = *s->on;\n\n}\n\nvoid\nHUlib_initIText\n( hu_itext_t*\tit,\n  int\t\tx,\n  int\t\ty,\n  patch_t**\tfont,\n  int\t\tstartchar,\n  boolean*\ton )\n{\n    it->lm = 0; // default left margin is start of text\n    it->on = on;\n    it->laston = true;\n    HUlib_initTextLine(&it->l, x, y, font, startchar);\n}\n\n\n// The following deletion routines adhere to the left margin restriction\nvoid HUlib_delCharFromIText(hu_itext_t* it)\n{\n    if (it->l.len != it->lm)\n\tHUlib_delCharFromTextLine(&it->l);\n}\n\nvoid HUlib_eraseLineFromIText(hu_itext_t* it)\n{\n    while (it->lm != it->l.len)\n\tHUlib_delCharFromTextLine(&it->l);\n}\n\n// Resets left margin as well\nvoid HUlib_resetIText(hu_itext_t* it)\n{\n    it->lm = 0;\n    HUlib_clearTextLine(&it->l);\n}\n\nvoid\nHUlib_addPrefixToIText\n( hu_itext_t*\tit,\n  char*\t\tstr )\n{\n    while (*str)\n\tHUlib_addCharToTextLine(&it->l, *(str++));\n    it->lm = it->l.len;\n}\n\n// wrapper function for handling general keyed input.\n// returns true if it ate the key\nboolean\nHUlib_keyInIText\n( hu_itext_t*\tit,\n  unsigned char ch )\n{\n    ch = toupper(ch);\n\n    if (ch >= ' ' && ch <= '_') \n  \tHUlib_addCharToTextLine(&it->l, (char) ch);\n    else \n\tif (ch == KEY_BACKSPACE) \n\t    HUlib_delCharFromIText(it);\n\telse \n\t    if (ch != KEY_ENTER) \n\t\treturn false; // did not eat key\n\n    return true; // ate the key\n\n}\n\nvoid HUlib_drawIText(hu_itext_t* it)\n{\n\n    hu_textline_t *l = &it->l;\n\n    if (!*it->on)\n\treturn;\n    HUlib_drawTextLine(l, true); // draw the line w/ cursor\n\n}\n\nvoid HUlib_eraseIText(hu_itext_t* it)\n{\n    if (it->laston && !*it->on)\n\tit->l.needsupdate = 4;\n    HUlib_eraseTextLine(&it->l);\n    it->laston = *it->on;\n}\n\n","//\n// Copyright(C) 2005-2014 Simon Howard\n// Copyright(C) 2014 Fabian Greffrath\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Parses [CODEPTR] sections in BEX files\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"info.h\"\n\n#include \"deh_io.h\"\n#include \"deh_main.h\"\n\nextern void A_Light0();\nextern void A_WeaponReady();\nextern void A_Lower();\nextern void A_Raise();\nextern void A_Punch();\nextern void A_ReFire();\nextern void A_FirePistol();\nextern void A_Light1();\nextern void A_FireShotgun();\nextern void A_Light2();\nextern void A_FireShotgun2();\nextern void A_CheckReload();\nextern void A_OpenShotgun2();\nextern void A_LoadShotgun2();\nextern void A_CloseShotgun2();\nextern void A_FireCGun();\nextern void A_GunFlash();\nextern void A_FireMissile();\nextern void A_Saw();\nextern void A_FirePlasma();\nextern void A_BFGsound();\nextern void A_FireBFG();\nextern void A_BFGSpray();\nextern void A_Explode();\nextern void A_Pain();\nextern void A_PlayerScream();\nextern void A_Fall();\nextern void A_XScream();\nextern void A_Look();\nextern void A_Chase();\nextern void A_FaceTarget();\nextern void A_PosAttack();\nextern void A_Scream();\nextern void A_SPosAttack();\nextern void A_VileChase();\nextern void A_VileStart();\nextern void A_VileTarget();\nextern void A_VileAttack();\nextern void A_StartFire();\nextern void A_Fire();\nextern void A_FireCrackle();\nextern void A_Tracer();\nextern void A_SkelWhoosh();\nextern void A_SkelFist();\nextern void A_SkelMissile();\nextern void A_FatRaise();\nextern void A_FatAttack1();\nextern void A_FatAttack2();\nextern void A_FatAttack3();\nextern void A_BossDeath();\nextern void A_CPosAttack();\nextern void A_CPosRefire();\nextern void A_TroopAttack();\nextern void A_SargAttack();\nextern void A_HeadAttack();\nextern void A_BruisAttack();\nextern void A_SkullAttack();\nextern void A_Metal();\nextern void A_SpidRefire();\nextern void A_BabyMetal();\nextern void A_BspiAttack();\nextern void A_Hoof();\nextern void A_CyberAttack();\nextern void A_PainAttack();\nextern void A_PainDie();\nextern void A_KeenDie();\nextern void A_BrainPain();\nextern void A_BrainScream();\nextern void A_BrainDie();\nextern void A_BrainAwake();\nextern void A_BrainSpit();\nextern void A_SpawnSound();\nextern void A_SpawnFly();\nextern void A_BrainExplode();\n// [crispy] additional BOOM and MBF states, sprites and code pointers\nextern void A_Stop();\nextern void A_Die();\nextern void A_FireOldBFG();\nextern void A_Detonate();\nextern void A_Mushroom();\nextern void A_BetaSkullAttack();\n// [crispy] more MBF code pointers\nextern void A_Spawn();\nextern void A_Turn();\nextern void A_Face();\nextern void A_Scratch();\nextern void A_PlaySound();\nextern void A_RandomJump();\nextern void A_LineEffect();\n\ntypedef struct {\n    const char *mnemonic;\n    const actionf_t pointer;\n} bex_codeptr_t;\n\nstatic const bex_codeptr_t bex_codeptrtable[] = {\n    {\"Light0\", {A_Light0}},\n    {\"WeaponReady\", {A_WeaponReady}},\n    {\"Lower\", {A_Lower}},\n    {\"Raise\", {A_Raise}},\n    {\"Punch\", {A_Punch}},\n    {\"ReFire\", {A_ReFire}},\n    {\"FirePistol\", {A_FirePistol}},\n    {\"Light1\", {A_Light1}},\n    {\"FireShotgun\", {A_FireShotgun}},\n    {\"Light2\", {A_Light2}},\n    {\"FireShotgun2\", {A_FireShotgun2}},\n    {\"CheckReload\", {A_CheckReload}},\n    {\"OpenShotgun2\", {A_OpenShotgun2}},\n    {\"LoadShotgun2\", {A_LoadShotgun2}},\n    {\"CloseShotgun2\", {A_CloseShotgun2}},\n    {\"FireCGun\", {A_FireCGun}},\n    {\"GunFlash\", {A_GunFlash}},\n    {\"FireMissile\", {A_FireMissile}},\n    {\"Saw\", {A_Saw}},\n    {\"FirePlasma\", {A_FirePlasma}},\n    {\"BFGsound\", {A_BFGsound}},\n    {\"FireBFG\", {A_FireBFG}},\n    {\"BFGSpray\", {A_BFGSpray}},\n    {\"Explode\", {A_Explode}},\n    {\"Pain\", {A_Pain}},\n    {\"PlayerScream\", {A_PlayerScream}},\n    {\"Fall\", {A_Fall}},\n    {\"XScream\", {A_XScream}},\n    {\"Look\", {A_Look}},\n    {\"Chase\", {A_Chase}},\n    {\"FaceTarget\", {A_FaceTarget}},\n    {\"PosAttack\", {A_PosAttack}},\n    {\"Scream\", {A_Scream}},\n    {\"SPosAttack\", {A_SPosAttack}},\n    {\"VileChase\", {A_VileChase}},\n    {\"VileStart\", {A_VileStart}},\n    {\"VileTarget\", {A_VileTarget}},\n    {\"VileAttack\", {A_VileAttack}},\n    {\"StartFire\", {A_StartFire}},\n    {\"Fire\", {A_Fire}},\n    {\"FireCrackle\", {A_FireCrackle}},\n    {\"Tracer\", {A_Tracer}},\n    {\"SkelWhoosh\", {A_SkelWhoosh}},\n    {\"SkelFist\", {A_SkelFist}},\n    {\"SkelMissile\", {A_SkelMissile}},\n    {\"FatRaise\", {A_FatRaise}},\n    {\"FatAttack1\", {A_FatAttack1}},\n    {\"FatAttack2\", {A_FatAttack2}},\n    {\"FatAttack3\", {A_FatAttack3}},\n    {\"BossDeath\", {A_BossDeath}},\n    {\"CPosAttack\", {A_CPosAttack}},\n    {\"CPosRefire\", {A_CPosRefire}},\n    {\"TroopAttack\", {A_TroopAttack}},\n    {\"SargAttack\", {A_SargAttack}},\n    {\"HeadAttack\", {A_HeadAttack}},\n    {\"BruisAttack\", {A_BruisAttack}},\n    {\"SkullAttack\", {A_SkullAttack}},\n    {\"Metal\", {A_Metal}},\n    {\"SpidRefire\", {A_SpidRefire}},\n    {\"BabyMetal\", {A_BabyMetal}},\n    {\"BspiAttack\", {A_BspiAttack}},\n    {\"Hoof\", {A_Hoof}},\n    {\"CyberAttack\", {A_CyberAttack}},\n    {\"PainAttack\", {A_PainAttack}},\n    {\"PainDie\", {A_PainDie}},\n    {\"KeenDie\", {A_KeenDie}},\n    {\"BrainPain\", {A_BrainPain}},\n    {\"BrainScream\", {A_BrainScream}},\n    {\"BrainDie\", {A_BrainDie}},\n    {\"BrainAwake\", {A_BrainAwake}},\n    {\"BrainSpit\", {A_BrainSpit}},\n    {\"SpawnSound\", {A_SpawnSound}},\n    {\"SpawnFly\", {A_SpawnFly}},\n    {\"BrainExplode\", {A_BrainExplode}},\n    // [crispy] additional BOOM and MBF states, sprites and code pointers\n    {\"Stop\", {A_Stop}},\n    {\"Die\", {A_Die}},\n    {\"FireOldBFG\", {A_FireOldBFG}},\n    {\"Detonate\", {A_Detonate}},\n    {\"Mushroom\", {A_Mushroom}},\n    {\"BetaSkullAttack\", {A_BetaSkullAttack}},\n    // [crispy] more MBF code pointers\n    {\"Spawn\", {A_Spawn}},\n    {\"Turn\", {A_Turn}},\n    {\"Face\", {A_Face}},\n    {\"Scratch\", {A_Scratch}},\n    {\"PlaySound\", {A_PlaySound}},\n    {\"RandomJump\", {A_RandomJump}},\n    {\"LineEffect\", {A_LineEffect}},\n    {\"NULL\", {NULL}},\n};\n\nextern actionf_t codeptrs[NUMSTATES];\n\nstatic void *DEH_BEXPtrStart(deh_context_t *context, char *line)\n{\n    char s[10];\n\n    if (sscanf(line, \"%9s\", s) == 0 || strcmp(\"[CODEPTR]\", s))\n    {\n\tDEH_Warning(context, \"Parse error on section start\");\n    }\n\n    return NULL;\n}\n\nstatic void DEH_BEXPtrParseLine(deh_context_t *context, char *line, void *tag)\n{\n    state_t *state;\n    char *variable_name, *value, frame_str[6];\n    int frame_number, i;\n\n    // parse \"FRAME nn = mnemonic\", where\n    // variable_name = \"FRAME nn\" and value = \"mnemonic\"\n    if (!DEH_ParseAssignment(line, &variable_name, &value))\n    {\n\tDEH_Warning(context, \"Failed to parse assignment: %s\", line);\n\treturn;\n    }\n\n    // parse \"FRAME nn\", where frame_number = \"nn\"\n    if (sscanf(variable_name, \"%5s %32d\", frame_str, &frame_number) != 2 ||\n        strcasecmp(frame_str, \"FRAME\"))\n    {\n\tDEH_Warning(context, \"Failed to parse assignment: %s\", variable_name);\n\treturn;\n    }\n\n    if (frame_number < 0 || frame_number >= NUMSTATES)\n    {\n\tDEH_Warning(context, \"Invalid frame number: %i\", frame_number);\n\treturn;\n    }\n\n    state = (state_t *) &states[frame_number];\n\n    for (i = 0; i < arrlen(bex_codeptrtable); i++)\n    {\n\tif (!strcasecmp(bex_codeptrtable[i].mnemonic, value))\n\t{\n\t    state->action = bex_codeptrtable[i].pointer;\n\t    return;\n\t}\n    }\n\n    DEH_Warning(context, \"Invalid mnemonic '%s'\", value);\n}\n\ndeh_section_t deh_section_bexptr =\n{\n    \"[CODEPTR]\",\n    NULL,\n    DEH_BEXPtrStart,\n    DEH_BEXPtrParseLine,\n    NULL,\n    NULL,\n};\n","//\n// Copyright(C) 2005-2014 Simon Howard\n// Copyright(C) 2014 Fabian Greffrath\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Parses [STRINGS] sections in BEX files\n//\n\n#include <stdio.h>\n#include <string.h>\n\n#include \"deh_defs.h\"\n#include \"deh_io.h\"\n#include \"deh_main.h\"\n\n#include \"dstrings.h\"\n\ntypedef struct {\n    const char *macro;\n    const char *string;\n} bex_string_t;\n\n// mnemonic keys table\nstatic const bex_string_t bex_stringtable[] = {\n    // part 1 - general initialization and prompts\n    {\"D_DEVSTR\", D_DEVSTR},\n    {\"D_CDROM\", D_CDROM},\n    {\"QUITMSG\", QUITMSG},\n    {\"LOADNET\", LOADNET},\n    {\"QLOADNET\", QLOADNET},\n    {\"QSAVESPOT\", QSAVESPOT},\n    {\"SAVEDEAD\", SAVEDEAD},\n    {\"QSPROMPT\", QSPROMPT},\n    {\"QLPROMPT\", QLPROMPT},\n    {\"NEWGAME\", NEWGAME},\n    {\"NIGHTMARE\", NIGHTMARE},\n    {\"SWSTRING\", SWSTRING},\n    {\"MSGOFF\", MSGOFF},\n    {\"MSGON\", MSGON},\n    {\"NETEND\", NETEND},\n    {\"ENDGAME\", ENDGAME},\n    {\"DETAILHI\", DETAILHI},\n    {\"DETAILLO\", DETAILLO},\n    {\"GAMMALVL0\", GAMMALVL0},\n    {\"GAMMALVL1\", GAMMALVL1},\n    {\"GAMMALVL2\", GAMMALVL2},\n    {\"GAMMALVL3\", GAMMALVL3},\n    {\"GAMMALVL4\", GAMMALVL4},\n    {\"EMPTYSTRING\", EMPTYSTRING},\n    {\"GGSAVED\", GGSAVED},\n    {\"SAVEGAMENAME\", SAVEGAMENAME},\n    // part 2 - messages when the player gets things\n    {\"GOTARMOR\", GOTARMOR},\n    {\"GOTMEGA\", GOTMEGA},\n    {\"GOTHTHBONUS\", GOTHTHBONUS},\n    {\"GOTARMBONUS\", GOTARMBONUS},\n    {\"GOTSTIM\", GOTSTIM},\n    {\"GOTMEDINEED\", GOTMEDINEED},\n    {\"GOTMEDIKIT\", GOTMEDIKIT},\n    {\"GOTSUPER\", GOTSUPER},\n    {\"GOTBLUECARD\", GOTBLUECARD},\n    {\"GOTYELWCARD\", GOTYELWCARD},\n    {\"GOTREDCARD\", GOTREDCARD},\n    {\"GOTBLUESKUL\", GOTBLUESKUL},\n    {\"GOTYELWSKUL\", GOTYELWSKUL},\n    {\"GOTREDSKULL\", GOTREDSKULL},\n    {\"GOTINVUL\", GOTINVUL},\n    {\"GOTBERSERK\", GOTBERSERK},\n    {\"GOTINVIS\", GOTINVIS},\n    {\"GOTSUIT\", GOTSUIT},\n    {\"GOTMAP\", GOTMAP},\n    {\"GOTVISOR\", GOTVISOR},\n    {\"GOTMSPHERE\", GOTMSPHERE},\n    {\"GOTCLIP\", GOTCLIP},\n    {\"GOTCLIPBOX\", GOTCLIPBOX},\n    {\"GOTROCKET\", GOTROCKET},\n    {\"GOTROCKBOX\", GOTROCKBOX},\n    {\"GOTCELL\", GOTCELL},\n    {\"GOTCELLBOX\", GOTCELLBOX},\n    {\"GOTSHELLS\", GOTSHELLS},\n    {\"GOTSHELLBOX\", GOTSHELLBOX},\n    {\"GOTBACKPACK\", GOTBACKPACK},\n    {\"GOTBFG9000\", GOTBFG9000},\n    {\"GOTCHAINGUN\", GOTCHAINGUN},\n    {\"GOTCHAINSAW\", GOTCHAINSAW},\n    {\"GOTLAUNCHER\", GOTLAUNCHER},\n    {\"GOTPLASMA\", GOTPLASMA},\n    {\"GOTSHOTGUN\", GOTSHOTGUN},\n    {\"GOTSHOTGUN2\", GOTSHOTGUN2},\n    // part 3 - messages when keys are needed\n    {\"PD_BLUEO\", PD_BLUEO},\n    {\"PD_REDO\", PD_REDO},\n    {\"PD_YELLOWO\", PD_YELLOWO},\n    {\"PD_BLUEK\", PD_BLUEK},\n    {\"PD_REDK\", PD_REDK},\n    {\"PD_YELLOWK\", PD_YELLOWK},\n    {\"PD_ANY\", PD_ANY},\n    {\"PD_ALL3\", PD_ALL3},\n    {\"PD_ALL6\", PD_ALL6},\n    // part 4 - multiplayer messaging\n    {\"HUSTR_MSGU\", HUSTR_MSGU},\n    {\"HUSTR_MESSAGESENT\", HUSTR_MESSAGESENT},\n    {\"HUSTR_CHATMACRO0\", HUSTR_CHATMACRO0},\n    {\"HUSTR_CHATMACRO1\", HUSTR_CHATMACRO1},\n    {\"HUSTR_CHATMACRO2\", HUSTR_CHATMACRO2},\n    {\"HUSTR_CHATMACRO3\", HUSTR_CHATMACRO3},\n    {\"HUSTR_CHATMACRO4\", HUSTR_CHATMACRO4},\n    {\"HUSTR_CHATMACRO5\", HUSTR_CHATMACRO5},\n    {\"HUSTR_CHATMACRO6\", HUSTR_CHATMACRO6},\n    {\"HUSTR_CHATMACRO7\", HUSTR_CHATMACRO7},\n    {\"HUSTR_CHATMACRO8\", HUSTR_CHATMACRO8},\n    {\"HUSTR_CHATMACRO9\", HUSTR_CHATMACRO9},\n    {\"HUSTR_TALKTOSELF1\", HUSTR_TALKTOSELF1},\n    {\"HUSTR_TALKTOSELF2\", HUSTR_TALKTOSELF2},\n    {\"HUSTR_TALKTOSELF3\", HUSTR_TALKTOSELF3},\n    {\"HUSTR_TALKTOSELF4\", HUSTR_TALKTOSELF4},\n    {\"HUSTR_TALKTOSELF5\", HUSTR_TALKTOSELF5},\n    {\"HUSTR_PLRGREEN\", HUSTR_PLRGREEN},\n    {\"HUSTR_PLRINDIGO\", HUSTR_PLRINDIGO},\n    {\"HUSTR_PLRBROWN\", HUSTR_PLRBROWN},\n    {\"HUSTR_PLRRED\", HUSTR_PLRRED},\n    // part 5 - level names in the automap\n    {\"HUSTR_E1M1\", HUSTR_E1M1},\n    {\"HUSTR_E1M2\", HUSTR_E1M2},\n    {\"HUSTR_E1M3\", HUSTR_E1M3},\n    {\"HUSTR_E1M4\", HUSTR_E1M4},\n    {\"HUSTR_E1M5\", HUSTR_E1M5},\n    {\"HUSTR_E1M6\", HUSTR_E1M6},\n    {\"HUSTR_E1M7\", HUSTR_E1M7},\n    {\"HUSTR_E1M8\", HUSTR_E1M8},\n    {\"HUSTR_E1M9\", HUSTR_E1M9},\n    {\"HUSTR_E2M1\", HUSTR_E2M1},\n    {\"HUSTR_E2M2\", HUSTR_E2M2},\n    {\"HUSTR_E2M3\", HUSTR_E2M3},\n    {\"HUSTR_E2M4\", HUSTR_E2M4},\n    {\"HUSTR_E2M5\", HUSTR_E2M5},\n    {\"HUSTR_E2M6\", HUSTR_E2M6},\n    {\"HUSTR_E2M7\", HUSTR_E2M7},\n    {\"HUSTR_E2M8\", HUSTR_E2M8},\n    {\"HUSTR_E2M9\", HUSTR_E2M9},\n    {\"HUSTR_E3M1\", HUSTR_E3M1},\n    {\"HUSTR_E3M2\", HUSTR_E3M2},\n    {\"HUSTR_E3M3\", HUSTR_E3M3},\n    {\"HUSTR_E3M4\", HUSTR_E3M4},\n    {\"HUSTR_E3M5\", HUSTR_E3M5},\n    {\"HUSTR_E3M6\", HUSTR_E3M6},\n    {\"HUSTR_E3M7\", HUSTR_E3M7},\n    {\"HUSTR_E3M8\", HUSTR_E3M8},\n    {\"HUSTR_E3M9\", HUSTR_E3M9},\n    {\"HUSTR_E4M1\", HUSTR_E4M1},\n    {\"HUSTR_E4M2\", HUSTR_E4M2},\n    {\"HUSTR_E4M3\", HUSTR_E4M3},\n    {\"HUSTR_E4M4\", HUSTR_E4M4},\n    {\"HUSTR_E4M5\", HUSTR_E4M5},\n    {\"HUSTR_E4M6\", HUSTR_E4M6},\n    {\"HUSTR_E4M7\", HUSTR_E4M7},\n    {\"HUSTR_E4M8\", HUSTR_E4M8},\n    {\"HUSTR_E4M9\", HUSTR_E4M9},\n    {\"HUSTR_1\", HUSTR_1},\n    {\"HUSTR_2\", HUSTR_2},\n    {\"HUSTR_3\", HUSTR_3},\n    {\"HUSTR_4\", HUSTR_4},\n    {\"HUSTR_5\", HUSTR_5},\n    {\"HUSTR_6\", HUSTR_6},\n    {\"HUSTR_7\", HUSTR_7},\n    {\"HUSTR_8\", HUSTR_8},\n    {\"HUSTR_9\", HUSTR_9},\n    {\"HUSTR_10\", HUSTR_10},\n    {\"HUSTR_11\", HUSTR_11},\n    {\"HUSTR_12\", HUSTR_12},\n    {\"HUSTR_13\", HUSTR_13},\n    {\"HUSTR_14\", HUSTR_14},\n    {\"HUSTR_15\", HUSTR_15},\n    {\"HUSTR_16\", HUSTR_16},\n    {\"HUSTR_17\", HUSTR_17},\n    {\"HUSTR_18\", HUSTR_18},\n    {\"HUSTR_19\", HUSTR_19},\n    {\"HUSTR_20\", HUSTR_20},\n    {\"HUSTR_21\", HUSTR_21},\n    {\"HUSTR_22\", HUSTR_22},\n    {\"HUSTR_23\", HUSTR_23},\n    {\"HUSTR_24\", HUSTR_24},\n    {\"HUSTR_25\", HUSTR_25},\n    {\"HUSTR_26\", HUSTR_26},\n    {\"HUSTR_27\", HUSTR_27},\n    {\"HUSTR_28\", HUSTR_28},\n    {\"HUSTR_29\", HUSTR_29},\n    {\"HUSTR_30\", HUSTR_30},\n    {\"HUSTR_31\", HUSTR_31},\n    {\"HUSTR_32\", HUSTR_32},\n    {\"PHUSTR_1\", PHUSTR_1},\n    {\"PHUSTR_2\", PHUSTR_2},\n    {\"PHUSTR_3\", PHUSTR_3},\n    {\"PHUSTR_4\", PHUSTR_4},\n    {\"PHUSTR_5\", PHUSTR_5},\n    {\"PHUSTR_6\", PHUSTR_6},\n    {\"PHUSTR_7\", PHUSTR_7},\n    {\"PHUSTR_8\", PHUSTR_8},\n    {\"PHUSTR_9\", PHUSTR_9},\n    {\"PHUSTR_10\", PHUSTR_10},\n    {\"PHUSTR_11\", PHUSTR_11},\n    {\"PHUSTR_12\", PHUSTR_12},\n    {\"PHUSTR_13\", PHUSTR_13},\n    {\"PHUSTR_14\", PHUSTR_14},\n    {\"PHUSTR_15\", PHUSTR_15},\n    {\"PHUSTR_16\", PHUSTR_16},\n    {\"PHUSTR_17\", PHUSTR_17},\n    {\"PHUSTR_18\", PHUSTR_18},\n    {\"PHUSTR_19\", PHUSTR_19},\n    {\"PHUSTR_20\", PHUSTR_20},\n    {\"PHUSTR_21\", PHUSTR_21},\n    {\"PHUSTR_22\", PHUSTR_22},\n    {\"PHUSTR_23\", PHUSTR_23},\n    {\"PHUSTR_24\", PHUSTR_24},\n    {\"PHUSTR_25\", PHUSTR_25},\n    {\"PHUSTR_26\", PHUSTR_26},\n    {\"PHUSTR_27\", PHUSTR_27},\n    {\"PHUSTR_28\", PHUSTR_28},\n    {\"PHUSTR_29\", PHUSTR_29},\n    {\"PHUSTR_30\", PHUSTR_30},\n    {\"PHUSTR_31\", PHUSTR_31},\n    {\"PHUSTR_32\", PHUSTR_32},\n    {\"THUSTR_1\", THUSTR_1},\n    {\"THUSTR_2\", THUSTR_2},\n    {\"THUSTR_3\", THUSTR_3},\n    {\"THUSTR_4\", THUSTR_4},\n    {\"THUSTR_5\", THUSTR_5},\n    {\"THUSTR_6\", THUSTR_6},\n    {\"THUSTR_7\", THUSTR_7},\n    {\"THUSTR_8\", THUSTR_8},\n    {\"THUSTR_9\", THUSTR_9},\n    {\"THUSTR_10\", THUSTR_10},\n    {\"THUSTR_11\", THUSTR_11},\n    {\"THUSTR_12\", THUSTR_12},\n    {\"THUSTR_13\", THUSTR_13},\n    {\"THUSTR_14\", THUSTR_14},\n    {\"THUSTR_15\", THUSTR_15},\n    {\"THUSTR_16\", THUSTR_16},\n    {\"THUSTR_17\", THUSTR_17},\n    {\"THUSTR_18\", THUSTR_18},\n    {\"THUSTR_19\", THUSTR_19},\n    {\"THUSTR_20\", THUSTR_20},\n    {\"THUSTR_21\", THUSTR_21},\n    {\"THUSTR_22\", THUSTR_22},\n    {\"THUSTR_23\", THUSTR_23},\n    {\"THUSTR_24\", THUSTR_24},\n    {\"THUSTR_25\", THUSTR_25},\n    {\"THUSTR_26\", THUSTR_26},\n    {\"THUSTR_27\", THUSTR_27},\n    {\"THUSTR_28\", THUSTR_28},\n    {\"THUSTR_29\", THUSTR_29},\n    {\"THUSTR_30\", THUSTR_30},\n    {\"THUSTR_31\", THUSTR_31},\n    {\"THUSTR_32\", THUSTR_32},\n    // part 6 - messages as a result of toggling states\n    {\"AMSTR_FOLLOWON\", AMSTR_FOLLOWON},\n    {\"AMSTR_FOLLOWOFF\", AMSTR_FOLLOWOFF},\n    {\"AMSTR_GRIDON\", AMSTR_GRIDON},\n    {\"AMSTR_GRIDOFF\", AMSTR_GRIDOFF},\n    {\"AMSTR_MARKEDSPOT\", AMSTR_MARKEDSPOT},\n    {\"AMSTR_MARKSCLEARED\", AMSTR_MARKSCLEARED},\n    {\"STSTR_MUS\", STSTR_MUS},\n    {\"STSTR_NOMUS\", STSTR_NOMUS},\n    {\"STSTR_DQDON\", STSTR_DQDON},\n    {\"STSTR_DQDOFF\", STSTR_DQDOFF},\n    {\"STSTR_KFAADDED\", STSTR_KFAADDED},\n    {\"STSTR_FAADDED\", STSTR_FAADDED},\n    {\"STSTR_NCON\", STSTR_NCON},\n    {\"STSTR_NCOFF\", STSTR_NCOFF},\n    {\"STSTR_BEHOLD\", STSTR_BEHOLD},\n    {\"STSTR_BEHOLDX\", STSTR_BEHOLDX},\n    {\"STSTR_CHOPPERS\", STSTR_CHOPPERS},\n    {\"STSTR_CLEV\", STSTR_CLEV},\n    // part 7 - episode intermission texts\n    {\"E1TEXT\", E1TEXT},\n    {\"E2TEXT\", E2TEXT},\n    {\"E3TEXT\", E3TEXT},\n    {\"E4TEXT\", E4TEXT},\n    {\"C1TEXT\", C1TEXT},\n    {\"C2TEXT\", C2TEXT},\n    {\"C3TEXT\", C3TEXT},\n    {\"C4TEXT\", C4TEXT},\n    {\"C5TEXT\", C5TEXT},\n    {\"C6TEXT\", C6TEXT},\n    {\"P1TEXT\", P1TEXT},\n    {\"P2TEXT\", P2TEXT},\n    {\"P3TEXT\", P3TEXT},\n    {\"P4TEXT\", P4TEXT},\n    {\"P5TEXT\", P5TEXT},\n    {\"P6TEXT\", P6TEXT},\n    {\"T1TEXT\", T1TEXT},\n    {\"T2TEXT\", T2TEXT},\n    {\"T3TEXT\", T3TEXT},\n    {\"T4TEXT\", T4TEXT},\n    {\"T5TEXT\", T5TEXT},\n    {\"T6TEXT\", T6TEXT},\n    // part 8 - creature names for the finale\n    {\"CC_ZOMBIE\", CC_ZOMBIE},\n    {\"CC_SHOTGUN\", CC_SHOTGUN},\n    {\"CC_HEAVY\", CC_HEAVY},\n    {\"CC_IMP\", CC_IMP},\n    {\"CC_DEMON\", CC_DEMON},\n    {\"CC_LOST\", CC_LOST},\n    {\"CC_CACO\", CC_CACO},\n    {\"CC_HELL\", CC_HELL},\n    {\"CC_BARON\", CC_BARON},\n    {\"CC_ARACH\", CC_ARACH},\n    {\"CC_PAIN\", CC_PAIN},\n    {\"CC_REVEN\", CC_REVEN},\n    {\"CC_MANCU\", CC_MANCU},\n    {\"CC_ARCH\", CC_ARCH},\n    {\"CC_SPIDER\", CC_SPIDER},\n    {\"CC_CYBER\", CC_CYBER},\n    {\"CC_HERO\", CC_HERO},\n    // part 9 - intermission tiled backgrounds\n    {\"BGFLATE1\", \"FLOOR4_8\"},\n    {\"BGFLATE2\", \"SFLR6_1\"},\n    {\"BGFLATE3\", \"MFLR8_4\"},\n    {\"BGFLATE4\", \"MFLR8_3\"},\n    {\"BGFLAT06\", \"SLIME16\"},\n    {\"BGFLAT11\", \"RROCK14\"},\n    {\"BGFLAT20\", \"RROCK07\"},\n    {\"BGFLAT30\", \"RROCK17\"},\n    {\"BGFLAT15\", \"RROCK13\"},\n    {\"BGFLAT31\", \"RROCK19\"},\n    {\"BGCASTCALL\", \"BOSSBACK\"},\n};\n\nstatic void *DEH_BEXStrStart(deh_context_t *context, char *line)\n{\n    char s[10];\n\n    if (sscanf(line, \"%9s\", s) == 0 || strncmp(\"[STRINGS]\", s, sizeof(s)))\n    {\n\tDEH_Warning(context, \"Parse error on section start\");\n    }\n\n    return NULL;\n}\n\nstatic void DEH_BEXStrParseLine(deh_context_t *context, char *line, void *tag)\n{\n    char *variable_name, *value;\n    int i;\n\n    if (!DEH_ParseAssignment(line, &variable_name, &value))\n    {\n\tDEH_Warning(context, \"Failed to parse assignment\");\n\treturn;\n    }\n\n    for (i = 0; i < arrlen(bex_stringtable); i++)\n    {\n\tif (!strcmp(bex_stringtable[i].macro, variable_name))\n\t{\n\t    DEH_AddStringReplacement(bex_stringtable[i].string, value);\n\t}\n    }\n}\n\ndeh_section_t deh_section_bexstr =\n{\n    \"[STRINGS]\",\n    NULL,\n    DEH_BEXStrStart,\n    DEH_BEXStrParseLine,\n    NULL,\n    NULL,\n};\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tMain program, simply calls D_DoomMain high level loop.\n//\n\n#include \"config.h\"\n\n#include <stdio.h>\n\n#include \"SDL.h\"\n\n#include \"doomtype.h\"\n#include \"i_system.h\"\n#include \"m_argv.h\"\n\n#include <emscripten.h>\n\n//\n// D_DoomMain()\n// Not a globally visible function, just included for source reference,\n// calls all startup code, parses command line options.\n//\n\nvoid D_DoomMain (void);\n\nint main(int argc, char **argv)\n{\n    // save arguments\n\n    myargc = argc;\n    myargv = argv;\n\n    M_FindResponseFile();\n\n    // start doom\n\n    D_DoomMain ();\n\n    return 0;\n}\n\nEMSCRIPTEN_KEEPALIVE\nint start()\n{\n    return main(0, NULL);\n}","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tTeleportation.\n//\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"doomdef.h\"\n#include \"doomstat.h\"\n\n#include \"s_sound.h\"\n\n#include \"p_local.h\"\n\n\n// Data.\n#include \"sounds.h\"\n\n// State.\n#include \"r_state.h\"\n\n// from PrBoom+\n#include \"p_spec.h\"\n// #include \"p_maputl.h\"\n// #include \"p_map.h\"\n#include \"r_main.h\"\n#include \"p_tick.h\"\n#include \"s_sound.h\"\n#include \"sounds.h\"\n\nstatic mobj_t* P_TeleportDestination(line_t* line)\n{\n  int i;\n  for (i = -1; (i = P_FindSectorFromLineTag(line, i)) >= 0;) {\n    register thinker_t* th = NULL;\n    for (th = thinkercap.next ; th != &thinkercap ; th=th->next)\n      if (th->function.acp1 == (actionf_p1) P_MobjThinker) {\n        register mobj_t* m = (mobj_t*)th;\n        if (m->type == MT_TELEPORTMAN  &&\n            ((sectors - m->subsector->sector) == i))\n            return m;\n      }\n  }\n  return NULL;\n}\n\n//\n// TELEPORTATION\n//\nint\nEV_Teleport\n( line_t*\tline,\n  int\t\tside,\n  mobj_t*\tthing )\n{\n    int\t\ti;\n    int\t\ttag;\n    mobj_t*\tm;\n    mobj_t*\tfog;\n    unsigned\tan;\n    thinker_t*\tthinker;\n    sector_t*\tsector;\n    fixed_t\toldx;\n    fixed_t\toldy;\n    fixed_t\toldz;\n\n    // don't teleport missiles\n    if (thing->flags & MF_MISSILE)\n\treturn 0;\t\t\n\n    // Don't teleport if hit back of line,\n    //  so you can get out of teleporter.\n    if (side == 1)\t\t\n\treturn 0;\t\n\n    \n    tag = line->tag;\n    for (i = 0; i < numsectors; i++)\n    {\n\tif (sectors[ i ].tag == tag )\n\t{\n\t    thinker = thinkercap.next;\n\t    for (thinker = thinkercap.next;\n\t\t thinker != &thinkercap;\n\t\t thinker = thinker->next)\n\t    {\n\t\t// not a mobj\n\t\tif (thinker->function.acp1 != (actionf_p1)P_MobjThinker)\n\t\t    continue;\t\n\n\t\tm = (mobj_t *)thinker;\n\t\t\n\t\t// not a teleportman\n\t\tif (m->type != MT_TELEPORTMAN )\n\t\t    continue;\t\t\n\n\t\tsector = m->subsector->sector;\n\t\t// wrong sector\n\t\tif (sector-sectors != i )\n\t\t    continue;\t\n\n\t\toldx = thing->x;\n\t\toldy = thing->y;\n\t\toldz = thing->z;\n\t\t\t\t\n\t\tif (!P_TeleportMove (thing, m->x, m->y))\n\t\t    return 0;\n\n                // The first Final Doom executable does not set thing->z\n                // when teleporting. This quirk is unique to this\n                // particular version; the later version included in\n                // some versions of the Id Anthology fixed this.\n\n                if (gameversion != exe_final)\n\t\t    thing->z = thing->floorz;\n\n\t\tif (thing->player)\n\t\t    thing->player->viewz = thing->z+thing->player->viewheight;\n\n\t\t// spawn teleport fog at source and destination\n\t\tfog = P_SpawnMobj (oldx, oldy, oldz, MT_TFOG);\n\t\tS_StartSound (fog, sfx_telept);\n\t\tan = m->angle >> ANGLETOFINESHIFT;\n\t\tfog = P_SpawnMobj (m->x+20*finecosine[an], m->y+20*finesine[an]\n\t\t\t\t   , thing->z, MT_TFOG);\n\n\t\t// emit sound, where?\n\t\tS_StartSound (fog, sfx_telept);\n\t\t\n\t\t// don't move for a bit\n\t\tif (thing->player)\n\t\t    thing->reactiontime = 18;\t\n\n\t\tthing->angle = m->angle;\n\t\tthing->momx = thing->momy = thing->momz = 0;\n\t\treturn 1;\n\t    }\t\n\t}\n    }\n    return 0;\n}\n\n//\n// Silent TELEPORTATION, by Lee Killough\n// Primarily for rooms-over-rooms etc.\n//\n\nint EV_SilentTeleport(line_t *line, int side, mobj_t *thing)\n{\n  mobj_t    *m;\n\n  // don't teleport missiles\n  // Don't teleport if hit back of line,\n  // so you can get out of teleporter.\n\n  if (side || thing->flags & MF_MISSILE)\n    return 0;\n\n  if ((m = P_TeleportDestination(line)) != NULL)\n        {\n          // Height of thing above ground, in case of mid-air teleports:\n          fixed_t z = thing->z - thing->floorz;\n\n          // Get the angle between the exit thing and source linedef.\n          // Rotate 90 degrees, so that walking perpendicularly across\n          // teleporter linedef causes thing to exit in the direction\n          // indicated by the exit thing.\n          angle_t angle =\n            R_PointToAngle2(0, 0, line->dx, line->dy) - m->angle + ANG90;\n\n          // Sine, cosine of angle adjustment\n          fixed_t s = finesine[angle>>ANGLETOFINESHIFT];\n          fixed_t c = finecosine[angle>>ANGLETOFINESHIFT];\n\n          // Momentum of thing crossing teleporter linedef\n          fixed_t momx = thing->momx;\n          fixed_t momy = thing->momy;\n\n          // Whether this is a player, and if so, a pointer to its player_t\n          player_t *player = thing->player;\n\n          // Attempt to teleport, aborting if blocked\n          if (!P_TeleportMove(thing, m->x, m->y)) /* killough 8/9/98 */\n            return 0;\n\n          // Rotate thing according to difference in angles\n          thing->angle += angle;\n\n          // Adjust z position to be same height above ground as before\n          thing->z = z + thing->floorz;\n\n          // Rotate thing's momentum to come out of exit just like it entered\n          thing->momx = FixedMul(momx, c) - FixedMul(momy, s);\n          thing->momy = FixedMul(momy, c) + FixedMul(momx, s);\n\n          // Adjust player's view, in case there has been a height change\n          // Voodoo dolls are excluded by making sure player->mo == thing.\n          if (player && player->mo == thing)\n            {\n              // Save the current deltaviewheight, used in stepping\n              fixed_t deltaviewheight = player->deltaviewheight;\n\n              // Clear deltaviewheight, since we don't want any changes\n              player->deltaviewheight = 0;\n\n              // Set player's view according to the newly set parameters\n\t\t      player->viewz = thing->z+player->viewheight;\n            //   P_CalcHeight(player);\n\n              // Reset the delta to have the same dynamics as before\n              player->deltaviewheight = deltaviewheight;\n            }\n          \n          // e6y\n        //   if (player && player->mo == thing)\n        //     R_ResetAfterTeleport(player);\n\n          return 1;\n        }\n  return 0;\n}\n\n//\n// Silent linedef-based TELEPORTATION, by Lee Killough\n// Primarily for rooms-over-rooms etc.\n// This is the complete player-preserving kind of teleporter.\n// It has advantages over the teleporter with thing exits.\n//\n\n// maximum fixed_t units to move object to avoid hiccups\n#define FUDGEFACTOR 10\n\nint EV_SilentLineTeleport(line_t *line, int side, mobj_t *thing,\n                          boolean reverse)\n{\n  int i;\n  line_t *l;\n\n  if (side || thing->flags & MF_MISSILE)\n    return 0;\n\n  for (i = -1; (i = P_FindLineFromLineTag(line, i)) >= 0;)\n    if ((l=lines+i) != line && l->backsector)\n      {\n        // Get the thing's position along the source linedef\n        fixed_t pos = abs(line->dx) > abs(line->dy) ?\n          FixedDiv(thing->x - line->v1->x, line->dx) :\n          FixedDiv(thing->y - line->v1->y, line->dy) ;\n\n        // Get the angle between the two linedefs, for rotating\n        // orientation and momentum. Rotate 180 degrees, and flip\n        // the position across the exit linedef, if reversed.\n        angle_t angle = (reverse ? pos = FRACUNIT-pos, 0 : ANG180) +\n          R_PointToAngle2(0, 0, l->dx, l->dy) -\n          R_PointToAngle2(0, 0, line->dx, line->dy);\n\n        // Interpolate position across the exit linedef\n        fixed_t x = l->v2->x - FixedMul(pos, l->dx);\n        fixed_t y = l->v2->y - FixedMul(pos, l->dy);\n\n        // Sine, cosine of angle adjustment\n        fixed_t s = finesine[angle>>ANGLETOFINESHIFT];\n        fixed_t c = finecosine[angle>>ANGLETOFINESHIFT];\n\n        // Maximum distance thing can be moved away from interpolated\n        // exit, to ensure that it is on the correct side of exit linedef\n        int fudge = FUDGEFACTOR;\n\n        // Whether this is a player, and if so, a pointer to its player_t.\n        // Voodoo dolls are excluded by making sure thing->player->mo==thing.\n        player_t *player = thing->player && thing->player->mo == thing ?\n          thing->player : NULL;\n\n        // Whether walking towards first side of exit linedef steps down\n        int stepdown =\n          l->frontsector->floorheight < l->backsector->floorheight;\n\n        // Height of thing above ground\n        fixed_t z = thing->z - thing->floorz;\n\n        // Side to exit the linedef on positionally.\n        //\n        // Notes:\n        //\n        // This flag concerns exit position, not momentum. Due to\n        // roundoff error, the thing can land on either the left or\n        // the right side of the exit linedef, and steps must be\n        // taken to make sure it does not end up on the wrong side.\n        //\n        // Exit momentum is always towards side 1 in a reversed\n        // teleporter, and always towards side 0 otherwise.\n        //\n        // Exiting positionally on side 1 is always safe, as far\n        // as avoiding oscillations and stuck-in-wall problems,\n        // but may not be optimum for non-reversed teleporters.\n        //\n        // Exiting on side 0 can cause oscillations if momentum\n        // is towards side 1, as it is with reversed teleporters.\n        //\n        // Exiting on side 1 slightly improves player viewing\n        // when going down a step on a non-reversed teleporter.\n\n        int side = reverse || (player && stepdown);\n\n        // Make sure we are on correct side of exit linedef.\n        while (P_PointOnLineSide(x, y, l) != side && --fudge>=0)\n          if (abs(l->dx) > abs(l->dy))\n            y -= (l->dx < 0) != side ? -1 : 1;\n          else\n            x += (l->dy < 0) != side ? -1 : 1;\n\n        // Attempt to teleport, aborting if blocked\n        if (!P_TeleportMove(thing, x, y)) /* killough 8/9/98 */\n          return 0;\n\n        // e6y\n        // if (player && player->mo == thing)\n        //   R_ResetAfterTeleport(player);\n\n        // Adjust z position to be same height above ground as before.\n        // Ground level at the exit is measured as the higher of the\n        // two floor heights at the exit linedef.\n        thing->z = z + sides[l->sidenum[stepdown]].sector->floorheight;\n\n        // Rotate thing's orientation according to difference in linedef angles\n        thing->angle += angle;\n\n        // Momentum of thing crossing teleporter linedef\n        x = thing->momx;\n        y = thing->momy;\n\n        // Rotate thing's momentum to come out of exit just like it entered\n        thing->momx = FixedMul(x, c) - FixedMul(y, s);\n        thing->momy = FixedMul(y, c) + FixedMul(x, s);\n\n        // Adjust a player's view, in case there has been a height change\n        if (player)\n          {\n            // Save the current deltaviewheight, used in stepping\n            fixed_t deltaviewheight = player->deltaviewheight;\n\n            // Clear deltaviewheight, since we don't want any changes now\n            player->deltaviewheight = 0;\n\n            // Set player's view according to the newly set parameters\n\t\t\tplayer->viewz = thing->z+player->viewheight;\n            // P_CalcHeight(player);\n\n            // Reset the delta to have the same dynamics as before\n            player->deltaviewheight = deltaviewheight;\n          }\n\n        // e6y\n        // if (player && player->mo == thing)\n        //   R_ResetAfterTeleport(player);\n\n        return 1;\n      }\n  return 0;\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tArchiving: SaveGame I/O.\n//\tThinker, Ticker.\n//\n\n\n#include \"z_zone.h\"\n#include \"p_local.h\"\n\n#include \"doomstat.h\"\n\n\nint\tleveltime;\n\n//\n// THINKERS\n// All thinkers should be allocated by Z_Malloc\n// so they can be operated on uniformly.\n// The actual structures will vary in size,\n// but the first element must be thinker_t.\n//\n\n\n\n// Both the head and tail of the thinker list.\nthinker_t\tthinkercap;\n\n\n//\n// P_InitThinkers\n//\nvoid P_InitThinkers (void)\n{\n    thinkercap.prev = thinkercap.next  = &thinkercap;\n}\n\n\n\n\n//\n// P_AddThinker\n// Adds a new thinker at the end of the list.\n//\nvoid P_AddThinker (thinker_t* thinker)\n{\n    thinkercap.prev->next = thinker;\n    thinker->next = &thinkercap;\n    thinker->prev = thinkercap.prev;\n    thinkercap.prev = thinker;\n}\n\n\n\n//\n// P_RemoveThinker\n// Deallocation is lazy -- it will not actually be freed\n// until its thinking turn comes up.\n//\nvoid P_RemoveThinker (thinker_t* thinker)\n{\n  // FIXME: NOP.\n  thinker->function.acv = (actionf_v)(-1);\n}\n\n\n\n//\n// P_AllocateThinker\n// Allocates memory and adds a new thinker at the end of the list.\n//\nvoid P_AllocateThinker (thinker_t*\tthinker)\n{\n}\n\n\n\n//\n// P_RunThinkers\n//\nvoid P_RunThinkers (void)\n{\n    thinker_t *currentthinker, *nextthinker;\n\n    currentthinker = thinkercap.next;\n    while (currentthinker != &thinkercap)\n    {\n\tif ( currentthinker->function.acv == (actionf_v)(-1) )\n\t{\n\t    // time to remove it\n            nextthinker = currentthinker->next;\n\t    currentthinker->next->prev = currentthinker->prev;\n\t    currentthinker->prev->next = currentthinker->next;\n\t    Z_Free(currentthinker);\n\t}\n\telse\n\t{\n\t    if (currentthinker->function.acp1)\n\t\tcurrentthinker->function.acp1 (currentthinker);\n            nextthinker = currentthinker->next;\n\t}\n\tcurrentthinker = nextthinker;\n    }\n}\n\n\n\n//\n// P_Ticker\n//\n\nvoid P_Ticker (void)\n{\n    int\t\ti;\n    \n    // run the tic\n    if (paused)\n\treturn;\n\t\t\n    // pause if in menu and at least one tic has been run\n    if ( !netgame\n\t && menuactive\n\t && !demoplayback\n\t && players[consoleplayer].viewz != 1)\n    {\n\treturn;\n    }\n    \n\t\t\n    for (i=0 ; i<MAXPLAYERS ; i++)\n\tif (playeringame[i])\n\t    P_PlayerThink (&players[i]);\n\t\t\t\n    P_RunThinkers ();\n    P_UpdateSpecials ();\n    P_RespawnSpecials ();\n\n    // for par times\n    leveltime++;\t\n}\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//\tPlayer related stuff.\n//\tBobbing POV/weapon, movement.\n//\tPending weapon.\n//\n\n\n\n\n#include \"doomdef.h\"\n#include \"d_event.h\"\n\n#include \"p_local.h\"\n\n#include \"doomstat.h\"\n\n\n\n// Index of the special effects (INVUL inverse) map.\n#define INVERSECOLORMAP\t\t32\n\n\n//\n// Movement.\n//\n\n// 16 pixels of bob\n#define MAXBOB\t0x100000\t\n\nboolean\t\tonground;\n\n\n//\n// P_Thrust\n// Moves the given origin along a given angle.\n//\nvoid\nP_Thrust\n( player_t*\tplayer,\n  angle_t\tangle,\n  fixed_t\tmove ) \n{\n    angle >>= ANGLETOFINESHIFT;\n    \n    player->mo->momx += FixedMul(move,finecosine[angle]); \n    player->mo->momy += FixedMul(move,finesine[angle]);\n}\n\n\n\n\n//\n// P_CalcHeight\n// Calculate the walking / running height adjustment\n//\nvoid P_CalcHeight (player_t* player) \n{\n    int\t\tangle;\n    fixed_t\tbob;\n    \n    // Regular movement bobbing\n    // (needs to be calculated for gun swing\n    // even if not on ground)\n    // OPTIMIZE: tablify angle\n    // Note: a LUT allows for effects\n    //  like a ramp with low health.\n    player->bob =\n\tFixedMul (player->mo->momx, player->mo->momx)\n\t+ FixedMul (player->mo->momy,player->mo->momy);\n    \n    player->bob >>= 2;\n\n    if (player->bob>MAXBOB)\n\tplayer->bob = MAXBOB;\n\n    if ((player->cheats & CF_NOMOMENTUM) || !onground)\n    {\n\tplayer->viewz = player->mo->z + VIEWHEIGHT;\n\n\tif (player->viewz > player->mo->ceilingz-4*FRACUNIT)\n\t    player->viewz = player->mo->ceilingz-4*FRACUNIT;\n\n\tplayer->viewz = player->mo->z + player->viewheight;\n\treturn;\n    }\n\t\t\n    angle = (FINEANGLES/20*leveltime)&FINEMASK;\n    bob = FixedMul ( player->bob/2, finesine[angle]);\n\n    \n    // move viewheight\n    if (player->playerstate == PST_LIVE)\n    {\n\tplayer->viewheight += player->deltaviewheight;\n\n\tif (player->viewheight > VIEWHEIGHT)\n\t{\n\t    player->viewheight = VIEWHEIGHT;\n\t    player->deltaviewheight = 0;\n\t}\n\n\tif (player->viewheight < VIEWHEIGHT/2)\n\t{\n\t    player->viewheight = VIEWHEIGHT/2;\n\t    if (player->deltaviewheight <= 0)\n\t\tplayer->deltaviewheight = 1;\n\t}\n\t\n\tif (player->deltaviewheight)\t\n\t{\n\t    player->deltaviewheight += FRACUNIT/4;\n\t    if (!player->deltaviewheight)\n\t\tplayer->deltaviewheight = 1;\n\t}\n    }\n    player->viewz = player->mo->z + player->viewheight + bob;\n\n    if (player->viewz > player->mo->ceilingz-4*FRACUNIT)\n\tplayer->viewz = player->mo->ceilingz-4*FRACUNIT;\n}\n\n\n\n//\n// P_MovePlayer\n//\nvoid P_MovePlayer (player_t* player)\n{\n    ticcmd_t*\t\tcmd;\n\t\n    cmd = &player->cmd;\n\t\n    player->mo->angle += (cmd->angleturn<<FRACBITS);\n\n    // Do not let the player control movement\n    //  if not onground.\n    onground = (player->mo->z <= player->mo->floorz);\n\t\n    if (cmd->forwardmove && onground)\n\tP_Thrust (player, player->mo->angle, cmd->forwardmove*2048);\n    \n    if (cmd->sidemove && onground)\n\tP_Thrust (player, player->mo->angle-ANG90, cmd->sidemove*2048);\n\n    if ( (cmd->forwardmove || cmd->sidemove) \n\t && player->mo->state == &states[S_PLAY] )\n    {\n\tP_SetMobjState (player->mo, S_PLAY_RUN1);\n    }\n}\t\n\n\n\n//\n// P_DeathThink\n// Fall on your face when dying.\n// Decrease POV height to floor height.\n//\n#define ANG5   \t(ANG90/18)\n\nvoid P_DeathThink (player_t* player)\n{\n    angle_t\t\tangle;\n    angle_t\t\tdelta;\n\n    P_MovePsprites (player);\n\t\n    // fall to the ground\n    if (player->viewheight > 6*FRACUNIT)\n\tplayer->viewheight -= FRACUNIT;\n\n    if (player->viewheight < 6*FRACUNIT)\n\tplayer->viewheight = 6*FRACUNIT;\n\n    player->deltaviewheight = 0;\n    onground = (player->mo->z <= player->mo->floorz);\n    P_CalcHeight (player);\n\t\n    if (player->attacker && player->attacker != player->mo)\n    {\n\tangle = R_PointToAngle2 (player->mo->x,\n\t\t\t\t player->mo->y,\n\t\t\t\t player->attacker->x,\n\t\t\t\t player->attacker->y);\n\t\n\tdelta = angle - player->mo->angle;\n\t\n\tif (delta < ANG5 || delta > (unsigned)-ANG5)\n\t{\n\t    // Looking at killer,\n\t    //  so fade damage flash down.\n\t    player->mo->angle = angle;\n\n\t    if (player->damagecount)\n\t\tplayer->damagecount--;\n\t}\n\telse if (delta < ANG180)\n\t    player->mo->angle += ANG5;\n\telse\n\t    player->mo->angle -= ANG5;\n    }\n    else if (player->damagecount)\n\tplayer->damagecount--;\n\t\n\n    if (player->cmd.buttons & BT_USE)\n\tplayer->playerstate = PST_REBORN;\n}\n\n\n\n//\n// P_PlayerThink\n//\nvoid P_PlayerThink (player_t* player)\n{\n    ticcmd_t*\t\tcmd;\n    weapontype_t\tnewweapon;\n\t\n    // fixme: do this in the cheat code\n    if (player->cheats & CF_NOCLIP)\n\tplayer->mo->flags |= MF_NOCLIP;\n    else\n\tplayer->mo->flags &= ~MF_NOCLIP;\n    \n    // chain saw run forward\n    cmd = &player->cmd;\n    if (player->mo->flags & MF_JUSTATTACKED)\n    {\n\tcmd->angleturn = 0;\n\tcmd->forwardmove = 0xc800/512;\n\tcmd->sidemove = 0;\n\tplayer->mo->flags &= ~MF_JUSTATTACKED;\n    }\n\t\t\t\n\t\n    if (player->playerstate == PST_DEAD)\n    {\n\tP_DeathThink (player);\n\treturn;\n    }\n    \n    // Move around.\n    // Reactiontime is used to prevent movement\n    //  for a bit after a teleport.\n    if (player->mo->reactiontime)\n\tplayer->mo->reactiontime--;\n    else\n\tP_MovePlayer (player);\n    \n    P_CalcHeight (player);\n\n    if (player->mo->subsector->sector->special)\n\tP_PlayerInSpecialSector (player);\n    \n    // Check for weapon change.\n\n    // A special event has no other buttons.\n    if (cmd->buttons & BT_SPECIAL)\n\tcmd->buttons = 0;\t\t\t\n\t\t\n    if (cmd->buttons & BT_CHANGE)\n    {\n\t// The actual changing of the weapon is done\n\t//  when the weapon psprite can do it\n\t//  (read: not in the middle of an attack).\n\tnewweapon = (cmd->buttons&BT_WEAPONMASK)>>BT_WEAPONSHIFT;\n\t\n\tif (newweapon == wp_fist\n\t    && player->weaponowned[wp_chainsaw]\n\t    && !(player->readyweapon == wp_chainsaw\n\t\t && player->powers[pw_strength]))\n\t{\n\t    newweapon = wp_chainsaw;\n\t}\n\t\n\tif ( (gamemode == commercial)\n\t    && newweapon == wp_shotgun \n\t    && player->weaponowned[wp_supershotgun]\n\t    && player->readyweapon != wp_supershotgun)\n\t{\n\t    newweapon = wp_supershotgun;\n\t}\n\t\n\n\tif (player->weaponowned[newweapon]\n\t    && newweapon != player->readyweapon)\n\t{\n\t    // Do not go to plasma or BFG in shareware,\n\t    //  even if cheated.\n\t    if ((newweapon != wp_plasma\n\t\t && newweapon != wp_bfg)\n\t\t|| (gamemode != shareware) )\n\t    {\n\t\tplayer->pendingweapon = newweapon;\n\t    }\n\t}\n    }\n    \n    // check for use\n    if (cmd->buttons & BT_USE)\n    {\n\tif (!player->usedown)\n\t{\n\t    P_UseLines (player);\n\t    player->usedown = true;\n\t}\n    }\n    else\n\tplayer->usedown = false;\n    \n    // cycle psprites\n    P_MovePsprites (player);\n    \n    // Counters, time dependend power ups.\n\n    // Strength counts up to diminish fade.\n    if (player->powers[pw_strength])\n\tplayer->powers[pw_strength]++;\t\n\t\t\n    if (player->powers[pw_invulnerability])\n\tplayer->powers[pw_invulnerability]--;\n\n    if (player->powers[pw_invisibility])\n\tif (! --player->powers[pw_invisibility] )\n\t    player->mo->flags &= ~MF_SHADOW;\n\t\t\t\n    if (player->powers[pw_infrared])\n\tplayer->powers[pw_infrared]--;\n\t\t\n    if (player->powers[pw_ironfeet])\n\tplayer->powers[pw_ironfeet]--;\n\t\t\n    if (player->damagecount)\n\tplayer->damagecount--;\n\t\t\n    if (player->bonuscount)\n\tplayer->bonuscount--;\n\n    \n    // Handling colormaps.\n    if (player->powers[pw_invulnerability])\n    {\n\tif (player->powers[pw_invulnerability] > 4*32\n\t    || (player->powers[pw_invulnerability]&8) )\n\t    player->fixedcolormap = INVERSECOLORMAP;\n\telse\n\t    player->fixedcolormap = 0;\n    }\n    else if (player->powers[pw_infrared])\t\n    {\n\tif (player->powers[pw_infrared] > 4*32\n\t    || (player->powers[pw_infrared]&8) )\n\t{\n\t    // almost full bright\n\t    player->fixedcolormap = 1;\n\t}\n\telse\n\t    player->fixedcolormap = 0;\n    }\n    else\n\tplayer->fixedcolormap = 0;\n}\n\n\n","/*\n  SDL_mixer:  An audio mixer library based on the SDL library\n  Copyright (C) 1997-2017 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n\n  This file by Ryan C. Gordon (icculus@icculus.org)\n\n  These are some helper functions for the internal mixer special effects.\n*/\n\n/* $Id$ */\n\n\n     /* ------ These are used internally only. Don't touch. ------ */\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"SDL_mixer.h\"\n\n#define __MIX_INTERNAL_EFFECT__\n#include \"effects_internal.h\"\n\n/* Should we favor speed over memory usage and/or quality of output? */\nint _Mix_effects_max_speed = 0;\n\n\nvoid _Mix_InitEffects(void)\n{\n    _Mix_effects_max_speed = (SDL_getenv(MIX_EFFECTSMAXSPEED) != NULL);\n}\n\nvoid _Mix_DeinitEffects(void)\n{\n    _Eff_PositionDeinit();\n}\n\n\nvoid *_Eff_volume_table = NULL;\n\n\n/* Build the volume table for Uint8-format samples.\n *\n * Each column of the table is a possible sample, while each row of the\n *  table is a volume. Volume is a Uint8, where 0 is silence and 255 is full\n *  volume. So _Eff_volume_table[128][mysample] would be the value of\n *  mysample, at half volume.\n */\nvoid *_Eff_build_volume_table_u8(void)\n{\n    int volume;\n    int sample;\n    Uint8 *rc;\n\n    if (!_Mix_effects_max_speed) {\n        return(NULL);\n    }\n\n    if (!_Eff_volume_table) {\n        rc = SDL_malloc(256 * 256);\n        if (rc) {\n            _Eff_volume_table = (void *) rc;\n            for (volume = 0; volume < 256; volume++) {\n                for (sample = -128; sample < 128; sample ++) {\n                    *rc = (Uint8)(((float) sample) * ((float) volume / 255.0))\n                        + 128;\n                    rc++;\n                }\n            }\n        }\n    }\n\n    return(_Eff_volume_table);\n}\n\n\n/* Build the volume table for Sint8-format samples.\n *\n * Each column of the table is a possible sample, while each row of the\n *  table is a volume. Volume is a Uint8, where 0 is silence and 255 is full\n *  volume. So _Eff_volume_table[128][mysample+128] would be the value of\n *  mysample, at half volume.\n */\nvoid *_Eff_build_volume_table_s8(void)\n{\n    int volume;\n    int sample;\n    Sint8 *rc;\n\n    if (!_Eff_volume_table) {\n        rc = SDL_malloc(256 * 256);\n        if (rc) {\n            _Eff_volume_table = (void *) rc;\n            for (volume = 0; volume < 256; volume++) {\n                for (sample = -128; sample < 128; sample ++) {\n                    *rc = (Sint8)(((float) sample) * ((float) volume / 255.0));\n                    rc++;\n                }\n            }\n        }\n    }\n\n    return(_Eff_volume_table);\n}\n\n\n/* end of effects.c ... */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","//\n// Copyright(C) 2005-2014 Simon Howard\n// Copyright(C) 2014 Fabian Greffrath\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Parses INCLUDE directives in BEX files\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"m_misc.h\"\n\n#include \"deh_io.h\"\n#include \"deh_main.h\"\n\nstatic boolean bex_nested = false;\n\nstatic void *DEH_BEXInclStart(deh_context_t *context, char *line)\n{\n    char *deh_file, *inc_file, *try_path;\n    extern boolean bex_notext;\n\n    if (!DEH_FileName(context))\n    {\n\tDEH_Warning(context, \"DEHACKED lumps may not include files\");\n\treturn NULL;\n    }\n\n    deh_file = DEH_FileName(context);\n\n    if (bex_nested)\n    {\n\tDEH_Warning(context, \"Included files may not include other files\");\n\treturn NULL;\n    }\n\n    inc_file = malloc(strlen(line) + 1);\n\n    if (sscanf(line, \"INCLUDE NOTEXT %32s\", inc_file) == 1)\n    {\n\tbex_notext = true;\n    }\n    else\n    if (sscanf(line, \"INCLUDE %32s\", inc_file) == 1)\n    {\n\t// well, fine\n    }\n    else\n    {\n\tDEH_Warning(context, \"Parse error on section start\");\n\tfree(inc_file);\n\treturn NULL;\n    }\n\n    // first, try loading the file right away\n    try_path = inc_file;\n\n    if (!M_FileExists(try_path))\n    {\n\t// second, try loading the file in the directory of the current file\n\tchar *dir;\n\tdir = M_DirName(deh_file);\n\ttry_path = M_StringJoin(dir, DIR_SEPARATOR_S, inc_file, NULL);\n\tfree(dir);\n    }\n\n    bex_nested = true;\n\n    if (!M_FileExists(try_path) || !DEH_LoadFile(try_path))\n    {\n\tDEH_Warning(context, \"Could not include \\\"%s\\\"\", inc_file);\n    }\n\n    bex_nested = false;\n    bex_notext = false;\n\n    if (try_path != inc_file)\n\tfree(try_path);\n    free(inc_file);\n\n    return NULL;\n}\n\nstatic void DEH_BEXInclParseLine(deh_context_t *context, char *line, void *tag)\n{\n    // not used\n}\n\ndeh_section_t deh_section_bexincl =\n{\n    \"INCLUDE\",\n    NULL,\n    DEH_BEXInclStart,\n    DEH_BEXInclParseLine,\n    NULL,\n    NULL,\n};\n","//\n// Copyright(C) 2005-2014 Simon Howard\n// Copyright(C) 2014 Fabian Greffrath\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Parses [PARS] sections in BEX files\n//\n\n#include <stdio.h>\n#include <string.h>\n\n#include \"deh_io.h\"\n\nint bex_pars[4][10] = {{0}};\nint bex_cpars[32] = {0};\n\nstatic void *DEH_BEXParsStart(deh_context_t *context, char *line)\n{\n    char s[7];\n\n    if (sscanf(line, \"%6s\", s) == 0 || strcmp(\"[PARS]\", s))\n    {\n\tDEH_Warning(context, \"Parse error on section start\");\n    }\n\n    return NULL;\n}\n\nstatic void DEH_BEXParsParseLine(deh_context_t *context, char *line, void *tag)\n{\n    int episode, map, partime;\n\n    if (sscanf(line, \"par %32d %32d %32d\", &episode, &map, &partime) == 3)\n    {\n\tif (episode >= 1 && episode <= 3 && map >= 1 && map <= 9)\n\t    bex_pars[episode][map] = partime;\n\telse\n\t{\n\t    DEH_Warning(context, \"Invalid episode or map: E%dM%d\", episode, map);\n\t    return;\n\t}\n    }\n    else\n    if (sscanf(line, \"par %32d %32d\", &map, &partime) == 2)\n    {\n\tif (map >= 1 && map <= 32)\n\t    bex_cpars[map-1] = partime;\n\telse\n\t{\n\t    DEH_Warning(context, \"Invalid map: MAP%02d\", map);\n\t    return;\n\t}\n    }\n    else\n    {\n\tDEH_Warning(context, \"Failed to parse assignment\");\n\treturn;\n    }\n}\n\ndeh_section_t deh_section_bexpars =\n{\n    \"[PARS]\",\n    NULL,\n    DEH_BEXParsStart,\n    DEH_BEXParsParseLine,\n    NULL,\n    NULL,\n};\n","//\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n//\n// Parses \"Ammo\" sections in dehacked files\n//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include \"doomdef.h\"\n#include \"doomtype.h\"\n#include \"deh_defs.h\"\n#include \"deh_io.h\"\n#include \"deh_main.h\"\n#include \"p_local.h\"\n\nstatic void *DEH_AmmoStart(deh_context_t *context, char *line)\n{\n    int ammo_number = 0;\n\n    if (sscanf(line, \"Ammo %i\", &ammo_number) != 1)\n    {\n        DEH_Warning(context, \"Parse error on section start\");\n        return NULL;\n    }\n\n    if (ammo_number < 0 || ammo_number >= NUMAMMO)\n    {\n        DEH_Warning(context, \"Invalid ammo number: %i\", ammo_number);\n        return NULL;\n    }\n    \n    return &maxammo[ammo_number];\n}\n\nstatic void DEH_AmmoParseLine(deh_context_t *context, char *line, void *tag)\n{\n    char *variable_name, *value;\n    int ivalue;\n    int ammo_number;\n\n    if (tag == NULL)\n        return;\n\n    ammo_number = ((int *) tag) - maxammo;\n\n    // Parse the assignment\n\n    if (!DEH_ParseAssignment(line, &variable_name, &value))\n    {\n        // Failed to parse\n\n        DEH_Warning(context, \"Failed to parse assignment\");\n        return;\n    }\n\n    ivalue = atoi(value);\n\n    // maxammo\n\n    if (!strcasecmp(variable_name, \"Per ammo\"))\n        clipammo[ammo_number] = ivalue;\n    else if (!strcasecmp(variable_name, \"Max ammo\"))\n        maxammo[ammo_number] = ivalue;\n    else\n    {\n        DEH_Warning(context, \"Field named '%s' not found\", variable_name);\n    }\n}\n\nstatic void DEH_AmmoSHA1Hash(sha1_context_t *context)\n{\n    int i;\n\n    for (i=0; i<NUMAMMO; ++i)\n    {\n        SHA1_UpdateInt32(context, clipammo[i]);\n        SHA1_UpdateInt32(context, maxammo[i]);\n    }\n}\n\ndeh_section_t deh_section_ammo =\n{\n    \"Ammo\",\n    NULL,\n    DEH_AmmoStart,\n    DEH_AmmoParseLine,\n    NULL,\n    DEH_AmmoSHA1Hash,\n};\n\n","//\n// Copyright(C) 1993-1996 Id Software, Inc.\n// Copyright(C) 2005-2014 Simon Howard\n//\n// This program is free software; you can redistribute it and/or\n// modify it under the terms of the GNU General Public License\n// as published by the Free Software Foundation; either version 2\n// of the License, or (at your option) any later version.\n//\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// DESCRIPTION:\n//  Sky rendering. The DOOM sky is a texture map like any\n//  wall, wrapping around. A 1024 columns equal 360 degrees.\n//  The default sky map is 256 columns and repeats 4 times\n//  on a 320 screen?\n//  \n//\n\n\n\n// Needed for FRACUNIT.\n#include \"m_fixed.h\"\n\n// Needed for Flat retrieval.\n#include \"r_data.h\"\n\n\n#include \"r_sky.h\"\n\n//\n// sky mapping\n//\nint\t\t\tskyflatnum;\nint\t\t\tskytexture;\nint\t\t\tskytexturemid;\n\n\n\n//\n// R_InitSkyMap\n// Called whenever the view size changes.\n//\nvoid R_InitSkyMap (void)\n{\n  // skyflatnum = R_FlatNumForName ( SKYFLATNAME );\n    skytexturemid = SCREENHEIGHT/2*FRACUNIT;\n}\n\n"]}